import {
  BCFTopics,
  FragmentsManager,
  Grids,
  IfcLoader,
  OrthoPerspectiveCamera,
  SimpleRenderer,
  SimpleScene,
  Topic,
  Viewpoints,
  Worlds
} from "./chunk-7X4VYLBA.js";
import {
  Bd,
  Js
} from "./chunk-DOW5NMDB.js";
import "./chunk-TXJIUF4P.js";
import {
  BufferAttribute,
  BufferGeometry,
  Color,
  Frustum,
  Group,
  LineBasicMaterial,
  LineSegments,
  Matrix4,
  Object3D,
  Vector2,
  Vector3
} from "./chunk-LVV4RLRG.js";
import "./chunk-CSAU5B4Q.js";

// node_modules/@thatopen/ui-obc/dist/index.js
var Ze = globalThis;
var dn = Ze.ShadowRoot && (Ze.ShadyCSS === void 0 || Ze.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var un = Symbol();
var Rn = /* @__PURE__ */ new WeakMap();
var Ds = class {
  constructor(t, e, n) {
    if (this._$cssResult$ = true, n !== un)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (dn && t === void 0) {
      const n = e !== void 0 && e.length === 1;
      n && (t = Rn.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), n && Rn.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
var Ur = (i) => new Ds(typeof i == "string" ? i : i + "", void 0, un);
var hn = (i, ...t) => {
  const e = i.length === 1 ? i[0] : t.reduce((n, s, o) => n + ((r) => {
    if (r._$cssResult$ === true)
      return r.cssText;
    if (typeof r == "number")
      return r;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + r + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s) + i[o + 1], i[0]);
  return new Ds(e, i, un);
};
var qr = (i, t) => {
  if (dn)
    i.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
  else
    for (const e of t) {
      const n = document.createElement("style"), s = Ze.litNonce;
      s !== void 0 && n.setAttribute("nonce", s), n.textContent = e.cssText, i.appendChild(n);
    }
};
var Dn = dn ? (i) => i : (i) => i instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const n of t.cssRules)
    e += n.cssText;
  return Ur(e);
})(i) : i;
var { is: Vr, defineProperty: Yr, getOwnPropertyDescriptor: Wr, getOwnPropertyNames: Gr, getOwnPropertySymbols: Xr, getPrototypeOf: Jr } = Object;
var $t = globalThis;
var Ln = $t.trustedTypes;
var Qr = Ln ? Ln.emptyScript : "";
var Ii = $t.reactiveElementPolyfillSupport;
var ye = (i, t) => i;
var ei = { toAttribute(i, t) {
  switch (t) {
    case Boolean:
      i = i ? Qr : null;
      break;
    case Object:
    case Array:
      i = i == null ? i : JSON.stringify(i);
  }
  return i;
}, fromAttribute(i, t) {
  let e = i;
  switch (t) {
    case Boolean:
      e = i !== null;
      break;
    case Number:
      e = i === null ? null : Number(i);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(i);
      } catch {
        e = null;
      }
  }
  return e;
} };
var pn = (i, t) => !Vr(i, t);
var jn = { attribute: true, type: String, converter: ei, reflect: false, useDefault: false, hasChanged: pn };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), $t.litPropertyMetadata ?? ($t.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
var Wt = class extends HTMLElement {
  static addInitializer(t) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, e = jn) {
    if (e.state && (e.attribute = false), this._$Ei(), this.prototype.hasOwnProperty(t) && ((e = Object.create(e)).wrapped = true), this.elementProperties.set(t, e), !e.noAccessor) {
      const n = Symbol(), s = this.getPropertyDescriptor(t, n, e);
      s !== void 0 && Yr(this.prototype, t, s);
    }
  }
  static getPropertyDescriptor(t, e, n) {
    const { get: s, set: o } = Wr(this.prototype, t) ?? { get() {
      return this[e];
    }, set(r) {
      this[e] = r;
    } };
    return { get: s, set(r) {
      const a = s == null ? void 0 : s.call(this);
      o == null || o.call(this, r), this.requestUpdate(t, a, n);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? jn;
  }
  static _$Ei() {
    if (this.hasOwnProperty(ye("elementProperties")))
      return;
    const t = Jr(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(ye("finalized")))
      return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(ye("properties"))) {
      const e = this.properties, n = [...Gr(e), ...Xr(e)];
      for (const s of n)
        this.createProperty(s, e[s]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const e = litPropertyMetadata.get(t);
      if (e !== void 0)
        for (const [n, s] of e)
          this.elementProperties.set(n, s);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, n] of this.elementProperties) {
      const s = this._$Eu(e, n);
      s !== void 0 && this._$Eh.set(s, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const n = new Set(t.flat(1 / 0).reverse());
      for (const s of n)
        e.unshift(Dn(s));
    } else
      t !== void 0 && e.push(Dn(t));
    return e;
  }
  static _$Eu(t, e) {
    const n = e.attribute;
    return n === false ? void 0 : typeof n == "string" ? n : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var t;
    this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((e) => e(this));
  }
  addController(t) {
    var e;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((e = t.hostConnected) == null || e.call(t));
  }
  removeController(t) {
    var e;
    (e = this._$EO) == null || e.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const n of e.keys())
      this.hasOwnProperty(n) && (t.set(n, this[n]), delete this[n]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return qr(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    var t;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (t = this._$EO) == null || t.forEach((e) => {
      var n;
      return (n = e.hostConnected) == null ? void 0 : n.call(e);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$EO) == null || t.forEach((e) => {
      var n;
      return (n = e.hostDisconnected) == null ? void 0 : n.call(e);
    });
  }
  attributeChangedCallback(t, e, n) {
    this._$AK(t, n);
  }
  _$ET(t, e) {
    var o;
    const n = this.constructor.elementProperties.get(t), s = this.constructor._$Eu(t, n);
    if (s !== void 0 && n.reflect === true) {
      const r = (((o = n.converter) == null ? void 0 : o.toAttribute) !== void 0 ? n.converter : ei).toAttribute(e, n.type);
      this._$Em = t, r == null ? this.removeAttribute(s) : this.setAttribute(s, r), this._$Em = null;
    }
  }
  _$AK(t, e) {
    var o, r;
    const n = this.constructor, s = n._$Eh.get(t);
    if (s !== void 0 && this._$Em !== s) {
      const a = n.getPropertyOptions(s), l = typeof a.converter == "function" ? { fromAttribute: a.converter } : ((o = a.converter) == null ? void 0 : o.fromAttribute) !== void 0 ? a.converter : ei;
      this._$Em = s, this[s] = l.fromAttribute(e, a.type) ?? ((r = this._$Ej) == null ? void 0 : r.get(s)) ?? null, this._$Em = null;
    }
  }
  requestUpdate(t, e, n) {
    var s;
    if (t !== void 0) {
      const o = this.constructor, r = this[t];
      if (n ?? (n = o.getPropertyOptions(t)), !((n.hasChanged ?? pn)(r, e) || n.useDefault && n.reflect && r === ((s = this._$Ej) == null ? void 0 : s.get(t)) && !this.hasAttribute(o._$Eu(t, n))))
        return;
      this.C(t, e, n);
    }
    this.isUpdatePending === false && (this._$ES = this._$EP());
  }
  C(t, e, { useDefault: n, reflect: s, wrapped: o }, r) {
    n && !(this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Map())).has(t) && (this._$Ej.set(t, r ?? e ?? this[t]), o !== true || r !== void 0) || (this._$AL.has(t) || (this.hasUpdated || n || (e = void 0), this._$AL.set(t, e)), s === true && this._$Em !== t && (this._$Eq ?? (this._$Eq = /* @__PURE__ */ new Set())).add(t));
  }
  async _$EP() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var n;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [o, r] of this._$Ep)
          this[o] = r;
        this._$Ep = void 0;
      }
      const s = this.constructor.elementProperties;
      if (s.size > 0)
        for (const [o, r] of s) {
          const { wrapped: a } = r, l = this[o];
          a !== true || this._$AL.has(o) || l === void 0 || this.C(o, void 0, r, l);
        }
    }
    let t = false;
    const e = this._$AL;
    try {
      t = this.shouldUpdate(e), t ? (this.willUpdate(e), (n = this._$EO) == null || n.forEach((s) => {
        var o;
        return (o = s.hostUpdate) == null ? void 0 : o.call(s);
      }), this.update(e)) : this._$EM();
    } catch (s) {
      throw t = false, this._$EM(), s;
    }
    t && this._$AE(e);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var e;
    (e = this._$EO) == null || e.forEach((n) => {
      var s;
      return (s = n.hostUpdated) == null ? void 0 : s.call(n);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t)), this.updated(t);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return true;
  }
  update(t) {
    this._$Eq && (this._$Eq = this._$Eq.forEach((e) => this._$ET(e, this[e]))), this._$EM();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
};
Wt.elementStyles = [], Wt.shadowRootOptions = { mode: "open" }, Wt[ye("elementProperties")] = /* @__PURE__ */ new Map(), Wt[ye("finalized")] = /* @__PURE__ */ new Map(), Ii == null || Ii({ ReactiveElement: Wt }), ($t.reactiveElementVersions ?? ($t.reactiveElementVersions = [])).push("2.1.0");
var _e = globalThis;
var ii = _e.trustedTypes;
var Bn = ii ? ii.createPolicy("lit-html", { createHTML: (i) => i }) : void 0;
var Ls = "$lit$";
var _t = `lit$${Math.random().toFixed(9).slice(2)}$`;
var js = "?" + _t;
var Zr = `<${js}>`;
var Ft = document;
var Se = () => Ft.createComment("");
var ke = (i) => i === null || typeof i != "object" && typeof i != "function";
var mn = Array.isArray;
var Kr = (i) => mn(i) || typeof (i == null ? void 0 : i[Symbol.iterator]) == "function";
var Ri = `[ 	
\f\r]`;
var be = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var Hn = /-->/g;
var Nn = />/g;
var Mt = RegExp(`>|${Ri}(?:([^\\s"'>=/]+)(${Ri}*=${Ri}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var Fn = /'/g;
var Un = /"/g;
var Bs = /^(?:script|style|textarea|title)$/i;
var ta = (i) => (t, ...e) => ({ _$litType$: i, strings: t, values: e });
var fn = ta(1);
var Zt = Symbol.for("lit-noChange");
var R = Symbol.for("lit-nothing");
var qn = /* @__PURE__ */ new WeakMap();
var Rt = Ft.createTreeWalker(Ft, 129);
function Hs(i, t) {
  if (!mn(i) || !i.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return Bn !== void 0 ? Bn.createHTML(t) : t;
}
var ea = (i, t) => {
  const e = i.length - 1, n = [];
  let s, o = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", r = be;
  for (let a = 0; a < e; a++) {
    const l = i[a];
    let c, d, u = -1, p = 0;
    for (; p < l.length && (r.lastIndex = p, d = r.exec(l), d !== null); )
      p = r.lastIndex, r === be ? d[1] === "!--" ? r = Hn : d[1] !== void 0 ? r = Nn : d[2] !== void 0 ? (Bs.test(d[2]) && (s = RegExp("</" + d[2], "g")), r = Mt) : d[3] !== void 0 && (r = Mt) : r === Mt ? d[0] === ">" ? (r = s ?? be, u = -1) : d[1] === void 0 ? u = -2 : (u = r.lastIndex - d[2].length, c = d[1], r = d[3] === void 0 ? Mt : d[3] === '"' ? Un : Fn) : r === Un || r === Fn ? r = Mt : r === Hn || r === Nn ? r = be : (r = Mt, s = void 0);
    const f = r === Mt && i[a + 1].startsWith("/>") ? " " : "";
    o += r === be ? l + Zr : u >= 0 ? (n.push(c), l.slice(0, u) + Ls + l.slice(u) + _t + f) : l + _t + (u === -2 ? a : f);
  }
  return [Hs(i, o + (i[e] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), n];
};
var Vi = class Ns {
  constructor({ strings: t, _$litType$: e }, n) {
    let s;
    this.parts = [];
    let o = 0, r = 0;
    const a = t.length - 1, l = this.parts, [c, d] = ea(t, e);
    if (this.el = Ns.createElement(c, n), Rt.currentNode = this.el.content, e === 2 || e === 3) {
      const u = this.el.content.firstChild;
      u.replaceWith(...u.childNodes);
    }
    for (; (s = Rt.nextNode()) !== null && l.length < a; ) {
      if (s.nodeType === 1) {
        if (s.hasAttributes())
          for (const u of s.getAttributeNames())
            if (u.endsWith(Ls)) {
              const p = d[r++], f = s.getAttribute(u).split(_t), b = /([.?@])?(.*)/.exec(p);
              l.push({ type: 1, index: o, name: b[2], strings: f, ctor: b[1] === "." ? na : b[1] === "?" ? sa : b[1] === "@" ? oa : fi }), s.removeAttribute(u);
            } else
              u.startsWith(_t) && (l.push({ type: 6, index: o }), s.removeAttribute(u));
        if (Bs.test(s.tagName)) {
          const u = s.textContent.split(_t), p = u.length - 1;
          if (p > 0) {
            s.textContent = ii ? ii.emptyScript : "";
            for (let f = 0; f < p; f++)
              s.append(u[f], Se()), Rt.nextNode(), l.push({ type: 2, index: ++o });
            s.append(u[p], Se());
          }
        }
      } else if (s.nodeType === 8)
        if (s.data === js)
          l.push({ type: 2, index: o });
        else {
          let u = -1;
          for (; (u = s.data.indexOf(_t, u + 1)) !== -1; )
            l.push({ type: 7, index: o }), u += _t.length - 1;
        }
      o++;
    }
  }
  static createElement(t, e) {
    const n = Ft.createElement("template");
    return n.innerHTML = t, n;
  }
};
function Kt(i, t, e = i, n) {
  var r, a;
  if (t === Zt)
    return t;
  let s = n !== void 0 ? (r = e._$Co) == null ? void 0 : r[n] : e._$Cl;
  const o = ke(t) ? void 0 : t._$litDirective$;
  return (s == null ? void 0 : s.constructor) !== o && ((a = s == null ? void 0 : s._$AO) == null || a.call(s, false), o === void 0 ? s = void 0 : (s = new o(i), s._$AT(i, e, n)), n !== void 0 ? (e._$Co ?? (e._$Co = []))[n] = s : e._$Cl = s), s !== void 0 && (t = Kt(i, s._$AS(i, t.values), s, n)), t;
}
var ia = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: n } = this._$AD, s = ((t == null ? void 0 : t.creationScope) ?? Ft).importNode(e, true);
    Rt.currentNode = s;
    let o = Rt.nextNode(), r = 0, a = 0, l = n[0];
    for (; l !== void 0; ) {
      if (r === l.index) {
        let c;
        l.type === 2 ? c = new bn(o, o.nextSibling, this, t) : l.type === 1 ? c = new l.ctor(o, l.name, l.strings, this, t) : l.type === 6 && (c = new ra(o, this, t)), this._$AV.push(c), l = n[++a];
      }
      r !== (l == null ? void 0 : l.index) && (o = Rt.nextNode(), r++);
    }
    return Rt.currentNode = Ft, s;
  }
  p(t) {
    let e = 0;
    for (const n of this._$AV)
      n !== void 0 && (n.strings !== void 0 ? (n._$AI(t, n, e), e += n.strings.length - 2) : n._$AI(t[e])), e++;
  }
};
var bn = class Fs {
  get _$AU() {
    var t;
    return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this._$Cv;
  }
  constructor(t, e, n, s) {
    this.type = 2, this._$AH = R, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = n, this.options = s, this._$Cv = (s == null ? void 0 : s.isConnected) ?? true;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = Kt(this, t, e), ke(t) ? t === R || t == null || t === "" ? (this._$AH !== R && this._$AR(), this._$AH = R) : t !== this._$AH && t !== Zt && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : Kr(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== R && ke(this._$AH) ? this._$AA.nextSibling.data = t : this.T(Ft.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    var o;
    const { values: e, _$litType$: n } = t, s = typeof n == "number" ? this._$AC(t) : (n.el === void 0 && (n.el = Vi.createElement(Hs(n.h, n.h[0]), this.options)), n);
    if (((o = this._$AH) == null ? void 0 : o._$AD) === s)
      this._$AH.p(e);
    else {
      const r = new ia(s, this), a = r.u(this.options);
      r.p(e), this.T(a), this._$AH = r;
    }
  }
  _$AC(t) {
    let e = qn.get(t.strings);
    return e === void 0 && qn.set(t.strings, e = new Vi(t)), e;
  }
  k(t) {
    mn(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let n, s = 0;
    for (const o of t)
      s === e.length ? e.push(n = new Fs(this.O(Se()), this.O(Se()), this, this.options)) : n = e[s], n._$AI(o), s++;
    s < e.length && (this._$AR(n && n._$AB.nextSibling, s), e.length = s);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var n;
    for ((n = this._$AP) == null ? void 0 : n.call(this, false, true, e); t && t !== this._$AB; ) {
      const s = t.nextSibling;
      t.remove(), t = s;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this._$Cv = t, (e = this._$AP) == null || e.call(this, t));
  }
};
var fi = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, n, s, o) {
    this.type = 1, this._$AH = R, this._$AN = void 0, this.element = t, this.name = e, this._$AM = s, this.options = o, n.length > 2 || n[0] !== "" || n[1] !== "" ? (this._$AH = Array(n.length - 1).fill(new String()), this.strings = n) : this._$AH = R;
  }
  _$AI(t, e = this, n, s) {
    const o = this.strings;
    let r = false;
    if (o === void 0)
      t = Kt(this, t, e, 0), r = !ke(t) || t !== this._$AH && t !== Zt, r && (this._$AH = t);
    else {
      const a = t;
      let l, c;
      for (t = o[0], l = 0; l < o.length - 1; l++)
        c = Kt(this, a[n + l], e, l), c === Zt && (c = this._$AH[l]), r || (r = !ke(c) || c !== this._$AH[l]), c === R ? t = R : t !== R && (t += (c ?? "") + o[l + 1]), this._$AH[l] = c;
    }
    r && !s && this.j(t);
  }
  j(t) {
    t === R ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
};
var na = class extends fi {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === R ? void 0 : t;
  }
};
var sa = class extends fi {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== R);
  }
};
var oa = class extends fi {
  constructor(t, e, n, s, o) {
    super(t, e, n, s, o), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = Kt(this, t, e, 0) ?? R) === Zt)
      return;
    const n = this._$AH, s = t === R && n !== R || t.capture !== n.capture || t.once !== n.once || t.passive !== n.passive, o = t !== R && (n === R || s);
    s && this.element.removeEventListener(this.name, this, n), o && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e;
    typeof this._$AH == "function" ? this._$AH.call(((e = this.options) == null ? void 0 : e.host) ?? this.element, t) : this._$AH.handleEvent(t);
  }
};
var ra = class {
  constructor(t, e, n) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = n;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    Kt(this, t);
  }
};
var Di = _e.litHtmlPolyfillSupport;
Di == null || Di(Vi, bn), (_e.litHtmlVersions ?? (_e.litHtmlVersions = [])).push("3.3.0");
var aa = (i, t, e) => {
  const n = (e == null ? void 0 : e.renderBefore) ?? t;
  let s = n._$litPart$;
  if (s === void 0) {
    const o = (e == null ? void 0 : e.renderBefore) ?? null;
    n._$litPart$ = s = new bn(t.insertBefore(Se(), o), o, void 0, e ?? {});
  }
  return s._$AI(i), s;
};
var jt = globalThis;
var Bt = class extends Wt {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var e;
    const t = super.createRenderRoot();
    return (e = this.renderOptions).renderBefore ?? (e.renderBefore = t.firstChild), t;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = aa(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) == null || t.setConnected(true);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) == null || t.setConnected(false);
  }
  render() {
    return Zt;
  }
};
var Is;
Bt._$litElement$ = true, Bt.finalized = true, (Is = jt.litElementHydrateSupport) == null || Is.call(jt, { LitElement: Bt });
var Li = jt.litElementPolyfillSupport;
Li == null || Li({ LitElement: Bt });
(jt.litElementVersions ?? (jt.litElementVersions = [])).push("4.2.0");
var la = { attribute: true, type: String, converter: ei, reflect: false, hasChanged: pn };
var ca = (i = la, t, e) => {
  const { kind: n, metadata: s } = e;
  let o = globalThis.litPropertyMetadata.get(s);
  if (o === void 0 && globalThis.litPropertyMetadata.set(s, o = /* @__PURE__ */ new Map()), n === "setter" && ((i = Object.create(i)).wrapped = true), o.set(e.name, i), n === "accessor") {
    const { name: r } = e;
    return { set(a) {
      const l = t.get.call(this);
      t.set.call(this, a), this.requestUpdate(r, l, i);
    }, init(a) {
      return a !== void 0 && this.C(r, void 0, i, a), a;
    } };
  }
  if (n === "setter") {
    const { name: r } = e;
    return function(a) {
      const l = this[r];
      t.call(this, a), this.requestUpdate(r, l, i);
    };
  }
  throw Error("Unsupported decorator location: " + n);
};
function Y(i) {
  return (t, e) => typeof e == "object" ? ca(i, t, e) : ((n, s, o) => {
    const r = s.hasOwnProperty(o);
    return s.constructor.createProperty(o, n), r ? Object.getOwnPropertyDescriptor(s, o) : void 0;
  })(i, t, e);
}
function da(i) {
  return Y({ ...i, state: true, attribute: false });
}
var ua = class extends Object3D {
  /**
   * Constructs a new CSS2D object.
   *
   * @param {DOMElement} [element] - The DOM element.
   */
  constructor(t = document.createElement("div")) {
    super(), this.isCSS2DObject = true, this.element = t, this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", false), this.center = new Vector2(0.5, 0.5), this.addEventListener("removed", function() {
      this.traverse(function(e) {
        e.element instanceof e.element.ownerDocument.defaultView.Element && e.element.parentNode !== null && e.element.remove();
      });
    });
  }
  copy(t, e) {
    return super.copy(t, e), this.element = t.element.cloneNode(true), this.center = t.center, this;
  }
};
new Vector3();
new Matrix4();
new Matrix4();
new Vector3();
new Vector3();
var ha = class {
  constructor(t, e) {
    this._group = new Group(), this._frustum = new Frustum(), this._frustumMat = new Matrix4(), this._regenerateDelay = 200, this._regenerateCounter = 0, this.material = new LineBasicMaterial({ color: "#2e3338" }), this.numbers = new Group(), this.maxRegenerateRetrys = 4, this.gridsFactor = 5, this._scaleX = 1, this._scaleY = 1, this._offsetX = 0, this._offsetY = 0, this._camera = t, this._container = e;
    const n = this.newGrid(-1), s = this.newGrid(-2);
    this.grids = { main: n, secondary: s }, this._group.add(s, n, this.numbers);
  }
  set scaleX(t) {
    this._scaleX = t, this.regenerate();
  }
  get scaleX() {
    return this._scaleX;
  }
  set scaleY(t) {
    this._scaleY = t, this.regenerate();
  }
  get scaleY() {
    return this._scaleY;
  }
  set offsetX(t) {
    this._offsetX = t, this.regenerate();
  }
  get offsetX() {
    return this._offsetX;
  }
  set offsetY(t) {
    this._offsetY = t, this.regenerate();
  }
  get offsetY() {
    return this._offsetY;
  }
  get() {
    return this._group;
  }
  dispose() {
    const { main: t, secondary: e } = this.grids;
    t.removeFromParent(), e.removeFromParent(), t.geometry.dispose(), t.material.dispose(), e.geometry.dispose(), e.material.dispose();
  }
  regenerate() {
    if (!this.isGridReady()) {
      if (this._regenerateCounter++, this._regenerateCounter > this.maxRegenerateRetrys)
        throw new Error("Grid could not be regenerated");
      setTimeout(() => this.regenerate, this._regenerateDelay);
      return;
    }
    this._regenerateCounter = 0, this._camera.updateMatrix(), this._camera.updateMatrixWorld();
    const e = this._frustumMat.multiplyMatrices(
      this._camera.projectionMatrix,
      this._camera.matrixWorldInverse
    );
    this._frustum.setFromProjectionMatrix(e);
    const { planes: n } = this._frustum, s = n[0].constant * -n[0].normal.x, o = n[1].constant * -n[1].normal.x, r = n[2].constant * -n[2].normal.y, a = n[3].constant * -n[3].normal.y, l = Math.abs(s - o), c = Math.abs(a - r), { clientWidth: d, clientHeight: u } = this._container, p = Math.max(d, u), b = Math.max(l, c) / p, v = Math.ceil(Math.log10(l / this.scaleX)), g = Math.ceil(Math.log10(c / this.scaleY)), $ = 10 ** (v - 2) * this.scaleX, y = 10 ** (g - 2) * this.scaleY, _ = $ * this.gridsFactor, w = y * this.gridsFactor, A = Math.ceil(c / w), x = Math.ceil(l / _), M = Math.ceil(c / y), N = Math.ceil(l / $), q = $ * Math.ceil(o / $), E = y * Math.ceil(r / y), ot = _ * Math.ceil(o / _), dt = w * Math.ceil(r / w), K = [...this.numbers.children];
    for (const B of K)
      B.removeFromParent();
    this.numbers.children = [];
    const C = [], z = 9 * b, P = 1e4, F = ot + this._offsetX, tt = Math.round(Math.abs(F / this.scaleX) * P) / P, ut = (x - 1) * _, Ti = Math.round(Math.abs((F + ut) / this.scaleX) * P) / P, Rr = Math.max(tt, Ti).toString().length * z;
    let Oi = Math.ceil(Rr / _) * _;
    for (let B = 0; B < x; B++) {
      let D = ot + B * _;
      C.push(D, a, 0, D, r, 0), D = Math.round(D * P) / P, Oi = Math.round(Oi * P) / P;
      const fe = D % Oi;
      if (!(_ < 1 || w < 1) && Math.abs(fe) > 0.01)
        continue;
      const zi = this.newNumber((D + this._offsetX) / this.scaleX), Hr = 12 * b;
      zi.position.set(D, r + Hr, 0);
    }
    for (let B = 0; B < A; B++) {
      const D = dt + B * w;
      C.push(o, D, 0, s, D, 0);
      const fe = this.newNumber(D / this.scaleY);
      let Mi = 12;
      fe.element.textContent && (Mi += 4 * fe.element.textContent.length);
      const zi = Mi * b;
      fe.position.set(o + zi, D, 0);
    }
    const Pi = [];
    for (let B = 0; B < N; B++) {
      const D = q + B * $;
      Pi.push(D, a, 0, D, r, 0);
    }
    for (let B = 0; B < M; B++) {
      const D = E + B * y;
      Pi.push(o, D, 0, s, D, 0);
    }
    const Dr = new BufferAttribute(new Float32Array(C), 3), Lr = new BufferAttribute(new Float32Array(Pi), 3), { main: jr, secondary: Br } = this.grids;
    jr.geometry.setAttribute("position", Dr), Br.geometry.setAttribute("position", Lr);
  }
  newNumber(t) {
    const e = document.createElement("bim-label");
    e.textContent = String(Math.round(t * 100) / 100);
    const n = new ua(e);
    return this.numbers.add(n), n;
  }
  newGrid(t) {
    const e = new BufferGeometry(), n = new LineSegments(e, this.material);
    return n.frustumCulled = false, n.renderOrder = t, n;
  }
  isGridReady() {
    const t = this._camera.projectionMatrix.elements;
    for (let e = 0; e < t.length; e++) {
      const n = t[e];
      if (Number.isNaN(n))
        return false;
    }
    return true;
  }
};
var pa = Object.defineProperty;
var ma = Object.getOwnPropertyDescriptor;
var Le = (i, t, e, n) => {
  for (var s = ma(t, e), o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = r(t, e, s) || s);
  return s && pa(t, e, s), s;
};
var Mn = class Mn2 extends Bt {
  constructor() {
    super(...arguments), this._grid = null, this._world = null, this.resize = () => {
      this._world && this._grid && this._grid.regenerate();
    };
  }
  set gridColor(t) {
    if (this._gridColor = t, !(t && this._grid))
      return;
    const e = Number(t.replace("#", "0x"));
    Number.isNaN(e) || this._grid.material.color.setHex(e);
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridScaleX(t) {
    this._gridScaleX = t, t && this._grid && (this._grid.scaleX = t);
  }
  get gridScaleX() {
    return this._gridScaleX;
  }
  set gridScaleY(t) {
    this._gridScaleY = t, t && this._grid && (this._grid.scaleY = t);
  }
  get gridScaleY() {
    return this._gridScaleY;
  }
  get gridOffsetX() {
    var t;
    return ((t = this._grid) == null ? void 0 : t.offsetX) || 0;
  }
  set gridOffsetX(t) {
    this._grid && (this._grid.offsetX = t);
  }
  get gridOffsetY() {
    var t;
    return ((t = this._grid) == null ? void 0 : t.offsetY) || 0;
  }
  set gridOffsetY(t) {
    this._grid && (this._grid.offsetY = t);
  }
  set components(t) {
    this.dispose();
    const n = t.get(Worlds).create();
    this._world = n, n.scene = new SimpleScene(t), n.scene.setup(), n.renderer = new Bd(t, this);
    const s = new OrthoPerspectiveCamera(t);
    n.camera = s;
    const o = new ha(s.threeOrtho, this);
    this._grid = o, n.scene.three.add(o.get()), s.controls.addEventListener(
      "update",
      () => o.regenerate()
    ), setTimeout(async () => {
      n.camera.updateAspect(), s.set("Plan"), await s.controls.setLookAt(0, 0, 100, 0, 0, 0), await s.projection.set("Orthographic"), s.controls.dollySpeed = 3, s.controls.draggingSmoothTime = 0.085, s.controls.maxZoom = 1e3, s.controls.zoom(4);
    });
  }
  get world() {
    return this._world;
  }
  dispose() {
    var t;
    (t = this.world) == null || t.dispose(), this._world = null, this._grid = null;
  }
  connectedCallback() {
    super.connectedCallback(), new ResizeObserver(this.resize).observe(this);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.dispose();
  }
  render() {
    return fn`<slot></slot>`;
  }
};
Mn.styles = hn`
    :host {
      position: relative;
      display: flex;
      min-width: 0px;
      height: 100%;
      background-color: var(--bim-ui_bg-base);
    }
  `;
var xt = Mn;
Le([
  Y({ type: String, attribute: "grid-color", reflect: true })
], xt.prototype, "gridColor");
Le([
  Y({ type: Number, attribute: "grid-scale-x", reflect: true })
], xt.prototype, "gridScaleX");
Le([
  Y({ type: Number, attribute: "grid-scale-y", reflect: true })
], xt.prototype, "gridScaleY");
Le([
  Y({ type: Number, attribute: "grid-offset-x", reflect: true })
], xt.prototype, "gridOffsetX");
Le([
  Y({ type: Number, attribute: "grid-offset-y", reflect: true })
], xt.prototype, "gridOffsetY");
var fa = Object.defineProperty;
var kt = (i, t, e, n) => {
  for (var s = void 0, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = r(t, e, s) || s);
  return s && fa(t, e, s), s;
};
var zn = class zn2 extends Bt {
  constructor() {
    super(...arguments), this._defaults = {
      size: 60
    }, this._cssMatrix3D = "", this._matrix = new Matrix4(), this._onRightClick = new Event("rightclick"), this._onLeftClick = new Event("leftclick"), this._onTopClick = new Event("topclick"), this._onBottomClick = new Event("bottomclick"), this._onFrontClick = new Event("frontclick"), this._onBackClick = new Event("backclick"), this._camera = null, this._epsilon = (t) => Math.abs(t) < 1e-10 ? 0 : t;
  }
  set camera(t) {
    this._camera = t, this.updateOrientation();
  }
  get camera() {
    return this._camera;
  }
  updateOrientation() {
    if (!this.camera)
      return;
    this._matrix.extractRotation(this.camera.matrixWorldInverse);
    const { elements: t } = this._matrix;
    this._cssMatrix3D = `matrix3d(
      ${this._epsilon(t[0])},
      ${this._epsilon(-t[1])},
      ${this._epsilon(t[2])},
      ${this._epsilon(t[3])},
      ${this._epsilon(t[4])},
      ${this._epsilon(-t[5])},
      ${this._epsilon(t[6])},
      ${this._epsilon(t[7])},
      ${this._epsilon(t[8])},
      ${this._epsilon(-t[9])},
      ${this._epsilon(t[10])},
      ${this._epsilon(t[11])},
      ${this._epsilon(t[12])},
      ${this._epsilon(-t[13])},
      ${this._epsilon(t[14])},
      ${this._epsilon(t[15])})
    `;
  }
  render() {
    const t = this.size ?? this._defaults.size;
    return fn`
      <style>
        .face,
        .cube {
          width: ${t}px;
          height: ${t}px;
          transform: translateZ(-300px) ${this._cssMatrix3D};
        }

        .face-right {
          translate: ${t / 2}px 0 0;
        }

        .face-left {
          translate: ${-t / 2}px 0 0;
        }

        .face-top {
          translate: 0 ${t / 2}px 0;
        }

        .face-bottom {
          translate: 0 ${-t / 2}px 0;
        }

        .face-front {
          translate: 0 0 ${t / 2}px;
        }

        .face-back {
          translate: 0 0 ${-t / 2}px;
        }
      </style>
      <div class="parent">
        <div class="cube">
          <div
            class="face x-direction face-right"
            @click=${() => this.dispatchEvent(this._onRightClick)}
          >
            ${this.rightText}
          </div>
          <div
            class="face x-direction face-left"
            @click=${() => this.dispatchEvent(this._onLeftClick)}
          >
            ${this.leftText}
          </div>
          <div
            class="face y-direction face-top"
            @click=${() => this.dispatchEvent(this._onTopClick)}
          >
            ${this.topText}
          </div>
          <div
            class="face y-direction face-bottom"
            @click=${() => this.dispatchEvent(this._onBottomClick)}
          >
            ${this.bottomText}
          </div>
          <div
            class="face z-direction face-front"
            @click=${() => this.dispatchEvent(this._onFrontClick)}
          >
            ${this.frontText}
          </div>
          <div
            class="face z-direction face-back"
            @click=${() => this.dispatchEvent(this._onBackClick)}
          >
            ${this.backText}
          </div>
        </div>
      </div>
    `;
  }
};
zn.styles = hn`
    :host {
      position: absolute;
      z-index: 999;
      bottom: 1rem;
      right: 1rem;
    }

    .parent {
      perspective: 400px;
    }

    .cube {
      position: relative;
      transform-style: preserve-3d;
    }

    .face {
      position: absolute;
      display: flex;
      justify-content: center;
      user-select: none;
      align-items: center;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s;
      color: var(--bim-view-cube--c, white);
      font-size: var(--bim-view-cube--fz, --bim-ui_size-2xl);
    }

    .x-direction {
      // background-color: var(--bim-view-cube_x--bgc, #c93830DD);
      background-color: var(--bim-view-cube_x--bgc, #01a6bcde);
    }

    .x-direction:hover {
      background-color: var(--bim-ui_accent-base, white);
    }

    .y-direction {
      // background-color: var(--bim-view-cube_y--bgc, #54ff19DD);
      background-color: var(--bim-view-cube_y--bgc, #8d0ec8de);
    }

    .y-direction:hover {
      background-color: var(--bim-ui_accent-base, white);
    }

    .z-direction {
      // background-color: var(--bim-view-cube_z--bgc, #3041c9DD);
      background-color: var(--bim-view-cube_z--bgc, #2718afde);
    }

    .z-direction:hover {
      background-color: var(--bim-ui_accent-base, white);
    }

    .face-front {
      transform: rotateX(180deg);
    }

    .face-back {
      transform: rotateZ(180deg);
    }

    .face-top {
      transform: rotateX(90deg);
    }

    .face-bottom {
      transform: rotateX(270deg);
    }

    .face-right {
      transform: rotateY(-270deg) rotateX(180deg);
    }

    .face-left {
      transform: rotateY(-90deg) rotateX(180deg);
    }
  `;
var at = zn;
kt([
  Y({ type: Number, reflect: true })
], at.prototype, "size");
kt([
  Y({ type: String, attribute: "right-text", reflect: true })
], at.prototype, "rightText");
kt([
  Y({ type: String, attribute: "left-text", reflect: true })
], at.prototype, "leftText");
kt([
  Y({ type: String, attribute: "top-text", reflect: true })
], at.prototype, "topText");
kt([
  Y({ type: String, attribute: "bottom-text", reflect: true })
], at.prototype, "bottomText");
kt([
  Y({ type: String, attribute: "front-text", reflect: true })
], at.prototype, "frontText");
kt([
  Y({ type: String, attribute: "back-text", reflect: true })
], at.prototype, "backText");
kt([
  da()
], at.prototype, "_cssMatrix3D");
var ba = (i) => i.strings === void 0;
var ga = { CHILD: 2 };
var va = (i) => (...t) => ({ _$litDirective$: i, values: t });
var ya = class {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, n) {
    this._$Ct = t, this._$AM = e, this._$Ci = n;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
};
var we = (i, t) => {
  var n;
  const e = i._$AN;
  if (e === void 0)
    return false;
  for (const s of e)
    (n = s._$AO) == null || n.call(s, t, false), we(s, t);
  return true;
};
var ni = (i) => {
  let t, e;
  do {
    if ((t = i._$AM) === void 0)
      break;
    e = t._$AN, e.delete(i), i = t;
  } while ((e == null ? void 0 : e.size) === 0);
};
var Us = (i) => {
  for (let t; t = i._$AM; i = t) {
    let e = t._$AN;
    if (e === void 0)
      t._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(i))
      break;
    e.add(i), $a(t);
  }
};
function _a(i) {
  this._$AN !== void 0 ? (ni(this), this._$AM = i, Us(this)) : this._$AM = i;
}
function wa(i, t = false, e = 0) {
  const n = this._$AH, s = this._$AN;
  if (s !== void 0 && s.size !== 0)
    if (t)
      if (Array.isArray(n))
        for (let o = e; o < n.length; o++)
          we(n[o], false), ni(n[o]);
      else
        n != null && (we(n, false), ni(n));
    else
      we(this, i);
}
var $a = (i) => {
  i.type == ga.CHILD && (i._$AP ?? (i._$AP = wa), i._$AQ ?? (i._$AQ = _a));
};
var xa = class extends ya {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, e, n) {
    super._$AT(t, e, n), Us(this), this.isConnected = t._$AU;
  }
  _$AO(t, e = true) {
    var n, s;
    t !== this.isConnected && (this.isConnected = t, t ? (n = this.reconnected) == null || n.call(this) : (s = this.disconnected) == null || s.call(this)), e && (we(this, t), ni(this));
  }
  setValue(t) {
    if (ba(this._$Ct))
      this._$Ct._$AI(t, this);
    else {
      const e = [...this._$Ct._$AH];
      e[this._$Ci] = t, this._$Ct._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};
var Yi = () => new Ca();
var Ca = class {
};
var ji = /* @__PURE__ */ new WeakMap();
var Aa = va(class extends xa {
  render(i) {
    return R;
  }
  update(i, [t]) {
    var n;
    const e = t !== this.G;
    return e && this.G !== void 0 && this.rt(void 0), (e || this.lt !== this.ct) && (this.G = t, this.ht = (n = i.options) == null ? void 0 : n.host, this.rt(this.ct = i.element)), R;
  }
  rt(i) {
    if (this.isConnected || (i = void 0), typeof this.G == "function") {
      const t = this.ht ?? globalThis;
      let e = ji.get(t);
      e === void 0 && (e = /* @__PURE__ */ new WeakMap(), ji.set(t, e)), e.get(this.G) !== void 0 && this.G.call(this.ht, void 0), e.set(this.G, i), i !== void 0 && this.G.call(this.ht, i);
    } else
      this.G.value = i;
  }
  get lt() {
    var i, t;
    return typeof this.G == "function" ? (i = ji.get(this.ht ?? globalThis)) == null ? void 0 : i.get(this.G) : (t = this.G) == null ? void 0 : t.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
var Sa = Object.defineProperty;
var ka = (i, t, e, n) => {
  for (var s = void 0, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = r(t, e, s) || s);
  return s && Sa(t, e, s), s;
};
var In = class In2 extends Bt {
  constructor() {
    super(...arguments), this.world = null, this._components = null, this._viewport = Yi();
  }
  set components(t) {
    var e;
    if (this._components = t, this.components) {
      const n = this.components.get(Worlds);
      this.world = n.create(), this.world.name = this.name;
    } else
      (e = this.world) == null || e.dispose(), this.world = null;
  }
  get components() {
    return this._components;
  }
  connectedCallback() {
    super.connectedCallback(), this.world && (this.world.enabled = true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.world && (this.world.enabled = false);
  }
  dispose() {
    this.components = null, this.remove();
  }
  firstUpdated() {
    const { value: t } = this._viewport;
    if (!(this.components && t && this.world))
      return;
    const e = new SimpleScene(this.components);
    this.world.scene = e, e.setup(), e.three.background = null;
    const n = new SimpleRenderer(this.components, t);
    this.world.renderer = n;
    const s = new OrthoPerspectiveCamera(this.components);
    this.world.camera = s;
    const o = this.components.get(Grids).create(this.world);
    o.material.uniforms.uColor.value = new Color(4342338), o.material.uniforms.uSize1.value = 2, o.material.uniforms.uSize2.value = 8;
  }
  onSlotChange() {
    const t = new Event("slotchange");
    this.dispatchEvent(t);
  }
  render() {
    return fn` <bim-viewport ${Aa(this._viewport)}>
      <slot @slotchange=${this.onSlotChange}></slot>
    </bim-viewport>`;
  }
};
In.styles = hn``;
var si = In;
ka([
  Y({ type: String, reflect: true })
], si.prototype, "name");
var Ea = Object.defineProperty;
var Ta = (i, t, e) => t in i ? Ea(i, t, { enumerable: true, configurable: true, writable: true, value: e }) : i[t] = e;
var zt = (i, t, e) => (Ta(i, typeof t != "symbol" ? t + "" : t, e), e);
var te = Math.min;
var bt = Math.max;
var oi = Math.round;
var Ct = (i) => ({
  x: i,
  y: i
});
var Oa = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var Pa = {
  start: "end",
  end: "start"
};
function Vn(i, t, e) {
  return bt(i, te(t, e));
}
function je(i, t) {
  return typeof i == "function" ? i(t) : i;
}
function gt(i) {
  return i.split("-")[0];
}
function bi(i) {
  return i.split("-")[1];
}
function qs(i) {
  return i === "x" ? "y" : "x";
}
function Vs(i) {
  return i === "y" ? "height" : "width";
}
var Ma = /* @__PURE__ */ new Set(["top", "bottom"]);
function ft(i) {
  return Ma.has(gt(i)) ? "y" : "x";
}
function Ys(i) {
  return qs(ft(i));
}
function za(i, t, e) {
  e === void 0 && (e = false);
  const n = bi(i), s = Ys(i), o = Vs(s);
  let r = s === "x" ? n === (e ? "end" : "start") ? "right" : "left" : n === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (r = ri(r)), [r, ri(r)];
}
function Ia(i) {
  const t = ri(i);
  return [Wi(i), t, Wi(t)];
}
function Wi(i) {
  return i.replace(/start|end/g, (t) => Pa[t]);
}
var Yn = ["left", "right"];
var Wn = ["right", "left"];
var Ra = ["top", "bottom"];
var Da = ["bottom", "top"];
function La(i, t, e) {
  switch (i) {
    case "top":
    case "bottom":
      return e ? t ? Wn : Yn : t ? Yn : Wn;
    case "left":
    case "right":
      return t ? Ra : Da;
    default:
      return [];
  }
}
function ja(i, t, e, n) {
  const s = bi(i);
  let o = La(gt(i), e === "start", n);
  return s && (o = o.map((r) => r + "-" + s), t && (o = o.concat(o.map(Wi)))), o;
}
function ri(i) {
  return i.replace(/left|right|bottom|top/g, (t) => Oa[t]);
}
function Ba(i) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...i
  };
}
function Ws(i) {
  return typeof i != "number" ? Ba(i) : {
    top: i,
    right: i,
    bottom: i,
    left: i
  };
}
function ee(i) {
  const {
    x: t,
    y: e,
    width: n,
    height: s
  } = i;
  return {
    width: n,
    height: s,
    top: e,
    left: t,
    right: t + n,
    bottom: e + s,
    x: t,
    y: e
  };
}
function Gn(i, t, e) {
  let {
    reference: n,
    floating: s
  } = i;
  const o = ft(t), r = Ys(t), a = Vs(r), l = gt(t), c = o === "y", d = n.x + n.width / 2 - s.width / 2, u = n.y + n.height / 2 - s.height / 2, p = n[a] / 2 - s[a] / 2;
  let f;
  switch (l) {
    case "top":
      f = {
        x: d,
        y: n.y - s.height
      };
      break;
    case "bottom":
      f = {
        x: d,
        y: n.y + n.height
      };
      break;
    case "right":
      f = {
        x: n.x + n.width,
        y: u
      };
      break;
    case "left":
      f = {
        x: n.x - s.width,
        y: u
      };
      break;
    default:
      f = {
        x: n.x,
        y: n.y
      };
  }
  switch (bi(t)) {
    case "start":
      f[r] -= p * (e && c ? -1 : 1);
      break;
    case "end":
      f[r] += p * (e && c ? -1 : 1);
      break;
  }
  return f;
}
var Ha = async (i, t, e) => {
  const {
    placement: n = "bottom",
    strategy: s = "absolute",
    middleware: o = [],
    platform: r
  } = e, a = o.filter(Boolean), l = await (r.isRTL == null ? void 0 : r.isRTL(t));
  let c = await r.getElementRects({
    reference: i,
    floating: t,
    strategy: s
  }), {
    x: d,
    y: u
  } = Gn(c, n, l), p = n, f = {}, b = 0;
  for (let v = 0; v < a.length; v++) {
    const {
      name: g,
      fn: $
    } = a[v], {
      x: y,
      y: _,
      data: w,
      reset: A
    } = await $({
      x: d,
      y: u,
      initialPlacement: n,
      placement: p,
      strategy: s,
      middlewareData: f,
      rects: c,
      platform: r,
      elements: {
        reference: i,
        floating: t
      }
    });
    d = y ?? d, u = _ ?? u, f = {
      ...f,
      [g]: {
        ...f[g],
        ...w
      }
    }, A && b <= 50 && (b++, typeof A == "object" && (A.placement && (p = A.placement), A.rects && (c = A.rects === true ? await r.getElementRects({
      reference: i,
      floating: t,
      strategy: s
    }) : A.rects), {
      x: d,
      y: u
    } = Gn(c, p, l)), v = -1);
  }
  return {
    x: d,
    y: u,
    placement: p,
    strategy: s,
    middlewareData: f
  };
};
async function Gs(i, t) {
  var e;
  t === void 0 && (t = {});
  const {
    x: n,
    y: s,
    platform: o,
    rects: r,
    elements: a,
    strategy: l
  } = i, {
    boundary: c = "clippingAncestors",
    rootBoundary: d = "viewport",
    elementContext: u = "floating",
    altBoundary: p = false,
    padding: f = 0
  } = je(t, i), b = Ws(f), v = a[p ? u === "floating" ? "reference" : "floating" : u], g = ee(await o.getClippingRect({
    element: (e = await (o.isElement == null ? void 0 : o.isElement(v))) == null || e ? v : v.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: d,
    strategy: l
  })), $ = u === "floating" ? {
    x: n,
    y: s,
    width: r.floating.width,
    height: r.floating.height
  } : r.reference, y = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), _ = await (o.isElement == null ? void 0 : o.isElement(y)) ? await (o.getScale == null ? void 0 : o.getScale(y)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, w = ee(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: $,
    offsetParent: y,
    strategy: l
  }) : $);
  return {
    top: (g.top - w.top + b.top) / _.y,
    bottom: (w.bottom - g.bottom + b.bottom) / _.y,
    left: (g.left - w.left + b.left) / _.x,
    right: (w.right - g.right + b.right) / _.x
  };
}
var Na = function(i) {
  return i === void 0 && (i = {}), {
    name: "flip",
    options: i,
    async fn(t) {
      var e, n;
      const {
        placement: s,
        middlewareData: o,
        rects: r,
        initialPlacement: a,
        platform: l,
        elements: c
      } = t, {
        mainAxis: d = true,
        crossAxis: u = true,
        fallbackPlacements: p,
        fallbackStrategy: f = "bestFit",
        fallbackAxisSideDirection: b = "none",
        flipAlignment: v = true,
        ...g
      } = je(i, t);
      if ((e = o.arrow) != null && e.alignmentOffset)
        return {};
      const $ = gt(s), y = ft(a), _ = gt(a) === a, w = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), A = p || (_ || !v ? [ri(a)] : Ia(a)), x = b !== "none";
      !p && x && A.push(...ja(a, v, b, w));
      const M = [a, ...A], N = await Gs(t, g), q = [];
      let E = ((n = o.flip) == null ? void 0 : n.overflows) || [];
      if (d && q.push(N[$]), u) {
        const C = za(s, r, w);
        q.push(N[C[0]], N[C[1]]);
      }
      if (E = [...E, {
        placement: s,
        overflows: q
      }], !q.every((C) => C <= 0)) {
        var ot, dt;
        const C = (((ot = o.flip) == null ? void 0 : ot.index) || 0) + 1, z = M[C];
        if (z && (!(u === "alignment" && y !== ft(z)) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        E.every((F) => F.overflows[0] > 0 && ft(F.placement) === y)))
          return {
            data: {
              index: C,
              overflows: E
            },
            reset: {
              placement: z
            }
          };
        let P = (dt = E.filter((F) => F.overflows[0] <= 0).sort((F, tt) => F.overflows[1] - tt.overflows[1])[0]) == null ? void 0 : dt.placement;
        if (!P)
          switch (f) {
            case "bestFit": {
              var K;
              const F = (K = E.filter((tt) => {
                if (x) {
                  const ut = ft(tt.placement);
                  return ut === y || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  ut === "y";
                }
                return true;
              }).map((tt) => [tt.placement, tt.overflows.filter((ut) => ut > 0).reduce((ut, Ti) => ut + Ti, 0)]).sort((tt, ut) => tt[1] - ut[1])[0]) == null ? void 0 : K[0];
              F && (P = F);
              break;
            }
            case "initialPlacement":
              P = a;
              break;
          }
        if (s !== P)
          return {
            reset: {
              placement: P
            }
          };
      }
      return {};
    }
  };
};
function Xs(i) {
  const t = te(...i.map((o) => o.left)), e = te(...i.map((o) => o.top)), n = bt(...i.map((o) => o.right)), s = bt(...i.map((o) => o.bottom));
  return {
    x: t,
    y: e,
    width: n - t,
    height: s - e
  };
}
function Fa(i) {
  const t = i.slice().sort((s, o) => s.y - o.y), e = [];
  let n = null;
  for (let s = 0; s < t.length; s++) {
    const o = t[s];
    !n || o.y - n.y > n.height / 2 ? e.push([o]) : e[e.length - 1].push(o), n = o;
  }
  return e.map((s) => ee(Xs(s)));
}
var Ua = function(i) {
  return i === void 0 && (i = {}), {
    name: "inline",
    options: i,
    async fn(t) {
      const {
        placement: e,
        elements: n,
        rects: s,
        platform: o,
        strategy: r
      } = t, {
        padding: a = 2,
        x: l,
        y: c
      } = je(i, t), d = Array.from(await (o.getClientRects == null ? void 0 : o.getClientRects(n.reference)) || []), u = Fa(d), p = ee(Xs(d)), f = Ws(a);
      function b() {
        if (u.length === 2 && u[0].left > u[1].right && l != null && c != null)
          return u.find((g) => l > g.left - f.left && l < g.right + f.right && c > g.top - f.top && c < g.bottom + f.bottom) || p;
        if (u.length >= 2) {
          if (ft(e) === "y") {
            const E = u[0], ot = u[u.length - 1], dt = gt(e) === "top", K = E.top, C = ot.bottom, z = dt ? E.left : ot.left, P = dt ? E.right : ot.right, F = P - z, tt = C - K;
            return {
              top: K,
              bottom: C,
              left: z,
              right: P,
              width: F,
              height: tt,
              x: z,
              y: K
            };
          }
          const g = gt(e) === "left", $ = bt(...u.map((E) => E.right)), y = te(...u.map((E) => E.left)), _ = u.filter((E) => g ? E.left === y : E.right === $), w = _[0].top, A = _[_.length - 1].bottom, x = y, M = $, N = M - x, q = A - w;
          return {
            top: w,
            bottom: A,
            left: x,
            right: M,
            width: N,
            height: q,
            x,
            y: w
          };
        }
        return p;
      }
      const v = await o.getElementRects({
        reference: {
          getBoundingClientRect: b
        },
        floating: n.floating,
        strategy: r
      });
      return s.reference.x !== v.reference.x || s.reference.y !== v.reference.y || s.reference.width !== v.reference.width || s.reference.height !== v.reference.height ? {
        reset: {
          rects: v
        }
      } : {};
    }
  };
};
var qa = /* @__PURE__ */ new Set(["left", "top"]);
async function Va(i, t) {
  const {
    placement: e,
    platform: n,
    elements: s
  } = i, o = await (n.isRTL == null ? void 0 : n.isRTL(s.floating)), r = gt(e), a = bi(e), l = ft(e) === "y", c = qa.has(r) ? -1 : 1, d = o && l ? -1 : 1, u = je(t, i);
  let {
    mainAxis: p,
    crossAxis: f,
    alignmentAxis: b
  } = typeof u == "number" ? {
    mainAxis: u,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: u.mainAxis || 0,
    crossAxis: u.crossAxis || 0,
    alignmentAxis: u.alignmentAxis
  };
  return a && typeof b == "number" && (f = a === "end" ? b * -1 : b), l ? {
    x: f * d,
    y: p * c
  } : {
    x: p * c,
    y: f * d
  };
}
var Js2 = function(i) {
  return {
    name: "offset",
    options: i,
    async fn(t) {
      var e, n;
      const {
        x: s,
        y: o,
        placement: r,
        middlewareData: a
      } = t, l = await Va(t, i);
      return r === ((e = a.offset) == null ? void 0 : e.placement) && (n = a.arrow) != null && n.alignmentOffset ? {} : {
        x: s + l.x,
        y: o + l.y,
        data: {
          ...l,
          placement: r
        }
      };
    }
  };
};
var Ya = function(i) {
  return i === void 0 && (i = {}), {
    name: "shift",
    options: i,
    async fn(t) {
      const {
        x: e,
        y: n,
        placement: s
      } = t, {
        mainAxis: o = true,
        crossAxis: r = false,
        limiter: a = {
          fn: (g) => {
            let {
              x: $,
              y
            } = g;
            return {
              x: $,
              y
            };
          }
        },
        ...l
      } = je(i, t), c = {
        x: e,
        y: n
      }, d = await Gs(t, l), u = ft(gt(s)), p = qs(u);
      let f = c[p], b = c[u];
      if (o) {
        const g = p === "y" ? "top" : "left", $ = p === "y" ? "bottom" : "right", y = f + d[g], _ = f - d[$];
        f = Vn(y, f, _);
      }
      if (r) {
        const g = u === "y" ? "top" : "left", $ = u === "y" ? "bottom" : "right", y = b + d[g], _ = b - d[$];
        b = Vn(y, b, _);
      }
      const v = a.fn({
        ...t,
        [p]: f,
        [u]: b
      });
      return {
        ...v,
        data: {
          x: v.x - e,
          y: v.y - n,
          enabled: {
            [p]: o,
            [u]: r
          }
        }
      };
    }
  };
};
function gi() {
  return typeof window < "u";
}
function At(i) {
  return Qs(i) ? (i.nodeName || "").toLowerCase() : "#document";
}
function J(i) {
  var t;
  return (i == null || (t = i.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Et(i) {
  var t;
  return (t = (Qs(i) ? i.ownerDocument : i.document) || window.document) == null ? void 0 : t.documentElement;
}
function Qs(i) {
  return gi() ? i instanceof Node || i instanceof J(i).Node : false;
}
function ht(i) {
  return gi() ? i instanceof Element || i instanceof J(i).Element : false;
}
function pt(i) {
  return gi() ? i instanceof HTMLElement || i instanceof J(i).HTMLElement : false;
}
function Xn(i) {
  return !gi() || typeof ShadowRoot > "u" ? false : i instanceof ShadowRoot || i instanceof J(i).ShadowRoot;
}
var Wa = /* @__PURE__ */ new Set(["inline", "contents"]);
function Be(i) {
  const {
    overflow: t,
    overflowX: e,
    overflowY: n,
    display: s
  } = et(i);
  return /auto|scroll|overlay|hidden|clip/.test(t + n + e) && !Wa.has(s);
}
var Ga = /* @__PURE__ */ new Set(["table", "td", "th"]);
function Xa(i) {
  return Ga.has(At(i));
}
var Ja = [":popover-open", ":modal"];
function Qa(i) {
  return Ja.some((t) => {
    try {
      return i.matches(t);
    } catch {
      return false;
    }
  });
}
var Za = ["transform", "translate", "scale", "rotate", "perspective"];
var Ka = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var tl = ["paint", "layout", "strict", "content"];
function gn(i) {
  const t = vn(), e = ht(i) ? et(i) : i;
  return Za.some((n) => e[n] ? e[n] !== "none" : false) || (e.containerType ? e.containerType !== "normal" : false) || !t && (e.backdropFilter ? e.backdropFilter !== "none" : false) || !t && (e.filter ? e.filter !== "none" : false) || Ka.some((n) => (e.willChange || "").includes(n)) || tl.some((n) => (e.contain || "").includes(n));
}
function el(i) {
  let t = ie(i);
  for (; pt(t) && !vi(t); ) {
    if (gn(t))
      return t;
    if (Qa(t))
      return null;
    t = ie(t);
  }
  return null;
}
function vn() {
  return typeof CSS > "u" || !CSS.supports ? false : CSS.supports("-webkit-backdrop-filter", "none");
}
var il = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function vi(i) {
  return il.has(At(i));
}
function et(i) {
  return J(i).getComputedStyle(i);
}
function yi(i) {
  return ht(i) ? {
    scrollLeft: i.scrollLeft,
    scrollTop: i.scrollTop
  } : {
    scrollLeft: i.scrollX,
    scrollTop: i.scrollY
  };
}
function ie(i) {
  if (At(i) === "html")
    return i;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    i.assignedSlot || // DOM Element detected.
    i.parentNode || // ShadowRoot detected.
    Xn(i) && i.host || // Fallback.
    Et(i)
  );
  return Xn(t) ? t.host : t;
}
function Zs(i) {
  const t = ie(i);
  return vi(t) ? i.ownerDocument ? i.ownerDocument.body : i.body : pt(t) && Be(t) ? t : Zs(t);
}
function Ks(i, t, e) {
  var n;
  t === void 0 && (t = []);
  const s = Zs(i), o = s === ((n = i.ownerDocument) == null ? void 0 : n.body), r = J(s);
  return o ? (nl(r), t.concat(r, r.visualViewport || [], Be(s) ? s : [], [])) : t.concat(s, Ks(s, []));
}
function nl(i) {
  return i.parent && Object.getPrototypeOf(i.parent) ? i.frameElement : null;
}
function to(i) {
  const t = et(i);
  let e = parseFloat(t.width) || 0, n = parseFloat(t.height) || 0;
  const s = pt(i), o = s ? i.offsetWidth : e, r = s ? i.offsetHeight : n, a = oi(e) !== o || oi(n) !== r;
  return a && (e = o, n = r), {
    width: e,
    height: n,
    $: a
  };
}
function eo(i) {
  return ht(i) ? i : i.contextElement;
}
function Xt(i) {
  const t = eo(i);
  if (!pt(t))
    return Ct(1);
  const e = t.getBoundingClientRect(), {
    width: n,
    height: s,
    $: o
  } = to(t);
  let r = (o ? oi(e.width) : e.width) / n, a = (o ? oi(e.height) : e.height) / s;
  return (!r || !Number.isFinite(r)) && (r = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: r,
    y: a
  };
}
var sl = Ct(0);
function io(i) {
  const t = J(i);
  return !vn() || !t.visualViewport ? sl : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function ol(i, t, e) {
  return t === void 0 && (t = false), !e || t && e !== J(i) ? false : t;
}
function Ee(i, t, e, n) {
  t === void 0 && (t = false), e === void 0 && (e = false);
  const s = i.getBoundingClientRect(), o = eo(i);
  let r = Ct(1);
  t && (n ? ht(n) && (r = Xt(n)) : r = Xt(i));
  const a = ol(o, e, n) ? io(o) : Ct(0);
  let l = (s.left + a.x) / r.x, c = (s.top + a.y) / r.y, d = s.width / r.x, u = s.height / r.y;
  if (o) {
    const p = J(o), f = n && ht(n) ? J(n) : n;
    let b = p, v = b.frameElement;
    for (; v && n && f !== b; ) {
      const g = Xt(v), $ = v.getBoundingClientRect(), y = et(v), _ = $.left + (v.clientLeft + parseFloat(y.paddingLeft)) * g.x, w = $.top + (v.clientTop + parseFloat(y.paddingTop)) * g.y;
      l *= g.x, c *= g.y, d *= g.x, u *= g.y, l += _, c += w, b = J(v), v = b.frameElement;
    }
  }
  return ee({
    width: d,
    height: u,
    x: l,
    y: c
  });
}
var rl = [":popover-open", ":modal"];
function no(i) {
  return rl.some((t) => {
    try {
      return i.matches(t);
    } catch {
      return false;
    }
  });
}
function al(i) {
  let {
    elements: t,
    rect: e,
    offsetParent: n,
    strategy: s
  } = i;
  const o = s === "fixed", r = Et(n), a = t ? no(t.floating) : false;
  if (n === r || a && o)
    return e;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = Ct(1);
  const d = Ct(0), u = pt(n);
  if ((u || !u && !o) && ((At(n) !== "body" || Be(r)) && (l = yi(n)), pt(n))) {
    const p = Ee(n);
    c = Xt(n), d.x = p.x + n.clientLeft, d.y = p.y + n.clientTop;
  }
  return {
    width: e.width * c.x,
    height: e.height * c.y,
    x: e.x * c.x - l.scrollLeft * c.x + d.x,
    y: e.y * c.y - l.scrollTop * c.y + d.y
  };
}
function ll(i) {
  return Array.from(i.getClientRects());
}
function so(i) {
  return Ee(Et(i)).left + yi(i).scrollLeft;
}
function cl(i) {
  const t = Et(i), e = yi(i), n = i.ownerDocument.body, s = bt(t.scrollWidth, t.clientWidth, n.scrollWidth, n.clientWidth), o = bt(t.scrollHeight, t.clientHeight, n.scrollHeight, n.clientHeight);
  let r = -e.scrollLeft + so(i);
  const a = -e.scrollTop;
  return et(n).direction === "rtl" && (r += bt(t.clientWidth, n.clientWidth) - s), {
    width: s,
    height: o,
    x: r,
    y: a
  };
}
function dl(i, t) {
  const e = J(i), n = Et(i), s = e.visualViewport;
  let o = n.clientWidth, r = n.clientHeight, a = 0, l = 0;
  if (s) {
    o = s.width, r = s.height;
    const c = vn();
    (!c || c && t === "fixed") && (a = s.offsetLeft, l = s.offsetTop);
  }
  return {
    width: o,
    height: r,
    x: a,
    y: l
  };
}
function ul(i, t) {
  const e = Ee(i, true, t === "fixed"), n = e.top + i.clientTop, s = e.left + i.clientLeft, o = pt(i) ? Xt(i) : Ct(1), r = i.clientWidth * o.x, a = i.clientHeight * o.y, l = s * o.x, c = n * o.y;
  return {
    width: r,
    height: a,
    x: l,
    y: c
  };
}
function Jn(i, t, e) {
  let n;
  if (t === "viewport")
    n = dl(i, e);
  else if (t === "document")
    n = cl(Et(i));
  else if (ht(t))
    n = ul(t, e);
  else {
    const s = io(i);
    n = {
      ...t,
      x: t.x - s.x,
      y: t.y - s.y
    };
  }
  return ee(n);
}
function oo(i, t) {
  const e = ie(i);
  return e === t || !ht(e) || vi(e) ? false : et(e).position === "fixed" || oo(e, t);
}
function hl(i, t) {
  const e = t.get(i);
  if (e)
    return e;
  let n = Ks(i, []).filter((a) => ht(a) && At(a) !== "body"), s = null;
  const o = et(i).position === "fixed";
  let r = o ? ie(i) : i;
  for (; ht(r) && !vi(r); ) {
    const a = et(r), l = gn(r);
    !l && a.position === "fixed" && (s = null), (o ? !l && !s : !l && a.position === "static" && s && ["absolute", "fixed"].includes(s.position) || Be(r) && !l && oo(i, r)) ? n = n.filter((c) => c !== r) : s = a, r = ie(r);
  }
  return t.set(i, n), n;
}
function pl(i) {
  let {
    element: t,
    boundary: e,
    rootBoundary: n,
    strategy: s
  } = i;
  const o = [...e === "clippingAncestors" ? hl(t, this._c) : [].concat(e), n], r = o[0], a = o.reduce((l, c) => {
    const d = Jn(t, c, s);
    return l.top = bt(d.top, l.top), l.right = te(d.right, l.right), l.bottom = te(d.bottom, l.bottom), l.left = bt(d.left, l.left), l;
  }, Jn(t, r, s));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function ml(i) {
  const {
    width: t,
    height: e
  } = to(i);
  return {
    width: t,
    height: e
  };
}
function fl(i, t, e) {
  const n = pt(t), s = Et(t), o = e === "fixed", r = Ee(i, true, o, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = Ct(0);
  if (n || !n && !o)
    if ((At(t) !== "body" || Be(s)) && (a = yi(t)), n) {
      const u = Ee(t, true, o, t);
      l.x = u.x + t.clientLeft, l.y = u.y + t.clientTop;
    } else
      s && (l.x = so(s));
  const c = r.left + a.scrollLeft - l.x, d = r.top + a.scrollTop - l.y;
  return {
    x: c,
    y: d,
    width: r.width,
    height: r.height
  };
}
function Qn(i, t) {
  return !pt(i) || et(i).position === "fixed" ? null : t ? t(i) : i.offsetParent;
}
function ro(i, t) {
  const e = J(i);
  if (!pt(i) || no(i))
    return e;
  let n = Qn(i, t);
  for (; n && Xa(n) && et(n).position === "static"; )
    n = Qn(n, t);
  return n && (At(n) === "html" || At(n) === "body" && et(n).position === "static" && !gn(n)) ? e : n || el(i) || e;
}
var bl = async function(i) {
  const t = this.getOffsetParent || ro, e = this.getDimensions;
  return {
    reference: fl(i.reference, await t(i.floating), i.strategy),
    floating: {
      x: 0,
      y: 0,
      ...await e(i.floating)
    }
  };
};
function gl(i) {
  return et(i).direction === "rtl";
}
var vl = {
  convertOffsetParentRelativeRectToViewportRelativeRect: al,
  getDocumentElement: Et,
  getClippingRect: pl,
  getOffsetParent: ro,
  getElementRects: bl,
  getClientRects: ll,
  getDimensions: ml,
  getScale: Xt,
  isElement: ht,
  isRTL: gl
};
var ao = Ya;
var lo = Na;
var co = Ua;
var uo = (i, t, e) => {
  const n = /* @__PURE__ */ new Map(), s = {
    platform: vl,
    ...e
  }, o = {
    ...s.platform,
    _c: n
  };
  return Ha(i, t, {
    ...s,
    platform: o
  });
};
var Ke = globalThis;
var yn = Ke.ShadowRoot && (Ke.ShadyCSS === void 0 || Ke.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var _n = Symbol();
var Zn = /* @__PURE__ */ new WeakMap();
var ho = class {
  constructor(i, t, e) {
    if (this._$cssResult$ = true, e !== _n)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = i, this.t = t;
  }
  get styleSheet() {
    let i = this.o;
    const t = this.t;
    if (yn && i === void 0) {
      const e = t !== void 0 && t.length === 1;
      e && (i = Zn.get(t)), i === void 0 && ((this.o = i = new CSSStyleSheet()).replaceSync(this.cssText), e && Zn.set(t, i));
    }
    return i;
  }
  toString() {
    return this.cssText;
  }
};
var yl = (i) => new ho(typeof i == "string" ? i : i + "", void 0, _n);
var O = (i, ...t) => {
  const e = i.length === 1 ? i[0] : t.reduce((n, s, o) => n + ((r) => {
    if (r._$cssResult$ === true)
      return r.cssText;
    if (typeof r == "number")
      return r;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + r + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s) + i[o + 1], i[0]);
  return new ho(e, i, _n);
};
var _l = (i, t) => {
  if (yn)
    i.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
  else
    for (const e of t) {
      const n = document.createElement("style"), s = Ke.litNonce;
      s !== void 0 && n.setAttribute("nonce", s), n.textContent = e.cssText, i.appendChild(n);
    }
};
var Kn = yn ? (i) => i : (i) => i instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const n of t.cssRules)
    e += n.cssText;
  return yl(e);
})(i) : i;
var { is: wl, defineProperty: $l, getOwnPropertyDescriptor: xl, getOwnPropertyNames: Cl, getOwnPropertySymbols: Al, getPrototypeOf: Sl } = Object;
var ne = globalThis;
var ts = ne.trustedTypes;
var kl = ts ? ts.emptyScript : "";
var es = ne.reactiveElementPolyfillSupport;
var $e = (i, t) => i;
var ai = { toAttribute(i, t) {
  switch (t) {
    case Boolean:
      i = i ? kl : null;
      break;
    case Object:
    case Array:
      i = i == null ? i : JSON.stringify(i);
  }
  return i;
}, fromAttribute(i, t) {
  let e = i;
  switch (t) {
    case Boolean:
      e = i !== null;
      break;
    case Number:
      e = i === null ? null : Number(i);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(i);
      } catch {
        e = null;
      }
  }
  return e;
} };
var wn = (i, t) => !wl(i, t);
var is = { attribute: true, type: String, converter: ai, reflect: false, useDefault: false, hasChanged: wn };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), ne.litPropertyMetadata ?? (ne.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
var Gt = class extends HTMLElement {
  static addInitializer(i) {
    this._$Ei(), (this.l ?? (this.l = [])).push(i);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(i, t = is) {
    if (t.state && (t.attribute = false), this._$Ei(), this.prototype.hasOwnProperty(i) && ((t = Object.create(t)).wrapped = true), this.elementProperties.set(i, t), !t.noAccessor) {
      const e = Symbol(), n = this.getPropertyDescriptor(i, e, t);
      n !== void 0 && $l(this.prototype, i, n);
    }
  }
  static getPropertyDescriptor(i, t, e) {
    const { get: n, set: s } = xl(this.prototype, i) ?? { get() {
      return this[t];
    }, set(o) {
      this[t] = o;
    } };
    return { get: n, set(o) {
      const r = n == null ? void 0 : n.call(this);
      s == null || s.call(this, o), this.requestUpdate(i, r, e);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(i) {
    return this.elementProperties.get(i) ?? is;
  }
  static _$Ei() {
    if (this.hasOwnProperty($e("elementProperties")))
      return;
    const i = Sl(this);
    i.finalize(), i.l !== void 0 && (this.l = [...i.l]), this.elementProperties = new Map(i.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty($e("finalized")))
      return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty($e("properties"))) {
      const t = this.properties, e = [...Cl(t), ...Al(t)];
      for (const n of e)
        this.createProperty(n, t[n]);
    }
    const i = this[Symbol.metadata];
    if (i !== null) {
      const t = litPropertyMetadata.get(i);
      if (t !== void 0)
        for (const [e, n] of t)
          this.elementProperties.set(e, n);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t, e] of this.elementProperties) {
      const n = this._$Eu(t, e);
      n !== void 0 && this._$Eh.set(n, t);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(i) {
    const t = [];
    if (Array.isArray(i)) {
      const e = new Set(i.flat(1 / 0).reverse());
      for (const n of e)
        t.unshift(Kn(n));
    } else
      i !== void 0 && t.push(Kn(i));
    return t;
  }
  static _$Eu(i, t) {
    const e = t.attribute;
    return e === false ? void 0 : typeof e == "string" ? e : typeof i == "string" ? i.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var i;
    this._$ES = new Promise((t) => this.enableUpdating = t), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (i = this.constructor.l) == null || i.forEach((t) => t(this));
  }
  addController(i) {
    var t;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(i), this.renderRoot !== void 0 && this.isConnected && ((t = i.hostConnected) == null || t.call(i));
  }
  removeController(i) {
    var t;
    (t = this._$EO) == null || t.delete(i);
  }
  _$E_() {
    const i = /* @__PURE__ */ new Map(), t = this.constructor.elementProperties;
    for (const e of t.keys())
      this.hasOwnProperty(e) && (i.set(e, this[e]), delete this[e]);
    i.size > 0 && (this._$Ep = i);
  }
  createRenderRoot() {
    const i = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return _l(i, this.constructor.elementStyles), i;
  }
  connectedCallback() {
    var i;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (i = this._$EO) == null || i.forEach((t) => {
      var e;
      return (e = t.hostConnected) == null ? void 0 : e.call(t);
    });
  }
  enableUpdating(i) {
  }
  disconnectedCallback() {
    var i;
    (i = this._$EO) == null || i.forEach((t) => {
      var e;
      return (e = t.hostDisconnected) == null ? void 0 : e.call(t);
    });
  }
  attributeChangedCallback(i, t, e) {
    this._$AK(i, e);
  }
  _$ET(i, t) {
    var e;
    const n = this.constructor.elementProperties.get(i), s = this.constructor._$Eu(i, n);
    if (s !== void 0 && n.reflect === true) {
      const o = (((e = n.converter) == null ? void 0 : e.toAttribute) !== void 0 ? n.converter : ai).toAttribute(t, n.type);
      this._$Em = i, o == null ? this.removeAttribute(s) : this.setAttribute(s, o), this._$Em = null;
    }
  }
  _$AK(i, t) {
    var e, n;
    const s = this.constructor, o = s._$Eh.get(i);
    if (o !== void 0 && this._$Em !== o) {
      const r = s.getPropertyOptions(o), a = typeof r.converter == "function" ? { fromAttribute: r.converter } : ((e = r.converter) == null ? void 0 : e.fromAttribute) !== void 0 ? r.converter : ai;
      this._$Em = o, this[o] = a.fromAttribute(t, r.type) ?? ((n = this._$Ej) == null ? void 0 : n.get(o)) ?? null, this._$Em = null;
    }
  }
  requestUpdate(i, t, e) {
    var n;
    if (i !== void 0) {
      const s = this.constructor, o = this[i];
      if (e ?? (e = s.getPropertyOptions(i)), !((e.hasChanged ?? wn)(o, t) || e.useDefault && e.reflect && o === ((n = this._$Ej) == null ? void 0 : n.get(i)) && !this.hasAttribute(s._$Eu(i, e))))
        return;
      this.C(i, t, e);
    }
    this.isUpdatePending === false && (this._$ES = this._$EP());
  }
  C(i, t, { useDefault: e, reflect: n, wrapped: s }, o) {
    e && !(this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Map())).has(i) && (this._$Ej.set(i, o ?? t ?? this[i]), s !== true || o !== void 0) || (this._$AL.has(i) || (this.hasUpdated || e || (t = void 0), this._$AL.set(i, t)), n === true && this._$Em !== i && (this._$Eq ?? (this._$Eq = /* @__PURE__ */ new Set())).add(i));
  }
  async _$EP() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t) {
      Promise.reject(t);
    }
    const i = this.scheduleUpdate();
    return i != null && await i, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var i;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [s, o] of this._$Ep)
          this[s] = o;
        this._$Ep = void 0;
      }
      const n = this.constructor.elementProperties;
      if (n.size > 0)
        for (const [s, o] of n) {
          const { wrapped: r } = o, a = this[s];
          r !== true || this._$AL.has(s) || a === void 0 || this.C(s, void 0, o, a);
        }
    }
    let t = false;
    const e = this._$AL;
    try {
      t = this.shouldUpdate(e), t ? (this.willUpdate(e), (i = this._$EO) == null || i.forEach((n) => {
        var s;
        return (s = n.hostUpdate) == null ? void 0 : s.call(n);
      }), this.update(e)) : this._$EM();
    } catch (n) {
      throw t = false, this._$EM(), n;
    }
    t && this._$AE(e);
  }
  willUpdate(i) {
  }
  _$AE(i) {
    var t;
    (t = this._$EO) == null || t.forEach((e) => {
      var n;
      return (n = e.hostUpdated) == null ? void 0 : n.call(e);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(i)), this.updated(i);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(i) {
    return true;
  }
  update(i) {
    this._$Eq && (this._$Eq = this._$Eq.forEach((t) => this._$ET(t, this[t]))), this._$EM();
  }
  updated(i) {
  }
  firstUpdated(i) {
  }
};
Gt.elementStyles = [], Gt.shadowRootOptions = { mode: "open" }, Gt[$e("elementProperties")] = /* @__PURE__ */ new Map(), Gt[$e("finalized")] = /* @__PURE__ */ new Map(), es == null || es({ ReactiveElement: Gt }), (ne.reactiveElementVersions ?? (ne.reactiveElementVersions = [])).push("2.1.0");
var li = globalThis;
var ci = li.trustedTypes;
var ns = ci ? ci.createPolicy("lit-html", { createHTML: (i) => i }) : void 0;
var po = "$lit$";
var wt = `lit$${Math.random().toFixed(9).slice(2)}$`;
var mo = "?" + wt;
var El = `<${mo}>`;
var Ut = document;
var Te = () => Ut.createComment("");
var Oe = (i) => i === null || typeof i != "object" && typeof i != "function";
var $n = Array.isArray;
var Tl = (i) => $n(i) || typeof (i == null ? void 0 : i[Symbol.iterator]) == "function";
var Bi = `[ 	
\f\r]`;
var ge = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var ss = /-->/g;
var os = />/g;
var It = RegExp(`>|${Bi}(?:([^\\s"'>=/]+)(${Bi}*=${Bi}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var rs = /'/g;
var as = /"/g;
var fo = /^(?:script|style|textarea|title)$/i;
var Ol = (i) => (t, ...e) => ({ _$litType$: i, strings: t, values: e });
var h = Ol(1);
var qt = Symbol.for("lit-noChange");
var I = Symbol.for("lit-nothing");
var ls = /* @__PURE__ */ new WeakMap();
var Dt = Ut.createTreeWalker(Ut, 129);
function bo(i, t) {
  if (!$n(i) || !i.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return ns !== void 0 ? ns.createHTML(t) : t;
}
var Pl = (i, t) => {
  const e = i.length - 1, n = [];
  let s, o = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", r = ge;
  for (let a = 0; a < e; a++) {
    const l = i[a];
    let c, d, u = -1, p = 0;
    for (; p < l.length && (r.lastIndex = p, d = r.exec(l), d !== null); )
      p = r.lastIndex, r === ge ? d[1] === "!--" ? r = ss : d[1] !== void 0 ? r = os : d[2] !== void 0 ? (fo.test(d[2]) && (s = RegExp("</" + d[2], "g")), r = It) : d[3] !== void 0 && (r = It) : r === It ? d[0] === ">" ? (r = s ?? ge, u = -1) : d[1] === void 0 ? u = -2 : (u = r.lastIndex - d[2].length, c = d[1], r = d[3] === void 0 ? It : d[3] === '"' ? as : rs) : r === as || r === rs ? r = It : r === ss || r === os ? r = ge : (r = It, s = void 0);
    const f = r === It && i[a + 1].startsWith("/>") ? " " : "";
    o += r === ge ? l + El : u >= 0 ? (n.push(c), l.slice(0, u) + po + l.slice(u) + wt + f) : l + wt + (u === -2 ? a : f);
  }
  return [bo(i, o + (i[e] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), n];
};
var Pe = class _Pe {
  constructor({ strings: t, _$litType$: e }, n) {
    let s;
    this.parts = [];
    let o = 0, r = 0;
    const a = t.length - 1, l = this.parts, [c, d] = Pl(t, e);
    if (this.el = _Pe.createElement(c, n), Dt.currentNode = this.el.content, e === 2 || e === 3) {
      const u = this.el.content.firstChild;
      u.replaceWith(...u.childNodes);
    }
    for (; (s = Dt.nextNode()) !== null && l.length < a; ) {
      if (s.nodeType === 1) {
        if (s.hasAttributes())
          for (const u of s.getAttributeNames())
            if (u.endsWith(po)) {
              const p = d[r++], f = s.getAttribute(u).split(wt), b = /([.?@])?(.*)/.exec(p);
              l.push({ type: 1, index: o, name: b[2], strings: f, ctor: b[1] === "." ? zl : b[1] === "?" ? Il : b[1] === "@" ? Rl : _i }), s.removeAttribute(u);
            } else
              u.startsWith(wt) && (l.push({ type: 6, index: o }), s.removeAttribute(u));
        if (fo.test(s.tagName)) {
          const u = s.textContent.split(wt), p = u.length - 1;
          if (p > 0) {
            s.textContent = ci ? ci.emptyScript : "";
            for (let f = 0; f < p; f++)
              s.append(u[f], Te()), Dt.nextNode(), l.push({ type: 2, index: ++o });
            s.append(u[p], Te());
          }
        }
      } else if (s.nodeType === 8)
        if (s.data === mo)
          l.push({ type: 2, index: o });
        else {
          let u = -1;
          for (; (u = s.data.indexOf(wt, u + 1)) !== -1; )
            l.push({ type: 7, index: o }), u += wt.length - 1;
        }
      o++;
    }
  }
  static createElement(t, e) {
    const n = Ut.createElement("template");
    return n.innerHTML = t, n;
  }
};
function se(i, t, e = i, n) {
  var s, o;
  if (t === qt)
    return t;
  let r = n !== void 0 ? (s = e._$Co) == null ? void 0 : s[n] : e._$Cl;
  const a = Oe(t) ? void 0 : t._$litDirective$;
  return (r == null ? void 0 : r.constructor) !== a && ((o = r == null ? void 0 : r._$AO) == null || o.call(r, false), a === void 0 ? r = void 0 : (r = new a(i), r._$AT(i, e, n)), n !== void 0 ? (e._$Co ?? (e._$Co = []))[n] = r : e._$Cl = r), r !== void 0 && (t = se(i, r._$AS(i, t.values), r, n)), t;
}
var Ml = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: n } = this._$AD, s = ((t == null ? void 0 : t.creationScope) ?? Ut).importNode(e, true);
    Dt.currentNode = s;
    let o = Dt.nextNode(), r = 0, a = 0, l = n[0];
    for (; l !== void 0; ) {
      if (r === l.index) {
        let c;
        l.type === 2 ? c = new He(o, o.nextSibling, this, t) : l.type === 1 ? c = new l.ctor(o, l.name, l.strings, this, t) : l.type === 6 && (c = new Dl(o, this, t)), this._$AV.push(c), l = n[++a];
      }
      r !== (l == null ? void 0 : l.index) && (o = Dt.nextNode(), r++);
    }
    return Dt.currentNode = Ut, s;
  }
  p(t) {
    let e = 0;
    for (const n of this._$AV)
      n !== void 0 && (n.strings !== void 0 ? (n._$AI(t, n, e), e += n.strings.length - 2) : n._$AI(t[e])), e++;
  }
};
var He = class _He {
  get _$AU() {
    var t;
    return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this._$Cv;
  }
  constructor(t, e, n, s) {
    this.type = 2, this._$AH = I, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = n, this.options = s, this._$Cv = (s == null ? void 0 : s.isConnected) ?? true;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = se(this, t, e), Oe(t) ? t === I || t == null || t === "" ? (this._$AH !== I && this._$AR(), this._$AH = I) : t !== this._$AH && t !== qt && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : Tl(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== I && Oe(this._$AH) ? this._$AA.nextSibling.data = t : this.T(Ut.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    var e;
    const { values: n, _$litType$: s } = t, o = typeof s == "number" ? this._$AC(t) : (s.el === void 0 && (s.el = Pe.createElement(bo(s.h, s.h[0]), this.options)), s);
    if (((e = this._$AH) == null ? void 0 : e._$AD) === o)
      this._$AH.p(n);
    else {
      const r = new Ml(o, this), a = r.u(this.options);
      r.p(n), this.T(a), this._$AH = r;
    }
  }
  _$AC(t) {
    let e = ls.get(t.strings);
    return e === void 0 && ls.set(t.strings, e = new Pe(t)), e;
  }
  k(t) {
    $n(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let n, s = 0;
    for (const o of t)
      s === e.length ? e.push(n = new _He(this.O(Te()), this.O(Te()), this, this.options)) : n = e[s], n._$AI(o), s++;
    s < e.length && (this._$AR(n && n._$AB.nextSibling, s), e.length = s);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var n;
    for ((n = this._$AP) == null ? void 0 : n.call(this, false, true, e); t && t !== this._$AB; ) {
      const s = t.nextSibling;
      t.remove(), t = s;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this._$Cv = t, (e = this._$AP) == null || e.call(this, t));
  }
};
var _i = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, n, s, o) {
    this.type = 1, this._$AH = I, this._$AN = void 0, this.element = t, this.name = e, this._$AM = s, this.options = o, n.length > 2 || n[0] !== "" || n[1] !== "" ? (this._$AH = Array(n.length - 1).fill(new String()), this.strings = n) : this._$AH = I;
  }
  _$AI(t, e = this, n, s) {
    const o = this.strings;
    let r = false;
    if (o === void 0)
      t = se(this, t, e, 0), r = !Oe(t) || t !== this._$AH && t !== qt, r && (this._$AH = t);
    else {
      const a = t;
      let l, c;
      for (t = o[0], l = 0; l < o.length - 1; l++)
        c = se(this, a[n + l], e, l), c === qt && (c = this._$AH[l]), r || (r = !Oe(c) || c !== this._$AH[l]), c === I ? t = I : t !== I && (t += (c ?? "") + o[l + 1]), this._$AH[l] = c;
    }
    r && !s && this.j(t);
  }
  j(t) {
    t === I ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
};
var zl = class extends _i {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === I ? void 0 : t;
  }
};
var Il = class extends _i {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== I);
  }
};
var Rl = class extends _i {
  constructor(t, e, n, s, o) {
    super(t, e, n, s, o), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = se(this, t, e, 0) ?? I) === qt)
      return;
    const n = this._$AH, s = t === I && n !== I || t.capture !== n.capture || t.once !== n.once || t.passive !== n.passive, o = t !== I && (n === I || s);
    s && this.element.removeEventListener(this.name, this, n), o && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e;
    typeof this._$AH == "function" ? this._$AH.call(((e = this.options) == null ? void 0 : e.host) ?? this.element, t) : this._$AH.handleEvent(t);
  }
};
var Dl = class {
  constructor(t, e, n) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = n;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    se(this, t);
  }
};
var cs = li.litHtmlPolyfillSupport;
cs == null || cs(Pe, He), (li.litHtmlVersions ?? (li.litHtmlVersions = [])).push("3.3.0");
var oe = (i, t, e) => {
  const n = (e == null ? void 0 : e.renderBefore) ?? t;
  let s = n._$litPart$;
  if (s === void 0) {
    const o = (e == null ? void 0 : e.renderBefore) ?? null;
    n._$litPart$ = s = new He(t.insertBefore(Te(), o), o, void 0, e ?? {});
  }
  return s._$AI(i), s;
};
var Me = globalThis;
var T = class extends Gt {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var i;
    const t = super.createRenderRoot();
    return (i = this.renderOptions).renderBefore ?? (i.renderBefore = t.firstChild), t;
  }
  update(i) {
    const t = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(i), this._$Do = oe(t, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var i;
    super.connectedCallback(), (i = this._$Do) == null || i.setConnected(true);
  }
  disconnectedCallback() {
    var i;
    super.disconnectedCallback(), (i = this._$Do) == null || i.setConnected(false);
  }
  render() {
    return qt;
  }
};
var ds;
T._$litElement$ = true, T.finalized = true, (ds = Me.litElementHydrateSupport) == null || ds.call(Me, { LitElement: T });
var us = Me.litElementPolyfillSupport;
us == null || us({ LitElement: T });
(Me.litElementVersions ?? (Me.litElementVersions = [])).push("4.2.0");
var Ll = { attribute: true, type: String, converter: ai, reflect: false, hasChanged: wn };
var jl = (i = Ll, t, e) => {
  const { kind: n, metadata: s } = e;
  let o = globalThis.litPropertyMetadata.get(s);
  if (o === void 0 && globalThis.litPropertyMetadata.set(s, o = /* @__PURE__ */ new Map()), n === "setter" && ((i = Object.create(i)).wrapped = true), o.set(e.name, i), n === "accessor") {
    const { name: r } = e;
    return { set(a) {
      const l = t.get.call(this);
      t.set.call(this, a), this.requestUpdate(r, l, i);
    }, init(a) {
      return a !== void 0 && this.C(r, void 0, i, a), a;
    } };
  }
  if (n === "setter") {
    const { name: r } = e;
    return function(a) {
      const l = this[r];
      t.call(this, a), this.requestUpdate(r, l, i);
    };
  }
  throw Error("Unsupported decorator location: " + n);
};
function m(i) {
  return (t, e) => typeof e == "object" ? jl(i, t, e) : ((n, s, o) => {
    const r = s.hasOwnProperty(o);
    return s.constructor.createProperty(o, n), r ? Object.getOwnPropertyDescriptor(s, o) : void 0;
  })(i, t, e);
}
function ae(i) {
  return m({ ...i, state: true, attribute: false });
}
var Bl = (i) => i.strings === void 0;
var go = { ATTRIBUTE: 1, CHILD: 2 };
var vo = (i) => (...t) => ({ _$litDirective$: i, values: t });
var yo = class {
  constructor(i) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(i, t, e) {
    this._$Ct = i, this._$AM = t, this._$Ci = e;
  }
  _$AS(i, t) {
    return this.update(i, t);
  }
  update(i, t) {
    return this.render(...t);
  }
};
var xe = (i, t) => {
  var e;
  const n = i._$AN;
  if (n === void 0)
    return false;
  for (const s of n)
    (e = s._$AO) == null || e.call(s, t, false), xe(s, t);
  return true;
};
var di = (i) => {
  let t, e;
  do {
    if ((t = i._$AM) === void 0)
      break;
    e = t._$AN, e.delete(i), i = t;
  } while ((e == null ? void 0 : e.size) === 0);
};
var _o = (i) => {
  for (let t; t = i._$AM; i = t) {
    let e = t._$AN;
    if (e === void 0)
      t._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(i))
      break;
    e.add(i), Fl(t);
  }
};
function Hl(i) {
  this._$AN !== void 0 ? (di(this), this._$AM = i, _o(this)) : this._$AM = i;
}
function Nl(i, t = false, e = 0) {
  const n = this._$AH, s = this._$AN;
  if (s !== void 0 && s.size !== 0)
    if (t)
      if (Array.isArray(n))
        for (let o = e; o < n.length; o++)
          xe(n[o], false), di(n[o]);
      else
        n != null && (xe(n, false), di(n));
    else
      xe(this, i);
}
var Fl = (i) => {
  i.type == go.CHILD && (i._$AP ?? (i._$AP = Nl), i._$AQ ?? (i._$AQ = Hl));
};
var Ul = class extends yo {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, e, n) {
    super._$AT(t, e, n), _o(this), this.isConnected = t._$AU;
  }
  _$AO(t, e = true) {
    var n, s;
    t !== this.isConnected && (this.isConnected = t, t ? (n = this.reconnected) == null || n.call(this) : (s = this.disconnected) == null || s.call(this)), e && (xe(this, t), di(this));
  }
  setValue(t) {
    if (Bl(this._$Ct))
      this._$Ct._$AI(t, this);
    else {
      const e = [...this._$Ct._$AH];
      e[this._$Ci] = t, this._$Ct._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};
var re = () => new ql();
var ql = class {
};
var Hi = /* @__PURE__ */ new WeakMap();
var V = vo(class extends Ul {
  render(i) {
    return I;
  }
  update(i, [t]) {
    var e;
    const n = t !== this.G;
    return n && this.G !== void 0 && this.rt(void 0), (n || this.lt !== this.ct) && (this.G = t, this.ht = (e = i.options) == null ? void 0 : e.host, this.rt(this.ct = i.element)), I;
  }
  rt(i) {
    if (this.isConnected || (i = void 0), typeof this.G == "function") {
      const t = this.ht ?? globalThis;
      let e = Hi.get(t);
      e === void 0 && (e = /* @__PURE__ */ new WeakMap(), Hi.set(t, e)), e.get(this.G) !== void 0 && this.G.call(this.ht, void 0), e.set(this.G, i), i !== void 0 && this.G.call(this.ht, i);
    } else
      this.G.value = i;
  }
  get lt() {
    var i, t;
    return typeof this.G == "function" ? (i = Hi.get(this.ht ?? globalThis)) == null ? void 0 : i.get(this.G) : (t = this.G) == null ? void 0 : t.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
var wo = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
);
var ui = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
var Ne = Object.freeze({
  ...wo,
  ...ui
});
var Gi = Object.freeze({
  ...Ne,
  body: "",
  hidden: false
});
var Vl = Object.freeze({
  width: null,
  height: null
});
var $o = Object.freeze({
  // Dimensions
  ...Vl,
  // Transformations
  ...ui
});
function Yl(i, t = 0) {
  const e = i.replace(/^-?[0-9.]*/, "");
  function n(s) {
    for (; s < 0; )
      s += 4;
    return s % 4;
  }
  if (e === "") {
    const s = parseInt(i);
    return isNaN(s) ? 0 : n(s);
  } else if (e !== i) {
    let s = 0;
    switch (e) {
      case "%":
        s = 25;
        break;
      case "deg":
        s = 90;
    }
    if (s) {
      let o = parseFloat(i.slice(0, i.length - e.length));
      return isNaN(o) ? 0 : (o = o / s, o % 1 === 0 ? n(o) : 0);
    }
  }
  return t;
}
var Wl = /[\s,]+/;
function Gl(i, t) {
  t.split(Wl).forEach((e) => {
    switch (e.trim()) {
      case "horizontal":
        i.hFlip = true;
        break;
      case "vertical":
        i.vFlip = true;
        break;
    }
  });
}
var xo = {
  ...$o,
  preserveAspectRatio: ""
};
function hs(i) {
  const t = {
    ...xo
  }, e = (n, s) => i.getAttribute(n) || s;
  return t.width = e("width", null), t.height = e("height", null), t.rotate = Yl(e("rotate", "")), Gl(t, e("flip", "")), t.preserveAspectRatio = e("preserveAspectRatio", e("preserveaspectratio", "")), t;
}
function Xl(i, t) {
  for (const e in xo)
    if (i[e] !== t[e])
      return true;
  return false;
}
var Ce = /^[a-z0-9]+(-[a-z0-9]+)*$/;
var Fe = (i, t, e, n = "") => {
  const s = i.split(":");
  if (i.slice(0, 1) === "@") {
    if (s.length < 2 || s.length > 3)
      return null;
    n = s.shift().slice(1);
  }
  if (s.length > 3 || !s.length)
    return null;
  if (s.length > 1) {
    const a = s.pop(), l = s.pop(), c = {
      // Allow provider without '@': "provider:prefix:name"
      provider: s.length > 0 ? s[0] : n,
      prefix: l,
      name: a
    };
    return t && !ti(c) ? null : c;
  }
  const o = s[0], r = o.split("-");
  if (r.length > 1) {
    const a = {
      provider: n,
      prefix: r.shift(),
      name: r.join("-")
    };
    return t && !ti(a) ? null : a;
  }
  if (e && n === "") {
    const a = {
      provider: n,
      prefix: "",
      name: o
    };
    return t && !ti(a, e) ? null : a;
  }
  return null;
};
var ti = (i, t) => i ? !!((i.provider === "" || i.provider.match(Ce)) && (t && i.prefix === "" || i.prefix.match(Ce)) && i.name.match(Ce)) : false;
function Jl(i, t) {
  const e = {};
  !i.hFlip != !t.hFlip && (e.hFlip = true), !i.vFlip != !t.vFlip && (e.vFlip = true);
  const n = ((i.rotate || 0) + (t.rotate || 0)) % 4;
  return n && (e.rotate = n), e;
}
function ps(i, t) {
  const e = Jl(i, t);
  for (const n in Gi)
    n in ui ? n in i && !(n in e) && (e[n] = ui[n]) : n in t ? e[n] = t[n] : n in i && (e[n] = i[n]);
  return e;
}
function Ql(i, t) {
  const e = i.icons, n = i.aliases || /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ Object.create(null);
  function o(r) {
    if (e[r])
      return s[r] = [];
    if (!(r in s)) {
      s[r] = null;
      const a = n[r] && n[r].parent, l = a && o(a);
      l && (s[r] = [a].concat(l));
    }
    return s[r];
  }
  return Object.keys(e).concat(Object.keys(n)).forEach(o), s;
}
function Zl(i, t, e) {
  const n = i.icons, s = i.aliases || /* @__PURE__ */ Object.create(null);
  let o = {};
  function r(a) {
    o = ps(
      n[a] || s[a],
      o
    );
  }
  return r(t), e.forEach(r), ps(i, o);
}
function Co(i, t) {
  const e = [];
  if (typeof i != "object" || typeof i.icons != "object")
    return e;
  i.not_found instanceof Array && i.not_found.forEach((s) => {
    t(s, null), e.push(s);
  });
  const n = Ql(i);
  for (const s in n) {
    const o = n[s];
    o && (t(s, Zl(i, s, o)), e.push(s));
  }
  return e;
}
var Kl = {
  provider: "",
  aliases: {},
  not_found: {},
  ...wo
};
function Ni(i, t) {
  for (const e in t)
    if (e in i && typeof i[e] != typeof t[e])
      return false;
  return true;
}
function Ao(i) {
  if (typeof i != "object" || i === null)
    return null;
  const t = i;
  if (typeof t.prefix != "string" || !i.icons || typeof i.icons != "object" || !Ni(i, Kl))
    return null;
  const e = t.icons;
  for (const s in e) {
    const o = e[s];
    if (!s.match(Ce) || typeof o.body != "string" || !Ni(
      o,
      Gi
    ))
      return null;
  }
  const n = t.aliases || /* @__PURE__ */ Object.create(null);
  for (const s in n) {
    const o = n[s], r = o.parent;
    if (!s.match(Ce) || typeof r != "string" || !e[r] && !n[r] || !Ni(
      o,
      Gi
    ))
      return null;
  }
  return t;
}
var hi = /* @__PURE__ */ Object.create(null);
function tc(i, t) {
  return {
    provider: i,
    prefix: t,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function St(i, t) {
  const e = hi[i] || (hi[i] = /* @__PURE__ */ Object.create(null));
  return e[t] || (e[t] = tc(i, t));
}
function xn(i, t) {
  return Ao(t) ? Co(t, (e, n) => {
    n ? i.icons[e] = n : i.missing.add(e);
  }) : [];
}
function ec(i, t, e) {
  try {
    if (typeof e.body == "string")
      return i.icons[t] = { ...e }, true;
  } catch {
  }
  return false;
}
function ic(i, t) {
  let e = [];
  return (typeof i == "string" ? [i] : Object.keys(hi)).forEach((n) => {
    (typeof n == "string" && typeof t == "string" ? [t] : Object.keys(hi[n] || {})).forEach((s) => {
      const o = St(n, s);
      e = e.concat(
        Object.keys(o.icons).map(
          (r) => (n !== "" ? "@" + n + ":" : "") + s + ":" + r
        )
      );
    });
  }), e;
}
var ze = false;
function So(i) {
  return typeof i == "boolean" && (ze = i), ze;
}
function Ie(i) {
  const t = typeof i == "string" ? Fe(i, true, ze) : i;
  if (t) {
    const e = St(t.provider, t.prefix), n = t.name;
    return e.icons[n] || (e.missing.has(n) ? null : void 0);
  }
}
function ko(i, t) {
  const e = Fe(i, true, ze);
  if (!e)
    return false;
  const n = St(e.provider, e.prefix);
  return ec(n, e.name, t);
}
function ms(i, t) {
  if (typeof i != "object")
    return false;
  if (typeof t != "string" && (t = i.provider || ""), ze && !t && !i.prefix) {
    let s = false;
    return Ao(i) && (i.prefix = "", Co(i, (o, r) => {
      r && ko(o, r) && (s = true);
    })), s;
  }
  const e = i.prefix;
  if (!ti({
    provider: t,
    prefix: e,
    name: "a"
  }))
    return false;
  const n = St(t, e);
  return !!xn(n, i);
}
function fs(i) {
  return !!Ie(i);
}
function nc(i) {
  const t = Ie(i);
  return t ? {
    ...Ne,
    ...t
  } : null;
}
function sc(i) {
  const t = {
    loaded: [],
    missing: [],
    pending: []
  }, e = /* @__PURE__ */ Object.create(null);
  i.sort((s, o) => s.provider !== o.provider ? s.provider.localeCompare(o.provider) : s.prefix !== o.prefix ? s.prefix.localeCompare(o.prefix) : s.name.localeCompare(o.name));
  let n = {
    provider: "",
    prefix: "",
    name: ""
  };
  return i.forEach((s) => {
    if (n.name === s.name && n.prefix === s.prefix && n.provider === s.provider)
      return;
    n = s;
    const o = s.provider, r = s.prefix, a = s.name, l = e[o] || (e[o] = /* @__PURE__ */ Object.create(null)), c = l[r] || (l[r] = St(o, r));
    let d;
    a in c.icons ? d = t.loaded : r === "" || c.missing.has(a) ? d = t.missing : d = t.pending;
    const u = {
      provider: o,
      prefix: r,
      name: a
    };
    d.push(u);
  }), t;
}
function Eo(i, t) {
  i.forEach((e) => {
    const n = e.loaderCallbacks;
    n && (e.loaderCallbacks = n.filter((s) => s.id !== t));
  });
}
function oc(i) {
  i.pendingCallbacksFlag || (i.pendingCallbacksFlag = true, setTimeout(() => {
    i.pendingCallbacksFlag = false;
    const t = i.loaderCallbacks ? i.loaderCallbacks.slice(0) : [];
    if (!t.length)
      return;
    let e = false;
    const n = i.provider, s = i.prefix;
    t.forEach((o) => {
      const r = o.icons, a = r.pending.length;
      r.pending = r.pending.filter((l) => {
        if (l.prefix !== s)
          return true;
        const c = l.name;
        if (i.icons[c])
          r.loaded.push({
            provider: n,
            prefix: s,
            name: c
          });
        else if (i.missing.has(c))
          r.missing.push({
            provider: n,
            prefix: s,
            name: c
          });
        else
          return e = true, true;
        return false;
      }), r.pending.length !== a && (e || Eo([i], o.id), o.callback(
        r.loaded.slice(0),
        r.missing.slice(0),
        r.pending.slice(0),
        o.abort
      ));
    });
  }));
}
var rc = 0;
function ac(i, t, e) {
  const n = rc++, s = Eo.bind(null, e, n);
  if (!t.pending.length)
    return s;
  const o = {
    id: n,
    icons: t,
    callback: i,
    abort: s
  };
  return e.forEach((r) => {
    (r.loaderCallbacks || (r.loaderCallbacks = [])).push(o);
  }), s;
}
var Xi = /* @__PURE__ */ Object.create(null);
function bs(i, t) {
  Xi[i] = t;
}
function Ji(i) {
  return Xi[i] || Xi[""];
}
function lc(i, t = true, e = false) {
  const n = [];
  return i.forEach((s) => {
    const o = typeof s == "string" ? Fe(s, t, e) : s;
    o && n.push(o);
  }), n;
}
var cc = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: false,
  dataAfterTimeout: false
};
function dc(i, t, e, n) {
  const s = i.resources.length, o = i.random ? Math.floor(Math.random() * s) : i.index;
  let r;
  if (i.random) {
    let x = i.resources.slice(0);
    for (r = []; x.length > 1; ) {
      const M = Math.floor(Math.random() * x.length);
      r.push(x[M]), x = x.slice(0, M).concat(x.slice(M + 1));
    }
    r = r.concat(x);
  } else
    r = i.resources.slice(o).concat(i.resources.slice(0, o));
  const a = Date.now();
  let l = "pending", c = 0, d, u = null, p = [], f = [];
  typeof n == "function" && f.push(n);
  function b() {
    u && (clearTimeout(u), u = null);
  }
  function v() {
    l === "pending" && (l = "aborted"), b(), p.forEach((x) => {
      x.status === "pending" && (x.status = "aborted");
    }), p = [];
  }
  function g(x, M) {
    M && (f = []), typeof x == "function" && f.push(x);
  }
  function $() {
    return {
      startTime: a,
      payload: t,
      status: l,
      queriesSent: c,
      queriesPending: p.length,
      subscribe: g,
      abort: v
    };
  }
  function y() {
    l = "failed", f.forEach((x) => {
      x(void 0, d);
    });
  }
  function _() {
    p.forEach((x) => {
      x.status === "pending" && (x.status = "aborted");
    }), p = [];
  }
  function w(x, M, N) {
    const q = M !== "success";
    switch (p = p.filter((E) => E !== x), l) {
      case "pending":
        break;
      case "failed":
        if (q || !i.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (M === "abort") {
      d = N, y();
      return;
    }
    if (q) {
      d = N, p.length || (r.length ? A() : y());
      return;
    }
    if (b(), _(), !i.random) {
      const E = i.resources.indexOf(x.resource);
      E !== -1 && E !== i.index && (i.index = E);
    }
    l = "completed", f.forEach((E) => {
      E(N);
    });
  }
  function A() {
    if (l !== "pending")
      return;
    b();
    const x = r.shift();
    if (x === void 0) {
      if (p.length) {
        u = setTimeout(() => {
          b(), l === "pending" && (_(), y());
        }, i.timeout);
        return;
      }
      y();
      return;
    }
    const M = {
      status: "pending",
      resource: x,
      callback: (N, q) => {
        w(M, N, q);
      }
    };
    p.push(M), c++, u = setTimeout(A, i.rotate), e(x, t, M.callback);
  }
  return setTimeout(A), $;
}
function To(i) {
  const t = {
    ...cc,
    ...i
  };
  let e = [];
  function n() {
    e = e.filter((r) => r().status === "pending");
  }
  function s(r, a, l) {
    const c = dc(
      t,
      r,
      a,
      (d, u) => {
        n(), l && l(d, u);
      }
    );
    return e.push(c), c;
  }
  function o(r) {
    return e.find((a) => r(a)) || null;
  }
  return {
    query: s,
    find: o,
    setIndex: (r) => {
      t.index = r;
    },
    getIndex: () => t.index,
    cleanup: n
  };
}
function Cn(i) {
  let t;
  if (typeof i.resources == "string")
    t = [i.resources];
  else if (t = i.resources, !(t instanceof Array) || !t.length)
    return null;
  return {
    // API hosts
    resources: t,
    // Root path
    path: i.path || "/",
    // URL length limit
    maxURL: i.maxURL || 500,
    // Timeout before next host is used.
    rotate: i.rotate || 750,
    // Timeout before failing query.
    timeout: i.timeout || 5e3,
    // Randomise default API end point.
    random: i.random === true,
    // Start index
    index: i.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: i.dataAfterTimeout !== false
  };
}
var wi = /* @__PURE__ */ Object.create(null);
var Je = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
];
var Qi = [];
for (; Je.length > 0; )
  Je.length === 1 || Math.random() > 0.5 ? Qi.push(Je.shift()) : Qi.push(Je.pop());
wi[""] = Cn({
  resources: ["https://api.iconify.design"].concat(Qi)
});
function gs(i, t) {
  const e = Cn(t);
  return e === null ? false : (wi[i] = e, true);
}
function $i(i) {
  return wi[i];
}
function uc() {
  return Object.keys(wi);
}
function vs() {
}
var Fi = /* @__PURE__ */ Object.create(null);
function hc(i) {
  if (!Fi[i]) {
    const t = $i(i);
    if (!t)
      return;
    const e = To(t), n = {
      config: t,
      redundancy: e
    };
    Fi[i] = n;
  }
  return Fi[i];
}
function Oo(i, t, e) {
  let n, s;
  if (typeof i == "string") {
    const o = Ji(i);
    if (!o)
      return e(void 0, 424), vs;
    s = o.send;
    const r = hc(i);
    r && (n = r.redundancy);
  } else {
    const o = Cn(i);
    if (o) {
      n = To(o);
      const r = i.resources ? i.resources[0] : "", a = Ji(r);
      a && (s = a.send);
    }
  }
  return !n || !s ? (e(void 0, 424), vs) : n.query(t, s, e)().abort;
}
var ys = "iconify2";
var Re = "iconify";
var Po = Re + "-count";
var _s = Re + "-version";
var Mo = 36e5;
var pc = 168;
var mc = 50;
function Zi(i, t) {
  try {
    return i.getItem(t);
  } catch {
  }
}
function An(i, t, e) {
  try {
    return i.setItem(t, e), true;
  } catch {
  }
}
function ws(i, t) {
  try {
    i.removeItem(t);
  } catch {
  }
}
function Ki(i, t) {
  return An(i, Po, t.toString());
}
function tn(i) {
  return parseInt(Zi(i, Po)) || 0;
}
var Ht = {
  local: true,
  session: true
};
var zo = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
var Sn = false;
function fc(i) {
  Sn = i;
}
var Qe = typeof window > "u" ? {} : window;
function Io(i) {
  const t = i + "Storage";
  try {
    if (Qe && Qe[t] && typeof Qe[t].length == "number")
      return Qe[t];
  } catch {
  }
  Ht[i] = false;
}
function Ro(i, t) {
  const e = Io(i);
  if (!e)
    return;
  const n = Zi(e, _s);
  if (n !== ys) {
    if (n) {
      const a = tn(e);
      for (let l = 0; l < a; l++)
        ws(e, Re + l.toString());
    }
    An(e, _s, ys), Ki(e, 0);
    return;
  }
  const s = Math.floor(Date.now() / Mo) - pc, o = (a) => {
    const l = Re + a.toString(), c = Zi(e, l);
    if (typeof c == "string") {
      try {
        const d = JSON.parse(c);
        if (typeof d == "object" && typeof d.cached == "number" && d.cached > s && typeof d.provider == "string" && typeof d.data == "object" && typeof d.data.prefix == "string" && // Valid item: run callback
        t(d, a))
          return true;
      } catch {
      }
      ws(e, l);
    }
  };
  let r = tn(e);
  for (let a = r - 1; a >= 0; a--)
    o(a) || (a === r - 1 ? (r--, Ki(e, r)) : zo[i].add(a));
}
function Do() {
  if (!Sn) {
    fc(true);
    for (const i in Ht)
      Ro(i, (t) => {
        const e = t.data, n = t.provider, s = e.prefix, o = St(
          n,
          s
        );
        if (!xn(o, e).length)
          return false;
        const r = e.lastModified || -1;
        return o.lastModifiedCached = o.lastModifiedCached ? Math.min(o.lastModifiedCached, r) : r, true;
      });
  }
}
function bc(i, t) {
  const e = i.lastModifiedCached;
  if (
    // Matches or newer
    e && e >= t
  )
    return e === t;
  if (i.lastModifiedCached = t, e)
    for (const n in Ht)
      Ro(n, (s) => {
        const o = s.data;
        return s.provider !== i.provider || o.prefix !== i.prefix || o.lastModified === t;
      });
  return true;
}
function gc(i, t) {
  Sn || Do();
  function e(n) {
    let s;
    if (!Ht[n] || !(s = Io(n)))
      return;
    const o = zo[n];
    let r;
    if (o.size)
      o.delete(r = Array.from(o).shift());
    else if (r = tn(s), r >= mc || !Ki(s, r + 1))
      return;
    const a = {
      cached: Math.floor(Date.now() / Mo),
      provider: i.provider,
      data: t
    };
    return An(
      s,
      Re + r.toString(),
      JSON.stringify(a)
    );
  }
  t.lastModified && !bc(i, t.lastModified) || Object.keys(t.icons).length && (t.not_found && (t = Object.assign({}, t), delete t.not_found), e("local") || e("session"));
}
function $s() {
}
function vc(i) {
  i.iconsLoaderFlag || (i.iconsLoaderFlag = true, setTimeout(() => {
    i.iconsLoaderFlag = false, oc(i);
  }));
}
function yc(i, t) {
  i.iconsToLoad ? i.iconsToLoad = i.iconsToLoad.concat(t).sort() : i.iconsToLoad = t, i.iconsQueueFlag || (i.iconsQueueFlag = true, setTimeout(() => {
    i.iconsQueueFlag = false;
    const { provider: e, prefix: n } = i, s = i.iconsToLoad;
    delete i.iconsToLoad;
    let o;
    !s || !(o = Ji(e)) || o.prepare(e, n, s).forEach((r) => {
      Oo(e, r, (a) => {
        if (typeof a != "object")
          r.icons.forEach((l) => {
            i.missing.add(l);
          });
        else
          try {
            const l = xn(
              i,
              a
            );
            if (!l.length)
              return;
            const c = i.pendingIcons;
            c && l.forEach((d) => {
              c.delete(d);
            }), gc(i, a);
          } catch (l) {
            console.error(l);
          }
        vc(i);
      });
    });
  }));
}
var kn = (i, t) => {
  const e = lc(i, true, So()), n = sc(e);
  if (!n.pending.length) {
    let l = true;
    return t && setTimeout(() => {
      l && t(
        n.loaded,
        n.missing,
        n.pending,
        $s
      );
    }), () => {
      l = false;
    };
  }
  const s = /* @__PURE__ */ Object.create(null), o = [];
  let r, a;
  return n.pending.forEach((l) => {
    const { provider: c, prefix: d } = l;
    if (d === a && c === r)
      return;
    r = c, a = d, o.push(St(c, d));
    const u = s[c] || (s[c] = /* @__PURE__ */ Object.create(null));
    u[d] || (u[d] = []);
  }), n.pending.forEach((l) => {
    const { provider: c, prefix: d, name: u } = l, p = St(c, d), f = p.pendingIcons || (p.pendingIcons = /* @__PURE__ */ new Set());
    f.has(u) || (f.add(u), s[c][d].push(u));
  }), o.forEach((l) => {
    const { provider: c, prefix: d } = l;
    s[c][d].length && yc(l, s[c][d]);
  }), t ? ac(t, n, o) : $s;
};
var _c = (i) => new Promise((t, e) => {
  const n = typeof i == "string" ? Fe(i, true) : i;
  if (!n) {
    e(i);
    return;
  }
  kn([n || i], (s) => {
    if (s.length && n) {
      const o = Ie(n);
      if (o) {
        t({
          ...Ne,
          ...o
        });
        return;
      }
    }
    e(i);
  });
});
function wc(i) {
  try {
    const t = typeof i == "string" ? JSON.parse(i) : i;
    if (typeof t.body == "string")
      return {
        ...t
      };
  } catch {
  }
}
function $c(i, t) {
  const e = typeof i == "string" ? Fe(i, true, true) : null;
  if (!e) {
    const o = wc(i);
    return {
      value: i,
      data: o
    };
  }
  const n = Ie(e);
  if (n !== void 0 || !e.prefix)
    return {
      value: i,
      name: e,
      data: n
      // could be 'null' -> icon is missing
    };
  const s = kn([e], () => t(i, e, Ie(e)));
  return {
    value: i,
    name: e,
    loading: s
  };
}
function Ui(i) {
  return i.hasAttribute("inline");
}
var Lo = false;
try {
  Lo = navigator.vendor.indexOf("Apple") === 0;
} catch {
}
function xc(i, t) {
  switch (t) {
    case "svg":
    case "bg":
    case "mask":
      return t;
  }
  return t !== "style" && (Lo || i.indexOf("<a") === -1) ? "svg" : i.indexOf("currentColor") === -1 ? "bg" : "mask";
}
var Cc = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
var Ac = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function en(i, t, e) {
  if (t === 1)
    return i;
  if (e = e || 100, typeof i == "number")
    return Math.ceil(i * t * e) / e;
  if (typeof i != "string")
    return i;
  const n = i.split(Cc);
  if (n === null || !n.length)
    return i;
  const s = [];
  let o = n.shift(), r = Ac.test(o);
  for (; ; ) {
    if (r) {
      const a = parseFloat(o);
      isNaN(a) ? s.push(o) : s.push(Math.ceil(a * t * e) / e);
    } else
      s.push(o);
    if (o = n.shift(), o === void 0)
      return s.join("");
    r = !r;
  }
}
function Sc(i, t = "defs") {
  let e = "";
  const n = i.indexOf("<" + t);
  for (; n >= 0; ) {
    const s = i.indexOf(">", n), o = i.indexOf("</" + t);
    if (s === -1 || o === -1)
      break;
    const r = i.indexOf(">", o);
    if (r === -1)
      break;
    e += i.slice(s + 1, o).trim(), i = i.slice(0, n).trim() + i.slice(r + 1);
  }
  return {
    defs: e,
    content: i
  };
}
function kc(i, t) {
  return i ? "<defs>" + i + "</defs>" + t : t;
}
function Ec(i, t, e) {
  const n = Sc(i);
  return kc(n.defs, t + n.content + e);
}
var Tc = (i) => i === "unset" || i === "undefined" || i === "none";
function jo(i, t) {
  const e = {
    ...Ne,
    ...i
  }, n = {
    ...$o,
    ...t
  }, s = {
    left: e.left,
    top: e.top,
    width: e.width,
    height: e.height
  };
  let o = e.body;
  [e, n].forEach((v) => {
    const g = [], $ = v.hFlip, y = v.vFlip;
    let _ = v.rotate;
    $ ? y ? _ += 2 : (g.push(
      "translate(" + (s.width + s.left).toString() + " " + (0 - s.top).toString() + ")"
    ), g.push("scale(-1 1)"), s.top = s.left = 0) : y && (g.push(
      "translate(" + (0 - s.left).toString() + " " + (s.height + s.top).toString() + ")"
    ), g.push("scale(1 -1)"), s.top = s.left = 0);
    let w;
    switch (_ < 0 && (_ -= Math.floor(_ / 4) * 4), _ = _ % 4, _) {
      case 1:
        w = s.height / 2 + s.top, g.unshift(
          "rotate(90 " + w.toString() + " " + w.toString() + ")"
        );
        break;
      case 2:
        g.unshift(
          "rotate(180 " + (s.width / 2 + s.left).toString() + " " + (s.height / 2 + s.top).toString() + ")"
        );
        break;
      case 3:
        w = s.width / 2 + s.left, g.unshift(
          "rotate(-90 " + w.toString() + " " + w.toString() + ")"
        );
        break;
    }
    _ % 2 === 1 && (s.left !== s.top && (w = s.left, s.left = s.top, s.top = w), s.width !== s.height && (w = s.width, s.width = s.height, s.height = w)), g.length && (o = Ec(
      o,
      '<g transform="' + g.join(" ") + '">',
      "</g>"
    ));
  });
  const r = n.width, a = n.height, l = s.width, c = s.height;
  let d, u;
  r === null ? (u = a === null ? "1em" : a === "auto" ? c : a, d = en(u, l / c)) : (d = r === "auto" ? l : r, u = a === null ? en(d, c / l) : a === "auto" ? c : a);
  const p = {}, f = (v, g) => {
    Tc(g) || (p[v] = g.toString());
  };
  f("width", d), f("height", u);
  const b = [s.left, s.top, l, c];
  return p.viewBox = b.join(" "), {
    attributes: p,
    viewBox: b,
    body: o
  };
}
function En(i, t) {
  let e = i.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const n in t)
    e += " " + n + '="' + t[n] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + e + ">" + i + "</svg>";
}
function Oc(i) {
  return i.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function Pc(i) {
  return "data:image/svg+xml," + Oc(i);
}
function Bo(i) {
  return 'url("' + Pc(i) + '")';
}
var Mc = () => {
  let i;
  try {
    if (i = fetch, typeof i == "function")
      return i;
  } catch {
  }
};
var pi = Mc();
function zc(i) {
  pi = i;
}
function Ic() {
  return pi;
}
function Rc(i, t) {
  const e = $i(i);
  if (!e)
    return 0;
  let n;
  if (!e.maxURL)
    n = 0;
  else {
    let s = 0;
    e.resources.forEach((r) => {
      s = Math.max(s, r.length);
    });
    const o = t + ".json?icons=";
    n = e.maxURL - s - e.path.length - o.length;
  }
  return n;
}
function Dc(i) {
  return i === 404;
}
var Lc = (i, t, e) => {
  const n = [], s = Rc(i, t), o = "icons";
  let r = {
    type: o,
    provider: i,
    prefix: t,
    icons: []
  }, a = 0;
  return e.forEach((l, c) => {
    a += l.length + 1, a >= s && c > 0 && (n.push(r), r = {
      type: o,
      provider: i,
      prefix: t,
      icons: []
    }, a = l.length), r.icons.push(l);
  }), n.push(r), n;
};
function jc(i) {
  if (typeof i == "string") {
    const t = $i(i);
    if (t)
      return t.path;
  }
  return "/";
}
var Bc = (i, t, e) => {
  if (!pi) {
    e("abort", 424);
    return;
  }
  let n = jc(t.provider);
  switch (t.type) {
    case "icons": {
      const o = t.prefix, r = t.icons.join(","), a = new URLSearchParams({
        icons: r
      });
      n += o + ".json?" + a.toString();
      break;
    }
    case "custom": {
      const o = t.uri;
      n += o.slice(0, 1) === "/" ? o.slice(1) : o;
      break;
    }
    default:
      e("abort", 400);
      return;
  }
  let s = 503;
  pi(i + n).then((o) => {
    const r = o.status;
    if (r !== 200) {
      setTimeout(() => {
        e(Dc(r) ? "abort" : "next", r);
      });
      return;
    }
    return s = 501, o.json();
  }).then((o) => {
    if (typeof o != "object" || o === null) {
      setTimeout(() => {
        o === 404 ? e("abort", o) : e("next", s);
      });
      return;
    }
    setTimeout(() => {
      e("success", o);
    });
  }).catch(() => {
    e("next", s);
  });
};
var Hc = {
  prepare: Lc,
  send: Bc
};
function xs(i, t) {
  switch (i) {
    case "local":
    case "session":
      Ht[i] = t;
      break;
    case "all":
      for (const e in Ht)
        Ht[e] = t;
      break;
  }
}
var qi = "data-style";
var Ho = "";
function Nc(i) {
  Ho = i;
}
function Cs(i, t) {
  let e = Array.from(i.childNodes).find((n) => n.hasAttribute && n.hasAttribute(qi));
  e || (e = document.createElement("style"), e.setAttribute(qi, qi), i.appendChild(e)), e.textContent = ":host{display:inline-block;vertical-align:" + (t ? "-0.125em" : "0") + "}span,svg{display:block}" + Ho;
}
function No() {
  bs("", Hc), So(true);
  let i;
  try {
    i = window;
  } catch {
  }
  if (i) {
    if (Do(), i.IconifyPreload !== void 0) {
      const t = i.IconifyPreload, e = "Invalid IconifyPreload syntax.";
      typeof t == "object" && t !== null && (t instanceof Array ? t : [t]).forEach((n) => {
        try {
          (typeof n != "object" || n === null || n instanceof Array || // Check for 'icons' and 'prefix'
          typeof n.icons != "object" || typeof n.prefix != "string" || // Add icon set
          !ms(n)) && console.error(e);
        } catch {
          console.error(e);
        }
      });
    }
    if (i.IconifyProviders !== void 0) {
      const t = i.IconifyProviders;
      if (typeof t == "object" && t !== null)
        for (const e in t) {
          const n = "IconifyProviders[" + e + "] is invalid.";
          try {
            const s = t[e];
            if (typeof s != "object" || !s || s.resources === void 0)
              continue;
            gs(e, s) || console.error(n);
          } catch {
            console.error(n);
          }
        }
    }
  }
  return {
    enableCache: (t) => xs(t, true),
    disableCache: (t) => xs(t, false),
    iconLoaded: fs,
    iconExists: fs,
    getIcon: nc,
    listIcons: ic,
    addIcon: ko,
    addCollection: ms,
    calculateSize: en,
    buildIcon: jo,
    iconToHTML: En,
    svgToURL: Bo,
    loadIcons: kn,
    loadIcon: _c,
    addAPIProvider: gs,
    appendCustomStyle: Nc,
    _api: {
      getAPIConfig: $i,
      setAPIModule: bs,
      sendAPIQuery: Oo,
      setFetch: zc,
      getFetch: Ic,
      listAPIProviders: uc
    }
  };
}
var nn = {
  "background-color": "currentColor"
};
var Fo = {
  "background-color": "transparent"
};
var As = {
  image: "var(--svg)",
  repeat: "no-repeat",
  size: "100% 100%"
};
var Ss = {
  "-webkit-mask": nn,
  mask: nn,
  background: Fo
};
for (const i in Ss) {
  const t = Ss[i];
  for (const e in As)
    t[i + "-" + e] = As[e];
}
function ks(i) {
  return i ? i + (i.match(/^[-0-9.]+$/) ? "px" : "") : "inherit";
}
function Fc(i, t, e) {
  const n = document.createElement("span");
  let s = i.body;
  s.indexOf("<a") !== -1 && (s += "<!-- " + Date.now() + " -->");
  const o = i.attributes, r = En(s, {
    ...o,
    width: t.width + "",
    height: t.height + ""
  }), a = Bo(r), l = n.style, c = {
    "--svg": a,
    width: ks(o.width),
    height: ks(o.height),
    ...e ? nn : Fo
  };
  for (const d in c)
    l.setProperty(d, c[d]);
  return n;
}
var Ae;
function Uc() {
  try {
    Ae = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (i) => i
    });
  } catch {
    Ae = null;
  }
}
function qc(i) {
  return Ae === void 0 && Uc(), Ae ? Ae.createHTML(i) : i;
}
function Vc(i) {
  const t = document.createElement("span"), e = i.attributes;
  let n = "";
  e.width || (n = "width: inherit;"), e.height || (n += "height: inherit;"), n && (e.style = n);
  const s = En(i.body, e);
  return t.innerHTML = qc(s), t.firstChild;
}
function sn(i) {
  return Array.from(i.childNodes).find((t) => {
    const e = t.tagName && t.tagName.toUpperCase();
    return e === "SPAN" || e === "SVG";
  });
}
function Es(i, t) {
  const e = t.icon.data, n = t.customisations, s = jo(e, n);
  n.preserveAspectRatio && (s.attributes.preserveAspectRatio = n.preserveAspectRatio);
  const o = t.renderedMode;
  let r;
  switch (o) {
    case "svg":
      r = Vc(s);
      break;
    default:
      r = Fc(s, {
        ...Ne,
        ...e
      }, o === "mask");
  }
  const a = sn(i);
  a ? r.tagName === "SPAN" && a.tagName === r.tagName ? a.setAttribute("style", r.getAttribute("style")) : i.replaceChild(r, a) : i.appendChild(r);
}
function Ts(i, t, e) {
  const n = e && (e.rendered ? e : e.lastRender);
  return {
    rendered: false,
    inline: t,
    icon: i,
    lastRender: n
  };
}
function Yc(i = "iconify-icon") {
  let t, e;
  try {
    t = window.customElements, e = window.HTMLElement;
  } catch {
    return;
  }
  if (!t || !e)
    return;
  const n = t.get(i);
  if (n)
    return n;
  const s = [
    // Icon
    "icon",
    // Mode
    "mode",
    "inline",
    "observe",
    // Customisations
    "width",
    "height",
    "rotate",
    "flip"
  ], o = class extends e {
    /**
     * Constructor
     */
    constructor() {
      super(), zt(this, "_shadowRoot"), zt(this, "_initialised", false), zt(this, "_state"), zt(this, "_checkQueued", false), zt(this, "_connected", false), zt(this, "_observer", null), zt(this, "_visible", true);
      const a = this._shadowRoot = this.attachShadow({
        mode: "open"
      }), l = Ui(this);
      Cs(a, l), this._state = Ts({
        value: ""
      }, l), this._queueCheck();
    }
    /**
     * Connected to DOM
     */
    connectedCallback() {
      this._connected = true, this.startObserver();
    }
    /**
     * Disconnected from DOM
     */
    disconnectedCallback() {
      this._connected = false, this.stopObserver();
    }
    /**
     * Observed attributes
     */
    static get observedAttributes() {
      return s.slice(0);
    }
    /**
     * Observed properties that are different from attributes
     *
     * Experimental! Need to test with various frameworks that support it
     */
    /*
    static get properties() {
        return {
            inline: {
                type: Boolean,
                reflect: true,
            },
            // Not listing other attributes because they are strings or combination
            // of string and another type. Cannot have multiple types
        };
    }
    */
    /**
     * Attribute has changed
     */
    attributeChangedCallback(a) {
      switch (a) {
        case "inline": {
          const l = Ui(this), c = this._state;
          l !== c.inline && (c.inline = l, Cs(this._shadowRoot, l));
          break;
        }
        case "observer": {
          this.observer ? this.startObserver() : this.stopObserver();
          break;
        }
        default:
          this._queueCheck();
      }
    }
    /**
     * Get/set icon
     */
    get icon() {
      const a = this.getAttribute("icon");
      if (a && a.slice(0, 1) === "{")
        try {
          return JSON.parse(a);
        } catch {
        }
      return a;
    }
    set icon(a) {
      typeof a == "object" && (a = JSON.stringify(a)), this.setAttribute("icon", a);
    }
    /**
     * Get/set inline
     */
    get inline() {
      return Ui(this);
    }
    set inline(a) {
      a ? this.setAttribute("inline", "true") : this.removeAttribute("inline");
    }
    /**
     * Get/set observer
     */
    get observer() {
      return this.hasAttribute("observer");
    }
    set observer(a) {
      a ? this.setAttribute("observer", "true") : this.removeAttribute("observer");
    }
    /**
     * Restart animation
     */
    restartAnimation() {
      const a = this._state;
      if (a.rendered) {
        const l = this._shadowRoot;
        if (a.renderedMode === "svg")
          try {
            l.lastChild.setCurrentTime(0);
            return;
          } catch {
          }
        Es(l, a);
      }
    }
    /**
     * Get status
     */
    get status() {
      const a = this._state;
      return a.rendered ? "rendered" : a.icon.data === null ? "failed" : "loading";
    }
    /**
     * Queue attributes re-check
     */
    _queueCheck() {
      this._checkQueued || (this._checkQueued = true, setTimeout(() => {
        this._check();
      }));
    }
    /**
     * Check for changes
     */
    _check() {
      if (!this._checkQueued)
        return;
      this._checkQueued = false;
      const a = this._state, l = this.getAttribute("icon");
      if (l !== a.icon.value) {
        this._iconChanged(l);
        return;
      }
      if (!a.rendered || !this._visible)
        return;
      const c = this.getAttribute("mode"), d = hs(this);
      (a.attrMode !== c || Xl(a.customisations, d) || !sn(this._shadowRoot)) && this._renderIcon(a.icon, d, c);
    }
    /**
     * Icon value has changed
     */
    _iconChanged(a) {
      const l = $c(a, (c, d, u) => {
        const p = this._state;
        if (p.rendered || this.getAttribute("icon") !== c)
          return;
        const f = {
          value: c,
          name: d,
          data: u
        };
        f.data ? this._gotIconData(f) : p.icon = f;
      });
      l.data ? this._gotIconData(l) : this._state = Ts(l, this._state.inline, this._state);
    }
    /**
     * Force render icon on state change
     */
    _forceRender() {
      if (!this._visible) {
        const a = sn(this._shadowRoot);
        a && this._shadowRoot.removeChild(a);
        return;
      }
      this._queueCheck();
    }
    /**
     * Got new icon data, icon is ready to (re)render
     */
    _gotIconData(a) {
      this._checkQueued = false, this._renderIcon(a, hs(this), this.getAttribute("mode"));
    }
    /**
     * Re-render based on icon data
     */
    _renderIcon(a, l, c) {
      const d = xc(a.data.body, c), u = this._state.inline;
      Es(this._shadowRoot, this._state = {
        rendered: true,
        icon: a,
        inline: u,
        customisations: l,
        attrMode: c,
        renderedMode: d
      });
    }
    /**
     * Start observer
     */
    startObserver() {
      if (!this._observer)
        try {
          this._observer = new IntersectionObserver((a) => {
            const l = a.some((c) => c.isIntersecting);
            l !== this._visible && (this._visible = l, this._forceRender());
          }), this._observer.observe(this);
        } catch {
          if (this._observer) {
            try {
              this._observer.disconnect();
            } catch {
            }
            this._observer = null;
          }
        }
    }
    /**
     * Stop observer
     */
    stopObserver() {
      this._observer && (this._observer.disconnect(), this._observer = null, this._visible = true, this._connected && this._forceRender());
    }
  };
  s.forEach((a) => {
    a in o.prototype || Object.defineProperty(o.prototype, a, {
      get: function() {
        return this.getAttribute(a);
      },
      set: function(l) {
        l !== null ? this.setAttribute(a, l) : this.removeAttribute(a);
      }
    });
  });
  const r = No();
  for (const a in r)
    o[a] = o.prototype[a] = r[a];
  return t.define(i, o), o;
}
var Wc = Yc() || No();
var {
  enableCache: Iu,
  disableCache: Ru,
  iconLoaded: Du,
  iconExists: Lu,
  // deprecated, kept to avoid breaking changes
  getIcon: ju,
  listIcons: Bu,
  addIcon: Hu,
  addCollection: Nu,
  calculateSize: Fu,
  buildIcon: Uu,
  iconToHTML: qu,
  svgToURL: Vu,
  loadIcons: Yu,
  loadIcon: Wu,
  addAPIProvider: Gu,
  _api: Xu
} = Wc;
var Gc = O`
  ::-webkit-scrollbar {
    width: 0.4rem;
    height: 0.4rem;
    overflow: hidden;
  }

  ::-webkit-scrollbar-thumb {
    border-radius: 0.25rem;
    background-color: var(
      --bim-scrollbar--c,
      color-mix(in lab, var(--bim-ui_main-base), white 15%)
    );
  }

  ::-webkit-scrollbar-track {
    background-color: var(--bim-scrollbar--bgc, var(--bim-ui_bg-base));
  }
`;
var Xc = O`
  :root {
    /* Grayscale Colors */
    --bim-ui_gray-0: hsl(210 10% 5%);
    --bim-ui_gray-1: hsl(210 10% 10%);
    --bim-ui_gray-2: hsl(210 10% 20%);
    --bim-ui_gray-3: hsl(210 10% 30%);
    --bim-ui_gray-4: hsl(210 10% 40%);
    --bim-ui_gray-6: hsl(210 10% 60%);
    --bim-ui_gray-7: hsl(210 10% 70%);
    --bim-ui_gray-8: hsl(210 10% 80%);
    --bim-ui_gray-9: hsl(210 10% 90%);
    --bim-ui_gray-10: hsl(210 10% 95%);

    /* Brand Colors */
    --bim-ui_main-base: #6528d7;
    --bim-ui_accent-base: #bcf124;

    /* Brand Colors Contrasts */
    --bim-ui_main-contrast: var(--bim-ui_gray-10);
    --bim-ui_accent-contrast: var(--bim-ui_gray-0);

    /* Sizes */
    --bim-ui_size-4xs: 0.375rem;
    --bim-ui_size-3xs: 0.5rem;
    --bim-ui_size-2xs: 0.625rem;
    --bim-ui_size-xs: 0.75rem;
    --bim-ui_size-sm: 0.875rem;
    --bim-ui_size-base: 1rem;
    --bim-ui_size-lg: 1.125rem;
    --bim-ui_size-xl: 1.25rem;
    --bim-ui_size-2xl: 1.375rem;
    --bim-ui_size-3xl: 1.5rem;
    --bim-ui_size-4xl: 1.625rem;
    --bim-ui_size-5xl: 1.75rem;
    --bim-ui_size-6xl: 1.875rem;
    --bim-ui_size-7xl: 2rem;
    --bim-ui_size-8xl: 2.125rem;
    --bim-ui_size-9xl: 2.25rem;
  }

  /* Background Colors */
  @media (prefers-color-scheme: dark) {
    :root {
      --bim-ui_bg-base: var(--bim-ui_gray-0);
      --bim-ui_bg-contrast-10: var(--bim-ui_gray-1);
      --bim-ui_bg-contrast-20: var(--bim-ui_gray-2);
      --bim-ui_bg-contrast-30: var(--bim-ui_gray-3);
      --bim-ui_bg-contrast-40: var(--bim-ui_gray-4);
      --bim-ui_bg-contrast-60: var(--bim-ui_gray-6);
      --bim-ui_bg-contrast-80: var(--bim-ui_gray-8);
      --bim-ui_bg-contrast-100: var(--bim-ui_gray-10);
    }
  }

  @media (prefers-color-scheme: light) {
    :root {
      --bim-ui_bg-base: var(--bim-ui_gray-10);
      --bim-ui_bg-contrast-10: var(--bim-ui_gray-9);
      --bim-ui_bg-contrast-20: var(--bim-ui_gray-8);
      --bim-ui_bg-contrast-30: var(--bim-ui_gray-7);
      --bim-ui_bg-contrast-40: var(--bim-ui_gray-6);
      --bim-ui_bg-contrast-60: var(--bim-ui_gray-4);
      --bim-ui_bg-contrast-80: var(--bim-ui_gray-2);
      --bim-ui_bg-contrast-100: var(--bim-ui_gray-0);
      --bim-ui_accent-base: #6528d7;
    }
  }

  .theme-transition-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    filter: drop-shadow(0 0 10px var(--bim-ui_bg-base));
    z-index: 9999;
  }

  .theme-transition-overlay > div {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--bim-ui_bg-base);
  }

  html.bim-ui-dark {
    --bim-ui_bg-base: var(--bim-ui_gray-0);
    --bim-ui_bg-contrast-10: var(--bim-ui_gray-1);
    --bim-ui_bg-contrast-20: var(--bim-ui_gray-2);
    --bim-ui_bg-contrast-30: var(--bim-ui_gray-3);
    --bim-ui_bg-contrast-40: var(--bim-ui_gray-4);
    --bim-ui_bg-contrast-60: var(--bim-ui_gray-6);
    --bim-ui_bg-contrast-80: var(--bim-ui_gray-8);
    --bim-ui_bg-contrast-100: var(--bim-ui_gray-10);
  }

  html.bim-ui-light {
    --bim-ui_bg-base: var(--bim-ui_gray-10);
    --bim-ui_bg-contrast-10: var(--bim-ui_gray-9);
    --bim-ui_bg-contrast-20: var(--bim-ui_gray-8);
    --bim-ui_bg-contrast-30: var(--bim-ui_gray-7);
    --bim-ui_bg-contrast-40: var(--bim-ui_gray-6);
    --bim-ui_bg-contrast-60: var(--bim-ui_gray-4);
    --bim-ui_bg-contrast-80: var(--bim-ui_gray-2);
    --bim-ui_bg-contrast-100: var(--bim-ui_gray-0);
    --bim-ui_accent-base: #6528d7;
  }

  @keyframes toggleOverlay {
    0%,
    99% {
      display: block;
    }

    100% {
      display: none;
    }
  }

  @keyframes toggleThemeAnimation {
    0% {
      clip-path: circle(0% at center top);
    }
    45%,
    55% {
      clip-path: circle(150% at center center);
    }
    100% {
      clip-path: circle(0% at center bottom);
    }
  }

  [data-context-dialog]::backdrop {
    background-color: transparent;
  }
`;
var Tt = {
  scrollbar: Gc,
  globalStyles: Xc
};
var Uo = class k {
  static set config(t) {
    this._config = { ...k._config, ...t };
  }
  static get config() {
    return k._config;
  }
  static addGlobalStyles() {
    let t = document.querySelector("style[id='bim-ui']");
    if (t)
      return;
    t = document.createElement("style"), t.id = "bim-ui", t.textContent = Tt.globalStyles.cssText;
    const e = document.head.firstChild;
    e ? document.head.insertBefore(t, e) : document.head.append(t);
  }
  static defineCustomElement(t, e) {
    customElements.get(t) || customElements.define(t, e);
  }
  /**
   * @deprecated Use `Manager.init()` instead.
   */
  static registerComponents() {
    k.init();
  }
  /**
   * Initializes the BIM UI library by defining custom elements.
   * It ensures that all necessary styles and custom elements are registered for use in BIM UI components.
   *
   * @example
   * ```typescript
   * import { Manager } from "@thatopen/ui";
   * Manager.init();
   * ```
   */
  static init(t = "", e = true) {
    k.addGlobalStyles(), k.defineCustomElement("bim-button", ed), k.defineCustomElement("bim-checkbox", le), k.defineCustomElement("bim-color-input", Ot), k.defineCustomElement("bim-context-menu", mi), k.defineCustomElement("bim-dropdown", mt), k.defineCustomElement("bim-grid", On), k.defineCustomElement("bim-icon", cd), k.defineCustomElement("bim-input", qe), k.defineCustomElement("bim-label", ce), k.defineCustomElement("bim-number-input", Q), k.defineCustomElement("bim-option", j), k.defineCustomElement("bim-panel", Yt), k.defineCustomElement("bim-panel-section", de), k.defineCustomElement("bim-selector", ue), k.defineCustomElement("bim-table", Z), k.defineCustomElement("bim-tabs", vt), k.defineCustomElement("bim-tab", G), k.defineCustomElement("bim-table-cell", sr), k.defineCustomElement("bim-table-children", $d), k.defineCustomElement("bim-table-group", ar), k.defineCustomElement("bim-table-row", he), k.defineCustomElement("bim-text-input", W), k.defineCustomElement("bim-toolbar", Ei), k.defineCustomElement("bim-toolbar-group", Si), k.defineCustomElement(
      "bim-toolbar-section",
      me
    ), k.defineCustomElement("bim-viewport", vr), e && this.animateOnLoad(t);
  }
  static newRandomId() {
    const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let e = "";
    for (let n = 0; n < 10; n++) {
      const s = Math.floor(Math.random() * t.length);
      e += t.charAt(s);
    }
    return e;
  }
  static animateOnLoad(t = "") {
    const e = `
      bim-input,
      bim-button,
      bim-checkbox,
      bim-selector,
      bim-label,
      bim-table-row,
      bim-panel-section,
      bim-table-children .branch-vertical,
      .switchers
    `, n = [];
    function s(o, r = document, a = /* @__PURE__ */ new Set()) {
      const l = [];
      return Array.from(r.querySelectorAll(o)).forEach((c) => {
        a.has(c) || (a.add(c), l.push(c));
      }), Array.from(
        r.querySelectorAll("*")
      ).filter((c) => c.shadowRoot).forEach((c) => {
        a.has(c) || (a.add(c), l.push(
          ...s(o, c.shadowRoot, a)
        ));
      }), l;
    }
    requestAnimationFrame(() => {
      s(
        t || e
      ).forEach((r) => {
        const a = r;
        let l = "auto";
        l = window.getComputedStyle(a).getPropertyValue("transition"), a.style.setProperty("opacity", "0"), a.style.setProperty("transition", "none"), requestAnimationFrame(() => {
          a.style.setProperty("transition", l);
        }), n.push(a);
      });
      const o = () => {
        n.forEach((r) => {
          const a = r, l = (a.getBoundingClientRect().x + a.getBoundingClientRect().y) / (window.innerWidth + window.innerHeight), c = window.getComputedStyle(a).getPropertyValue("transform"), d = 400, u = 200 + l * 1e3;
          a.animate(
            [
              {
                transform: "translateY(-20px)",
                opacity: "0"
              },
              {
                transform: "translateY(0)",
                opacity: "1"
              }
            ],
            {
              duration: d,
              easing: "ease-in-out",
              delay: u
            }
          ), setTimeout(() => {
            a.style.removeProperty("opacity"), c !== "none" ? a.style.setProperty("transform", c) : a.style.removeProperty("transform");
          }, u + d);
        });
      };
      document.readyState === "complete" ? o() : window.addEventListener("load", o);
    });
  }
  static toggleTheme(t = true) {
    const e = document.querySelector("html");
    if (!e)
      return;
    const n = () => {
      e.classList.contains("bim-ui-dark") ? e.classList.replace("bim-ui-dark", "bim-ui-light") : e.classList.contains("bim-ui-light") ? e.classList.replace("bim-ui-light", "bim-ui-dark") : e.classList.add("bim-ui-light");
    };
    if (t) {
      const s = document.createElement("div");
      s.classList.add("theme-transition-overlay");
      const o = document.createElement("div");
      s.appendChild(o), o.style.setProperty(
        "transition",
        `background-color ${1e3 / 3200}s`
      ), document.body.appendChild(s), s.style.setProperty(
        "animation",
        `toggleOverlay ${1e3 / 1e3}s ease-in forwards`
      ), o.style.setProperty(
        "animation",
        `toggleThemeAnimation ${1e3 / 1e3}s ease forwards`
      ), setTimeout(() => {
        n();
      }, 1e3 / 4), setTimeout(() => {
        document.body.querySelectorAll(
          ".theme-transition-overlay"
        ).forEach((r) => {
          document.body.removeChild(r);
        });
      }, 1e3);
    } else
      n();
  }
};
Uo._config = {
  sectionLabelOnVerticalToolbar: false
  // draggableToolbars: true,
  // draggablePanels: true,
};
var U = Uo;
var H = class extends T {
  constructor() {
    super(...arguments), this._lazyLoadObserver = null, this._visibleElements = [], this.ELEMENTS_BEFORE_OBSERVER = 20, this.useObserver = false, this.elements = /* @__PURE__ */ new Set(), this.observe = (t) => {
      if (!this.useObserver)
        return;
      for (const n of t)
        this.elements.add(n);
      const e = t.slice(this.ELEMENTS_BEFORE_OBSERVER);
      for (const n of e)
        n.remove();
      this.observeLastElement();
    };
  }
  set visibleElements(t) {
    this._visibleElements = this.useObserver ? t : [], this.requestUpdate();
  }
  get visibleElements() {
    return this._visibleElements;
  }
  getLazyObserver() {
    if (!this.useObserver)
      return null;
    if (this._lazyLoadObserver)
      return this._lazyLoadObserver;
    const t = new IntersectionObserver(
      (e) => {
        const n = e[0];
        if (!n.isIntersecting)
          return;
        const s = n.target;
        t.unobserve(s);
        const o = this.ELEMENTS_BEFORE_OBSERVER + this.visibleElements.length, r = [...this.elements][o];
        r && (this.visibleElements = [...this.visibleElements, r], t.observe(r));
      },
      { threshold: 0.5 }
    );
    return t;
  }
  observeLastElement() {
    const t = this.getLazyObserver();
    if (!t)
      return;
    const e = this.ELEMENTS_BEFORE_OBSERVER + this.visibleElements.length - 1, n = [...this.elements][e];
    n && t.observe(n);
  }
  resetVisibleElements() {
    const t = this.getLazyObserver();
    if (t) {
      for (const e of this.elements)
        t.unobserve(e);
      this.visibleElements = [], this.observeLastElement();
    }
  }
  /**
   * Creates a new UI component instance based on the provided template and initial state.
   *
   * @template T - The type of the UI component element.
   * @template S - The type of the component state.
   *
   * @param template - The component template function (stateless or stateful).
   * @param initialState - The initial state of the component (optional for stateless components).
   * @returns The created UI component element or an array containing the element and a function to update its state.
   */
  static create(t, e) {
    const n = document.createDocumentFragment();
    if (t.length === 0)
      return oe(t(), n), n.firstElementChild;
    if (!e)
      throw new Error(
        "UIComponent: Initial state is required for statefull components."
      );
    let s = e;
    const o = t, r = (l) => (s = { ...s, ...l }, oe(o(s, r), n), s);
    r(e);
    const a = () => s;
    return [n.firstElementChild, r, a];
  }
};
var De = (i, t = {}, e = true) => {
  let n = {};
  for (const s of i.children) {
    const o = s, r = o.getAttribute("name") || o.getAttribute("label"), a = r ? t[r] : void 0;
    if (r) {
      if ("value" in o && typeof o.value < "u" && o.value !== null) {
        const l = o.value;
        if (typeof l == "object" && !Array.isArray(l) && Object.keys(l).length === 0)
          continue;
        n[r] = a ? a(o.value) : o.value;
      } else if (e) {
        const l = De(o, t);
        if (Object.keys(l).length === 0)
          continue;
        n[r] = a ? a(l) : l;
      }
    } else
      e && (n = { ...n, ...De(o, t) });
  }
  return n;
};
var xi = (i) => i === "true" || i === "false" ? i === "true" : i && !isNaN(Number(i)) && i.trim() !== "" ? Number(i) : i;
var Jc = [">=", "<=", "=", ">", "<", "?", "/", "#"];
function Os(i) {
  const t = Jc.find(
    (r) => i.split(r).length === 2
  ), e = i.split(t).map((r) => r.trim()), [n, s] = e, o = s.startsWith("'") && s.endsWith("'") ? s.replace(/'/g, "") : xi(s);
  return { key: n, condition: t, value: o };
}
var on = (i) => {
  try {
    const t = [], e = i.split(/&(?![^()]*\))/).map((n) => n.trim());
    for (const n of e) {
      const s = !n.startsWith("(") && !n.endsWith(")"), o = n.startsWith("(") && n.endsWith(")");
      if (s) {
        const r = Os(n);
        t.push(r);
      }
      if (o) {
        const r = {
          operator: "&",
          queries: n.replace(/^(\()|(\))$/g, "").split("&").map((a) => a.trim()).map((a, l) => {
            const c = Os(a);
            return l > 0 && (c.operator = "&"), c;
          })
        };
        t.push(r);
      }
    }
    return t;
  } catch {
    return null;
  }
};
var Ps = (i, t, e) => {
  let n = false;
  switch (t) {
    case "=":
      n = i === e;
      break;
    case "?":
      n = String(i).includes(String(e));
      break;
    case "<":
      (typeof i == "number" || typeof e == "number") && (n = i < e);
      break;
    case "<=":
      (typeof i == "number" || typeof e == "number") && (n = i <= e);
      break;
    case ">":
      (typeof i == "number" || typeof e == "number") && (n = i > e);
      break;
    case ">=":
      (typeof i == "number" || typeof e == "number") && (n = i >= e);
      break;
    case "/":
      n = String(i).startsWith(String(e));
      break;
  }
  return n;
};
var Qc = Object.defineProperty;
var Zc = Object.getOwnPropertyDescriptor;
var qo = (i, t, e, n) => {
  for (var s = Zc(t, e), o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = r(t, e, s) || s);
  return s && Qc(t, e, s), s;
};
var L;
var Tn = (L = class extends T {
  constructor() {
    super(...arguments), this._previousContainer = null, this._visible = false;
  }
  get placement() {
    return this._placement;
  }
  set placement(i) {
    this._placement = i, this.updatePosition();
  }
  static removeMenus() {
    for (const i of L.menus)
      i instanceof L && (i.visible = false);
    setTimeout(() => {
      L.dialog.close(), L.dialog.remove();
    }, 310);
  }
  get visible() {
    return this._visible;
  }
  set visible(i) {
    this._visible = i, i ? (L.dialog.parentElement || document.body.append(L.dialog), this._previousContainer = this.parentElement, L.dialog.style.top = `${window.scrollY || document.documentElement.scrollTop}px`, this.style.setProperty("display", "flex"), L.dialog.append(this), L.dialog.showModal(), this.updatePosition(), this.dispatchEvent(new Event("visible"))) : setTimeout(() => {
      var t;
      (t = this._previousContainer) == null || t.append(this), this._previousContainer = null, this.style.setProperty("display", "none"), this.dispatchEvent(new Event("hidden"));
    }, 310);
  }
  /**
   * Asynchronously updates the position of the context menu relative to a target element.
   * If no target element is provided, it attempts to use the parent node as the target.
   * The position is calculated using the `computePosition` function from `@floating-ui/dom`,
   * which considers various adjustments like offset, inline positioning, flipping, and shifting
   * to ensure the context menu is properly placed relative to the target element.
   *
   * @param [target] - The target element relative to which the context menu should be positioned.
   *                                 If not provided, the parent node is used as the target.
   * @returns A promise that resolves once the position has been updated. This method
   *                          does not explicitly return a value but updates the context menu's style
   *                          properties to position it on the screen.
   */
  async updatePosition() {
    if (!(this.visible && this._previousContainer))
      return;
    const i = this.placement ?? "right", t = await uo(this._previousContainer, this, {
      placement: i,
      middleware: [Js2(10), co(), lo(), ao({ padding: 5 })]
    }), { x: e, y: n } = t;
    this.style.left = `${e}px`, this.style.top = `${n}px`;
  }
  connectedCallback() {
    super.connectedCallback(), L.menus.push(this), this.visible ? (this.style.setProperty("width", "auto"), this.style.setProperty("height", "auto")) : (this.style.setProperty("display", "none"), this.style.setProperty("width", "0"), this.style.setProperty("height", "0"));
  }
  render() {
    return h` <slot></slot> `;
  }
}, L.styles = [
  Tt.scrollbar,
  O`
      :host {
        pointer-events: auto;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 999;
        overflow: auto;
        max-height: 20rem;
        min-width: 3rem;
        flex-direction: column;
        box-shadow: 1px 2px 8px 2px rgba(0, 0, 0, 0.15);
        padding: 0.5rem;
        border-radius: var(--bim-ui_size-4xs);
        display: flex;
        transform-origin: top left;
        transform: scale(1);
        clip-path: circle(150% at top left);
        background-color: var(--bim-ui_bg-contrast-20);
        transition:
          clip-path 0.2s cubic-bezier(0.72, 0.1, 0.43, 0.93),
          transform 0.3s cubic-bezier(0.72, 0.1, 0.45, 2.35);
      }

      :host(:not([visible])) {
        transform: scale(0.8);
        clip-path: circle(0 at top left);
      }
    `
], L.dialog = H.create(() => h` <dialog
      @click=${(i) => {
  i.target === L.dialog && L.removeMenus();
}}
      @cancel=${() => L.removeMenus()}
      data-context-dialog
      style="
      width: 0;
      height: 0;
      position: relative;
      padding: 0;
      border: none;
      outline: none;
      margin: none;
      overflow: visible;
      background-color: transparent;
    "
    ></dialog>`), L.menus = [], L);
qo([
  m({ type: String, reflect: true })
], Tn.prototype, "placement");
qo([
  m({ type: Boolean, reflect: true })
], Tn.prototype, "visible");
var mi = Tn;
var Kc = Object.defineProperty;
var td = Object.getOwnPropertyDescriptor;
var lt = (i, t, e, n) => {
  for (var s = n > 1 ? void 0 : n ? td(t, e) : t, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = (n ? r(t, e, s) : r(s)) || s);
  return n && s && Kc(t, e, s), s;
};
var ve;
var it = (ve = class extends T {
  constructor() {
    super(), this.labelHidden = false, this.active = false, this.disabled = false, this.vertical = false, this.tooltipVisible = false, this._stateBeforeLoading = {
      disabled: false,
      icon: ""
    }, this._loading = false, this._parent = re(), this._tooltip = re(), this._mouseLeave = false, this.onClick = (i) => {
      i.stopPropagation(), this.disabled || this.dispatchEvent(new Event("click"));
    }, this.showContextMenu = () => {
      const i = this._contextMenu;
      if (i) {
        const t = this.getAttribute("data-context-group");
        t && i.setAttribute("data-context-group", t), this.closeNestedContexts();
        const e = U.newRandomId();
        for (const n of i.children)
          n instanceof ve && n.setAttribute("data-context-group", e);
        i.visible = true;
      }
    }, this.mouseLeave = true;
  }
  set loading(i) {
    if (this._loading = i, i)
      this._stateBeforeLoading = {
        disabled: this.disabled,
        icon: this.icon
      }, this.disabled = i, this.icon = "eos-icons:loading";
    else {
      const { disabled: t, icon: e } = this._stateBeforeLoading;
      this.disabled = t, this.icon = e;
    }
  }
  get loading() {
    return this._loading;
  }
  set mouseLeave(i) {
    this._mouseLeave = i, i && (this.tooltipVisible = false, clearTimeout(this.timeoutID));
  }
  get mouseLeave() {
    return this._mouseLeave;
  }
  computeTooltipPosition() {
    const { value: i } = this._parent, { value: t } = this._tooltip;
    i && t && uo(i, t, {
      placement: "bottom",
      middleware: [Js2(10), co(), lo(), ao({ padding: 5 })]
    }).then((e) => {
      const { x: n, y: s } = e;
      Object.assign(t.style, {
        left: `${n}px`,
        top: `${s}px`
      });
    });
  }
  onMouseEnter() {
    if (!(this.tooltipTitle || this.tooltipText))
      return;
    this.mouseLeave = false;
    const i = this.tooltipTime ?? 700;
    this.timeoutID = setTimeout(() => {
      this.mouseLeave || (this.computeTooltipPosition(), this.tooltipVisible = true);
    }, i);
  }
  closeNestedContexts() {
    const i = this.getAttribute("data-context-group");
    if (i)
      for (const t of mi.dialog.children) {
        const e = t.getAttribute("data-context-group");
        if (t instanceof mi && e === i) {
          t.visible = false, t.removeAttribute("data-context-group");
          for (const n of t.children)
            n instanceof ve && (n.closeNestedContexts(), n.removeAttribute("data-context-group"));
        }
      }
  }
  click() {
    this.disabled || super.click();
  }
  get _contextMenu() {
    return this.querySelector("bim-context-menu");
  }
  connectedCallback() {
    super.connectedCallback(), this.addEventListener("click", this.showContextMenu);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.removeEventListener("click", this.showContextMenu);
  }
  render() {
    const i = h`
      <div ${V(this._tooltip)} class="tooltip">
        ${this.tooltipTitle ? h`<p style="text-wrap: nowrap;">
              <strong>${this.tooltipTitle}</strong>
            </p>` : null}
        ${this.tooltipText ? h`<p style="width: 9rem;">${this.tooltipText}</p>` : null}
      </div>
    `, t = h`<svg
      xmlns="http://www.w3.org/2000/svg"
      height="1.125rem"
      viewBox="0 0 24 24"
      width="1.125rem"
      style="fill: var(--bim-label--c)"
    >
      <path d="M0 0h24v24H0V0z" fill="none" />
      <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
    </svg>`;
    return h`
      <div ${V(this._parent)} class="parent" @click=${this.onClick}>
        ${this.label || this.icon ? h`
              <div
                class="button"
                @mouseenter=${this.onMouseEnter}
                @mouseleave=${() => this.mouseLeave = true}
              >
                <bim-label
                  .icon=${this.icon}
                  .vertical=${this.vertical}
                  .labelHidden=${this.labelHidden}
                  >${this.label}${this.label && this._contextMenu ? t : null}</bim-label
                >
              </div>
            ` : null}
        ${this.tooltipTitle || this.tooltipText ? i : null}
      </div>
      <slot></slot>
    `;
  }
}, ve.styles = O`
    :host {
      --bim-label--c: var(--bim-ui_bg-contrast-100, white);
      position: relative;
      display: block;
      flex: 1;
      pointer-events: none;
      background-color: var(--bim-button--bgc, var(--bim-ui_bg-contrast-20));
      border-radius: var(--bim-ui_size-4xs);
      transition: all 0.15s;
    }

    :host(:not([disabled]))::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: inherit;
      background-color: var(--bim-ui_main-base);
      clip-path: circle(0 at center center);
      box-sizing: border-box;
      transition:
        clip-path 0.3s cubic-bezier(0.65, 0.05, 0.36, 1),
        transform 0.15s;
    }

    :host(:not([disabled]):hover) {
      cursor: pointer;
    }

    bim-label {
      pointer-events: none;
    }

    .parent {
      --bim-icon--c: var(--bim-label--c);
      position: relative;
      display: flex;
      height: 100%;
      user-select: none;
      row-gap: 0.125rem;
      min-height: var(--bim-ui_size-5xl);
      min-width: var(--bim-ui_size-5xl);
    }

    .button,
    .children {
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    }

    .children {
      padding: 0 0.375rem;
      position: absolute;
      height: 100%;
      right: 0;
    }

    :host(:not([label-hidden])[icon][vertical]) .parent {
      min-height: 2.5rem;
    }

    .button {
      flex-grow: 1;
      transition: transform 0.15s;
    }

    :host(:not([label-hidden])[label]) .button {
      justify-content: var(--bim-button--jc, center);
    }

    :host(:hover)::before {
      clip-path: circle(120% at center center);
    }

    :host(:hover) {
      --bim-label--c: var(--bim-ui_main-contrast);
      z-index: 2;
    }

    :host([active]) {
      background-color: var(--bim-ui_main-base);
    }

    :host(:not([disabled]):active) {
      background: transparent;
    }

    :host(:not([disabled]):active) .button,
    :host(:not([disabled]):active)::before {
      transform: scale(0.98);
    }

    :host(:not([label]):not([icon])) .children {
      flex: 1;
    }

    :host([vertical]) .parent {
      justify-content: center;
    }

    :host(:not([label-hidden])[label]) .button {
      padding: 0 0.5rem;
    }

    :host([disabled]) {
      --bim-label--c: var(--bim-ui_bg-contrast-80) !important;
      background-color: gray !important;
    }

    ::slotted(bim-button) {
      --bim-icon--fz: var(--bim-ui_size-base);
      --bim-button--bdrs: var(--bim-ui_size-4xs);
      --bim-button--olw: 0;
      --bim-button--olc: transparent;
    }

    .tooltip {
      position: absolute;
      padding: 0.75rem;
      z-index: 99;
      display: flex;
      flex-flow: column;
      row-gap: 0.375rem;
      box-shadow: 0 0 10px 3px rgba(0 0 0 / 20%);
      outline: 1px solid var(--bim-ui_bg-contrast-40);
      font-size: var(--bim-ui_size-xs);
      border-radius: var(--bim-ui_size-4xs);
      background-color: var(--bim-ui_bg-contrast-20);
      color: var(--bim-ui_bg-contrast-100);
      animation: openTooltips 0.15s ease-out forwards;
      transition: visibility 0.2s;
    }

    .tooltip p {
      margin: 0;
      padding: 0;
    }

    :host(:not([tooltip-visible])) .tooltip {
      animation: closeTooltips 0.15s ease-in forwards;
      visibility: hidden;
      display: none;
    }

    @keyframes closeTooltips {
      0% {
        display: flex;
        padding: 0.75rem;
        transform: translateY(0);
        opacity: 1;
      }
      90% {
        padding: 0.75rem;
      }
      100% {
        display: none;
        padding: 0;
        transform: translateY(-10px);
        opacity: 0;
      }
    }

    @keyframes openTooltips {
      0% {
        display: flex;
        transform: translateY(-10px);
        opacity: 0;
      }
      100% {
        transform: translateY(0);
        opacity: 1;
      }
    }
  `, ve);
lt([
  m({ type: String, reflect: true })
], it.prototype, "label", 2);
lt([
  m({ type: Boolean, attribute: "label-hidden", reflect: true })
], it.prototype, "labelHidden", 2);
lt([
  m({ type: Boolean, reflect: true })
], it.prototype, "active", 2);
lt([
  m({ type: Boolean, reflect: true, attribute: "disabled" })
], it.prototype, "disabled", 2);
lt([
  m({ type: String, reflect: true })
], it.prototype, "icon", 2);
lt([
  m({ type: Boolean, reflect: true })
], it.prototype, "vertical", 2);
lt([
  m({ type: Number, attribute: "tooltip-time", reflect: true })
], it.prototype, "tooltipTime", 2);
lt([
  m({ type: Boolean, attribute: "tooltip-visible", reflect: true })
], it.prototype, "tooltipVisible", 2);
lt([
  m({ type: String, attribute: "tooltip-title", reflect: true })
], it.prototype, "tooltipTitle", 2);
lt([
  m({ type: String, attribute: "tooltip-text", reflect: true })
], it.prototype, "tooltipText", 2);
lt([
  m({ type: Boolean, reflect: true })
], it.prototype, "loading", 1);
var ed = it;
var id = Object.defineProperty;
var Ue = (i, t, e, n) => {
  for (var s = void 0, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = r(t, e, s) || s);
  return s && id(t, e, s), s;
};
var Vo = class extends T {
  constructor() {
    super(...arguments), this.checked = false, this.inverted = false, this.onValueChange = new Event("change");
  }
  /**
   * A getter that returns the current checked state of the checkbox. This is useful for retrieving the checkbox's value in form submissions or JavaScript interactions as it provides a consistent `value` property as many other components.
   * @type {boolean}
   * @default false
   * @example <script>console.log(document.querySelector('bim-checkbox').value);<\/script>
   * @example
   * const checkbox = document.createElement('bim-checkbox');
   * document.body.appendChild(checkbox);
   * console.log(checkbox.value); // false initially
   */
  get value() {
    return this.checked;
  }
  onChange(t) {
    t.stopPropagation(), this.checked = t.target.checked, this.dispatchEvent(this.onValueChange);
  }
  render() {
    const t = h`
      <svg viewBox="0 0 21 21">
        <polyline points="5 10.75 8.5 14.25 16 6"></polyline>
      </svg>
    `;
    return h`
      <div class="parent">
        <label class="parent-label">
          ${this.label ? h`<bim-label .icon="${this.icon}">${this.label}</bim-label> ` : null}
          <div class="input-container">
            <input
              type="checkbox"
              aria-label=${this.label || this.name || "Checkbox Input"}
              @change="${this.onChange}"
              .checked="${this.checked}"
            />
            ${t}
          </div>
        </label>
      </div>
    `;
  }
};
Vo.styles = O`
    :host {
      display: block;
    }

    .parent-label {
      --background: #fff;
      --border: #dfdfe6;
      --stroke: #fff;
      --border-hover: var(--bim-ui_main-base);
      --border-active: var(--bim-ui_main-base);
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      width: 100%;
      height: 1.75rem;
      column-gap: 0.25rem;
      position: relative;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    :host([inverted]) .parent-label {
      flex-direction: row-reverse;
      justify-content: start;
    }

    input,
    svg {
      width: 1rem;
      height: 1rem;
      display: block;
    }

    input {
      -webkit-appearance: none;
      -moz-appearance: none;
      position: relative;
      outline: none;
      background: var(--background);
      border: none;
      margin: 0;
      padding: 0;
      cursor: pointer;
      border-radius: 4px;
      transition: box-shadow 0.3s;
      box-shadow: inset 0 0 0 var(--s, 1px) var(--b, var(--border));
    }

    svg {
      pointer-events: none;
      fill: none;
      stroke-width: 2.2px;
      stroke-linecap: round;
      stroke-linejoin: round;
      stroke: var(--stroke, var(--border-active));
      transform: translateY(-100%) scale(0);
      position: absolute;
      width: 1rem;
      height: 1rem;
    }

    input:hover {
      --s: 2px;
      --b: var(--border-hover);
    }

    input:checked {
      --b: var(--border-active);
      --s: 11px;
    }

    input:checked + svg {
      -webkit-animation: bounce 0.4s linear forwards 0.2s;
      animation: bounce 0.4s linear forwards 0.2s;
    }

    @keyframes bounce {
      0% {
        transform: translateY(-100%) scale(0);
      }
      50% {
        transform: translateY(-100%) scale(1.2);
      }
      75% {
        transform: translateY(-100%) scale(0.9);
      }
      100% {
        transform: translateY(-100%) scale(1);
      }
    }
  `;
var le = Vo;
Ue([
  m({ type: String, reflect: true })
], le.prototype, "icon");
Ue([
  m({ type: String, reflect: true })
], le.prototype, "name");
Ue([
  m({ type: String, reflect: true })
], le.prototype, "label");
Ue([
  m({ type: Boolean, reflect: true })
], le.prototype, "checked");
Ue([
  m({ type: Boolean, reflect: true })
], le.prototype, "inverted");
var nd = Object.defineProperty;
var Vt = (i, t, e, n) => {
  for (var s = void 0, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = r(t, e, s) || s);
  return s && nd(t, e, s), s;
};
var Yo = class extends T {
  constructor() {
    super(...arguments), this.vertical = false, this.color = "#bcf124", this.disabled = false, this._colorInput = re(), this._textInput = re(), this.onValueChange = new Event("input"), this.onOpacityInput = (t) => {
      const e = t.target;
      this.opacity = e.value, this.dispatchEvent(this.onValueChange);
    };
  }
  /**
   * Represents both the color and opacity values combined into a single object. This is an instance property, not an HTMLElement attribute.
   * @type {Object}
   * @example
   * const colorInput = document.createElement('bim-color-input');
   * colorInput.value = { color: '#ff0000', opacity: 0.5 };
   */
  set value(t) {
    const { color: e, opacity: n } = t;
    this.color = e, n && (this.opacity = n);
  }
  get value() {
    const t = {
      color: this.color
    };
    return this.opacity && (t.opacity = this.opacity), t;
  }
  onColorInput(t) {
    t.stopPropagation();
    const { value: e } = this._colorInput;
    e && (this.color = e.value, this.dispatchEvent(this.onValueChange));
  }
  onTextInput(t) {
    t.stopPropagation();
    const { value: e } = this._textInput;
    if (!e)
      return;
    const { value: n } = e;
    let s = n.replace(/[^a-fA-F0-9]/g, "");
    s.startsWith("#") || (s = `#${s}`), e.value = s.slice(0, 7), e.value.length === 7 && (this.color = e.value, this.dispatchEvent(this.onValueChange));
  }
  /**
   * Focuses on the color input by programmatically triggering a click event on the underlying color input element.
   * If the color input element is not available, the function does nothing.
   */
  focus() {
    const { value: t } = this._colorInput;
    t && t.click();
  }
  render() {
    return h`
      <div class="parent">
        <bim-input
          .label=${this.label}
          .icon=${this.icon}
          .vertical="${this.vertical}"
        >
          <div class="color-container">
            <div
              style="display: flex; align-items: center; gap: .375rem; height: 100%; flex: 1; padding: 0 0.5rem;"
            >
              <input
                ${V(this._colorInput)}
                @input="${this.onColorInput}"
                type="color"
                aria-label=${this.label || this.name || "Color Input"}
                value="${this.color}"
                ?disabled=${this.disabled}
              />
              <div
                @click=${this.focus}
                class="sample"
                style="background-color: ${this.color}"
              ></div>
              <input
                ${V(this._textInput)}
                @input="${this.onTextInput}"
                value="${this.color}"
                type="text"
                aria-label=${this.label || this.name || "Text Color Input"}
                ?disabled=${this.disabled}
              />
            </div>
            ${this.opacity !== void 0 ? h`<bim-number-input
                  @change=${this.onOpacityInput}
                  slider
                  suffix="%"
                  min="0"
                  value=${this.opacity}
                  max="100"
                ></bim-number-input>` : null}
          </div>
        </bim-input>
      </div>
    `;
  }
};
Yo.styles = O`
    :host {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
      flex: 1;
      display: block;
    }

    :host(:focus) {
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(--bim-ui_accent-base);
    }

    .parent {
      display: flex;
      gap: 0.375rem;
    }

    .color-container {
      position: relative;
      outline: none;
      display: flex;
      height: 100%;
      gap: 0.5rem;
      justify-content: flex-start;
      align-items: center;
      flex: 1;
      border-radius: var(--bim-color-input--bdrs, var(--bim-ui_size-4xs));
    }

    .color-container input[type="color"] {
      position: absolute;
      bottom: -0.25rem;
      visibility: hidden;
      width: 0;
      height: 0;
    }

    .color-container .sample {
      width: 1rem;
      height: 1rem;
      border-radius: 0.125rem;
      background-color: #fff;
    }

    .color-container input[type="text"] {
      height: 100%;
      flex: 1;
      width: 3.25rem;
      text-transform: uppercase;
      font-size: 0.75rem;
      background-color: transparent;
      padding: 0%;
      outline: none;
      border: none;
      color: var(--bim-color-input--c, var(--bim-ui_bg-contrast-100));
    }

    :host([disabled]) .color-container input[type="text"] {
      color: var(--bim-ui_bg-contrast-60);
    }

    bim-number-input {
      flex-grow: 0;
    }
  `;
var Ot = Yo;
Vt([
  m({ type: String, reflect: true })
], Ot.prototype, "name");
Vt([
  m({ type: String, reflect: true })
], Ot.prototype, "label");
Vt([
  m({ type: String, reflect: true })
], Ot.prototype, "icon");
Vt([
  m({ type: Boolean, reflect: true })
], Ot.prototype, "vertical");
Vt([
  m({ type: Number, reflect: true })
], Ot.prototype, "opacity");
Vt([
  m({ type: String, reflect: true })
], Ot.prototype, "color");
Vt([
  m({ type: Boolean, reflect: true })
], Ot.prototype, "disabled");
var sd = Object.defineProperty;
var od = Object.getOwnPropertyDescriptor;
var Pt = (i, t, e, n) => {
  for (var s = n > 1 ? void 0 : n ? od(t, e) : t, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = (n ? r(t, e, s) : r(s)) || s);
  return n && s && sd(t, e, s), s;
};
var Wo = class extends T {
  constructor() {
    super(...arguments), this.checked = false, this.checkbox = false, this.noMark = false, this.vertical = false;
  }
  get value() {
    return this._value !== void 0 ? this._value : this.label ? xi(this.label) : this.label;
  }
  set value(t) {
    this._value = t;
  }
  render() {
    return h`
      <div class="parent" .title=${this.label ?? ""}>
        ${this.img || this.icon || this.label ? h` <div style="display: flex; column-gap: 0.375rem">
              ${this.checkbox && !this.noMark ? h`<bim-checkbox
                    style="pointer-events: none"
                    .checked=${this.checked}
                  ></bim-checkbox>` : null}
              <bim-label
                .vertical=${this.vertical}
                .icon=${this.icon}
                .img=${this.img}
                >${this.label}</bim-label
              >
            </div>` : null}
        ${!this.checkbox && !this.noMark && this.checked ? h`<svg
              xmlns="http://www.w3.org/2000/svg"
              height="1.125rem"
              viewBox="0 0 24 24"
              width="1.125rem"
              fill="#FFFFFF"
            >
              <path d="M0 0h24v24H0z" fill="none" />
              <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" />
            </svg>` : null}
        <slot></slot>
      </div>
    `;
  }
};
Wo.styles = O`
    :host {
      --bim-label--c: var(--bim-ui_bg-contrast-100);
      display: block;
      box-sizing: border-box;
      flex: 1;
      padding: 0rem 0.5rem;
      border-radius: var(--bim-ui_size-4xs);
      transition: all 0.15s;
    }

    :host(:hover) {
      cursor: pointer;
    }

    :host([checked]) {
      --bim-label--c: color-mix(in lab, var(--bim-ui_main-base), white 30%);
    }

    :host([checked]) svg {
      fill: color-mix(in lab, var(--bim-ui_main-base), white 30%);
    }

    .parent {
      box-sizing: border-box;
      display: flex;
      justify-content: var(--bim-option--jc, space-between);
      column-gap: 0.5rem;
      align-items: center;
      min-height: 1.75rem;
      height: 100%;
    }

    input {
      height: 1rem;
      width: 1rem;
      cursor: pointer;
      border: none;
      outline: none;
      accent-color: var(--bim-checkbox--c, var(--bim-ui_main-base));
    }

    input:focus {
      outline: var(--bim-checkbox--olw, 2px) solid
        var(--bim-checkbox--olc, var(--bim-ui_accent-base));
    }

    bim-label {
      pointer-events: none;
      z-index: 1;
    }
  `;
var j = Wo;
Pt([
  m({ type: String, reflect: true })
], j.prototype, "img", 2);
Pt([
  m({ type: String, reflect: true })
], j.prototype, "label", 2);
Pt([
  m({ type: String, reflect: true })
], j.prototype, "icon", 2);
Pt([
  m({ type: Boolean, reflect: true })
], j.prototype, "checked", 2);
Pt([
  m({ type: Boolean, reflect: true })
], j.prototype, "checkbox", 2);
Pt([
  m({ type: Boolean, attribute: "no-mark", reflect: true })
], j.prototype, "noMark", 2);
Pt([
  m({
    converter: {
      fromAttribute(i) {
        return i && xi(i);
      }
    }
  })
], j.prototype, "value", 1);
Pt([
  m({ type: Boolean, reflect: true })
], j.prototype, "vertical", 2);
var rd = Object.defineProperty;
var ad = Object.getOwnPropertyDescriptor;
var yt = (i, t, e, n) => {
  for (var s = n > 1 ? void 0 : n ? ad(t, e) : t, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = (n ? r(t, e, s) : r(s)) || s);
  return n && s && rd(t, e, s), s;
};
var Go = class extends H {
  constructor() {
    super(), this.multiple = false, this.required = false, this.vertical = false, this._visible = false, this._value = /* @__PURE__ */ new Set(), this.onValueChange = new Event("change"), this._contextMenu = re(), this.onOptionClick = (t) => {
      const e = t.target, n = this._value.has(e);
      if (!this.multiple && !this.required && !n)
        this._value = /* @__PURE__ */ new Set([e]);
      else if (!this.multiple && !this.required && n)
        this._value = /* @__PURE__ */ new Set([]);
      else if (!this.multiple && this.required && !n)
        this._value = /* @__PURE__ */ new Set([e]);
      else if (this.multiple && !this.required && !n)
        this._value = /* @__PURE__ */ new Set([...this._value, e]);
      else if (this.multiple && !this.required && n) {
        const s = [...this._value].filter((o) => o !== e);
        this._value = new Set(s);
      } else if (this.multiple && this.required && !n)
        this._value = /* @__PURE__ */ new Set([...this._value, e]);
      else if (this.multiple && this.required && n) {
        const s = [...this._value].filter((r) => r !== e), o = new Set(s);
        o.size !== 0 && (this._value = o);
      }
      this.updateOptionsState(), this.dispatchEvent(this.onValueChange);
    }, this.useObserver = true;
  }
  set visible(t) {
    if (t) {
      const { value: e } = this._contextMenu;
      if (!e)
        return;
      for (const n of this.elements)
        e.append(n);
      this._visible = true;
    } else {
      for (const e of this.elements)
        this.append(e);
      this._visible = false, this.resetVisibleElements();
    }
  }
  get visible() {
    return this._visible;
  }
  /**
   * The selected values in the dropdown.
   * @type {any[]}
   * @example
   * const dropdown = document.createElement('bim-dropdown');
   * dropdown.value = ['option1', 'option2'];
   */
  set value(t) {
    if (this.required && Object.keys(t).length === 0)
      return;
    const e = /* @__PURE__ */ new Set();
    for (const n of t) {
      const s = this.findOption(n);
      if (s && (e.add(s), !this.multiple && Object.keys(t).length === 1))
        break;
    }
    this._value = e, this.updateOptionsState(), this.dispatchEvent(this.onValueChange);
  }
  get value() {
    return [...this._value].filter(
      (t) => t instanceof j && t.checked
    ).map((t) => t.value);
  }
  get _options() {
    const t = /* @__PURE__ */ new Set([...this.elements]);
    for (const e of this.children)
      e instanceof j && t.add(e);
    return [...t];
  }
  onSlotChange(t) {
    const e = t.target.assignedElements();
    this.observe(e);
    const n = /* @__PURE__ */ new Set();
    for (const s of this.elements) {
      if (!(s instanceof j)) {
        s.remove();
        continue;
      }
      s.checked && n.add(s), s.removeEventListener("click", this.onOptionClick), s.addEventListener("click", this.onOptionClick);
    }
    this._value = n;
  }
  updateOptionsState() {
    for (const t of this._options)
      t instanceof j && (t.checked = this._value.has(t));
  }
  findOption(t) {
    return this._options.find((e) => e instanceof j ? e.label === t || e.value === t : false);
  }
  render() {
    let t, e, n;
    if (this._value.size === 0)
      t = this.placeholder ?? "Select an option...";
    else if (this._value.size === 1) {
      const s = [...this._value][0];
      t = (s == null ? void 0 : s.label) || (s == null ? void 0 : s.value), e = s == null ? void 0 : s.img, n = s == null ? void 0 : s.icon;
    } else
      t = `Multiple (${this._value.size})`;
    return h`
      <bim-input
        title=${this.label ?? ""}
        .label=${this.label}
        .icon=${this.icon}
        .vertical=${this.vertical}
      >
        <div class="input" @click=${() => this.visible = !this.visible}>
          <bim-label
            .img=${e}
            .icon=${n}
            style="overflow: hidden;"
            >${t}</bim-label
          >
          <svg
            style="flex-shrink: 0; fill: var(--bim-dropdown--c, var(--bim-ui_bg-contrast-100))"
            xmlns="http://www.w3.org/2000/svg"
            height="1.125rem"
            viewBox="0 0 24 24"
            width="1.125rem"
            fill="#9ca3af"
          >
            <path d="M0 0h24v24H0V0z" fill="none" />
            <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
          </svg>
          <bim-context-menu
            ${V(this._contextMenu)}
            .visible=${this.visible}
            @hidden=${() => {
      this.visible && (this.visible = false);
    }}
          >
            <slot @slotchange=${this.onSlotChange}></slot>
          </bim-context-menu>
        </div>
      </bim-input>
    `;
  }
};
Go.styles = [
  Tt.scrollbar,
  O`
      :host {
        --bim-input--bgc: var(
          --bim-dropdown--bgc,
          var(--bim-ui_bg-contrast-20)
        );
        --bim-input--olw: 2px;
        --bim-input--olc: transparent;
        --bim-input--bdrs: var(--bim-ui_size-4xs);
        flex: 1;
        display: block;
      }

      :host([visible]) {
        --bim-input--olc: var(--bim-ui_accent-base);
      }

      .input {
        --bim-label--fz: var(--bim-drodown--fz, var(--bim-ui_size-xs));
        --bim-label--c: var(--bim-dropdown--c, var(--bim-ui_bg-contrast-100));
        height: 100%;
        display: flex;
        flex: 1;
        overflow: hidden;
        column-gap: 0.25rem;
        outline: none;
        cursor: pointer;
        align-items: center;
        justify-content: space-between;
        padding: 0 0.5rem;
      }

      bim-label {
        pointer-events: none;
      }
    `
];
var mt = Go;
yt([
  m({ type: String, reflect: true })
], mt.prototype, "name", 2);
yt([
  m({ type: String, reflect: true })
], mt.prototype, "icon", 2);
yt([
  m({ type: String, reflect: true })
], mt.prototype, "label", 2);
yt([
  m({ type: Boolean, reflect: true })
], mt.prototype, "multiple", 2);
yt([
  m({ type: Boolean, reflect: true })
], mt.prototype, "required", 2);
yt([
  m({ type: Boolean, reflect: true })
], mt.prototype, "vertical", 2);
yt([
  m({ type: String, reflect: true })
], mt.prototype, "placeholder", 2);
yt([
  m({ type: Boolean, reflect: true })
], mt.prototype, "visible", 1);
yt([
  ae()
], mt.prototype, "_value", 2);
var ld = Object.defineProperty;
var Xo = (i, t, e, n) => {
  for (var s = void 0, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = r(t, e, s) || s);
  return s && ld(t, e, s), s;
};
var Jo = class extends T {
  constructor() {
    super(...arguments), this.floating = false, this._layouts = {}, this._elements = {}, this._templateIds = /* @__PURE__ */ new Map(), this._updateFunctions = {}, this.updateComponent = {};
  }
  /**
   * Represents a collection of predefined grid layouts for the Grid component.
   * Each layout is defined by a unique name, a grid template string, and a map of area names to HTMLElement instances or
   * Statefull/Stateless component definitions.
   * The grid template string defines the structure of the grid, and the area names correspond to the grid-area property of the HTMLElement instances.
   * The HTMLElement instances are used to populate the grid with content.
   * @remarks Once defined, the layout is meant to be immutable.
   */
  set layouts(t) {
    this._layouts = t, this._templateIds.clear();
  }
  get layouts() {
    return this._layouts;
  }
  set elements(t) {
    this._elements = t;
    const e = {};
    for (const [n, s] of Object.entries(this.elements))
      "template" in s && (e[n] = (o) => {
        const r = this._updateFunctions[n];
        r && r(o);
      });
    this.updateComponent = e;
  }
  get elements() {
    return this._elements;
  }
  // private isVerticalArea(area: string) {
  //   const { rows } = this;
  //   const row = rows.find((row) => row.includes(area));
  //   if (!row)
  //     throw new Error(
  //       `${area} wasn't defined in the grid-template of this bim-grid`,
  //     );
  //   const index = rows.indexOf(row);
  //   const abovePanel = index > 0 && rows[index - 1].includes(area);
  //   const belowPanel =
  //     index < rows.length - 1 && rows[index + 1].includes(area);
  //   return abovePanel || belowPanel;
  // }
  getLayoutAreas(t) {
    const { template: e } = t, n = e.split(`
`).map((s) => s.trim()).map((s) => s.split('"')[1]).filter((s) => s !== void 0).flatMap((s) => s.split(/\s+/));
    return [...new Set(n)].filter((s) => s !== "");
  }
  firstUpdated() {
    this._onLayoutChange = new Event("layoutchange");
  }
  getTemplateId(t) {
    let e = this._templateIds.get(t);
    return e || (e = U.newRandomId(), this._templateIds.set(t, e)), e;
  }
  cleanUpdateFunctions() {
    if (!this.layout) {
      this._updateFunctions = {};
      return;
    }
    const t = this.layouts[this.layout], e = this.getLayoutAreas(t);
    for (const n in this.elements)
      e.includes(n) || delete this._updateFunctions[n];
  }
  render() {
    if (this.layout) {
      if (this.layouts[this.layout]) {
        const t = this.layouts[this.layout], e = this.getLayoutAreas(t).map((n) => {
          var s;
          const o = ((s = t.elements) == null ? void 0 : s[n]) || this.elements[n];
          if (!o)
            return null;
          if (o instanceof HTMLElement)
            return o.style.gridArea = n, o;
          if ("template" in o) {
            const { template: c, initialState: d } = o, u = this.getTemplateId(c), p = this.querySelector(
              `[data-grid-template-id="${u}"]`
            );
            if (p)
              return p;
            const [f, b] = H.create(c, d);
            return f.setAttribute("data-grid-template-id", u), f.style.gridArea = n, this._updateFunctions[n] = b, f;
          }
          const r = this.getTemplateId(o), a = this.querySelector(
            `[data-grid-template-id="${r}"]`
          );
          if (a)
            return a;
          const l = H.create(o);
          return l.setAttribute(
            "data-grid-template-id",
            this.getTemplateId(o)
          ), l.style.gridArea = n, l;
        }).filter((n) => n !== null);
        this.innerHTML = "", this.style.gridTemplate = t.template, this.append(...e), this._onLayoutChange && this.dispatchEvent(this._onLayoutChange);
      }
    } else
      this.innerHTML = "", this.style.gridTemplate = "", this._onLayoutChange && this.dispatchEvent(this._onLayoutChange);
    return this.cleanUpdateFunctions(), h`<slot></slot>`;
  }
};
Jo.styles = O`
    :host {
      display: grid;
      height: 100%;
      width: 100%;
      overflow: hidden;
      box-sizing: border-box;
    }

    /* :host(:not([layout])) {
      display: none;
    } */

    :host([floating]) {
      --bim-panel--bdrs: var(--bim-ui_size-4xs);
      background-color: transparent;
      padding: 1rem;
      gap: 1rem;
      position: absolute;
      pointer-events: none;
      top: 0px;
      left: 0px;
    }

    :host(:not([floating])) {
      --bim-panel--bdrs: 0;
      background-color: var(--bim-ui_bg-contrast-20);
      gap: 1px;
    }
  `;
var On = Jo;
Xo([
  m({ type: Boolean, reflect: true })
], On.prototype, "floating");
Xo([
  m({ type: String, reflect: true })
], On.prototype, "layout");
var rn = class extends T {
  render() {
    return h`
      <iconify-icon .icon=${this.icon} height="none"></iconify-icon>
    `;
  }
};
rn.styles = O`
    :host {
      height: var(--bim-icon--fz, var(--bim-ui_size-sm));
      width: var(--bim-icon--fz, var(--bim-ui_size-sm));
    }

    iconify-icon {
      height: var(--bim-icon--fz, var(--bim-ui_size-sm));
      width: var(--bim-icon--fz, var(--bim-ui_size-sm));
      color: var(--bim-icon--c);
      transition: all 0.15s;
      display: flex;
    }
  `, rn.properties = {
  icon: { type: String }
};
var cd = rn;
var dd = Object.defineProperty;
var Ci = (i, t, e, n) => {
  for (var s = void 0, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = r(t, e, s) || s);
  return s && dd(t, e, s), s;
};
var Qo = class extends T {
  constructor() {
    super(...arguments), this.vertical = false, this.onValueChange = new Event("change");
  }
  get value() {
    const t = {};
    for (const e of this.children) {
      const n = e;
      "value" in n ? t[n.name || n.label] = n.value : "checked" in n && (t[n.name || n.label] = n.checked);
    }
    return t;
  }
  set value(t) {
    const e = [...this.children];
    for (const n in t) {
      const s = e.find((a) => {
        const l = a;
        return l.name === n || l.label === n;
      });
      if (!s)
        continue;
      const o = s, r = t[n];
      typeof r == "boolean" ? o.checked = r : o.value = r;
    }
  }
  render() {
    return h`
      <div class="parent">
        ${this.label || this.icon ? h`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        <div class="input">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
Qo.styles = O`
    :host {
      flex: 1;
      display: block;
    }

    .parent {
      display: flex;
      flex-wrap: wrap;
      column-gap: 1rem;
      row-gap: 0.375rem;
      user-select: none;
      flex: 1;
    }

    :host(:not([vertical])) .parent {
      justify-content: space-between;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    .input {
      position: relative;
      overflow: hidden;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      min-height: 1.75rem;
      min-width: 3rem;
      gap: var(--bim-input--g, var(--bim-ui_size-4xs));
      padding: var(--bim-input--p, 0);
      background-color: var(--bim-input--bgc, transparent);
      border: var(--bim-input--olw, 2px) solid
        var(--bim-input--olc, transparent);
      border-radius: var(--bim-input--bdrs, var(--bim-ui_size-4xs));
      transition: all 0.15s;
    }

    :host(:not([vertical])) .input {
      flex: 1;
      justify-content: flex-end;
    }

    :host(:not([vertical])[label]) .input {
      max-width: fit-content;
    }
  `;
var qe = Qo;
Ci([
  m({ type: String, reflect: true })
], qe.prototype, "name");
Ci([
  m({ type: String, reflect: true })
], qe.prototype, "label");
Ci([
  m({ type: String, reflect: true })
], qe.prototype, "icon");
Ci([
  m({ type: Boolean, reflect: true })
], qe.prototype, "vertical");
var ud = Object.defineProperty;
var Ve = (i, t, e, n) => {
  for (var s = void 0, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = r(t, e, s) || s);
  return s && ud(t, e, s), s;
};
var Zo = class extends T {
  constructor() {
    super(...arguments), this.labelHidden = false, this.iconHidden = false, this.vertical = false;
  }
  get value() {
    return this.textContent ? xi(this.textContent) : this.textContent;
  }
  render() {
    return h`
      <div class="parent" .title=${this.textContent ?? ""}>
        ${this.img ? h`<img .src=${this.img} .alt=${this.textContent || ""} />` : null}
        ${!this.iconHidden && this.icon ? h`<bim-icon .icon=${this.icon}></bim-icon>` : null}
        <p><slot></slot></p>
      </div>
    `;
  }
};
Zo.styles = O`
    :host {
      --bim-icon--c: var(--bim-label--c);
      overflow: auto;
      color: var(--bim-label--c, var(--bim-ui_bg-contrast-60));
      font-size: var(--bim-label--fz, var(--bim-ui_size-xs));
      display: block;
      white-space: nowrap;
      transition: all 0.15s;
    }

    :host([icon]) {
      line-height: 1.1rem;
    }

    .parent {
      display: flex;
      align-items: center;
      column-gap: 0.25rem;
      row-gap: 0.125rem;
      user-select: none;
      height: 100%;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    .parent p {
      display: flex;
      margin: 0;
      text-overflow: ellipsis;
      overflow: hidden;
      align-items: center;
      gap: 0.125rem;
    }

    :host([label-hidden]) .parent p,
    :host(:empty) .parent p {
      display: none;
    }

    img {
      height: 100%;
      aspect-ratio: 1;
      border-radius: 100%;
      margin-right: 0.125rem;
    }

    :host(:not([vertical])) img {
      max-height: var(
        --bim-label_icon--sz,
        calc(var(--bim-label--fz, var(--bim-ui_size-xs)) * 1.8)
      );
    }

    :host([vertical]) img {
      max-height: var(
        --bim-label_icon--sz,
        calc(var(--bim-label--fz, var(--bim-ui_size-xs)) * 4)
      );
    }
  `;
var ce = Zo;
Ve([
  m({ type: String, reflect: true })
], ce.prototype, "img");
Ve([
  m({ type: Boolean, attribute: "label-hidden", reflect: true })
], ce.prototype, "labelHidden");
Ve([
  m({ type: String, reflect: true })
], ce.prototype, "icon");
Ve([
  m({ type: Boolean, attribute: "icon-hidden", reflect: true })
], ce.prototype, "iconHidden");
Ve([
  m({ type: Boolean, reflect: true })
], ce.prototype, "vertical");
var hd = Object.defineProperty;
var pd = Object.getOwnPropertyDescriptor;
var nt = (i, t, e, n) => {
  for (var s = n > 1 ? void 0 : n ? pd(t, e) : t, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = (n ? r(t, e, s) : r(s)) || s);
  return n && s && hd(t, e, s), s;
};
var Ko = class extends T {
  constructor() {
    super(...arguments), this._value = 0, this.vertical = false, this.slider = false, this._input = re(), this.onValueChange = new Event("change");
  }
  set value(t) {
    this.setValue(t.toString());
  }
  get value() {
    return this._value;
  }
  onChange(t) {
    t.stopPropagation();
    const { value: e } = this._input;
    e && this.setValue(e.value);
  }
  setValue(t) {
    const { value: e } = this._input;
    let n = t;
    if (n = n.replace(/[^0-9.-]/g, ""), n = n.replace(/(\..*)\./g, "$1"), n.endsWith(".") || (n.lastIndexOf("-") > 0 && (n = n[0] + n.substring(1).replace(/-/g, "")), n === "-" || n === "-0"))
      return;
    let s = Number(n);
    Number.isNaN(s) || (s = this.min !== void 0 ? Math.max(s, this.min) : s, s = this.max !== void 0 ? Math.min(s, this.max) : s, this.value !== s && (this._value = s, e && (e.value = this.value.toString()), this.requestUpdate(), this.dispatchEvent(this.onValueChange)));
  }
  onBlur() {
    const { value: t } = this._input;
    t && Number.isNaN(Number(t.value)) && (t.value = this.value.toString());
  }
  onSliderMouseDown(t) {
    document.body.style.cursor = "w-resize";
    const { clientX: e } = t, n = this.value;
    let s = false;
    const o = (l) => {
      var c;
      s = true;
      const { clientX: d } = l, u = this.step ?? 1, p = ((c = u.toString().split(".")[1]) == null ? void 0 : c.length) || 0, f = 1 / (this.sensitivity ?? 1), b = (d - e) / f;
      if (Math.floor(Math.abs(b)) !== Math.abs(b))
        return;
      const v = n + b * u;
      this.setValue(v.toFixed(p));
    }, r = () => {
      this.slider = true, this.removeEventListener("blur", r);
    }, a = () => {
      document.removeEventListener("mousemove", o), document.body.style.cursor = "default", s ? s = false : (this.addEventListener("blur", r), this.slider = false, requestAnimationFrame(() => this.focus())), document.removeEventListener("mouseup", a);
    };
    document.addEventListener("mousemove", o), document.addEventListener("mouseup", a);
  }
  onFocus(t) {
    t.stopPropagation();
    const e = (n) => {
      n.key === "Escape" && (this.blur(), window.removeEventListener("keydown", e));
    };
    window.addEventListener("keydown", e);
  }
  connectedCallback() {
    super.connectedCallback(), this.min && this.min > this.value && (this._value = this.min), this.max && this.max < this.value && (this._value = this.max);
  }
  /**
   * Sets focus to the input element of the number input component.
   * This method is useful for programmatically focusing the input element, for example,
   * in response to a user action or to emphasize the input in the UI.
   *
   * If the input element reference is not available (not yet rendered or disconnected),
   * this method will do nothing.
   */
  focus() {
    const { value: t } = this._input;
    t && t.focus();
  }
  render() {
    const t = h`
      ${this.pref || this.icon ? h`<bim-label
            style="pointer-events: auto"
            @mousedown=${this.onSliderMouseDown}
            .icon=${this.icon}
            >${this.pref}</bim-label
          >` : null}
      <input
        ${V(this._input)}
        type="text"
        aria-label=${this.label || this.name || "Number Input"}
        size="1"
        @input=${(a) => a.stopPropagation()}
        @change=${this.onChange}
        @blur=${this.onBlur}
        @focus=${this.onFocus}
        .value=${this.value.toString()}
      />
      ${this.suffix ? h`<bim-label
            style="pointer-events: auto"
            @mousedown=${this.onSliderMouseDown}
            >${this.suffix}</bim-label
          >` : null}
    `, e = this.min ?? -1 / 0, n = this.max ?? 1 / 0, s = 100 * (this.value - e) / (n - e), o = h`
      <style>
        .slider-indicator {
          width: ${`${s}%`};
        }
      </style>
      <div class="slider" @mousedown=${this.onSliderMouseDown}>
        <div class="slider-indicator"></div>
        ${this.pref || this.icon ? h`<bim-label
              style="z-index: 1; margin-right: 0.125rem"
              .icon=${this.icon}
              >${`${this.pref}: `}</bim-label
            >` : null}
        <bim-label style="z-index: 1;">${this.value}</bim-label>
        ${this.suffix ? h`<bim-label style="z-index: 1;">${this.suffix}</bim-label>` : null}
      </div>
    `, r = `${this.label || this.name || this.pref ? `${this.label || this.name || this.pref}: ` : ""}${this.value}${this.suffix ?? ""}`;
    return h`
      <bim-input
        title=${r}
        .label=${this.label}
        .icon=${this.icon}
        .vertical=${this.vertical}
      >
        ${this.slider ? o : t}
      </bim-input>
    `;
  }
};
Ko.styles = O`
    :host {
      --bim-input--bgc: var(
        --bim-number-input--bgc,
        var(--bim-ui_bg-contrast-20)
      );
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(--bim-number-input--olc, transparent);
      --bim-input--bdrs: var(--bim-number-input--bdrs, var(--bim-ui_size-4xs));
      --bim-input--p: 0 0.375rem;
      flex: 1;
      display: block;
    }

    :host(:focus) {
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(
        --bim-number-input¡focus--c,
        var(--bim-ui_accent-base)
      );
    }

    :host(:not([slider])) bim-label {
      --bim-label--c: var(
        --bim-number-input_affixes--c,
        var(--bim-ui_bg-contrast-60)
      );
      --bim-label--fz: var(
        --bim-number-input_affixes--fz,
        var(--bim-ui_size-xs)
      );
    }

    p {
      margin: 0;
      padding: 0;
    }

    input {
      background-color: transparent;
      outline: none;
      border: none;
      padding: 0;
      flex-grow: 1;
      text-align: right;
      font-family: inherit;
      font-feature-settings: inherit;
      font-variation-settings: inherit;
      font-size: var(--bim-number-input--fz, var(--bim-ui_size-xs));
      color: var(--bim-number-input--c, var(--bim-ui_bg-contrast-100));
    }

    :host([suffix]:not([pref])) input {
      text-align: left;
    }

    :host([slider]) {
      --bim-input--p: 0;
    }

    :host([slider]) .slider {
      --bim-label--c: var(--bim-ui_bg-contrast-100);
    }

    .slider {
      position: relative;
      display: flex;
      justify-content: center;
      width: 100%;
      height: 100%;
      padding: 0 0.5rem;
    }

    .slider-indicator {
      height: 100%;
      background-color: var(--bim-ui_main-base);
      position: absolute;
      top: 0;
      left: 0;
      border-radius: var(--bim-input--bdrs, var(--bim-ui_size-4xs));
    }

    bim-input {
      display: flex;
    }

    bim-label {
      pointer-events: none;
    }
  `;
var Q = Ko;
nt([
  m({ type: String, reflect: true })
], Q.prototype, "name", 2);
nt([
  m({ type: String, reflect: true })
], Q.prototype, "icon", 2);
nt([
  m({ type: String, reflect: true })
], Q.prototype, "label", 2);
nt([
  m({ type: String, reflect: true })
], Q.prototype, "pref", 2);
nt([
  m({ type: Number, reflect: true })
], Q.prototype, "min", 2);
nt([
  m({ type: Number, reflect: true })
], Q.prototype, "value", 1);
nt([
  m({ type: Number, reflect: true })
], Q.prototype, "step", 2);
nt([
  m({ type: Number, reflect: true })
], Q.prototype, "sensitivity", 2);
nt([
  m({ type: Number, reflect: true })
], Q.prototype, "max", 2);
nt([
  m({ type: String, reflect: true })
], Q.prototype, "suffix", 2);
nt([
  m({ type: Boolean, reflect: true })
], Q.prototype, "vertical", 2);
nt([
  m({ type: Boolean, reflect: true })
], Q.prototype, "slider", 2);
var md = Object.defineProperty;
var fd = Object.getOwnPropertyDescriptor;
var Ye = (i, t, e, n) => {
  for (var s = n > 1 ? void 0 : n ? fd(t, e) : t, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = (n ? r(t, e, s) : r(s)) || s);
  return n && s && md(t, e, s), s;
};
var tr = class extends T {
  constructor() {
    super(...arguments), this.onValueChange = new Event("change"), this._hidden = false, this.headerHidden = false, this.valueTransform = {}, this.activationButton = document.createElement("bim-button");
  }
  set hidden(t) {
    this._hidden = t, this.activationButton.active = !t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  /**
   * The `value` getter computes and returns the current state of the panel's form elements as an object. This property is dynamic and reflects the current input values within the panel. When accessed, it traverses the panel's child elements, collecting values from those that have a `name` or `label` attribute, and constructs an object where each key corresponds to the `name` or `label` of the element, and the value is the element's value. This property is particularly useful for forms or interactive panels where the user's input needs to be retrieved programmatically. The value returned is a snapshot of the panel's state at the time of access, and it does not maintain a live link to the input elements.
   *
   * @default {}
   * @example <bim-panel></bim-panel> <!-- Access via JavaScript to get value -->
   * @example
   * const panel = document.createElement('bim-panel');
   * document.body.appendChild(panel);
   * console.log(panel.value); // Logs the current value object of the panel
   */
  get value() {
    return De(this, this.valueTransform);
  }
  /**
   * The `value` setter allows programmatically updating the values of the panel's form elements. When a data object is passed to this property, it attempts to match the object's keys with the `name` or `label` attributes of the panel's child elements. If a match is found, the corresponding element's value is updated to the value associated with the key in the data object. This property is useful for initializing the panel with specific data or updating its state based on external inputs. Note that this operation does not affect elements without a matching `name` or `label`, and it only updates the values of elements that are direct children of the panel.
   *
   * @type {Record<string, any>}
   * @example <bim-panel></bim-panel> <!-- Set value via JavaScript -->
   * @example
   * const panel = document.createElement('bim-panel');
   * document.body.appendChild(panel);
   * panel.value = { 'input-name': 'John Doe', 'checkbox-name': true };
   */
  set value(t) {
    const e = [...this.children];
    for (const n in t) {
      const s = e.find((r) => {
        const a = r;
        return a.name === n || a.label === n;
      });
      if (!s)
        continue;
      const o = s;
      o.value = t[n];
    }
  }
  animatePanles() {
    const t = [
      {
        maxHeight: "100vh",
        maxWidth: "100vw",
        opacity: 1
      },
      {
        maxHeight: "100vh",
        maxWidth: "100vw",
        opacity: 0
      },
      {
        maxHeight: 0,
        maxWidth: 0,
        opacity: 0
      }
    ];
    this.animate(t, {
      duration: 300,
      easing: "cubic-bezier(0.65, 0.05, 0.36, 1)",
      direction: this.hidden ? "normal" : "reverse",
      fill: "forwards"
    });
  }
  connectedCallback() {
    super.connectedCallback(), this.activationButton.active = !this.hidden, this.activationButton.onclick = () => {
      this.hidden = !this.hidden, this.animatePanles();
    };
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.activationButton.remove();
  }
  /**
   * Collapses all `bim-panel-section` elements within the panel.
   * This method iterates over each `bim-panel-section` found within the panel's DOM and sets their `collapsed` property to `true`,
   * effectively hiding their content from view. This can be used to programmatically minimize the space taken up by sections
   * within the panel, making the panel more compact or to hide details that are not immediately necessary.
   */
  collapseSections() {
    const t = this.querySelectorAll("bim-panel-section");
    for (const e of t)
      e.collapsed = true;
  }
  /**
   * Expands all `bim-panel-section` elements within the panel.
   * This method iterates over each `bim-panel-section` found within the panel's DOM and sets their `collapsed` property to `false`,
   * effectively showing their content. This can be used to programmatically reveal the content of sections within the panel,
   * making the panel more informative or to display details that are necessary for the user.
   */
  expandSections() {
    const t = this.querySelectorAll("bim-panel-section");
    for (const e of t)
      e.collapsed = false;
  }
  render() {
    return this.activationButton.icon = this.icon, this.activationButton.label = this.label || this.name, this.activationButton.tooltipTitle = this.label || this.name, h`
      <div class="parent">
        ${this.label || this.name || this.icon ? h`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        <div class="sections">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
tr.styles = [
  Tt.scrollbar,
  O`
      :host {
        display: flex;
        border-radius: var(--bim-ui_size-base);
        background-color: var(--bim-ui_bg-base);
        overflow: auto;
      }

      :host([hidden]) {
        max-height: 0;
        max-width: 0;
        opacity: 0;
      }

      .parent {
        display: flex;
        flex: 1;
        flex-direction: column;
        pointer-events: auto;
        overflow: auto;
      }

      .parent bim-label {
        --bim-label--c: var(--bim-panel--c, var(--bim-ui_bg-contrast-80));
        --bim-label--fz: var(--bim-panel--fz, var(--bim-ui_size-sm));
        font-weight: 600;
        padding: 1rem;
        flex-shrink: 0;
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([header-hidden]) .parent bim-label {
        display: none;
      }

      .sections {
        height: 100%;
        display: flex;
        flex-direction: column;
        overflow: auto;
        flex: 1;
      }

      ::slotted(bim-panel-section:not(:last-child)) {
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }
    `
];
var Yt = tr;
Ye([
  m({ type: String, reflect: true })
], Yt.prototype, "icon", 2);
Ye([
  m({ type: String, reflect: true })
], Yt.prototype, "name", 2);
Ye([
  m({ type: String, reflect: true })
], Yt.prototype, "label", 2);
Ye([
  m({ type: Boolean, reflect: true })
], Yt.prototype, "hidden", 1);
Ye([
  m({ type: Boolean, attribute: "header-hidden", reflect: true })
], Yt.prototype, "headerHidden", 2);
var bd = Object.defineProperty;
var We = (i, t, e, n) => {
  for (var s = void 0, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = r(t, e, s) || s);
  return s && bd(t, e, s), s;
};
var er = class extends T {
  constructor() {
    super(...arguments), this.onValueChange = new Event("change"), this.valueTransform = {}, this.componentHeight = -1;
  }
  /**
   * The `value` getter computes and returns the current state of the panel section's form elements as an object. This object's keys are the `name` or `label` attributes of the child elements, and the values are the corresponding values of these elements. This property is particularly useful for retrieving a consolidated view of the user's input or selections within the panel section. When the value of any child element changes, the returned object from this getter will reflect those changes, providing a dynamic snapshot of the panel section's state. Note that this property does not have a default value as it dynamically reflects the current state of the panel section's form elements.
   * @example <bim-panel-section></bim-panel-section> <!-- Usage in HTML not directly applicable as this is a getter -->
   * @example
   * const section = document.createElement('bim-panel-section');
   * console.log(section.value); // Logs the current value object
   */
  get value() {
    const t = this.parentElement;
    let e;
    return t instanceof Yt && (e = t.valueTransform), Object.values(this.valueTransform).length !== 0 && (e = this.valueTransform), De(this, e);
  }
  /**
   * The `value` setter allows programmatically updating the values of the panel section's child elements. It accepts an object where keys correspond to the `name` or `label` attributes of the child elements, and the values are the new values to be set for these elements. This property is useful for initializing the panel section with specific values or updating its state based on external data. When the property changes, the corresponding child elements' values are updated to reflect the new state. This does not have a default value as it is a method for updating child elements' values.
   * @type {Record<string, any>}
   * @default undefined
   * @example <bim-panel-section></bim-panel-section> <!-- Usage in HTML not directly applicable as this is a setter -->
   * @example
   * const section = document.createElement('bim-panel-section');
   * section.value = { 'user-settings': 'John Doe' }; // Programmatically sets the value of a child element named 'user-settings'
   */
  set value(t) {
    const e = [...this.children];
    for (const n in t) {
      const s = e.find((r) => {
        const a = r;
        return a.name === n || a.label === n;
      });
      if (!s)
        continue;
      const o = s;
      o.value = t[n];
    }
  }
  setFlexAfterTransition() {
    var t;
    const e = (t = this.shadowRoot) == null ? void 0 : t.querySelector(
      ".components"
    );
    e && setTimeout(() => {
      this.collapsed ? e.style.removeProperty("flex") : e.style.setProperty("flex", "1");
    }, 150);
  }
  animateHeader() {
    var t;
    const e = (t = this.shadowRoot) == null ? void 0 : t.querySelector(
      ".components"
    );
    this.componentHeight < 0 && (this.collapsed ? this.componentHeight = e.clientHeight : (e.style.setProperty("transition", "none"), e.style.setProperty("height", "auto"), e.style.setProperty("padding", "0.125rem 1rem 1rem"), this.componentHeight = e.clientHeight, requestAnimationFrame(() => {
      e.style.setProperty("height", "0px"), e.style.setProperty("padding", "0 1rem 0"), e.style.setProperty(
        "transition",
        "height 0.25s cubic-bezier(0.65, 0.05, 0.36, 1), padding 0.25s cubic-bezier(0.65, 0.05, 0.36, 1)"
      );
    }))), this.collapsed ? (e.style.setProperty(
      "height",
      `${this.componentHeight}px`
    ), requestAnimationFrame(() => {
      e.style.setProperty("height", "0px"), e.style.setProperty("padding", "0 1rem 0");
    })) : (e.style.setProperty("height", "0px"), e.style.setProperty("padding", "0 1rem 0"), requestAnimationFrame(() => {
      e.style.setProperty(
        "height",
        `${this.componentHeight}px`
      ), e.style.setProperty("padding", "0.125rem 1rem 1rem");
    })), this.setFlexAfterTransition();
  }
  onHeaderClick() {
    this.fixed || (this.collapsed = !this.collapsed, this.animateHeader());
  }
  handelSlotChange(t) {
    t.target.assignedElements({ flatten: true }).forEach((e, n) => {
      const s = n * 0.05;
      e.style.setProperty("transition-delay", `${s}s`);
    });
  }
  handlePointerEnter() {
    const t = this.renderRoot.querySelector(".expand-icon");
    this.collapsed ? t == null || t.style.setProperty("animation", "collapseAnim 0.5s") : t == null || t.style.setProperty("animation", "expandAnim 0.5s");
  }
  handlePointerLeave() {
    const t = this.renderRoot.querySelector(".expand-icon");
    t == null || t.style.setProperty("animation", "none");
  }
  render() {
    const t = this.label || this.icon || this.name || this.fixed, e = h`<svg
      xmlns="http://www.w3.org/2000/svg"
      height="1.125rem"
      viewBox="0 0 24 24"
      width="1.125rem"
      class="expand-icon"
    >
      <path d="M0 0h24v24H0z" fill="none" />
      <path d="M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z" />
    </svg>`, n = h`
      <div
        class="header"
        title=${this.label ?? ""}
        @pointerenter=${this.handlePointerEnter}
        @pointerleave=${this.handlePointerLeave}
        @click=${this.onHeaderClick}
      >
        ${this.label || this.icon || this.name ? h`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        ${this.fixed ? null : e}
      </div>
    `;
    return h`
      <div class="parent">
        ${t ? n : null}
        <div class="components" style="flex: 1;">
          <div>
            <slot @slotchange=${this.handelSlotChange}></slot>
          </div>
        </div>
      </div>
    `;
  }
};
er.styles = [
  Tt.scrollbar,
  O`
      :host {
        display: block;
        pointer-events: auto;
      }

      :host .parent {
        display: flex;
        flex-direction: column;
        height: 100%;
      }

      :host(:not([fixed])) .header:hover {
        --bim-label--c: var(--bim-ui_accent-base);
        color: var(--bim-ui_accent-base);
        cursor: pointer;
      }

      :host(:not([fixed])) .header:hover .expand-icon {
        fill: var(--bim-ui_accent-base);
      }

      .header {
        --bim-label--fz: var(--bim-ui_size-sm);
        --bim-label--c: var(
          --bim-panel-section_hc,
          var(--bim-ui_bg-contrast-80)
        );
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        height: 1.5rem;
        padding: 0.75rem 1rem;
      }

      .expand-icon {
        fill: var(--bim-ui_bg-contrast-80);
        transition: transform 0.2s;
      }

      :host([collapsed]) .expand-icon {
        transform: rotateZ(-180deg);
      }

      .title {
        display: flex;
        align-items: center;
        column-gap: 0.5rem;
      }

      .title p {
        font-size: var(--bim-ui_size-sm);
      }

      .components {
        display: flex;
        flex-direction: column;
        overflow: hidden;
        row-gap: 0.75rem;
        padding: 0 1rem 1rem;
        box-sizing: border-box;
        transition:
          height 0.25s cubic-bezier(0.65, 0.05, 0.36, 1),
          padding 0.25s cubic-bezier(0.65, 0.05, 0.36, 1);
      }

      .components > div {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        flex: 1;
        overflow: auto;
      }

      :host(:not([icon]):not([label])) .components {
        padding: 1rem;
      }

      :host(:not([fixed])[collapsed]) .components {
        padding: 0 1rem 0;
        height: 0px;
      }

      bim-label {
        pointer-events: none;
      }

      ::slotted(*) {
        transition:
          transform 0.25s cubic-bezier(0.65, 0.05, 0.36, 1),
          opacity 0.25s cubic-bezier(0.65, 0.05, 0.36, 1);
      }

      :host(:not([fixed])[collapsed]) ::slotted(*) {
        transform: translateX(-20%);
        opacity: 0;
      }

      @keyframes expandAnim {
        0%,
        100% {
          transform: translateY(0%);
        }
        25% {
          transform: translateY(-30%);
        }
        50% {
          transform: translateY(10%);
        }
        75% {
          transform: translateY(-30%);
        }
      }

      @keyframes collapseAnim {
        0%,
        100% {
          transform: translateY(0%) rotateZ(-180deg);
        }
        25% {
          transform: translateY(30%) rotateZ(-180deg);
        }
        50% {
          transform: translateY(-10%) rotateZ(-180deg);
        }
        75% {
          transform: translateY(30%) rotateZ(-180deg);
        }
      }
    `
];
var de = er;
We([
  m({ type: String, reflect: true })
], de.prototype, "icon");
We([
  m({ type: String, reflect: true })
], de.prototype, "label");
We([
  m({ type: String, reflect: true })
], de.prototype, "name");
We([
  m({ type: Boolean, reflect: true })
], de.prototype, "fixed");
We([
  m({ type: Boolean, reflect: true })
], de.prototype, "collapsed");
var gd = Object.defineProperty;
var Ge = (i, t, e, n) => {
  for (var s = void 0, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = r(t, e, s) || s);
  return s && gd(t, e, s), s;
};
var ir = class extends T {
  constructor() {
    super(...arguments), this.vertical = false, this.onValueChange = new Event("change"), this._canEmitEvents = false, this._value = document.createElement("bim-option"), this.onOptionClick = (t) => {
      this._value = t.target, this.setAnimatedBackgound(), this.dispatchEvent(this.onValueChange);
      for (const e of this.children)
        e instanceof j && (e.checked = e === t.target);
    };
  }
  get _options() {
    return [...this.querySelectorAll("bim-option")];
  }
  /**
   * Sets the value of the selector.
   * It finds the matching option based on the provided value and sets it as the selected option.
   * If no matching option is found, it does nothing.
   *
   * @param value - The value to set for the selector.
   */
  set value(t) {
    const e = this.findOption(t);
    if (e) {
      for (const n of this._options)
        n.checked = n === e;
      this._value = e, this.setAnimatedBackgound(), this._canEmitEvents && this.dispatchEvent(this.onValueChange);
    }
  }
  get value() {
    return this._value.value;
  }
  onSlotChange(t) {
    const e = t.target.assignedElements();
    for (const n of e)
      n instanceof j && (n.noMark = true, n.removeEventListener("click", this.onOptionClick), n.addEventListener("click", this.onOptionClick));
  }
  findOption(t) {
    return this._options.find((e) => e instanceof j ? e.label === t || e.value === t : false);
  }
  doubleRequestAnimationFrames(t) {
    requestAnimationFrame(() => requestAnimationFrame(t));
  }
  setAnimatedBackgound(t = false) {
    const e = this.renderRoot.querySelector(
      ".animated-background"
    ), n = this._value;
    requestAnimationFrame(() => {
      var s, o, r, a;
      const l = (a = (r = (o = (s = n == null ? void 0 : n.parentElement) == null ? void 0 : s.shadowRoot) == null ? void 0 : o.querySelector("bim-input")) == null ? void 0 : r.shadowRoot) == null ? void 0 : a.querySelector(".input"), c = {
        width: n == null ? void 0 : n.clientWidth,
        height: n == null ? void 0 : n.clientHeight,
        top: ((n == null ? void 0 : n.offsetTop) ?? 0) - ((l == null ? void 0 : l.offsetTop) ?? 0),
        left: ((n == null ? void 0 : n.offsetLeft) ?? 0) - ((l == null ? void 0 : l.offsetLeft) ?? 0)
      };
      e == null || e.style.setProperty("width", `${c.width}px`), e == null || e.style.setProperty("height", `${c.height}px`), e == null || e.style.setProperty("top", `${c.top}px`), e == null || e.style.setProperty("left", `${c.left}px`);
    }), t && this.doubleRequestAnimationFrames(() => {
      const s = "ease";
      e == null || e.style.setProperty(
        "transition",
        `width ${0.3}s ${s}, height ${0.3}s ${s}, top ${0.3}s ${s}, left ${0.3}s ${s}`
      );
    });
  }
  firstUpdated() {
    const t = [...this.children].find(
      (e) => e instanceof j && e.checked
    );
    t && (this._value = t), window.addEventListener("load", () => {
      this.setAnimatedBackgound(true);
    }), new ResizeObserver(() => {
      this.setAnimatedBackgound();
    }).observe(this);
  }
  render() {
    return h`
      <bim-input
        .vertical=${this.vertical}
        .label=${this.label}
        .icon=${this.icon}
      >
        <div class="animated-background"></div>
        <slot @slotchange=${this.onSlotChange}></slot>
      </bim-input>
    `;
  }
};
ir.styles = O`
    :host {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
      --bim-input--g: 0;
      --bim-option--jc: center;
      flex: 1;
      display: block;
    }

    ::slotted(bim-option) {
      position: relative;
      border-radius: 0;
      overflow: hidden;
      min-width: min-content;
      min-height: min-content;
      transition: background-color 0.2s;
    }

    .animated-background {
      position: absolute;
      background: var(--bim-ui_main-base);
      width: 0;
      height: 0;
      top: 0;
      left: 0;
    }

    ::slotted(bim-option[checked]) {
      --bim-label--c: var(--bim-ui_main-contrast);
    }

    ::slotted(bim-option:not([checked]):hover) {
      background-color: #0003;
    }
  `;
var ue = ir;
Ge([
  m({ type: String, reflect: true })
], ue.prototype, "name");
Ge([
  m({ type: String, reflect: true })
], ue.prototype, "icon");
Ge([
  m({ type: String, reflect: true })
], ue.prototype, "label");
Ge([
  m({ type: Boolean, reflect: true })
], ue.prototype, "vertical");
Ge([
  ae()
], ue.prototype, "_value");
var vd = () => h`
    <style>
      div {
        display: flex;
        gap: 0.375rem;
        border-radius: 0.25rem;
        min-height: 1.25rem;
      }

      [data-type="row"] {
        background-color: var(--bim-ui_bg-contrast-10);
        animation: row-loading 1s linear infinite alternate;
        padding: 0.5rem;
      }

      [data-type="cell"] {
        background-color: var(--bim-ui_bg-contrast-20);
        flex: 0.25;
      }

      @keyframes row-loading {
        0% {
          background-color: var(--bim-ui_bg-contrast-10);
        }
        100% {
          background-color: var(--bim-ui_bg-contrast-20);
        }
      }
    </style>
    <div style="display: flex; flex-direction: column;">
      <div data-type="row" style="gap: 2rem">
        <div data-type="cell" style="flex: 1"></div>
        <div data-type="cell" style="flex: 2"></div>
        <div data-type="cell" style="flex: 1"></div>
        <div data-type="cell" style="flex: 0.5"></div>
      </div>
      <div style="display: flex;">
        <div data-type="row" style="flex: 1">
          <div data-type="cell" style="flex: 0.5"></div>
        </div>
        <div data-type="row" style="flex: 2">
          <div data-type="cell" style="flex: 0.75"></div>
        </div>
        <div data-type="row" style="flex: 1">
          <div data-type="cell"></div>
        </div>
        <div data-type="row" style="flex: 0.5">
          <div data-type="cell" style="flex: 0.75"></div>
        </div>
      </div>
      <div style="display: flex;">
        <div data-type="row" style="flex: 1">
          <div data-type="cell" style="flex: 0.75"></div>
        </div>
        <div data-type="row" style="flex: 2">
          <div data-type="cell"></div>
        </div>
        <div data-type="row" style="flex: 1">
          <div data-type="cell" style="flex: 0.5"></div>
        </div>
        <div data-type="row" style="flex: 0.5">
          <div data-type="cell" style="flex: 0.5"></div>
        </div>
      </div>
      <div style="display: flex;">
        <div data-type="row" style="flex: 1">
          <div data-type="cell"></div>
        </div>
        <div data-type="row" style="flex: 2">
          <div data-type="cell" style="flex: 0.5"></div>
        </div>
        <div data-type="row" style="flex: 1">
          <div data-type="cell" style="flex: 0.75"></div>
        </div>
        <div data-type="row" style="flex: 0.5">
          <div data-type="cell" style="flex: 0.7s5"></div>
        </div>
      </div>
    </div>
  `;
var yd = () => h`
    <style>
      .loader {
        grid-area: Processing;
        position: relative;
        padding: 0.125rem;
      }
      .loader:before {
        content: "";
        position: absolute;
      }
      .loader .loaderBar {
        position: absolute;
        top: 0;
        right: 100%;
        bottom: 0;
        left: 0;
        background: var(--bim-ui_main-base);
        /* width: 25%; */
        width: 0;
        animation: borealisBar 2s linear infinite;
      }

      @keyframes borealisBar {
        0% {
          left: 0%;
          right: 100%;
          width: 0%;
        }
        10% {
          left: 0%;
          right: 75%;
          width: 25%;
        }
        90% {
          right: 0%;
          left: 75%;
          width: 25%;
        }
        100% {
          left: 100%;
          right: 0%;
          width: 0%;
        }
      }
    </style>
    <div class="loader">
      <div class="loaderBar"></div>
    </div>
  `;
var _d = Object.defineProperty;
var wd = (i, t, e, n) => {
  for (var s = void 0, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = r(t, e, s) || s);
  return s && _d(t, e, s), s;
};
var nr = class extends T {
  constructor() {
    super(...arguments), this.column = "", this.columnIndex = 0, this.rowData = {};
  }
  get data() {
    return this.column ? this.rowData[this.column] : null;
  }
  render() {
    return h`
      <style>
        :host {
          grid-area: ${this.column ?? "unset"};
        }
      </style>
      <slot></slot>
    `;
  }
};
nr.styles = O`
    :host {
      padding: 0.375rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    :host([data-column-index="0"]) {
      justify-content: normal;
    }

    :host([data-column-index="0"]:not([data-cell-header]))
      ::slotted(bim-label) {
      text-align: left;
    }

    ::slotted(*) {
      --bim-input--bgc: transparent;
      --bim-input--olc: var(--bim-ui_bg-contrast-20);
      --bim-input--olw: 1px;
    }

    ::slotted(bim-input) {
      --bim-input--olw: 0;
    }

    ::slotted(bim-label) {
      white-space: normal;
      text-align: center;
    }
  `;
var sr = nr;
wd([
  m({ type: String, reflect: true })
], sr.prototype, "column");
var or = class extends T {
  constructor() {
    super(...arguments), this._groups = [], this.group = this.closest("bim-table-group"), this._data = [], this.table = this.closest("bim-table");
  }
  get data() {
    var t;
    return ((t = this.group) == null ? void 0 : t.data.children) ?? this._data;
  }
  set data(t) {
    this._data = t;
  }
  render() {
    return this._groups = [], h`
      <slot></slot>
      ${this.data.map((t) => {
      const e = document.createElement(
        "bim-table-group"
      );
      return this._groups.push(e), e.table = this.table, e.data = t, e;
    })}
    `;
  }
};
or.styles = O`
    :host {
      --bim-button--bgc: transparent;
      position: relative;
      display: block;
      overflow: hidden;
      grid-area: Children;
    }

    :host([hidden]) {
      height: 0;
      opacity: 0;
    }

    ::slotted(.branch.branch-vertical) {
      top: 0;
      bottom: 1.125rem;
    }
  `;
var $d = or;
var xd = Object.defineProperty;
var Cd = (i, t, e, n) => {
  for (var s = void 0, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = r(t, e, s) || s);
  return s && xd(t, e, s), s;
};
var rr = class extends T {
  constructor() {
    super(...arguments), this.childrenHidden = true, this.table = this.closest("bim-table"), this.data = { data: {} };
  }
  get rowElement() {
    const t = this.shadowRoot;
    return t ? t.querySelector("bim-table-row") : null;
  }
  get childrenElement() {
    const t = this.shadowRoot;
    return t ? t.querySelector("bim-table-children") : null;
  }
  get _isChildrenEmpty() {
    return !(this.data.children && this.data.children.length !== 0);
  }
  connectedCallback() {
    super.connectedCallback(), this.table && this.table.expanded ? this.childrenHidden = false : this.childrenHidden = true;
  }
  toggleChildren(t) {
    this.childrenHidden = typeof t > "u" ? !this.childrenHidden : !t, this.animateTableChildren(true);
  }
  animateTableChildren(t = true) {
    if (!t) {
      requestAnimationFrame(() => {
        var r;
        const a = this.renderRoot.querySelector(".caret"), l = this.renderRoot.querySelector(
          ".branch-vertical"
        ), c = (r = this.renderRoot.querySelector("bim-table-children")) == null ? void 0 : r.querySelector(".branch-vertical");
        a.style.setProperty(
          "transform",
          `translateY(-50%) rotate(${this.childrenHidden ? "0" : "90"}deg)`
        ), l.style.setProperty(
          "transform",
          `scaleY(${this.childrenHidden ? "0" : "1"})`
        ), c == null || c.style.setProperty(
          "transform",
          `scaleY(${this.childrenHidden ? "0" : "1"})`
        );
      });
      return;
    }
    const e = 500, n = 0, s = 200, o = 350;
    requestAnimationFrame(() => {
      var r;
      const a = this.renderRoot.querySelector("bim-table-children"), l = this.renderRoot.querySelector(".caret"), c = this.renderRoot.querySelector(
        ".branch-vertical"
      ), d = (r = this.renderRoot.querySelector("bim-table-children")) == null ? void 0 : r.querySelector(".branch-vertical"), u = () => {
        const g = a == null ? void 0 : a.renderRoot.querySelectorAll("bim-table-group");
        g == null || g.forEach(($, y) => {
          $.style.setProperty("opacity", "0"), $.style.setProperty("left", "-30px");
          const _ = [
            {
              opacity: "0",
              left: "-30px"
            },
            {
              opacity: "1",
              left: "0"
            }
          ];
          $.animate(_, {
            duration: e / 2,
            delay: 50 + y * n,
            easing: "cubic-bezier(0.65, 0.05, 0.36, 1)",
            fill: "forwards"
          });
        });
      }, p = () => {
        const g = [
          { transform: "translateY(-50%) rotate(90deg)" },
          { transform: "translateY(-50%) rotate(0deg)" }
        ];
        l == null || l.animate(g, {
          duration: o,
          easing: "cubic-bezier(0.68, -0.55, 0.27, 1.55)",
          fill: "forwards",
          direction: this.childrenHidden ? "normal" : "reverse"
        });
      }, f = () => {
        const g = [
          { transform: "scaleY(1)" },
          { transform: "scaleY(0)" }
        ];
        c == null || c.animate(g, {
          duration: s,
          easing: "cubic-bezier(0.4, 0, 0.2, 1)",
          delay: n,
          fill: "forwards",
          direction: this.childrenHidden ? "normal" : "reverse"
        });
      }, b = () => {
        var g;
        const $ = (g = this.renderRoot.querySelector("bim-table-row")) == null ? void 0 : g.querySelector(".branch-horizontal");
        if ($) {
          $.style.setProperty("transform-origin", "center right");
          const y = [
            { transform: "scaleX(0)" },
            { transform: "scaleX(1)" }
          ];
          $.animate(y, {
            duration: s,
            easing: "cubic-bezier(0.4, 0, 0.2, 1)",
            fill: "forwards",
            direction: this.childrenHidden ? "normal" : "reverse"
          });
        }
      }, v = () => {
        const g = [
          { transform: "scaleY(0)" },
          { transform: "scaleY(1)" }
        ];
        d == null || d.animate(g, {
          duration: s * 1.2,
          easing: "cubic-bezier(0.4, 0, 0.2, 1)",
          fill: "forwards",
          delay: (n + s) * 0.7
        });
      };
      u(), p(), f(), b(), v();
    });
  }
  firstUpdated() {
    this.renderRoot.querySelectorAll(".caret").forEach((t) => {
      var e, n, s;
      if (!this.childrenHidden) {
        t.style.setProperty(
          "transform",
          "translateY(-50%) rotate(90deg)"
        );
        const o = (e = t.parentElement) == null ? void 0 : e.querySelector(
          ".branch-horizontal"
        );
        o && o.style.setProperty("transform", "scaleX(0)");
        const r = (s = (n = t.parentElement) == null ? void 0 : n.parentElement) == null ? void 0 : s.querySelectorAll(
          ".branch-vertical"
        );
        r == null || r.forEach((a) => {
          a.style.setProperty("transform", "scaleY(1)");
        });
      }
    });
  }
  render() {
    if (!this.table)
      throw new Error("TableGroup: parent table wasn't found!");
    const t = this.table.getGroupIndentation(this.data) ?? 0, e = h`
      ${this.table.noIndentation ? null : h`
            <style>
              .branch-vertical {
                left: ${t + (this.table.selectableRows ? 1.9375 : 0.5625)}rem;
              }
            </style>
            <div class="branch branch-vertical"></div>
          `}
    `;
    let n = null;
    this.table.noIndentation || (n = document.createElement("div"), n.classList.add("branch", "branch-horizontal"), n.style.left = `${t - 1 + (this.table.selectableRows ? 2.05 : 0.5625)}rem`);
    let s = null;
    if (!this.table.noIndentation) {
      s = document.createElement("div");
      const a = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "svg"
      );
      if (a.setAttribute("height", "9.9"), a.setAttribute("width", "7.5"), a.setAttribute("viewBox", "0 0 4.6666672 7.7"), this.table.noCarets) {
        const l = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "circle"
        );
        l.setAttribute("cx", "2.3333336"), l.setAttribute("cy", "3.85"), l.setAttribute("r", "2.5"), a.append(l);
      } else {
        const l = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        l.setAttribute(
          "d",
          "m 1.7470835,6.9583848 2.5899999,-2.59 c 0.39,-0.39 0.39,-1.02 0,-1.41 L 1.7470835,0.36838483 c -0.63,-0.62000003 -1.71000005,-0.18 -1.71000005,0.70999997 v 5.17 c 0,0.9 1.08000005,1.34 1.71000005,0.71 z"
        ), a.append(l), s.style.cursor = "pointer", s.addEventListener("click", (c) => {
          c.stopPropagation(), this.toggleChildren();
        });
      }
      s.classList.add("caret"), s.style.left = `${(this.table.selectableRows ? 1.5 : 0.125) + t}rem`, s.append(a);
    }
    const o = document.createElement("bim-table-row");
    if (!this._isChildrenEmpty) {
      const a = document.createDocumentFragment();
      oe(e, a), o.append(a);
    }
    o.table = this.table, o.group = this, this.table.dispatchEvent(
      new CustomEvent("rowcreated", {
        detail: { row: o }
      })
    ), s && !this._isChildrenEmpty && o.append(s), t !== 0 && n && o.append(n);
    let r;
    if (!this._isChildrenEmpty && !this.childrenHidden) {
      r = document.createElement(
        "bim-table-children"
      ), r.table = this.table, r.group = this;
      const a = document.createDocumentFragment();
      oe(e, a), r.append(a), this.animateTableChildren();
    }
    return h`<div class="parent">${o} ${r}</div>`;
  }
};
rr.styles = O`
    :host {
      position: relative;
    }

    .parent {
      display: grid;
      grid-template-areas: "Data" "Children";
    }

    .branch {
      position: absolute;
      z-index: 1;
    }

    .branch-vertical {
      border-left: 1px dotted var(--bim-ui_bg-contrast-40);
      transform-origin: top center;
      transform: scaleY(0);
    }

    .branch-horizontal {
      top: 50%;
      width: 1rem;
      border-bottom: 1px dotted var(--bim-ui_bg-contrast-40);
    }

    .branch-horizontal {
      transform-origin: center left;
    }

    .caret {
      position: absolute;
      z-index: 2;
      transform: translateY(-50%) rotate(0deg);
      top: 50%;
      display: flex;
      width: 0.95rem;
      height: 0.95rem;
      justify-content: center;
      align-items: center;
    }

    .caret svg {
      fill: var(--bim-ui_bg-contrast-60);
    }
  `;
var ar = rr;
Cd([
  m({ type: Boolean, attribute: "children-hidden", reflect: true })
], ar.prototype, "childrenHidden");
var Ad = Object.defineProperty;
var Xe = (i, t, e, n) => {
  for (var s = void 0, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = r(t, e, s) || s);
  return s && Ad(t, e, s), s;
};
var lr = class extends T {
  constructor() {
    super(...arguments), this.selected = false, this.columns = [], this.hiddenColumns = [], this.group = this.closest("bim-table-group"), this._data = {}, this.isHeader = false, this.table = this.closest("bim-table"), this.onTableColumnsChange = () => {
      this.table && (this.columns = this.table.columns);
    }, this.onTableColumnsHidden = () => {
      this.table && (this.hiddenColumns = this.table.hiddenColumns);
    }, this._observer = new IntersectionObserver(
      (t) => {
        this._intersecting = t[0].isIntersecting;
      },
      { rootMargin: "36px" }
    );
  }
  get groupData() {
    var t;
    return (t = this.group) == null ? void 0 : t.data;
  }
  get data() {
    var t;
    return ((t = this.group) == null ? void 0 : t.data.data) ?? this._data;
  }
  set data(t) {
    this._data = t;
  }
  get _columnNames() {
    return this.columns.filter(
      (t) => !this.hiddenColumns.includes(t.name)
    ).map((t) => t.name);
  }
  get _columnWidths() {
    return this.columns.filter(
      (t) => !this.hiddenColumns.includes(t.name)
    ).map((t) => t.width);
  }
  get _isSelected() {
    var t;
    return (t = this.table) == null ? void 0 : t.selection.has(this.data);
  }
  onSelectionChange(t) {
    if (!this.table)
      return;
    const e = t.target;
    this.selected = e.value, e.value ? (this.table.selection.add(this.data), this.table.dispatchEvent(
      new CustomEvent("rowselected", {
        detail: {
          data: this.data
        }
      })
    )) : (this.table.selection.delete(this.data), this.table.dispatchEvent(
      new CustomEvent("rowdeselected", {
        detail: {
          data: this.data
        }
      })
    ));
  }
  connectedCallback() {
    super.connectedCallback(), this._observer.observe(this), this.table && (this.columns = this.table.columns, this.hiddenColumns = this.table.hiddenColumns, this.table.addEventListener("columnschange", this.onTableColumnsChange), this.table.addEventListener("columnshidden", this.onTableColumnsHidden), this.toggleAttribute("selected", this._isSelected));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._observer.unobserve(this), this.table && (this.columns = [], this.hiddenColumns = [], this.table.removeEventListener("columnschange", this.onTableColumnsChange), this.table.removeEventListener("columnshidden", this.onTableColumnsHidden), this.toggleAttribute("selected", false));
  }
  compute() {
    if (!this.table)
      throw new Error("TableRow: parent table wasn't found!");
    const t = this.table.getRowIndentation(this.data) ?? 0, e = this.isHeader ? this.data : this.table.applyDataTransform(this.group) ?? this.data, n = [];
    for (const s in e) {
      if (this.hiddenColumns.includes(s))
        continue;
      const o = e[s];
      let r;
      if (typeof o == "string" || typeof o == "boolean" || typeof o == "number" ? (r = document.createElement("bim-label"), r.textContent = String(o)) : o instanceof HTMLElement ? r = o : (r = document.createDocumentFragment(), oe(o, r)), !r)
        continue;
      const a = document.createElement("bim-table-cell");
      a.append(r), a.column = s, this._columnNames.indexOf(s) === 0 && (a.style.marginLeft = `${this.table.noIndentation ? 0 : t + 0.75}rem`);
      const l = this._columnNames.indexOf(s);
      a.setAttribute("data-column-index", String(l)), a.toggleAttribute(
        "data-no-indentation",
        l === 0 && this.table.noIndentation
      ), a.toggleAttribute("data-cell-header", this.isHeader), a.rowData = this.data, this.table.dispatchEvent(
        new CustomEvent("cellcreated", {
          detail: { cell: a }
        })
      ), n.push(a);
    }
    return this.style.gridTemplateAreas = `"${this.table.selectableRows ? "Selection" : ""} ${this._columnNames.join(" ")}"`, this.style.gridTemplateColumns = `${this.table.selectableRows ? "1.6rem" : ""} ${this._columnWidths.join(" ")}`, h`
      ${!this.isHeader && this.table.selectableRows ? h`<bim-checkbox
            @change=${this.onSelectionChange}
            .checked=${this._isSelected}
            style="align-self: center; justify-self: center"
          ></bim-checkbox>` : null}
      ${n}
      <slot></slot>
    `;
  }
  render() {
    return h`${this._intersecting ? this.compute() : h``}`;
  }
};
lr.styles = O`
    :host {
      position: relative;
      grid-area: Data;
      display: grid;
      min-height: 2.25rem;
      transition: all 0.15s;
    }

    ::slotted(.branch.branch-vertical) {
      top: 50%;
      bottom: 0;
    }

    :host([selected]) {
      background-color: color-mix(
        in lab,
        var(--bim-ui_bg-contrast-20) 30%,
        var(--bim-ui_main-base) 10%
      );
    }
  `;
var he = lr;
Xe([
  m({ type: Boolean, reflect: true })
], he.prototype, "selected");
Xe([
  m({ attribute: false })
], he.prototype, "columns");
Xe([
  m({ attribute: false })
], he.prototype, "hiddenColumns");
Xe([
  m({ type: Boolean, attribute: "is-header", reflect: true })
], he.prototype, "isHeader");
Xe([
  ae()
], he.prototype, "_intersecting");
var Sd = Object.defineProperty;
var kd = Object.getOwnPropertyDescriptor;
var st = (i, t, e, n) => {
  for (var s = n > 1 ? void 0 : n ? kd(t, e) : t, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = (n ? r(t, e, s) : r(s)) || s);
  return n && s && Sd(t, e, s), s;
};
var cr = class extends T {
  constructor() {
    super(...arguments), this._filteredData = [], this.headersHidden = false, this.minColWidth = "4rem", this._columns = [], this._textDelimiters = {
      comma: ",",
      tab: "	"
    }, this._queryString = null, this._data = [], this.expanded = false, this.preserveStructureOnFilter = false, this.indentationInText = false, this.dataTransform = {}, this.selectableRows = false, this.selection = /* @__PURE__ */ new Set(), this.noIndentation = false, this.noCarets = false, this.loading = false, this._errorLoading = false, this._onColumnsHidden = new Event("columnshidden"), this._hiddenColumns = [], this._stringFilterFunction = (t, e) => Object.values(e.data).some((n) => String(n).toLowerCase().includes(t.toLowerCase())), this._queryFilterFunction = (t, e) => {
      let n = false;
      const s = on(t) ?? [];
      for (const o of s) {
        if ("queries" in o) {
          n = false;
          break;
        }
        const { condition: r, value: a } = o;
        let { key: l } = o;
        if (l.startsWith("[") && l.endsWith("]")) {
          const c = l.replace("[", "").replace("]", "");
          l = c, n = Object.keys(e.data).filter((d) => d.includes(c)).map(
            (d) => Ps(e.data[d], r, a)
          ).some((d) => d);
        } else
          n = Ps(e.data[l], r, a);
        if (!n)
          break;
      }
      return n;
    };
  }
  set columns(t) {
    const e = [];
    for (const n of t) {
      const s = typeof n == "string" ? { name: n, width: `minmax(${this.minColWidth}, 1fr)` } : n;
      e.push(s);
    }
    this._columns = e, this.computeMissingColumns(this.data), this.dispatchEvent(new Event("columnschange"));
  }
  get columns() {
    return this._columns;
  }
  get _headerRowData() {
    const t = {};
    for (const e of this.columns) {
      const { name: n } = e;
      t[n] = String(n);
    }
    return t;
  }
  /**
   * Getter for the `value` property.
   * Returns the filtered data if a search string is provided, otherwise returns the original data.
   *
   * @example
   * ```typescript
   * const tableValue = table.value;
   * console.log(tableValue); // Output: The filtered or original data.
   * ```
   */
  get value() {
    return this._filteredData;
  }
  /**
   * Sets the search string for filtering the table data.
   * This property allows you to filter the table data based on a search string.
   * If a search string is provided, the table will only display rows that match the search criteria.
   * The search criteria can be a simple string or a complex query.
   * If a simple string is provided, the table will filter rows based on the string's presence in any column.
   * If a complex query is provided, the table will filter rows based on the query's conditions and values.
   *
   * @example Simple Query
   * ```typescript
   * table.queryString = "example";
   * ```
   *
   * @example Complex Query
   * ```typescript
   * table.queryString = "column1="Jhon Doe" & column2=20";
   * ```
   */
  set queryString(t) {
    this.toggleAttribute("data-processing", true), this._queryString = t && t.trim() !== "" ? t.trim() : null, this.updateFilteredData(), this.toggleAttribute("data-processing", false);
  }
  get queryString() {
    return this._queryString;
  }
  set data(t) {
    this._data = t, this.updateFilteredData(), this.computeMissingColumns(t) && (this.columns = this._columns);
  }
  get data() {
    return this._data;
  }
  get dataAsync() {
    return new Promise((t) => {
      setTimeout(() => {
        t(this.data);
      });
    });
  }
  set hiddenColumns(t) {
    this._hiddenColumns = t, setTimeout(() => {
      this.dispatchEvent(this._onColumnsHidden);
    });
  }
  get hiddenColumns() {
    return this._hiddenColumns;
  }
  updateFilteredData() {
    this.queryString ? (on(this.queryString) ? (this.filterFunction = this._queryFilterFunction, this._filteredData = this.filter(this.queryString)) : (this.filterFunction = this._stringFilterFunction, this._filteredData = this.filter(this.queryString)), this.preserveStructureOnFilter && (this._expandedBeforeFilter === void 0 && (this._expandedBeforeFilter = this.expanded), this.expanded = true)) : (this.preserveStructureOnFilter && this._expandedBeforeFilter !== void 0 && (this.expanded = this._expandedBeforeFilter, this._expandedBeforeFilter = void 0), this._filteredData = this.data);
  }
  computeMissingColumns(t) {
    let e = false;
    for (const n of t) {
      const { children: s, data: o } = n;
      for (const r in o)
        this._columns.map((a) => typeof a == "string" ? a : a.name).includes(r) || (this._columns.push({
          name: r,
          width: `minmax(${this.minColWidth}, 1fr)`
        }), e = true);
      if (s) {
        const r = this.computeMissingColumns(s);
        r && !e && (e = r);
      }
    }
    return e;
  }
  generateText(t = "comma", e = this.value, n = "", s = true) {
    const o = this._textDelimiters[t];
    let r = "";
    const a = this.columns.map((l) => l.name);
    if (s) {
      this.indentationInText && (r += `Indentation${o}`);
      const l = `${a.join(o)}
`;
      r += l;
    }
    for (const [l, c] of e.entries()) {
      const { data: d, children: u } = c, p = this.indentationInText ? `${n}${l + 1}${o}` : "", f = a.map((v) => d[v] ?? ""), b = `${p}${f.join(o)}
`;
      r += b, u && (r += this.generateText(
        t,
        c.children,
        `${n}${l + 1}.`,
        false
      ));
    }
    return r;
  }
  /**
   * A getter function that generates a CSV (Comma Separated Values) representation of the table data.
   *
   * @returns A string containing the CSV representation of the table data.
   *
   * @example
   * ```typescript
   * const csvData = table.csv;
   * console.log(csvData); // Output: "Column 1,Column 2\nValue 1,Value 2\nValue 3,Value 4"
   * ```
   */
  get csv() {
    return this.generateText("comma");
  }
  /**
   * A getter function that generates a Tab Separated Values (TSV) representation of the table data.
   *
   * @returns A string containing the TSV representation of the table data.
   *
   * @example
   * ```typescript
   * const tsvData = table.tsv;
   * console.log(tsvData); // Output: "Column 1\tColumn 2\nValue 1\tValue 2\nValue 3\tValue 4"
   * ```
   */
  get tsv() {
    return this.generateText("tab");
  }
  applyDataTransform(t) {
    const e = {};
    if (!t)
      return e;
    const { data: n } = t.data;
    for (const o of Object.keys(this.dataTransform)) {
      const r = this.columns.find((a) => a.name === o);
      r && r.forceDataTransform && (o in n || (n[o] = ""));
    }
    const s = n;
    for (const o in s) {
      const r = this.dataTransform[o];
      r ? e[o] = r(s[o], n, t) : e[o] = n[o];
    }
    return e;
  }
  /**
   * The `downloadData` method is used to download the table data in different formats.
   *
   * @param fileName - The name of the downloaded file. Default is "BIM Table Data".
   * @param format - The format of the downloaded file. Can be "json", "tsv", or "csv". Default is "json".
   *
   * @returns - This method does not return any value.
   *
   * @example
   * ```typescript
   * table.downloadData("MyTableData", "tsv");
   * ```
   */
  downloadData(t = "BIM Table Data", e = "json") {
    let n = null;
    if (e === "json" && (n = new File(
      [JSON.stringify(this.value, void 0, 2)],
      `${t}.json`
    )), e === "csv" && (n = new File([this.csv], `${t}.csv`)), e === "tsv" && (n = new File([this.tsv], `${t}.tsv`)), !n)
      return;
    const s = document.createElement("a");
    s.href = URL.createObjectURL(n), s.download = n.name, s.click(), URL.revokeObjectURL(s.href);
  }
  getRowIndentation(t, e = this.value, n = 0) {
    for (const s of e) {
      if (s.data === t)
        return n;
      if (s.children) {
        const o = this.getRowIndentation(
          t,
          s.children,
          n + 1
        );
        if (o !== null)
          return o;
      }
    }
    return null;
  }
  getGroupIndentation(t, e = this.value, n = 0) {
    for (const s of e) {
      if (s === t)
        return n;
      if (s.children) {
        const o = this.getGroupIndentation(
          t,
          s.children,
          n + 1
        );
        if (o !== null)
          return o;
      }
    }
    return null;
  }
  connectedCallback() {
    super.connectedCallback(), this.dispatchEvent(new Event("connected"));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.dispatchEvent(new Event("disconnected"));
  }
  /**
   * Asynchronously loads data into the table based on Table.loadFunction.
   * If the data is already available, just set it in Table.data.
   *
   * @param force - A boolean indicating whether to force loading even if the table already has data.
   *
   * @returns - A promise that resolves to a boolean indicating whether the data loading was successful.
   * If the promise resolves to `true`, the data loading was successful.
   * If the promise resolves to `false`, the data loading was not successful.
   *
   * @remarks - If the table already has data and `force` is `false`, the function resolves to `false` without making any changes.
   * If the table already has data and `force` is `true`, the existing data is discarded before loading the new data.
   * If an error occurs during data loading, the function sets the `errorLoadingMessage` property with the error message and resolves to `false`.
   */
  async loadData(t = false) {
    if (this._filteredData.length !== 0 && !t || !this.loadFunction)
      return false;
    this.loading = true;
    try {
      const e = await this.loadFunction();
      return this.data = e, this.loading = false, this._errorLoading = false, true;
    } catch (e) {
      if (this.loading = false, this._filteredData.length !== 0)
        return false;
      const n = this.querySelector("[slot='error-loading']"), s = n == null ? void 0 : n.querySelector(
        "[data-table-element='error-message']"
      );
      return e instanceof Error && s && e.message.trim() !== "" && (s.textContent = e.message), this._errorLoading = true, false;
    }
  }
  filter(t, e = this.filterFunction ?? this._stringFilterFunction, n = this.data) {
    const s = [];
    for (const o of n)
      if (e(t, o)) {
        if (this.preserveStructureOnFilter) {
          const r = { data: o.data };
          if (o.children) {
            const a = this.filter(
              t,
              e,
              o.children
            );
            a.length && (r.children = a);
          }
          s.push(r);
        } else if (s.push({ data: o.data }), o.children) {
          const r = this.filter(
            t,
            e,
            o.children
          );
          s.push(...r);
        }
      } else if (o.children) {
        const r = this.filter(
          t,
          e,
          o.children
        );
        this.preserveStructureOnFilter && r.length ? s.push({
          data: o.data,
          children: r
        }) : s.push(...r);
      }
    return s;
  }
  get _missingDataElement() {
    return this.querySelector("[slot='missing-data']");
  }
  render() {
    if (this.loading)
      return vd();
    if (this._errorLoading)
      return h`<slot name="error-loading"></slot>`;
    if (this._filteredData.length === 0 && this._missingDataElement)
      return h`<slot name="missing-data"></slot>`;
    const t = document.createElement("bim-table-row");
    t.table = this, t.isHeader = true, t.data = this._headerRowData, t.style.gridArea = "Header", t.style.position = "sticky", t.style.top = "0", t.style.zIndex = "5";
    const e = document.createElement(
      "bim-table-children"
    );
    return e.table = this, e.data = this.value, e.style.gridArea = "Body", e.style.backgroundColor = "transparent", h`
      <div class="parent">
        ${this.headersHidden ? null : t} ${yd()}
        <div style="overflow-x: hidden; grid-area: Body">${e}</div>
      </div>
    `;
  }
};
cr.styles = [
  Tt.scrollbar,
  O`
      :host {
        position: relative;
        overflow: auto;
        display: block;
        pointer-events: auto;
      }

      :host(:not([data-processing])) .loader {
        display: none;
      }

      .parent {
        display: grid;
        grid-template:
          "Header" auto
          "Processing" auto
          "Body" 1fr
          "Footer" auto;
        overflow: auto;
        height: 100%;
      }

      .parent > bim-table-row[is-header] {
        color: var(--bim-table_header--c, var(--bim-ui_bg-contrast-100));
        background-color: var(
          --bim-table_header--bgc,
          var(--bim-ui_bg-contrast-20)
        );
      }

      .controls {
        display: flex;
        gap: 0.375rem;
        flex-wrap: wrap;
        margin-bottom: 0.5rem;
      }
    `
];
var Z = cr;
st([
  ae()
], Z.prototype, "_filteredData", 2);
st([
  m({
    type: Boolean,
    attribute: "headers-hidden",
    reflect: true
  })
], Z.prototype, "headersHidden", 2);
st([
  m({ type: String, attribute: "min-col-width", reflect: true })
], Z.prototype, "minColWidth", 2);
st([
  m({ type: Array, attribute: false })
], Z.prototype, "columns", 1);
st([
  m({ type: Array, attribute: false })
], Z.prototype, "data", 1);
st([
  m({ type: Boolean, reflect: true })
], Z.prototype, "expanded", 2);
st([
  m({ type: Boolean, reflect: true, attribute: "selectable-rows" })
], Z.prototype, "selectableRows", 2);
st([
  m({ attribute: false })
], Z.prototype, "selection", 2);
st([
  m({ type: Boolean, attribute: "no-indentation", reflect: true })
], Z.prototype, "noIndentation", 2);
st([
  m({ type: Boolean, attribute: "no-carets", reflect: true })
], Z.prototype, "noCarets", 2);
st([
  m({ type: Boolean, reflect: true })
], Z.prototype, "loading", 2);
st([
  ae()
], Z.prototype, "_errorLoading", 2);
var Ed = Object.defineProperty;
var Td = Object.getOwnPropertyDescriptor;
var pe = (i, t, e, n) => {
  for (var s = n > 1 ? void 0 : n ? Td(t, e) : t, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = (n ? r(t, e, s) : r(s)) || s);
  return n && s && Ed(t, e, s), s;
};
var dr = class extends T {
  constructor() {
    super(...arguments), this._switchers = [], this.bottom = false, this.switchersHidden = false, this.floating = false, this.switchersFull = false, this.onTabHiddenChange = (t) => {
      const e = t.target;
      e instanceof G && !e.hidden && (e.removeEventListener("hiddenchange", this.onTabHiddenChange), this.tab = e.name, e.addEventListener("hiddenchange", this.onTabHiddenChange));
    };
  }
  set tab(t) {
    this._tab = t;
    const e = [...this.children], n = e.find(
      (s) => s instanceof G && s.name === t
    );
    for (const s of e) {
      if (!(s instanceof G))
        continue;
      s.hidden = n !== s;
      const o = this.getTabSwitcher(s.name);
      o && o.toggleAttribute("data-active", !s.hidden);
    }
    n || (this._tab = "hidden", this.setAttribute("tab", "hidden"));
  }
  get tab() {
    return this._tab;
  }
  getTabSwitcher(t) {
    return this._switchers.find(
      (e) => e.getAttribute("data-name") === t
    );
  }
  createSwitchers() {
    this._switchers = [];
    for (const t of this.children) {
      if (!(t instanceof G))
        continue;
      const e = document.createElement("div");
      e.addEventListener("click", () => {
        this.tab === t.name ? this.toggleAttribute("tab", false) : this.tab = t.name, this.setAnimatedBackgound();
      }), e.setAttribute("data-name", t.name), e.className = "switcher";
      const n = document.createElement("bim-label");
      n.textContent = t.label ?? null, n.icon = t.icon, e.append(n), this._switchers.push(e);
    }
  }
  updateSwitchers() {
    for (const t of this.children) {
      if (!(t instanceof G))
        continue;
      const e = this._switchers.find(
        (s) => s.getAttribute("data-name") === t.name
      );
      if (!e)
        continue;
      const n = e.querySelector("bim-label");
      n && (n.textContent = t.label ?? null, n.icon = t.icon);
    }
  }
  onSlotChange(t) {
    this.createSwitchers();
    const e = t.target.assignedElements(), n = e.find((s) => s instanceof G ? this.tab ? s.name === this.tab : !s.hidden : false);
    n && n instanceof G && (this.tab = n.name);
    for (const s of e) {
      if (!(s instanceof G)) {
        s.remove();
        continue;
      }
      s.removeEventListener("hiddenchange", this.onTabHiddenChange), n !== s && (s.hidden = true), s.addEventListener("hiddenchange", this.onTabHiddenChange);
    }
  }
  doubleRequestAnimationFrames(t) {
    requestAnimationFrame(() => requestAnimationFrame(t));
  }
  setAnimatedBackgound(t = false) {
    var e;
    const n = this.renderRoot.querySelector(
      ".animated-background"
    ), s = [
      ...((e = this.renderRoot.querySelector(".switchers")) == null ? void 0 : e.querySelectorAll(".switcher")) || []
    ].filter((o) => o.hasAttribute("data-active"))[0];
    requestAnimationFrame(() => {
      var o, r, a, l;
      const c = (l = (a = (r = (o = s == null ? void 0 : s.parentElement) == null ? void 0 : o.shadowRoot) == null ? void 0 : r.querySelector("bim-input")) == null ? void 0 : a.shadowRoot) == null ? void 0 : l.querySelector(".input"), d = {
        width: s == null ? void 0 : s.clientWidth,
        height: s == null ? void 0 : s.clientHeight,
        top: ((s == null ? void 0 : s.offsetTop) ?? 0) - ((c == null ? void 0 : c.offsetTop) ?? 0),
        left: ((s == null ? void 0 : s.offsetLeft) ?? 0) - ((c == null ? void 0 : c.offsetLeft) ?? 0)
      };
      s ? (n == null || n.style.setProperty("width", `${d.width}px`), n == null || n.style.setProperty("height", `${d.height}px`), n == null || n.style.setProperty("left", `${d.left}px`)) : n == null || n.style.setProperty("width", "0"), this.bottom ? (n == null || n.style.setProperty("top", "100%"), n == null || n.style.setProperty("transform", "translateY(-100%)")) : n == null || n.style.setProperty("top", `${d.top}px`);
    }), t && this.doubleRequestAnimationFrames(() => {
      const o = "ease";
      n == null || n.style.setProperty(
        "transition",
        `width ${0.3}s ${o}, height ${0.3}s ${o}, top ${0.3}s ${o}, left ${0.3}s ${o}`
      );
    });
  }
  firstUpdated() {
    requestAnimationFrame(() => {
      this.setAnimatedBackgound(true);
    }), new ResizeObserver(() => {
      this.setAnimatedBackgound();
    }).observe(this);
  }
  render() {
    return h`
      <div class="parent">
        <div class="switchers">
          <div class="animated-background"></div>
          ${this._switchers}
        </div>
        <div class="content">
          <slot @slotchange=${this.onSlotChange}></slot>
        </div>
      </div>
    `;
  }
};
dr.styles = [
  Tt.scrollbar,
  O`
      * {
        box-sizing: border-box;
      }

      :host {
        background-color: var(--bim-ui_bg-base);
        display: block;
        overflow: auto;
      }

      .parent {
        display: grid;
        overflow: hidden;
        position: relative;
        grid-template: "switchers" auto "content" 1fr;
        height: 100%;
      }

      :host([bottom]) .parent {
        grid-template: "content" 1fr "switchers" auto;
      }

      .switchers {
        position: relative;
        display: flex;
        height: 2.25rem;
        font-weight: 600;
        grid-area: switchers;
      }

      .switcher {
        --bim-label--c: var(--bim-ui_bg-contrast-80);
        background-color: transparent;
        position: relative;
        cursor: pointer;
        pointer-events: auto;
        padding: 0rem 0.75rem;
        display: flex;
        justify-content: center;
        z-index: 2;
        transition: all 0.15s;
      }

      .switcher:not([data-active]):hover {
        filter: brightness(150%);
      }

      :host([switchers-full]) .switcher {
        flex: 1;
      }

      .switcher[data-active] {
        --bim-label--c: var(--bim-ui_main-contrast);
      }

      .switchers bim-label {
        pointer-events: none;
      }

      :host([switchers-hidden]) .switchers {
        display: none;
      }

      .content {
        position: relative;
        display: grid;
        grid-template-columns: 1fr;
        grid-area: content;
        max-height: 100vh;
        overflow: auto;
        transition: max-height 0.2s;
      }

      :host([tab="hidden"]) .content {
        max-height: 0;
      }

      .animated-background {
        position: absolute;
        background: var(--bim-ui_main-base);
        width: 0;
        height: 0;
        top: 0;
        left: 0;
      }

      :host(:not([bottom])) .content {
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([bottom]) .content {
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating]) {
        background-color: transparent;
      }

      :host([floating]) .switchers {
        justify-self: center;
        overflow: hidden;
        background-color: var(--bim-ui_bg-base);
      }

      :host([floating]:not([bottom])) .switchers {
        border-radius: var(--bim-ui_size-2xs) var(--bim-ui_size-2xs) 0 0;
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
        border-left: 1px solid var(--bim-ui_bg-contrast-20);
        border-right: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating][bottom]) .switchers {
        border-radius: 0 0 var(--bim-ui_size-2xs) var(--bim-ui_size-2xs);
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
        border-left: 1px solid var(--bim-ui_bg-contrast-20);
        border-right: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating][tab="hidden"]) .switchers {
        border-radius: var(--bim-ui_size-2xs);
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating][bottom][tab="hidden"]) .switchers {
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating]) .content {
        border: 1px solid var(--bim-ui_bg-contrast-20);
        border-radius: var(--bim-ui_size-2xs);
        background-color: var(--bim-ui_bg-base);
      }
    `
];
var vt = dr;
pe([
  ae()
], vt.prototype, "_switchers", 2);
pe([
  m({ type: Boolean, reflect: true })
], vt.prototype, "bottom", 2);
pe([
  m({ type: Boolean, attribute: "switchers-hidden", reflect: true })
], vt.prototype, "switchersHidden", 2);
pe([
  m({ type: Boolean, reflect: true })
], vt.prototype, "floating", 2);
pe([
  m({ type: String, reflect: true })
], vt.prototype, "tab", 1);
pe([
  m({ type: Boolean, attribute: "switchers-full", reflect: true })
], vt.prototype, "switchersFull", 2);
var Od = Object.defineProperty;
var Pd = Object.getOwnPropertyDescriptor;
var Ai = (i, t, e, n) => {
  for (var s = n > 1 ? void 0 : n ? Pd(t, e) : t, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = (n ? r(t, e, s) : r(s)) || s);
  return n && s && Od(t, e, s), s;
};
var ur = class extends T {
  constructor() {
    super(...arguments), this._defaultName = "__unnamed__", this.name = this._defaultName, this._hidden = false;
  }
  set label(t) {
    this._label = t;
    const e = this.parentElement;
    e instanceof vt && e.updateSwitchers();
  }
  get label() {
    return this._label;
  }
  set icon(t) {
    this._icon = t;
    const e = this.parentElement;
    e instanceof vt && e.updateSwitchers();
  }
  get icon() {
    return this._icon;
  }
  set hidden(t) {
    this._hidden = t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  connectedCallback() {
    super.connectedCallback();
    const { parentElement: t } = this;
    if (t && this.name === this._defaultName) {
      const e = [...t.children].indexOf(this);
      this.name = `${this._defaultName}${e}`;
    }
  }
  render() {
    return h` <slot></slot> `;
  }
};
ur.styles = O`
    :host {
      display: block;
      height: 100%;
      grid-row-start: 1;
      grid-column-start: 1;
      animation: openAnim 3s forwards;
      transform: translateY(0);
      max-height: 100vh;
      transition:
        opacity 0.3s ease,
        max-height 0.6s ease,
        transform 0.3s ease;
    }

    :host([hidden]) {
      transform: translateY(-20px);
      max-height: 0;
      opacity: 0;
      overflow: hidden;
      visibility: hidden;
    }
  `;
var G = ur;
Ai([
  m({ type: String, reflect: true })
], G.prototype, "name", 2);
Ai([
  m({ type: String, reflect: true })
], G.prototype, "label", 1);
Ai([
  m({ type: String, reflect: true })
], G.prototype, "icon", 1);
Ai([
  m({ type: Boolean, reflect: true })
], G.prototype, "hidden", 1);
var Ms = (i) => i ?? I;
var Md = Object.defineProperty;
var zd = Object.getOwnPropertyDescriptor;
var ct = (i, t, e, n) => {
  for (var s = n > 1 ? void 0 : n ? zd(t, e) : t, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = (n ? r(t, e, s) : r(s)) || s);
  return n && s && Md(t, e, s), s;
};
var hr = class extends T {
  constructor() {
    super(...arguments), this._inputTypes = [
      "date",
      "datetime-local",
      "email",
      "month",
      "password",
      "search",
      "tel",
      "text",
      "time",
      "url",
      "week",
      "area"
    ], this.value = "", this.vertical = false, this.disabled = false, this.resize = "vertical", this._type = "text", this.onValueChange = new Event("input");
  }
  set type(t) {
    this._inputTypes.includes(t) && (this._type = t);
  }
  get type() {
    return this._type;
  }
  /**
   * Gets the query value derived from the current input value.
   * The `getQuery` function is assumed to be a utility function that takes a string as input
   * and returns a processed query value based on the input.
   *
   * @returns The processed query value derived from the current input value.
   *
   * @example
   * ```typescript
   * const textInput = new TextInput();
   * textInput.value = "Key?Value";
   * console.log(textInput.query);
   * ```
   */
  get query() {
    return on(this.value);
  }
  onInputChange(t) {
    t.stopPropagation();
    const e = t.target;
    clearTimeout(this._debounceTimeoutID), this._debounceTimeoutID = setTimeout(() => {
      this.value = e.value, this.dispatchEvent(this.onValueChange);
    }, this.debounce);
  }
  focus() {
    setTimeout(() => {
      var t;
      const e = (t = this.shadowRoot) == null ? void 0 : t.querySelector("input");
      e == null || e.focus();
    });
  }
  render() {
    return h`
      <bim-input
        .name=${this.name}
        .icon=${this.icon}
        .label=${this.label}
        .vertical=${this.vertical}
      >
        ${this.type === "area" ? h` <textarea
              aria-label=${this.label || this.name || "Text Input"}
              .value=${this.value}
              .rows=${this.rows ?? 5}
              ?disabled=${this.disabled}
              placeholder=${Ms(this.placeholder)}
              @input=${this.onInputChange}
              style="resize: ${this.resize};"
            ></textarea>` : h` <input
              aria-label=${this.label || this.name || "Text Input"}
              .type=${this.type}
              .value=${this.value}
              ?disabled=${this.disabled}
              placeholder=${Ms(this.placeholder)}
              @input=${this.onInputChange}
            />`}
      </bim-input>
    `;
  }
};
hr.styles = [
  Tt.scrollbar,
  O`
      :host {
        --bim-input--bgc: var(--bim-ui_bg-contrast-20);
        flex: 1;
        display: block;
      }

      input,
      textarea {
        font-family: inherit;
        background-color: transparent;
        border: none;
        width: 100%;
        padding: var(--bim-ui_size-3xs);
        color: var(--bim-text-input--c, var(--bim-ui_bg-contrast-100));
      }

      input {
        outline: none;
        height: 100%;
        padding: 0 var(--bim-ui_size-3xs); /* Override padding */
        border-radius: var(--bim-text-input--bdrs, var(--bim-ui_size-4xs));
      }

      :host([disabled]) input,
      :host([disabled]) textarea {
        color: var(--bim-ui_bg-contrast-60);
      }

      textarea {
        line-height: 1.1rem;
        outline: none;
      }

      :host(:focus) {
        --bim-input--olc: var(--bim-ui_accent-base);
      }

      /* :host([disabled]) {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
    } */
    `
];
var W = hr;
ct([
  m({ type: String, reflect: true })
], W.prototype, "icon", 2);
ct([
  m({ type: String, reflect: true })
], W.prototype, "label", 2);
ct([
  m({ type: String, reflect: true })
], W.prototype, "name", 2);
ct([
  m({ type: String, reflect: true })
], W.prototype, "placeholder", 2);
ct([
  m({ type: String, reflect: true })
], W.prototype, "value", 2);
ct([
  m({ type: Boolean, reflect: true })
], W.prototype, "vertical", 2);
ct([
  m({ type: Number, reflect: true })
], W.prototype, "debounce", 2);
ct([
  m({ type: Number, reflect: true })
], W.prototype, "rows", 2);
ct([
  m({ type: Boolean, reflect: true })
], W.prototype, "disabled", 2);
ct([
  m({ type: String, reflect: true })
], W.prototype, "resize", 2);
ct([
  m({ type: String, reflect: true })
], W.prototype, "type", 1);
var Id = Object.defineProperty;
var Rd = Object.getOwnPropertyDescriptor;
var pr = (i, t, e, n) => {
  for (var s = n > 1 ? void 0 : n ? Rd(t, e) : t, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = (n ? r(t, e, s) : r(s)) || s);
  return n && s && Id(t, e, s), s;
};
var mr = class extends T {
  constructor() {
    super(...arguments), this.rows = 2, this._vertical = false;
  }
  set vertical(t) {
    this._vertical = t, this.updateChildren();
  }
  get vertical() {
    return this._vertical;
  }
  updateChildren() {
    const t = this.children;
    for (const e of t)
      this.vertical ? e.setAttribute("label-hidden", "") : e.removeAttribute("label-hidden");
  }
  render() {
    return h`
      <style>
        .parent {
          grid-auto-flow: ${this.vertical ? "row" : "column"};
          grid-template-rows: repeat(${this.rows}, 1fr);
        }
      </style>
      <div class="parent">
        <slot @slotchange=${this.updateChildren}></slot>
      </div>
    `;
  }
};
mr.styles = O`
    .parent {
      display: grid;
      gap: 0.25rem;
    }

    ::slotted(bim-button[label]:not([vertical])) {
      --bim-button--jc: flex-start;
    }

    ::slotted(bim-button) {
      --bim-label--c: var(--bim-ui_bg-contrast-80);
    }
  `;
var Si = mr;
pr([
  m({ type: Number, reflect: true })
], Si.prototype, "rows", 2);
pr([
  m({ type: Boolean, reflect: true })
], Si.prototype, "vertical", 1);
var Dd = Object.defineProperty;
var Ld = Object.getOwnPropertyDescriptor;
var ki = (i, t, e, n) => {
  for (var s = n > 1 ? void 0 : n ? Ld(t, e) : t, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = (n ? r(t, e, s) : r(s)) || s);
  return n && s && Dd(t, e, s), s;
};
var fr = class extends T {
  constructor() {
    super(...arguments), this._vertical = false, this._labelHidden = false;
  }
  set vertical(t) {
    this._vertical = t, this.updateChildren();
  }
  get vertical() {
    return this._vertical;
  }
  set labelHidden(t) {
    this._labelHidden = t, this.updateChildren();
  }
  get labelHidden() {
    return this._labelHidden;
  }
  updateChildren() {
    const t = this.children;
    for (const e of t)
      e instanceof Si && (e.vertical = this.vertical), e.toggleAttribute("label-hidden", this.vertical);
  }
  render() {
    return h`
      <div class="parent">
        <div class="children">
          <slot @slotchange=${this.updateChildren}></slot>
        </div>
        ${!this.labelHidden && (this.label || this.icon) ? h`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
      </div>
    `;
  }
};
fr.styles = O`
    :host {
      --bim-label--fz: var(--bim-ui_size-xs);
      --bim-label--c: var(--bim-ui_bg-contrast-60);
      display: block;
      flex: 1;
    }

    :host(:not([vertical])) ::slotted(bim-button[vertical]) {
      --bim-icon--fz: var(--bim-ui_size-5xl);
      min-height: 3.75rem;
    }

    .parent {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: center;
      padding: 0.5rem;
      height: 100%;
      box-sizing: border-box;
      justify-content: space-between;
    }

    :host([vertical]) .parent {
      flex-direction: row-reverse;
    }

    :host([vertical]) .parent > bim-label {
      writing-mode: tb;
    }

    .children {
      display: flex;
      gap: 0.25rem;
    }

    :host([vertical]) .children {
      flex-direction: column;
    }
  `;
var me = fr;
ki([
  m({ type: String, reflect: true })
], me.prototype, "label", 2);
ki([
  m({ type: String, reflect: true })
], me.prototype, "icon", 2);
ki([
  m({ type: Boolean, reflect: true })
], me.prototype, "vertical", 1);
ki([
  m({ type: Boolean, attribute: "label-hidden", reflect: true })
], me.prototype, "labelHidden", 1);
var jd = Object.defineProperty;
var Bd2 = Object.getOwnPropertyDescriptor;
var Pn = (i, t, e, n) => {
  for (var s = n > 1 ? void 0 : n ? Bd2(t, e) : t, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = (n ? r(t, e, s) : r(s)) || s);
  return n && s && jd(t, e, s), s;
};
var br = class extends T {
  constructor() {
    super(...arguments), this.labelsHidden = false, this._vertical = false, this._hidden = false;
  }
  set vertical(t) {
    this._vertical = t, this.updateSections();
  }
  get vertical() {
    return this._vertical;
  }
  set hidden(t) {
    this._hidden = t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  // private setActivationButton() {
  //   this.activationButton.draggable = Manager.config.draggableToolbars;
  //   this.activationButton.addEventListener(
  //     "click",
  //     () => (this.hidden = !this.hidden),
  //   );
  //   this.activationButton.setAttribute("data-ui-manager-id", this._managerID);
  //   this.activationButton.addEventListener("dragstart", (e) => {
  //     const id = this.getAttribute("data-ui-manager-id");
  //     if (e.dataTransfer && id) {
  //       e.dataTransfer.setData("id", id);
  //       e.dataTransfer.effectAllowed = "move";
  //     }
  //     const containers = document.querySelectorAll("bim-toolbars-container");
  //     for (const container of containers) {
  //       if (container === this.parentElement) continue;
  //       container.dropping = true;
  //     }
  //   });
  //   this.activationButton.addEventListener("dragend", (e) => {
  //     if (e.dataTransfer) e.dataTransfer.clearData();
  //     const containers = document.querySelectorAll("bim-toolbars-container");
  //     for (const container of containers) {
  //       container.dropping = false;
  //     }
  //   });
  // }
  updateSections() {
    const t = this.children;
    for (const e of t)
      e instanceof me && (e.labelHidden = this.vertical && !U.config.sectionLabelOnVerticalToolbar, e.vertical = this.vertical);
  }
  // firstUpdated() {
  //   this.setAttribute("data-ui-manager-id", this._managerID);
  // }
  render() {
    return h`
      <div class="parent">
        <slot @slotchange=${this.updateSections}></slot>
      </div>
    `;
  }
};
br.styles = O`
    :host {
      --bim-button--bgc: transparent;
      background-color: var(--bim-ui_bg-base);
      border-radius: var(--bim-ui_size-2xs);
      display: block;
    }

    :host([hidden]) {
      display: none;
    }

    .parent {
      display: flex;
      width: max-content;
      pointer-events: auto;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    :host([vertical]) {
      width: min-content;
      border-radius: var(--bim-ui_size-2xs);
      border: 1px solid var(--bim-ui_bg-contrast-20);
    }

    ::slotted(bim-toolbar-section:not(:last-child)) {
      border-right: 1px solid var(--bim-ui_bg-contrast-20);
      border-bottom: none;
    }

    :host([vertical]) ::slotted(bim-toolbar-section:not(:last-child)) {
      border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      border-right: none;
    }
  `;
var Ei = br;
Pn([
  m({ type: String, reflect: true })
], Ei.prototype, "icon", 2);
Pn([
  m({ type: Boolean, attribute: "labels-hidden", reflect: true })
], Ei.prototype, "labelsHidden", 2);
Pn([
  m({ type: Boolean, reflect: true })
], Ei.prototype, "vertical", 1);
var Hd = Object.defineProperty;
var Nd = (i, t, e, n) => {
  for (var s = void 0, o = i.length - 1, r; o >= 0; o--)
    (r = i[o]) && (s = r(t, e, s) || s);
  return s && Hd(t, e, s), s;
};
var gr = class extends T {
  constructor() {
    super(), this._onResize = new Event("resize"), new ResizeObserver(() => {
      setTimeout(() => {
        this.dispatchEvent(this._onResize);
      });
    }).observe(this);
  }
  render() {
    return h`
      <div class="parent">
        <slot></slot>
      </div>
    `;
  }
};
gr.styles = O`
    :host {
      display: grid;
      min-width: 0;
      min-height: 0;
      height: 100%;
    }

    .parent {
      overflow: hidden;
      position: relative;
    }
  `;
var vr = gr;
Nd([
  m({ type: String, reflect: true })
], vr.prototype, "name");
var yr = "important";
var Fd = " !" + yr;
var Nt = vo(class extends yo {
  constructor(i) {
    var t;
    if (super(i), i.type !== go.ATTRIBUTE || i.name !== "style" || ((t = i.strings) == null ? void 0 : t.length) > 2)
      throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(i) {
    return Object.keys(i).reduce((t, e) => {
      const n = i[e];
      return n == null ? t : t + `${e = e.includes("-") ? e : e.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${n};`;
    }, "");
  }
  update(i, [t]) {
    const { style: e } = i.element;
    if (this.ft === void 0)
      return this.ft = new Set(Object.keys(t)), this.render(t);
    for (const n of this.ft)
      t[n] == null && (this.ft.delete(n), n.includes("-") ? e.removeProperty(n) : e[n] = null);
    for (const n in t) {
      const s = t[n];
      if (s != null) {
        this.ft.add(n);
        const o = typeof s == "string" && s.endsWith(Fd);
        n.includes("-") || o ? e.setProperty(n, o ? s.slice(0, -11) : s, o ? yr : "") : e[n] = s;
      }
    }
    return qt;
  }
});
var _h = class {
  /**
   * Initializes the custom elements for the BIM application.
   *
   * @remarks
   * This method should be called once during the application's initialization.
   *
   */
  static init() {
    U.defineCustomElement("bim-view-cube", at), U.defineCustomElement("bim-world-2d", xt), U.defineCustomElement("bim-world", si);
  }
};
var Ud = (i) => {
  const { components: t, modelUserData: e, worldName: n } = i;
  return h`
    <bim-button
      data-ui-id="import-ifc"
      label="Load IFC"
      icon="mage:box-3d-fill"
      @click=${() => {
    if (!(t && n))
      return;
    const r = [...t.get(Worlds).list.values()].find((l) => "name" in l && l.name === n);
    if (!r)
      return;
    const a = document.createElement("input");
    a.type = "file", a.accept = ".ifc", a.onchange = async () => {
      if (a.files === null || a.files.length === 0)
        return;
      const l = a.files[0], c = await l.arrayBuffer(), d = new Uint8Array(c), u = l.name.replace(".ifc", ""), p = t.get(FragmentsManager), f = t.get(IfcLoader);
      f.settings.autoSetWasm = false, f.settings.wasm = {
        path: "https://unpkg.com/web-ifc@0.0.69/",
        absolute: false
      };
      const b = await f.load(d, true, u, {
        userData: e
      });
      r.scene.three.add(b.object), b.useCamera(r.camera.three), p.core.update(true);
    }, a.click();
  }}
    ></bim-button>
  `;
};
var qd = (i) => H.create(
  Ud,
  i
);
var Vd = Object.freeze(Object.defineProperty({
  __proto__: null,
  loadIfc: qd
}, Symbol.toStringTag, { value: "Module" }));
var Yd = (i) => {
  const { components: t, world: e } = i;
  return h`
    <bim-button @click=${() => {
    const s = document.createElement("input");
    s.type = "file", s.accept = ".frag", s.onchange = async () => {
      if (s.files === null || s.files.length === 0)
        return;
      const o = s.files[0], r = await o.arrayBuffer(), a = new Uint8Array(r), l = o.name.replace(".frag", ""), c = t.get(FragmentsManager), d = await c.core.load(a, {
        modelId: l
      });
      e && (e.scene.three.add(d.object), d.useCamera(e.camera.three), c.core.update(true));
    }, s.click();
  }}></bim-button>
  `;
};
var Wd = (i) => {
  const t = H.create(
    Yd,
    i
  ), [e] = t;
  return e.label = "Load FRAG", e.icon = "mage:box-3d-fill", t;
};
var Gd = Object.freeze(Object.defineProperty({
  __proto__: null,
  loadFrag: Wd
}, Symbol.toStringTag, { value: "Module" }));
var wh = {
  ...Vd,
  ...Gd
};
var an = async (i, t) => {
  const { localId: e, category: n, children: s } = t;
  if (n && s) {
    const o = {
      data: {
        Name: n,
        modelId: i.modelId,
        children: JSON.stringify(s.map((r) => r.localId))
      }
    };
    for (const r of s) {
      const a = await an(i, r);
      a && (o.children || (o.children = []), o.children.push(a));
    }
    return o;
  }
  if (e !== null) {
    const r = await i.getItem(e).getAttributes();
    if (!r)
      return null;
    const a = {
      data: {
        Name: String(r.getValue("Name")),
        modelId: i.modelId,
        localId: e
      }
    };
    for (const l of s ?? []) {
      const c = await an(i, l);
      c && (a.children || (a.children = []), a.children.push(c));
    }
    return a;
  }
  return null;
};
var Xd = async (i) => {
  const t = [];
  for (const e of i) {
    const n = await e.getSpatialStructure(), s = await an(e, n);
    if (!s)
      continue;
    const o = {
      data: {
        Name: e.modelId,
        modelId: e.modelId
      },
      children: [s]
    };
    t.push(o);
  }
  return t;
};
var _r = (i) => {
  const { components: t, models: e } = i, n = i.selectHighlighterName ?? "select";
  return h`
    <bim-table @rowcreated=${(a) => {
    a.stopImmediatePropagation();
    const { row: l } = a.detail, c = t.get(Js), d = t.get(FragmentsManager);
    l.onclick = async () => {
      if (!n)
        return;
      const {
        data: { modelId: u, localId: p, children: f }
      } = l;
      if (!(u && (p !== void 0 || f)))
        return;
      const b = d.list.get(u);
      if (b) {
        if (p !== void 0) {
          const v = await b.getItemsChildren([p]), g = {
            [u]: v.length !== 0 ? new Set(v) : /* @__PURE__ */ new Set([p])
          };
          c.highlightByID(
            n,
            g,
            true,
            true
          );
        } else if (f) {
          const v = JSON.parse(f), g = await b.getItemsChildren(v), $ = {
            [u]: g.length !== 0 ? g : v
          };
          c.highlightByID(
            n,
            $,
            true,
            true
          );
        }
      }
    };
  }} @cellcreated=${({
    detail: a
  }) => {
    const { cell: l } = a;
    l.column === "Name" && !l.rowData.Name && (l.style.gridColumn = "1 / -1");
  }} ${V(async (a) => {
    if (!a)
      return;
    const l = a;
    l.loadFunction = async () => new Promise((c) => {
      setTimeout(() => {
        c(Xd(e));
      });
    }), l.loadData(true);
  })} headers-hidden>
      <bim-label slot="missing-data" style="--bim-icon--c: gold" icon="ic:round-warning">
        No models available to display the spatial structure!
      </bim-label>
    </bim-table>
  `;
};
var Jd = (i, t = true) => {
  const e = H.create(_r, i), [n, s] = e;
  if (n.hiddenColumns = ["modelId", "localId", "children"], n.columns = ["Name"], n.headersHidden = true, t) {
    const { components: o } = i, r = o.get(FragmentsManager);
    r.list.onItemSet.add(
      () => s({ models: r.list.values() })
    ), r.list.onItemDeleted.add(() => s());
  }
  return e;
};
var Qd = Object.freeze(Object.defineProperty({
  __proto__: null,
  spatialTree: Jd,
  spatialTreeTemplate: _r
}, Symbol.toStringTag, { value: "Module" }));
var Lt = {};
var zs = {
  _category: "Category",
  _localId: "LocalId",
  _guid: "Guid"
};
var Zd = (i, t, e) => {
  const n = {
    data: {
      Name: t in zs ? zs[t] : t,
      Value: e
    }
  };
  i.children || (i.children = []), i.children.push(n);
};
var wr = (i, t, e) => {
  var l;
  i in Lt || (Lt[i] = /* @__PURE__ */ new Map());
  const n = Lt[i], s = t._localId.value;
  if (n.has(s))
    return n.get(s);
  const o = (l = t[e.defaultItemNameKey]) == null ? void 0 : l.value, r = t._category.value, a = {
    data: {
      Name: (o == null ? void 0 : o.toString().length) > 0 ? o.toString() : r ?? String(s)
    }
  };
  n.set(s, a);
  for (const c in t) {
    const d = t[c];
    if (!Array.isArray(d))
      Zd(a, c, d.value);
    else {
      const u = {
        data: {
          Name: c
        }
      };
      a.children || (a.children = []), a.children.push(u);
      for (const p of d) {
        const f = wr(i, p, e);
        u.children || (u.children = []), u.children.push(f);
      }
    }
  }
  return a;
};
var Kd = async (i, t, e) => {
  const n = i.get(FragmentsManager);
  Object.keys(t).length === 0 && (Lt = {});
  const s = [];
  for (const o in t) {
    const r = n.list.get(o);
    if (!r)
      continue;
    o in Lt || (Lt[o] = /* @__PURE__ */ new Map());
    const a = Lt[o], l = t[o];
    for (const c of l) {
      let d = a.get(c);
      if (d) {
        s.push(d);
        continue;
      }
      const [u] = await r.getItemsData(
        [c],
        e.itemsDataConfig
      );
      d = wr(o, u, e), s.push(d);
    }
  }
  return s;
};
var $r = (i) => {
  const t = {
    defaultItemNameKey: "Name",
    itemsDataConfig: {
      attributesDefault: true,
      relationsDefault: { attributes: false, relations: false },
      relations: {
        IsDefinedBy: { attributes: true, relations: true },
        DefinesOcurrence: { attributes: false, relations: false },
        ContainedInStructure: { attributes: true, relations: true },
        ContainsElements: { attributes: false, relations: false },
        Decomposes: { attributes: false, relations: false }
      }
    },
    ...i
  }, { components: e, modelIdMap: n, emptySelectionWarning: s } = i;
  return h`
    <bim-table @cellcreated=${({
    detail: a
  }) => {
    const { cell: l } = a;
    l.column === "Name" && !("Value" in l.rowData) && (l.style.gridColumn = "1 / -1");
  }} ${V(async (a) => {
    if (!a)
      return;
    const l = a;
    l.loadFunction = async () => Kd(e, n, t), await l.loadData(true) && l.dispatchEvent(new Event("datacomputed"));
  })}>
      ${s ? h`
            <bim-label slot="missing-data" style="--bim-icon--c: gold" icon="ic:round-warning">
              Select some elements to display its properties
            </bim-label>
            ` : null}
      <bim-label slot="error-loading" style="--bim-icon--c: #e72e2e" icon="bxs:error-alt">
        Something went wrong with the properties
      </bim-label>
    </bim-table>
  `;
};
var tu = (i, t) => {
  t.columns = [{ name: "Name", width: "12rem" }], t.headersHidden = true;
};
var eu = (i) => {
  const t = H.create($r, i), [e] = t;
  return tu(i, e), t;
};
var iu = Object.freeze(Object.defineProperty({
  __proto__: null,
  itemsData: eu,
  itemsDataTemplate: $r
}, Symbol.toStringTag, { value: "Module" }));
var xr = (i) => {
  const { components: t } = i, e = i.missingDataMessage ?? "No models has been loaded yet", n = t.get(FragmentsManager), s = ({
    detail: r
  }) => {
    const { cell: a } = r;
    a.style.padding = "0.25rem 0";
  };
  return h`
    <bim-table ${V(async (r) => {
    if (!r)
      return;
    const a = r, l = [];
    for (const [, c] of n.list) {
      if (!c)
        continue;
      const d = await c.getMetadata(), u = {
        data: {
          Name: c.modelId,
          modelId: c.modelId,
          metadata: JSON.stringify(d)
        }
      };
      l.push(u);
    }
    a.data = l;
  })} @cellcreated=${s}>
      <bim-label slot="missing-data" style="--bim-icon--c: gold" icon="ic:round-warning">
        ${e}
      </bim-label>
    </bim-table>
  `;
};
var nu = (i, t) => {
  const { components: e, actions: n, metaDataTags: s } = i, o = e.get(FragmentsManager), r = (n == null ? void 0 : n.dispose) ?? true, a = (n == null ? void 0 : n.download) ?? true, l = (n == null ? void 0 : n.visibility) ?? true, c = s ?? [];
  t.hiddenColumns = ["modelId", "metadata"], t.headersHidden = true, t.noIndentation = true, t.dataTransform = {
    Name: (d, u) => {
      const { modelId: p, metadata: f } = u;
      if (!p)
        return d;
      const b = o.list.get(p);
      if (!b)
        return p;
      const v = [];
      if (f) {
        const _ = JSON.parse(f);
        for (const w of c) {
          const A = _[w];
          if (!(typeof A == "string" || typeof A == "boolean" || typeof A == "number"))
            continue;
          const x = h`
            <bim-label style="background-color: var(--bim-ui_main-base); padding: 0 0.25rem; color: var(--bim-ui_main-contrast); border-radius: 0.25rem;">${A}</bim-label>
            `;
          v.push(x);
        }
      }
      let g;
      r && (g = h`<bim-button @click=${() => o.core.disposeModel(b.modelId)} icon="mdi:delete"></bim-button>`);
      let $;
      l && ($ = h`<bim-button @click=${async ({ target: w }) => {
        w.loading = true, await b.setVisible(
          void 0,
          w.hasAttribute("data-model-hidden")
        ), await o.core.update(true), w.toggleAttribute("data-model-hidden"), w.icon = w.hasAttribute("data-model-hidden") ? "mdi:eye-off" : "mdi:eye", w.loading = false;
      }} icon="mdi:eye"></bim-button>`);
      let y;
      return a && (y = h`<bim-button @click=${async () => {
        const w = await b.getBuffer(false), A = new File([w], `${b.modelId}.frag`), x = document.createElement("a");
        x.href = URL.createObjectURL(A), x.download = A.name, x.click(), URL.revokeObjectURL(x.href);
      }} icon="flowbite:download-solid"></bim-button>`), h`
       <div style="display: flex; flex: 1; gap: var(--bim-ui_size-4xs); justify-content: space-between; overflow: auto;">
        <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 0 var(--bim-ui_size-4xs); flex-grow: 1; overflow: auto;">
          <div style="min-height: 1.75rem; overflow: auto; display: flex;">
            <bim-label style="white-space: normal;">${d}</bim-label>
          </div>
          <div style="display: flex; flex-wrap: wrap; gap: var(--bim-ui_size-4xs); overflow: auto;">
            ${v}
          </div>
        </div>
        <div style="display: flex; align-self: flex-start; flex-shrink: 0;">
          ${y}
          ${$}
          ${g}
        </div>
       </div>
      `;
    }
  };
};
var su = (i, t = true) => {
  const e = H.create(xr, i), [n, s] = e;
  if (nu(i, n), t) {
    const { components: o } = i, r = o.get(FragmentsManager), a = () => setTimeout(() => s());
    r.list.onItemSet.add(a), r.list.onItemDeleted.add(a);
  }
  return e;
};
var ou = Object.freeze(Object.defineProperty({
  __proto__: null,
  modelsList: su,
  modelsListTemplate: xr
}, Symbol.toStringTag, { value: "Module" }));
var Cr = (i) => {
  var l;
  const { components: t } = i, e = i.missingDataMessage ?? "No viewpoints to display", n = t.get(Viewpoints), s = ((l = i.topic) == null ? void 0 : l.viewpoints) ?? n.list.keys(), o = [];
  for (const c of s) {
    const d = n.list.get(c);
    d && o.push(d);
  }
  const r = (c) => {
    if (!c)
      return;
    const d = c;
    d.data = o.map((u, p) => ({
      data: {
        Guid: u.guid,
        Title: u.title ?? `Viewpoint ${i.topic ? p + 1 : ""}`,
        Actions: ""
      }
    }));
  }, a = ({
    detail: c
  }) => {
    const { cell: d } = c;
    d.style.padding = "0.25rem";
  };
  return h`
    <bim-table ${V(r)} @cellcreated=${a}>
      <bim-label slot="missing-data" icon="ph:warning-fill" style="--bim-icon--c: gold;">${e}</bim-label>
    </bim-table>
  `;
};
var ru = (i, t) => {
  const { components: e, topic: n } = i;
  t.noIndentation = true, t.headersHidden = true, t.hiddenColumns = ["Guid"], t.columns = ["Title", { name: "Actions", width: "auto" }];
  const s = {
    selectComponents: true,
    colorizeComponent: true,
    resetColors: true,
    updateCamera: true,
    delete: true,
    unlink: !!n,
    ...i.actions
  }, o = e.get(Viewpoints);
  t.dataTransform = {
    Actions: (r, a) => {
      const { Guid: l } = a;
      if (!(l && typeof l == "string"))
        return r;
      const c = o.list.get(l);
      if (!c)
        return r;
      const d = async ({ target: y }) => {
        y.loading = true, await c.go(), y.loading = false;
      };
      let u;
      s.selectComponents && (u = h`
          <bim-button label="Select Components" @click=${async ({ target: _ }) => {
        const w = e.get(FragmentsManager), A = e.get(Js);
        if (!A.isSetup)
          return;
        _.loading = true;
        const x = await w.guidsToModelIdMap([
          ...c.selectionComponents
        ]);
        await A.highlightByID("select", x), _.loading = false;
      }}></bim-button>
        `);
      let p;
      s.colorizeComponent && (p = h`
          <bim-button label="Colorize Components" @click=${async ({ target: _ }) => {
        _.loading = true, await c.setColorizationState(true), _.loading = false;
      }}></bim-button>
        `);
      let f;
      s.resetColors && (f = h`
          <bim-button label="Reset Colors" @click=${async ({ target: _ }) => {
        _.loading = true, await c.setColorizationState(false), _.loading = false;
      }}></bim-button>
        `);
      let b;
      s.updateCamera && (b = h`
          <bim-button label="Update Camera" @click=${() => c.updateCamera()}></bim-button>
        `);
      let v;
      s.unlink && (v = h`
          <bim-button label="Unlink" @click=${() => n == null ? void 0 : n.viewpoints.delete(c.guid)}></bim-button>
        `);
      let g;
      s.delete && (g = h`
          <bim-button label="Delete" @click=${() => {
        o.list.delete(c.guid), mi.removeMenus();
      }}></bim-button>
        `);
      let $;
      return Object.values(s).includes(true) && ($ = h`
          <bim-button icon="prime:ellipsis-v">
            <bim-context-menu>
              ${u}
              ${p}
              ${f}
              ${b}
              ${v}
              ${g}
            </bim-context-menu>
          </bim-button>
        `), h`
        <bim-button icon="ph:eye-fill" @click=${d}></bim-button>
        ${$}
      `;
    }
  };
};
var Ar = (i, t = true) => {
  const e = H.create(Cr, i), [n, s] = e;
  if (ru(i, n), t) {
    const { components: o, topic: r } = i, a = o.get(Viewpoints);
    a.list.onItemUpdated.add(() => s()), a.list.onItemDeleted.add(() => s()), a.list.onCleared.add(() => s()), r ? (r.viewpoints.onItemAdded.add(() => s()), r.viewpoints.onItemDeleted.add(() => s()), r.viewpoints.onCleared.add(() => s())) : a.list.onItemSet.add(() => s());
  }
  return e;
};
var au = Object.freeze(Object.defineProperty({
  __proto__: null,
  viewpointsList: Ar,
  viewpointsListTemplate: Cr
}, Symbol.toStringTag, { value: "Module" }));
var Sr = (i) => {
  const { components: t } = i, e = i.missingDataMessage ?? "No topics to display", n = t.get(BCFTopics), s = i.topics ?? n.list.values();
  return h`
    <bim-table no-indentation ${V((r) => {
    if (!r)
      return;
    const a = r;
    a.data = [...s].map((l) => {
      var c;
      return {
        data: {
          Guid: l.guid,
          Title: l.title,
          Status: l.status,
          Description: l.description ?? "",
          Author: l.creationAuthor,
          Assignee: l.assignedTo ?? "",
          Date: l.creationDate.toDateString(),
          DueDate: ((c = l.dueDate) == null ? void 0 : c.toDateString()) ?? "",
          Type: l.type,
          Priority: l.priority ?? ""
        }
      };
    });
  })}>
      <bim-label slot="missing-data" icon="ph:warning-fill" style="--bim-icon--c: gold;">${e}</bim-label>
    </bim-table>
  `;
};
var Jt = (i, t) => {
  const e = t[i], n = (e == null ? void 0 : e.name) ?? i, s = n.trim().split(/\s+/);
  let o, r;
  return s[0] && s[0][0] && (o = s[0][0].toUpperCase(), s[0][1] && (r = s[0][1].toUpperCase())), s[1] && s[1][0] && (r = s[1][0].toUpperCase()), h`
    <div style="display: flex; gap: 0.25rem; overflow: hidden;">
      ${!(e != null && e.picture) && (o || r) ? h`
        <bim-label
          style=${Nt({
    borderRadius: "999px",
    padding: "0.375rem",
    backgroundColor: "var(--bim-ui_bg-contrast-20)",
    aspectRatio: "1",
    fontSize: "0.7rem"
  })}>${o}${r}</bim-label>
        ` : null}
      <bim-label .img=${e == null ? void 0 : e.picture}>${n}</bim-label>
    </div>
  `;
};
var X = {
  users: {
    "jhon.doe@example.com": {
      name: "Jhon Doe"
    }
  },
  priorities: {
    "On hold": {
      icon: "flowbite:circle-pause-outline",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#767676"
      }
    },
    Minor: {
      icon: "mingcute:arrows-down-fill",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#4CAF50"
      }
    },
    Normal: {
      icon: "fa6-solid:grip-lines",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FB8C00"
      }
    },
    Major: {
      icon: "mingcute:arrows-up-fill",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FF5252"
      }
    },
    Critical: {
      icon: "ph:warning",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FB8C00"
      }
    }
  },
  statuses: {
    Active: {
      icon: "prime:circle-fill",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)"
      }
    },
    "In Progress": {
      icon: "prime:circle-fill",
      style: {
        backgroundColor: "#fa89004d",
        "--bim-label--c": "#FB8C00",
        "--bim-icon--c": "#FB8C00"
      }
    },
    "In Review": {
      icon: "prime:circle-fill",
      style: {
        backgroundColor: "#9c6bff4d",
        "--bim-label--c": "#9D6BFF",
        "--bim-icon--c": "#9D6BFF"
      }
    },
    Done: {
      icon: "prime:circle-fill",
      style: {
        backgroundColor: "#4CAF504D",
        "--bim-label--c": "#4CAF50",
        "--bim-icon--c": "#4CAF50"
      }
    },
    Closed: {
      icon: "prime:circle-fill",
      style: {
        backgroundColor: "#414141",
        "--bim-label--c": "#727272",
        "--bim-icon--c": "#727272"
      }
    }
  },
  types: {
    Clash: {
      icon: "gg:close-r",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FB8C00"
      }
    },
    Issue: {
      icon: "mdi:bug-outline",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FF5252"
      }
    },
    Failure: {
      icon: "mdi:bug-outline",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FF5252"
      }
    },
    Inquiry: {
      icon: "majesticons:comment-line",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FF5252"
      }
    },
    Fault: {
      icon: "ph:warning",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FF5252"
      }
    },
    Remark: {
      icon: "ph:note-blank-bold",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FB8C00"
      }
    },
    Request: {
      icon: "mynaui:edit-one",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#9D6BFF"
      }
    }
  }
};
var Qt = {
  padding: "0.25rem 0.5rem",
  borderRadius: "999px",
  "--bim-label--c": "var(--bim-ui_bg-contrast-100)"
};
var lu = {
  dueDate: (i) => {
    if (typeof i == "string" && i.trim() !== "")
      return new Date(i);
  },
  status: (i) => {
    if (Array.isArray(i) && i.length !== 0)
      return i[0];
  },
  type: (i) => {
    if (Array.isArray(i) && i.length !== 0)
      return i[0];
  },
  priority: (i) => {
    if (Array.isArray(i) && i.length !== 0)
      return i[0];
  },
  stage: (i) => {
    if (Array.isArray(i) && i.length !== 0)
      return i[0];
  },
  assignedTo: (i) => {
    if (Array.isArray(i) && i.length !== 0)
      return i[0];
  },
  labels: (i) => {
    if (Array.isArray(i))
      return new Set(i);
  }
};
var kr = (i) => {
  const {
    components: t,
    topic: e,
    value: n,
    onCancel: s,
    onSubmit: o,
    styles: r
  } = i, a = o ?? (() => {
  }), l = t.get(BCFTopics), c = (n == null ? void 0 : n.title) ?? (e == null ? void 0 : e.title) ?? Topic.default.title, d = (n == null ? void 0 : n.status) ?? (e == null ? void 0 : e.status) ?? Topic.default.status, u = (n == null ? void 0 : n.type) ?? (e == null ? void 0 : e.type) ?? Topic.default.type, p = (n == null ? void 0 : n.priority) ?? (e == null ? void 0 : e.priority) ?? Topic.default.priority, f = (n == null ? void 0 : n.assignedTo) ?? (e == null ? void 0 : e.assignedTo) ?? Topic.default.assignedTo, b = (n == null ? void 0 : n.labels) ?? (e == null ? void 0 : e.labels) ?? Topic.default.labels, v = (n == null ? void 0 : n.stage) ?? (e == null ? void 0 : e.stage) ?? Topic.default.stage, g = (n == null ? void 0 : n.description) ?? (e == null ? void 0 : e.description) ?? Topic.default.description, $ = e != null && e.dueDate ? e.dueDate.toISOString().split("T")[0] : null, y = /* @__PURE__ */ new Set([...l.config.statuses]);
  d && y.add(d);
  const _ = /* @__PURE__ */ new Set([...l.config.types]);
  u && _.add(u);
  const w = /* @__PURE__ */ new Set([...l.config.priorities]);
  p && w.add(p);
  const A = /* @__PURE__ */ new Set([...l.config.users]);
  f && A.add(f);
  const x = /* @__PURE__ */ new Set([...l.config.labels]);
  if (b)
    for (const C of b)
      x.add(C);
  const M = /* @__PURE__ */ new Set([...l.config.stages]);
  v && M.add(v);
  const N = Yi(), q = async () => {
    const { value: C } = N;
    if (!C)
      return;
    const z = De(
      C,
      lu
    );
    if (e)
      e.set(z), await a(e);
    else {
      const P = l.create(z);
      await a(P);
    }
  }, E = Yi(), ot = (C) => {
    const { value: z } = E;
    if (!z)
      return;
    const P = C.target;
    z.disabled = P.value.trim() === "";
  }, dt = `btn-${U.newRandomId()}`, K = `btn-${U.newRandomId()}`;
  return h`
    <div ${V(N)} style="display: flex; flex-direction: column; gap: 0.75rem;">
      <div style="display: flex; gap: 0.375rem">
        <bim-text-input @input=${ot} vertical label="Title" name="title" .value=${c}></bim-text-input>
        ${e ? h`
            <bim-dropdown vertical label="Status" name="status" required>
              ${[...y].map((C) => h`<bim-option label=${C} .checked=${d === C}></bim-option>`)}
            </bim-dropdown>` : h``}
      </div>
      <div style="display: flex; gap: 0.375rem">
        <bim-dropdown vertical label="Type" name="type" required>
          ${[..._].map((C) => h`<bim-option label=${C} .checked=${u === C}></bim-option>`)}
        </bim-dropdown>
        <bim-dropdown vertical label="Priority" name="priority">
          ${[...w].map((C) => h`<bim-option label=${C} .checked=${p === C}></bim-option>`)}
        </bim-dropdown>
      </div>
      <div style="display: flex; gap: 0.375rem">
        <bim-dropdown vertical label="Labels" name="labels" multiple>
          ${[...x].map((C) => h`<bim-option label=${C} .checked=${b ? [...b].includes(C) : false}></bim-option>`)}
        </bim-dropdown>
        <bim-dropdown vertical label="Assignee" name="assignedTo">
          ${[...A].map((C) => {
    const z = r != null && r.users ? r.users[C] : null, P = z ? z.name : C, F = z == null ? void 0 : z.picture;
    return h`<bim-option label=${P} value=${C} .img=${F} .checked=${f === C}></bim-option>`;
  })}
        </bim-dropdown>
      </div>
      <div style="display: flex; gap: 0.375rem">
        <bim-text-input vertical type="date" label="Due Date" name="dueDate" .value=${$}></bim-text-input> 
        <bim-dropdown vertical label="Stage" name="stage">
          ${[...M].map((C) => h`<bim-option label=${C} .checked=${v === C}></bim-option>`)}
        </bim-dropdown>
      </div>
      <bim-text-input vertical label="Description" name="description" type="area" .value=${g ?? null}></bim-text-input>
      <div style="justify-content: right; display: flex; gap: 0.375rem">
        <style>
          #${K} {
            background-color: transparent;
          }

          #${K}:hover {
            --bim-label--c: #FF5252;
          }

          #${dt}:hover {
            background-color: #329936;
          }
        </style>
        <bim-button id=${K} style="flex: 0" @click=${s} label="Cancel"></bim-button>
        <bim-button id=${dt} style="flex: 0" @click=${q} ${V(E)} label=${e ? "Update Topic" : "Add Topic"} icon=${e ? "tabler:refresh" : "mi:add"}></bim-button>
      </div>
    </div>
  `;
};
var cu = (i, t) => {
  const { dataStyles: e } = i;
  t.hiddenColumns.length === 0 && (t.hiddenColumns = ["Guid"]), t.columns = ["Title"], t.dataTransform = {
    Priority: (n) => {
      if (typeof n != "string")
        return n;
      const o = ((e == null ? void 0 : e.priorities) ?? X.priorities)[n];
      return h`
            <bim-label
              .icon=${o == null ? void 0 : o.icon}
              style=${Nt({ ...Qt, ...o == null ? void 0 : o.style })}
            >${n}
            </bim-label>
          `;
    },
    Status: (n) => {
      if (typeof n != "string")
        return n;
      const o = ((e == null ? void 0 : e.statuses) ?? X.statuses)[n];
      return h`
            <bim-label
              .icon=${o == null ? void 0 : o.icon}
              style=${Nt({ ...Qt, ...o == null ? void 0 : o.style })}
            >${n}
            </bim-label>
          `;
    },
    Type: (n) => {
      if (typeof n != "string")
        return n;
      const o = ((e == null ? void 0 : e.types) ?? X.types)[n];
      return h`
            <bim-label
              .icon=${o == null ? void 0 : o.icon}
              style=${Nt({ ...Qt, ...o == null ? void 0 : o.style })}
            >${n}
            </bim-label>
          `;
    },
    Author: (n) => typeof n != "string" ? n : Jt(n, (e == null ? void 0 : e.users) ?? X.users),
    Assignee: (n) => typeof n != "string" ? n : Jt(n, (e == null ? void 0 : e.users) ?? X.users)
  };
};
var Er = (i, t = true) => {
  const e = H.create(Sr, i), [n, s] = e;
  if (cu(i, n), t) {
    const { components: o, topics: r } = i, a = o.get(BCFTopics), l = () => s();
    if (a.list.onItemUpdated.add(l), a.list.onItemDeleted.add(l), r)
      for (const c of r)
        c.relatedTopics.onItemAdded.add(l), c.relatedTopics.onItemDeleted.add(l), c.relatedTopics.onCleared.add(l);
    else
      a.list.onItemSet.add(l);
  }
  return e;
};
var du = Object.freeze(Object.defineProperty({
  __proto__: null,
  topicsList: Er,
  topicsListTemplate: Sr
}, Symbol.toStringTag, { value: "Module" }));
var Tr = (i) => {
  const { topic: t, styles: e, viewpoint: n } = i, s = i.missingDataMessage ?? "The topic has no comments";
  return h`
    <bim-table no-indentation ${V((r) => {
    if (!r)
      return;
    const a = r;
    let l = t.comments.values();
    n && (l = [...t.comments.values()].filter(
      (c) => c.viewpoint === n.guid
    )), a.data = [...l].map((c) => ({
      data: {
        guid: c.guid,
        Comment: c.comment,
        author: (() => {
          const d = e;
          if (!d)
            return c.author;
          const u = d[c.author];
          return (u == null ? void 0 : u.name) ?? c.author;
        })()
      }
    }));
  })}>
      <bim-label slot="missing-data" icon="ph:warning-fill" style="--bim-icon--c: gold;">${s}</bim-label>
    </bim-table>
  `;
};
var uu = (i, t) => {
  const { topic: e, styles: n } = i, s = { delete: true, ...i.actions };
  t.headersHidden = true, t.hiddenColumns = ["guid", "author"], t.dataTransform = {
    Comment: (o, r) => {
      const { guid: a } = r;
      if (typeof a != "string")
        return o;
      const l = e.comments.get(a);
      if (!l)
        return o;
      const c = () => {
        e.comments.delete(a);
      };
      let d;
      if (s.delete) {
        const u = `btn-${U.newRandomId()}`;
        d = h`
          <div>
            <style>
              #${u} {
                background-color: transparent;
                --bim-label--c: var(--bim-ui_bg-contrast-60)
              }
  
              #${u}:hover {
                --bim-label--c: #FF5252;
              }
            </style>
            <bim-button @click=${c} id=${u} icon="majesticons:delete-bin"></bim-button>
          </div>
        `;
      }
      return h`
        <div style="display: flex; flex-direction: column; gap: 0.25rem; flex: 1">
          <div style="display: flex; justify-content: space-between;">
            <div style="display: flex; gap: 0.375rem;">
              ${Jt(l.author, n ?? X.users)}
              <bim-label style="color: var(--bim-ui_bg-contrast-40)">@ ${l.date.toDateString()}</bim-label>
            </div>
            ${d}
          </div>
          <bim-label style="margin-left: 1.7rem; white-space: normal">${l.comment}</bim-label>
        </div>
      `;
    }
  };
};
var Or = (i, t = true) => {
  const e = H.create(Tr, i), [n, s] = e;
  if (uu(i, n), t) {
    const { topic: o } = i, r = () => s();
    o.comments.onItemSet.add(r), o.comments.onItemUpdated.add(r), o.comments.onItemDeleted.add(r), o.comments.onCleared.add(r);
  }
  return e;
};
var hu = Object.freeze(Object.defineProperty({
  __proto__: null,
  commentsList: Or,
  commentsListTemplate: Tr
}, Symbol.toStringTag, { value: "Module" }));
var $h = {
  // ...worldsConfiguration,
  ...Qd,
  ...iu,
  ...ou,
  ...au,
  ...du,
  ...hu
};
var Pr = (i, t) => {
  const { showInput: e, topic: n, styles: s } = i, o = {
    add: true,
    delete: true,
    ...i.actions
  }, r = `input-${U.newRandomId()}`, a = `btn-${U.newRandomId()}`, l = `btn-${U.newRandomId()}`, c = () => document.getElementById(a), d = () => document.getElementById(r), u = () => {
    const w = d();
    return w ? w.value.trim().length > 0 : false;
  }, p = () => {
    t({ showInput: true });
  }, f = () => {
    const w = d(), A = u();
    w && A && (n.createComment(w.value), t({ showInput: false }));
  }, b = () => {
    t({ showInput: false });
  }, v = () => {
    const w = c();
    if (!w)
      return;
    if (!d()) {
      w.disabled = true;
      return;
    }
    w.disabled = !u();
  }, g = h`
    ${o.add ? h`<bim-button @click=${p} label="Add Comment" icon="majesticons:comment-line"></bim-button>` : null}
  `, y = h`
    <bim-text-input id=${r} @input=${v} @keypress=${(w) => {
    w.code === "Enter" && w.ctrlKey && f();
  }} type="area"></bim-text-input>

    <div style="justify-content: right; display: flex; gap: 0.375rem">
      <style>
        #${a} {
          background-color: #329936;
        }  

        #${l} {
          background-color: transparent;
        }

        #${l}:hover {
          --bim-label--c: #FF5252;
        }
      </style>

      <bim-button style="flex: 0" id=${l} @click=${b} label="Cancel"></bim-button>
      <bim-button style="flex: 0" id=${a} @click=${f} label="Accept" icon="material-symbols:check" disabled></bim-button>
    </div>
  `, [_] = Or({
    topic: n,
    actions: o,
    styles: s ?? X.users
  });
  return h`
    <div style="display: flex; flex-direction: column; gap: 0.5rem">
      ${_}
      ${e ? y : g}
    </div>
  `;
};
var pu = (i) => H.create(Pr, i);
var mu = Object.freeze(Object.defineProperty({
  __proto__: null,
  topicComments: pu,
  topicCommentsSectionTemplate: Pr
}, Symbol.toStringTag, { value: "Module" }));
var Mr = (i, t) => {
  const { components: e, editing: n, topic: s, styles: o } = i, r = {
    update: true,
    ...i.actions
  }, a = (o == null ? void 0 : o.priorities) ?? X.priorities, l = (o == null ? void 0 : o.statuses) ?? X.statuses, c = (o == null ? void 0 : o.types) ?? X.types;
  let d;
  s != null && s.priority && (d = a[s.priority]);
  let u;
  s != null && s.type && (u = c[s.type]);
  let p;
  s != null && s.type && (p = l[s.status]);
  let f, b;
  return n ? f = kr({
    components: e,
    topic: s,
    styles: o,
    onSubmit: () => {
      t({ editing: false });
    },
    onCancel: () => {
      t({ editing: false });
    }
  }) : b = h`
      <div>
        <bim-label>Title</bim-label>
        <bim-label style="--bim-label--c: var(--bim-ui_bg-contrast-100)">${s.title}</bim-label>
      </div>

      ${s.description ? h`
            <div>
              <bim-label>Description</bim-label>
              <bim-label style="--bim-label--c: var(--bim-ui_bg-contrast-100); white-space: normal">${s.description}</bim-label>
            </div>
          ` : null}

      <div style="display: flex; gap: 0.375rem">
        <bim-label>Status</bim-label>
        <bim-label .icon=${p == null ? void 0 : p.icon} style=${Nt({ ...Qt, ...p == null ? void 0 : p.style })}
        >${s.status}
        </bim-label>
      </div>

      <div style="display: flex; gap: 0.375rem">
        <bim-label>Type</bim-label>
        <bim-label .icon=${u == null ? void 0 : u.icon} style=${Nt({ ...Qt, ...u == null ? void 0 : u.style })}
        >${s.type}
        </bim-label>
      </div>

      ${s.priority ? h`
            <div style="display: flex; gap: 0.375rem">
              <bim-label>Priority</bim-label>
              <bim-label .icon=${d == null ? void 0 : d.icon} style=${Nt({ ...Qt, ...d == null ? void 0 : d.style })}
              >${s.priority}
              </bim-label>
            </div>` : null}

      <div style="display: flex; gap: 0.375rem">
        <bim-label>Author</bim-label>
        ${Jt(s.creationAuthor, (o == null ? void 0 : o.users) ?? X.users)}
      </div>

      ${s.assignedTo ? h`
          <div style="display: flex; gap: 0.375rem">
            <bim-label>Assignee</bim-label>
            ${Jt(s.assignedTo, (o == null ? void 0 : o.users) ?? X.users)}
          </div>` : null}

      ${s.dueDate ? h`
          <div style="display: flex; gap: 0.375rem">
            <bim-label>Due Date</bim-label>
            <bim-label style="--bim-label--c: var(--bim-ui_bg-contrast-100)">${s.dueDate.toDateString()}</bim-label>
          </div>` : null}

      ${s.modifiedAuthor ? h`
          <div style="display: flex; gap: 0.375rem">
            <bim-label>Modified By</bim-label>
            ${Jt(s.modifiedAuthor, (o == null ? void 0 : o.users) ?? X.users)}
          </div>` : null}

      ${s.modifiedDate ? h`
            <div style="display: flex; gap: 0.375rem">
              <bim-label>Modified Date</bim-label>
              <bim-label style="--bim-label--c: var(--bim-ui_bg-contrast-100)">${s.modifiedDate.toDateString()}</bim-label>
            </div>` : null}

      ${s.labels.size !== 0 ? h`
          <div style="display: flex; gap: 0.375rem">
            <bim-label>Labels</bim-label>
            <bim-label style="white-space: normal; --bim-label--c: var(--bim-ui_bg-contrast-100)">${[...s.labels].join(", ")}</bim-label>
          </div>` : null}

      ${r.update ? h`
              <bim-button @click=${() => t({ editing: true })} label="Update Information" icon="tabler:refresh"></bim-button> 
            ` : null}
    `, h`
    <div style="display: flex; flex-direction: column; gap: 0.75rem;">
      ${n ? f : b}
    </div>
  `;
};
var fu = (i) => H.create(Mr, i);
var bu = Object.freeze(Object.defineProperty({
  __proto__: null,
  topicInformation: fu,
  topicInformationSectionTemplate: Mr
}, Symbol.toStringTag, { value: "Module" }));
var zr = (i, t) => {
  const { components: e, topic: n, linking: s } = i, o = e.get(BCFTopics), r = {
    link: true,
    ...i.actions
  }, [a, l] = Er({
    components: e,
    topics: [...n.relatedTopics].map((p) => o.list.get(p)).map((p) => p)
  });
  a.headersHidden = true, a.hiddenColumns = [
    "Guid",
    "Status",
    // "Title",
    "Description",
    "Author",
    "Assignee",
    "Date",
    "DueDate",
    "Type",
    "Priority"
  ];
  const c = () => h`
      <bim-text-input placeholder="Search..." debounce="100" @input=${(f) => {
    const b = f.target;
    b instanceof W && (a.queryString = b.value);
  }}></bim-text-input> 
    `;
  let d, u;
  if (s) {
    a.selectableRows = true, l({
      topics: void 0
    });
    const p = a.data.filter(($) => {
      const { Guid: y } = $.data;
      return typeof y != "string" ? false : n.relatedTopics.has(y);
    }).map(($) => $.data);
    a.selection = new Set(p);
    const f = () => {
      const $ = [...a.selection].map(({ Guid: y }) => typeof y != "string" ? null : o.list.has(y) ? y : null).map((y) => y);
      n.relatedTopics.clear(), n.relatedTopics.add(...$), t({ linking: false });
    }, b = () => {
      t({ linking: false });
    }, v = `btn-${U.newRandomId()}`, g = `btn-${U.newRandomId()}`;
    d = h`
      <div style="display: flex; gap: 0.25rem">
        <style>
          #${v}:hover {
            background-color: #329936;
          }  

          #${g} {
            background-color: transparent;
          }

          #${g}:hover {
            --bim-label--c: #FF5252;
          }
        </style>
        ${c()}
        <div style="display: flex; justify-content: right; gap: 0.25rem">
          <bim-button id=${g} @click=${b} style="flex: 0" label="Cancel" icon="material-symbols:close"></bim-button>
          <bim-button id=${v} @click=${f} style="flex: 0" label="Accept" icon="material-symbols:check"></bim-button>
        </div>
      </div> 
    `;
  } else {
    a.selectableRows = false;
    const p = () => {
      t({ linking: true });
    };
    u = h`
      <div style="display: flex; justify-content: right; gap: 0.25rem">
        ${c()}
        ${r.link ? h`<bim-button style="flex: 0" @click=${p} icon="tabler:link"></bim-button>` : null}
      </div> 
    `;
  }
  return h`
    <div style="display: flex; flex-direction: column; gap: 0.5rem;">
      ${u}
      ${d}
      ${a}
    </div> 
  `;
};
var gu = (i) => H.create(zr, i);
var vu = Object.freeze(Object.defineProperty({
  __proto__: null,
  topicRelations: gu,
  topicRelationsSectionTemplate: zr
}, Symbol.toStringTag, { value: "Module" }));
var Ir = (i, t) => {
  const { components: e, topic: n, world: s, linking: o } = i, r = {
    add: true,
    link: true,
    selectComponents: true,
    colorizeComponent: true,
    resetColors: true,
    updateCamera: true,
    delete: true,
    unlink: true,
    ...i.actions
  }, a = e.get(Viewpoints), [l, c] = Ar({
    components: e,
    topic: n,
    actions: r
  }), d = () => h`
      <bim-text-input placeholder="Search..." debounce="100" @input=${(b) => {
    const v = b.target;
    v instanceof W && (l.queryString = v.value);
  }}></bim-text-input> 
    `;
  let u, p;
  if (o) {
    l.selectableRows = true, c({
      topic: void 0,
      actions: {
        delete: false,
        updateCamera: false,
        colorizeComponent: false,
        resetColors: false
      }
    });
    const f = l.data.filter((y) => {
      const { Guid: _ } = y.data;
      return typeof _ != "string" ? false : n.viewpoints.has(_);
    }).map((y) => y.data);
    l.selection = new Set(f);
    const b = () => {
      const y = [...l.selection].map(({ Guid: _ }) => typeof _ != "string" ? null : a.list.has(_) ? _ : null).map((_) => _);
      n.viewpoints.clear(), n.viewpoints.add(...y), t({ linking: false });
    }, v = () => {
      t({ linking: false });
    }, g = `btn-${U.newRandomId()}`, $ = `btn-${U.newRandomId()}`;
    u = h`
      <div style="display: flex; gap: 0.25rem">
        <style>
          #${g}:hover {
            background-color: #329936;
          }  

          #${$} {
            background-color: transparent;
          }

          #${$}:hover {
            --bim-label--c: #FF5252;
          }
        </style>
        ${d()}
        <div style="display: flex; justify-content: right; gap: 0.25rem">
          <bim-button id=${$} @click=${v} style="flex: 0" label="Cancel" icon="material-symbols:close"></bim-button>
          <bim-button id=${g} @click=${b} style="flex: 0" label="Accept" icon="material-symbols:check"></bim-button>
        </div>
      </div> 
    `;
  } else {
    l.selectableRows = false, c({
      topic: n,
      actions: r
    });
    const f = () => {
      if (!(n && r.add && !o))
        return;
      const $ = a.create();
      s && ($.world = s), n.viewpoints.add($.guid);
    }, b = () => {
      t({ linking: true });
    }, v = h`<bim-button style="flex: 0" @click=${f} .disabled=${!s} icon="mi:add"></bim-button>`, g = h`<bim-button style="flex: 0" @click=${b} icon="tabler:link"></bim-button>`;
    p = h`
      <div style="display: flex; justify-content: right; gap: 0.25rem">
        ${d()}
        <div style="display: flex; justify-content: right; gap: 0.25rem">
          ${r.add ? v : null}
          ${r.link ? g : null}
        </div>
      </div> 
    `;
  }
  return h`
    <div style="display: flex; flex-direction: column; gap: 0.5rem;">
      ${p}
      ${u}
      ${l}
    </div> 
  `;
};
var yu = (i) => H.create(Ir, i);
var _u = Object.freeze(Object.defineProperty({
  __proto__: null,
  topicViewpoints: yu,
  topicViewpointsSectionTemplate: Ir
}, Symbol.toStringTag, { value: "Module" }));
var xh = {
  ...mu,
  ...bu,
  ...vu,
  ..._u
  // ...specificationInformation,
};
var wu = (i) => h`
    <bim-panel-section fixed label="New Topic" name="topic">
      ${kr(i)}
    </bim-panel-section>
  `;
var $u = (i) => H.create(
  wu,
  i
);
var xu = Object.freeze(Object.defineProperty({
  __proto__: null,
  topic: $u
}, Symbol.toStringTag, { value: "Module" }));
var Ch = {
  ...xu
};
export {
  _h as Manager,
  at as ViewCube,
  si as World,
  xt as World2D,
  wh as buttons,
  Ch as forms,
  xh as sections,
  $h as tables,
  Pr as topicCommentsSectionTemplate,
  Mr as topicInformationSectionTemplate,
  zr as topicRelationsSectionTemplate,
  Ir as topicViewpointsSectionTemplate
};
/*! Bundled license information:

@thatopen/ui-obc/dist/index.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
  (**
  * (c) Iconify
  *
  * For the full copyright and license information, please view the license.txt
  * files at https://github.com/iconify/iconify
  *
  * Licensed under MIT.
  *
  * @license MIT
  * @version 2.0.0
  *)
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=@thatopen_ui-obc.js.map
