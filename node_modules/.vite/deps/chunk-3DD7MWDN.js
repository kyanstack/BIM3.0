import {
  IfcAPI2,
  LogLevel,
  Sd,
  Wt,
  Yt,
  cd,
  ve,
  ze
} from "./chunk-JND42KI4.js";
import {
  ACESFilmicToneMapping,
  AddEquation,
  AgXToneMapping,
  BackSide,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  CameraHelper,
  CineonToneMapping,
  Clock,
  Color,
  ColorManagement,
  Controls,
  CustomBlending,
  CustomToneMapping,
  CylinderGeometry,
  DataTexture,
  DepthStencilFormat,
  DepthTexture,
  DoubleSide,
  DstAlphaFactor,
  DstColorFactor,
  DynamicDrawUsage,
  Euler,
  Float32BufferAttribute,
  FrontSide,
  Frustum,
  Group,
  HalfFloatType,
  InstancedBufferGeometry,
  InstancedInterleavedBuffer,
  InstancedMesh,
  InterleavedBufferAttribute,
  Line,
  Line3,
  LineBasicMaterial,
  LineDashedMaterial,
  LineSegments,
  LinearFilter,
  LinearToneMapping,
  MOUSE,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshLambertMaterial,
  MeshNormalMaterial,
  NearestFilter,
  NeutralToneMapping,
  NoBlending,
  Object3D,
  OctahedronGeometry,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  PlaneHelper,
  Points,
  PointsMaterial,
  Quaternion,
  RGBAFormat,
  RawShaderMaterial,
  Ray,
  Raycaster,
  ReinhardToneMapping,
  RepeatWrapping,
  SRGBTransfer,
  Scene,
  ShaderLib,
  ShaderMaterial,
  ShapeUtils,
  Sphere,
  SphereGeometry,
  Spherical,
  Texture,
  TorusGeometry,
  Triangle,
  Uint16BufferAttribute,
  UniformsLib,
  UniformsUtils,
  UnsignedByteType,
  UnsignedInt248Type,
  Vector2,
  Vector3,
  Vector4,
  WebGLRenderTarget,
  WebGLRenderer,
  WireframeGeometry,
  ZeroFactor
} from "./chunk-LVV4RLRG.js";

// node_modules/@thatopen/components-front/dist/index.js
var ja = Object.defineProperty;
var Wa = (l, t, e) => t in l ? ja(l, t, { enumerable: true, configurable: true, writable: true, value: e }) : l[t] = e;
var A = (l, t, e) => (Wa(l, typeof t != "symbol" ? t + "" : t, e), e);
var El = Object.defineProperty;
var Tl = (l, t, e) => t in l ? El(l, t, { enumerable: true, configurable: true, writable: true, value: e }) : l[t] = e;
var E = (l, t, e) => (Tl(l, typeof t != "symbol" ? t + "" : t, e), e);
var tt = class {
  constructor() {
    E(this, "enabled", true), E(this, "trigger", (t) => {
      if (!this.enabled)
        return;
      const e = this.handlers.slice(0);
      for (const s of e)
        s(t);
    }), E(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(t) {
    this.handlers.push(t);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(t) {
    this.handlers = this.handlers.filter((e) => e !== t);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
};
var fr = class {
  constructor(t) {
    E(this, "isDisposeable", () => "dispose" in this && "onDisposed" in this), E(this, "isResizeable", () => "resize" in this && "getSize" in this), E(this, "isUpdateable", () => "onAfterUpdate" in this && "onBeforeUpdate" in this && "update" in this), E(this, "isHideable", () => "visible" in this), E(this, "isConfigurable", () => "setup" in this && "config" in this && "onSetup" in this), this.components = t;
  }
};
var St = class extends fr {
};
var Zo = class extends fr {
  constructor(t) {
    super(t), E(this, "worlds", new Yt()), E(this, "onWorldChanged", new tt()), E(this, "_currentWorld", null), this.onWorldChanged.add(({ world: e, action: s }) => {
      s === "removed" && this.worlds.delete(e.uuid);
    });
  }
  /**
   * The current world this item is associated with. It can be null if no world is currently active.
   */
  set currentWorld(t) {
    this._currentWorld = t;
  }
  get currentWorld() {
    return this._currentWorld;
  }
};
var Cl = class extends Zo {
  constructor() {
    super(...arguments), E(this, "hasCameraControls", () => "controls" in this);
  }
};
var Al = class extends Zo {
  constructor() {
    super(...arguments), E(this, "onAfterUpdate", new tt()), E(this, "onBeforeUpdate", new tt()), E(this, "onDisposed", new tt()), E(this, "onResize", new tt()), E(this, "onClippingPlanesUpdated", new tt()), E(this, "clippingPlanes", []);
  }
  /**
   * Updates the clipping planes and triggers the `onClippingPlanesUpdated` event.
   *
   * @remarks
   * This method is typically called when there is a change to the list of clipping planes
   * used by the active renderer.
   */
  updateClippingPlanes() {
    this.onClippingPlanesUpdated.trigger();
  }
  /**
   * Sets or removes a clipping plane from the renderer.
   *
   * @param active - A boolean indicating whether the clipping plane should be active or not.
   * @param plane - The clipping plane to be added or removed.
   * @param isLocal - An optional boolean indicating whether the clipping plane is local to the object. If not provided, it defaults to `false`.
   *
   * @remarks
   * This method adds or removes a clipping plane from the `clippingPlanes` array.
   * If `active` is `true` and the plane is not already in the array, it is added.
   * If `active` is `false` and the plane is in the array, it is removed.
   * The `three.clippingPlanes` property is then updated to reflect the current state of the `clippingPlanes` array,
   * excluding any planes marked as local.
   */
  setPlane(t, e, s) {
    e.isLocal = s;
    const i = this.clippingPlanes.indexOf(e);
    t && i === -1 ? this.clippingPlanes.push(e) : !t && i > -1 && this.clippingPlanes.splice(i, 1), this.three.clippingPlanes = this.clippingPlanes.filter(
      (n) => !n.isLocal
    );
  }
};
var qo = class Zn extends St {
  constructor(t) {
    super(t), E(this, "_disposedComponents", /* @__PURE__ */ new Set()), E(this, "enabled", true), t.add(Zn.uuid, this);
  }
  // TODO: Remove this?
  /**
   * Return the UUIDs of all disposed components.
   */
  get() {
    return this._disposedComponents;
  }
  /**
   * Removes a mesh, its geometry and its materials from memory. If you are
   * using any of these in other parts of the application, make sure that you
   * remove them from the mesh before disposing it.
   *
   * @param object - the [object](https://threejs.org/docs/#api/en/core/Object3D)
   * to remove.
   *
   * @param materials - whether to dispose the materials of the mesh.
   *
   * @param recursive - whether to recursively dispose the children of the mesh.
   */
  destroy(t, e = true, s = true) {
    t.removeFromParent();
    const i = t;
    i.dispose && i.dispose(), this.disposeGeometryAndMaterials(t, e), s && i.children && i.children.length && this.disposeChildren(i), t.children.length = 0;
  }
  /**
   * Disposes a geometry from memory.
   *
   * @param geometry - the
   * [geometry](https://threejs.org/docs/#api/en/core/BufferGeometry)
   * to remove.
   */
  disposeGeometry(t) {
    t.boundsTree && t.disposeBoundsTree && t.disposeBoundsTree(), t.dispose();
  }
  disposeGeometryAndMaterials(t, e) {
    const s = t;
    s.geometry && this.disposeGeometry(s.geometry), e && s.material && Zn.disposeMaterial(s), s.material = [], s.geometry = null;
  }
  disposeChildren(t) {
    for (const e of t.children)
      this.destroy(e);
  }
  static disposeMaterial(t) {
    if (t.material)
      if (Array.isArray(t.material))
        for (const e of t.material)
          e.dispose();
      else
        t.material.dispose();
  }
};
E(qo, "uuid", "76e9cd8e-ad8f-4753-9ef6-cbc60f7247fe");
var De = qo;
var _n = class extends Set {
  /**
   * Constructs a new instance of the DataSet class.
   *
   * @param iterable - An optional iterable object to initialize the set with.
   */
  constructor(t) {
    super(t), E(this, "onItemAdded", new tt()), E(this, "onItemDeleted", new tt()), E(this, "onCleared", new tt()), E(this, "guard", () => true);
  }
  /**
   * Clears the set and triggers the onCleared event.
   */
  clear() {
    super.clear(), this.onCleared.trigger();
  }
  /**
   * Adds one or multiple values to the set and triggers the onItemAdded event per each.
   *
   * @param value - The value to add to the set.
   * @returns - The set instance.
   */
  add(...t) {
    for (const e of t)
      this.has(e) || !this.guard(e) || (super.add(e), this.onItemAdded || (this.onItemAdded = new tt()), this.onItemAdded.trigger(e));
    return this;
  }
  /**
   * Deletes a value from the set and triggers the onItemDeleted event.
   *
   * @param value - The value to delete from the set.
   * @returns - True if the value was successfully deleted, false otherwise.
   */
  delete(t) {
    const e = super.delete(t);
    return e && this.onItemDeleted.trigger(), e;
  }
  /**
   * Clears the set and resets the onItemAdded, onItemDeleted, and onCleared events.
   */
  dispose() {
    this.clear(), this.onItemAdded.reset(), this.onItemDeleted.reset(), this.onCleared.reset();
  }
};
var pr = class kt {
  // Copied from three.js source
  // Original source: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
  static create() {
    const t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, s = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
    return `${kt._lut[t & 255] + kt._lut[t >> 8 & 255] + kt._lut[t >> 16 & 255] + kt._lut[t >> 24 & 255]}-${kt._lut[e & 255]}${kt._lut[e >> 8 & 255]}-${kt._lut[e >> 16 & 15 | 64]}${kt._lut[e >> 24 & 255]}-${kt._lut[s & 63 | 128]}${kt._lut[s >> 8 & 255]}-${kt._lut[s >> 16 & 255]}${kt._lut[s >> 24 & 255]}${kt._lut[i & 255]}${kt._lut[i >> 8 & 255]}${kt._lut[i >> 16 & 255]}${kt._lut[i >> 24 & 255]}`.toLowerCase();
  }
  static validate(t) {
    if (!kt._pattern.test(t))
      throw new Error(
        `${t} is not a valid UUID v4.

- If you're the tool creator, you can take one from https://www.uuidgenerator.net/.

- If you're using a platform tool, verify the uuid isn't misspelled or contact the tool creator.`
      );
  }
};
E(pr, "_pattern", /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/);
E(pr, "_lut", [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff"
]);
var Xt = pr;
var hi = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Pl(l) {
  return l && l.__esModule && Object.prototype.hasOwnProperty.call(l, "default") ? l.default : l;
}
var Qo = {};
var hn = {};
(function(l) {
  const t = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", e = t + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040", s = "[" + t + "][" + e + "]*", i = new RegExp("^" + s + "$"), n = function(o, a) {
    const c = [];
    let h = a.exec(o);
    for (; h; ) {
      const d = [];
      d.startIndex = a.lastIndex - h[0].length;
      const u = h.length;
      for (let f = 0; f < u; f++)
        d.push(h[f]);
      c.push(d), h = a.exec(o);
    }
    return c;
  }, r = function(o) {
    const a = i.exec(o);
    return !(a === null || typeof a > "u");
  };
  l.isExist = function(o) {
    return typeof o < "u";
  }, l.isEmptyObject = function(o) {
    return Object.keys(o).length === 0;
  }, l.merge = function(o, a, c) {
    if (a) {
      const h = Object.keys(a), d = h.length;
      for (let u = 0; u < d; u++)
        c === "strict" ? o[h[u]] = [a[h[u]]] : o[h[u]] = a[h[u]];
    }
  }, l.getValue = function(o) {
    return l.isExist(o) ? o : "";
  }, l.isName = r, l.getAllMatches = n, l.nameRegexp = s;
})(hn);
var mr = hn;
var Ml = {
  allowBooleanAttributes: false,
  //A tag can have attributes without any value
  unpairedTags: []
};
Qo.validate = function(l, t) {
  t = Object.assign({}, Ml, t);
  const e = [];
  let s = false, i = false;
  l[0] === "\uFEFF" && (l = l.substr(1));
  for (let n = 0; n < l.length; n++)
    if (l[n] === "<" && l[n + 1] === "?") {
      if (n += 2, n = Ir(l, n), n.err)
        return n;
    } else if (l[n] === "<") {
      let r = n;
      if (n++, l[n] === "!") {
        n = zr(l, n);
        continue;
      } else {
        let o = false;
        l[n] === "/" && (o = true, n++);
        let a = "";
        for (; n < l.length && l[n] !== ">" && l[n] !== " " && l[n] !== "	" && l[n] !== `
` && l[n] !== "\r"; n++)
          a += l[n];
        if (a = a.trim(), a[a.length - 1] === "/" && (a = a.substring(0, a.length - 1), n--), !Bl(a)) {
          let d;
          return a.trim().length === 0 ? d = "Invalid space after '<'." : d = "Tag '" + a + "' is an invalid name.", Ot("InvalidTag", d, Gt(l, n));
        }
        const c = Il(l, n);
        if (c === false)
          return Ot("InvalidAttr", "Attributes for '" + a + "' have open quote.", Gt(l, n));
        let h = c.value;
        if (n = c.index, h[h.length - 1] === "/") {
          const d = n - h.length;
          h = h.substring(0, h.length - 1);
          const u = Lr(h, t);
          if (u === true)
            s = true;
          else
            return Ot(u.err.code, u.err.msg, Gt(l, d + u.err.line));
        } else if (o)
          if (c.tagClosed) {
            if (h.trim().length > 0)
              return Ot("InvalidTag", "Closing tag '" + a + "' can't have attributes or invalid starting.", Gt(l, r));
            if (e.length === 0)
              return Ot("InvalidTag", "Closing tag '" + a + "' has not been opened.", Gt(l, r));
            {
              const d = e.pop();
              if (a !== d.tagName) {
                let u = Gt(l, d.tagStartPos);
                return Ot(
                  "InvalidTag",
                  "Expected closing tag '" + d.tagName + "' (opened in line " + u.line + ", col " + u.col + ") instead of closing tag '" + a + "'.",
                  Gt(l, r)
                );
              }
              e.length == 0 && (i = true);
            }
          } else
            return Ot("InvalidTag", "Closing tag '" + a + "' doesn't have proper closing.", Gt(l, n));
        else {
          const d = Lr(h, t);
          if (d !== true)
            return Ot(d.err.code, d.err.msg, Gt(l, n - h.length + d.err.line));
          if (i === true)
            return Ot("InvalidXml", "Multiple possible root nodes found.", Gt(l, n));
          t.unpairedTags.indexOf(a) !== -1 || e.push({ tagName: a, tagStartPos: r }), s = true;
        }
        for (n++; n < l.length; n++)
          if (l[n] === "<")
            if (l[n + 1] === "!") {
              n++, n = zr(l, n);
              continue;
            } else if (l[n + 1] === "?") {
              if (n = Ir(l, ++n), n.err)
                return n;
            } else
              break;
          else if (l[n] === "&") {
            const d = Nl(l, n);
            if (d == -1)
              return Ot("InvalidChar", "char '&' is not expected.", Gt(l, n));
            n = d;
          } else if (i === true && !Dr(l[n]))
            return Ot("InvalidXml", "Extra text at the end", Gt(l, n));
        l[n] === "<" && n--;
      }
    } else {
      if (Dr(l[n]))
        continue;
      return Ot("InvalidChar", "char '" + l[n] + "' is not expected.", Gt(l, n));
    }
  if (s) {
    if (e.length == 1)
      return Ot("InvalidTag", "Unclosed tag '" + e[0].tagName + "'.", Gt(l, e[0].tagStartPos));
    if (e.length > 0)
      return Ot("InvalidXml", "Invalid '" + JSON.stringify(e.map((n) => n.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  } else
    return Ot("InvalidXml", "Start tag expected.", 1);
  return true;
};
function Dr(l) {
  return l === " " || l === "	" || l === `
` || l === "\r";
}
function Ir(l, t) {
  const e = t;
  for (; t < l.length; t++)
    if (l[t] == "?" || l[t] == " ") {
      const s = l.substr(e, t - e);
      if (t > 5 && s === "xml")
        return Ot("InvalidXml", "XML declaration allowed only at the start of the document.", Gt(l, t));
      if (l[t] == "?" && l[t + 1] == ">") {
        t++;
        break;
      } else
        continue;
    }
  return t;
}
function zr(l, t) {
  if (l.length > t + 5 && l[t + 1] === "-" && l[t + 2] === "-") {
    for (t += 3; t < l.length; t++)
      if (l[t] === "-" && l[t + 1] === "-" && l[t + 2] === ">") {
        t += 2;
        break;
      }
  } else if (l.length > t + 8 && l[t + 1] === "D" && l[t + 2] === "O" && l[t + 3] === "C" && l[t + 4] === "T" && l[t + 5] === "Y" && l[t + 6] === "P" && l[t + 7] === "E") {
    let e = 1;
    for (t += 8; t < l.length; t++)
      if (l[t] === "<")
        e++;
      else if (l[t] === ">" && (e--, e === 0))
        break;
  } else if (l.length > t + 9 && l[t + 1] === "[" && l[t + 2] === "C" && l[t + 3] === "D" && l[t + 4] === "A" && l[t + 5] === "T" && l[t + 6] === "A" && l[t + 7] === "[") {
    for (t += 8; t < l.length; t++)
      if (l[t] === "]" && l[t + 1] === "]" && l[t + 2] === ">") {
        t += 2;
        break;
      }
  }
  return t;
}
var Ol = '"';
var Dl = "'";
function Il(l, t) {
  let e = "", s = "", i = false;
  for (; t < l.length; t++) {
    if (l[t] === Ol || l[t] === Dl)
      s === "" ? s = l[t] : s !== l[t] || (s = "");
    else if (l[t] === ">" && s === "") {
      i = true;
      break;
    }
    e += l[t];
  }
  return s !== "" ? false : {
    value: e,
    index: t,
    tagClosed: i
  };
}
var zl = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function Lr(l, t) {
  const e = mr.getAllMatches(l, zl), s = {};
  for (let i = 0; i < e.length; i++) {
    if (e[i][1].length === 0)
      return Ot("InvalidAttr", "Attribute '" + e[i][2] + "' has no space in starting.", Ds(e[i]));
    if (e[i][3] !== void 0 && e[i][4] === void 0)
      return Ot("InvalidAttr", "Attribute '" + e[i][2] + "' is without value.", Ds(e[i]));
    if (e[i][3] === void 0 && !t.allowBooleanAttributes)
      return Ot("InvalidAttr", "boolean attribute '" + e[i][2] + "' is not allowed.", Ds(e[i]));
    const n = e[i][2];
    if (!kl(n))
      return Ot("InvalidAttr", "Attribute '" + n + "' is an invalid name.", Ds(e[i]));
    if (!s.hasOwnProperty(n))
      s[n] = 1;
    else
      return Ot("InvalidAttr", "Attribute '" + n + "' is repeated.", Ds(e[i]));
  }
  return true;
}
function Ll(l, t) {
  let e = /\d/;
  for (l[t] === "x" && (t++, e = /[\da-fA-F]/); t < l.length; t++) {
    if (l[t] === ";")
      return t;
    if (!l[t].match(e))
      break;
  }
  return -1;
}
function Nl(l, t) {
  if (t++, l[t] === ";")
    return -1;
  if (l[t] === "#")
    return t++, Ll(l, t);
  let e = 0;
  for (; t < l.length; t++, e++)
    if (!(l[t].match(/\w/) && e < 20)) {
      if (l[t] === ";")
        break;
      return -1;
    }
  return t;
}
function Ot(l, t, e) {
  return {
    err: {
      code: l,
      msg: t,
      line: e.line || e,
      col: e.col
    }
  };
}
function kl(l) {
  return mr.isName(l);
}
function Bl(l) {
  return mr.isName(l);
}
function Gt(l, t) {
  const e = l.substring(0, t).split(/\r?\n/);
  return {
    line: e.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: e[e.length - 1].length + 1
  };
}
function Ds(l) {
  return l.startIndex + l[1].length;
}
var gr = {};
var Ko = {
  preserveOrder: false,
  attributeNamePrefix: "@_",
  attributesGroupName: false,
  textNodeName: "#text",
  ignoreAttributes: true,
  removeNSPrefix: false,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: false,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: true,
  parseAttributeValue: false,
  trimValues: true,
  //Trim string values of tag and attributes
  cdataPropName: false,
  numberParseOptions: {
    hex: true,
    leadingZeros: true,
    eNotation: true
  },
  tagValueProcessor: function(l, t) {
    return t;
  },
  attributeValueProcessor: function(l, t) {
    return t;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: false,
  isArray: () => false,
  commentPropName: false,
  unpairedTags: [],
  processEntities: true,
  htmlEntities: false,
  ignoreDeclaration: false,
  ignorePiTags: false,
  transformTagName: false,
  transformAttributeName: false,
  updateTag: function(l, t, e) {
    return l;
  }
  // skipEmptyListItem: false
};
var Rl = function(l) {
  return Object.assign({}, Ko, l);
};
gr.buildOptions = Rl;
gr.defaultOptions = Ko;
var Ul = class {
  constructor(t) {
    this.tagname = t, this.child = [], this[":@"] = {};
  }
  add(t, e) {
    t === "__proto__" && (t = "#__proto__"), this.child.push({ [t]: e });
  }
  addChild(t) {
    t.tagname === "__proto__" && (t.tagname = "#__proto__"), t[":@"] && Object.keys(t[":@"]).length > 0 ? this.child.push({ [t.tagname]: t.child, ":@": t[":@"] }) : this.child.push({ [t.tagname]: t.child });
  }
};
var Fl = Ul;
var Vl = hn;
function Hl(l, t) {
  const e = {};
  if (l[t + 3] === "O" && l[t + 4] === "C" && l[t + 5] === "T" && l[t + 6] === "Y" && l[t + 7] === "P" && l[t + 8] === "E") {
    t = t + 9;
    let s = 1, i = false, n = false, r = "";
    for (; t < l.length; t++)
      if (l[t] === "<" && !n) {
        if (i && Xl(l, t))
          t += 7, [entityName, val, t] = jl(l, t + 1), val.indexOf("&") === -1 && (e[ql(entityName)] = {
            regx: RegExp(`&${entityName};`, "g"),
            val
          });
        else if (i && Yl(l, t))
          t += 8;
        else if (i && Gl(l, t))
          t += 8;
        else if (i && Zl(l, t))
          t += 9;
        else if (Wl)
          n = true;
        else
          throw new Error("Invalid DOCTYPE");
        s++, r = "";
      } else if (l[t] === ">") {
        if (n ? l[t - 1] === "-" && l[t - 2] === "-" && (n = false, s--) : s--, s === 0)
          break;
      } else
        l[t] === "[" ? i = true : r += l[t];
    if (s !== 0)
      throw new Error("Unclosed DOCTYPE");
  } else
    throw new Error("Invalid Tag instead of DOCTYPE");
  return { entities: e, i: t };
}
function jl(l, t) {
  let e = "";
  for (; t < l.length && l[t] !== "'" && l[t] !== '"'; t++)
    e += l[t];
  if (e = e.trim(), e.indexOf(" ") !== -1)
    throw new Error("External entites are not supported");
  const s = l[t++];
  let i = "";
  for (; t < l.length && l[t] !== s; t++)
    i += l[t];
  return [e, i, t];
}
function Wl(l, t) {
  return l[t + 1] === "!" && l[t + 2] === "-" && l[t + 3] === "-";
}
function Xl(l, t) {
  return l[t + 1] === "!" && l[t + 2] === "E" && l[t + 3] === "N" && l[t + 4] === "T" && l[t + 5] === "I" && l[t + 6] === "T" && l[t + 7] === "Y";
}
function Yl(l, t) {
  return l[t + 1] === "!" && l[t + 2] === "E" && l[t + 3] === "L" && l[t + 4] === "E" && l[t + 5] === "M" && l[t + 6] === "E" && l[t + 7] === "N" && l[t + 8] === "T";
}
function Gl(l, t) {
  return l[t + 1] === "!" && l[t + 2] === "A" && l[t + 3] === "T" && l[t + 4] === "T" && l[t + 5] === "L" && l[t + 6] === "I" && l[t + 7] === "S" && l[t + 8] === "T";
}
function Zl(l, t) {
  return l[t + 1] === "!" && l[t + 2] === "N" && l[t + 3] === "O" && l[t + 4] === "T" && l[t + 5] === "A" && l[t + 6] === "T" && l[t + 7] === "I" && l[t + 8] === "O" && l[t + 9] === "N";
}
function ql(l) {
  if (Vl.isName(l))
    return l;
  throw new Error(`Invalid entity name ${l}`);
}
var Ql = Hl;
var Kl = /^[-+]?0x[a-fA-F0-9]+$/;
var Jl = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/;
var $l = {
  hex: true,
  // oct: false,
  leadingZeros: true,
  decimalPoint: ".",
  eNotation: true
  //skipLike: /regex/
};
function tc(l, t = {}) {
  if (t = Object.assign({}, $l, t), !l || typeof l != "string")
    return l;
  let e = l.trim();
  if (t.skipLike !== void 0 && t.skipLike.test(e))
    return l;
  if (l === "0")
    return 0;
  if (t.hex && Kl.test(e))
    return sc(e, 16);
  if (e.search(/[eE]/) !== -1) {
    const s = e.match(/^([-\+])?(0*)([0-9]*(\.[0-9]*)?[eE][-\+]?[0-9]+)$/);
    if (s) {
      if (t.leadingZeros)
        e = (s[1] || "") + s[3];
      else if (!(s[2] === "0" && s[3][0] === "."))
        return l;
      return t.eNotation ? Number(e) : l;
    } else
      return l;
  } else {
    const s = Jl.exec(e);
    if (s) {
      const i = s[1], n = s[2];
      let r = ec(s[3]);
      if (!t.leadingZeros && n.length > 0 && i && e[2] !== ".")
        return l;
      if (!t.leadingZeros && n.length > 0 && !i && e[1] !== ".")
        return l;
      if (t.leadingZeros && n === l)
        return 0;
      {
        const o = Number(e), a = "" + o;
        return a.search(/[eE]/) !== -1 ? t.eNotation ? o : l : e.indexOf(".") !== -1 ? a === "0" && r === "" || a === r || i && a === "-" + r ? o : l : n ? r === a || i + r === a ? o : l : e === a || e === i + a ? o : l;
      }
    } else
      return l;
  }
}
function ec(l) {
  return l && l.indexOf(".") !== -1 && (l = l.replace(/0+$/, ""), l === "." ? l = "0" : l[0] === "." ? l = "0" + l : l[l.length - 1] === "." && (l = l.substr(0, l.length - 1))), l;
}
function sc(l, t) {
  if (parseInt)
    return parseInt(l, t);
  if (Number.parseInt)
    return Number.parseInt(l, t);
  if (window && window.parseInt)
    return window.parseInt(l, t);
  throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
}
var ic = tc;
var Jo = hn;
var Is = Fl;
var nc = Ql;
var rc = ic;
var oc = class {
  constructor(t) {
    this.options = t, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = {
      apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
      gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
      lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
      quot: { regex: /&(quot|#34|#x22);/g, val: '"' }
    }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = {
      space: { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      cent: { regex: /&(cent|#162);/g, val: "¢" },
      pound: { regex: /&(pound|#163);/g, val: "£" },
      yen: { regex: /&(yen|#165);/g, val: "¥" },
      euro: { regex: /&(euro|#8364);/g, val: "€" },
      copyright: { regex: /&(copy|#169);/g, val: "©" },
      reg: { regex: /&(reg|#174);/g, val: "®" },
      inr: { regex: /&(inr|#8377);/g, val: "₹" },
      num_dec: { regex: /&#([0-9]{1,7});/g, val: (e, s) => String.fromCharCode(Number.parseInt(s, 10)) },
      num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (e, s) => String.fromCharCode(Number.parseInt(s, 16)) }
    }, this.addExternalEntities = ac, this.parseXml = uc, this.parseTextData = lc, this.resolveNameSpace = cc, this.buildAttributesMap = dc, this.isItStopNode = gc, this.replaceEntitiesValue = pc, this.readStopNodeData = yc, this.saveTextToParentTag = mc, this.addChild = fc;
  }
};
function ac(l) {
  const t = Object.keys(l);
  for (let e = 0; e < t.length; e++) {
    const s = t[e];
    this.lastEntities[s] = {
      regex: new RegExp("&" + s + ";", "g"),
      val: l[s]
    };
  }
}
function lc(l, t, e, s, i, n, r) {
  if (l !== void 0 && (this.options.trimValues && !s && (l = l.trim()), l.length > 0)) {
    r || (l = this.replaceEntitiesValue(l));
    const o = this.options.tagValueProcessor(t, l, e, i, n);
    return o == null ? l : typeof o != typeof l || o !== l ? o : this.options.trimValues ? Qn(l, this.options.parseTagValue, this.options.numberParseOptions) : l.trim() === l ? Qn(l, this.options.parseTagValue, this.options.numberParseOptions) : l;
  }
}
function cc(l) {
  if (this.options.removeNSPrefix) {
    const t = l.split(":"), e = l.charAt(0) === "/" ? "/" : "";
    if (t[0] === "xmlns")
      return "";
    t.length === 2 && (l = e + t[1]);
  }
  return l;
}
var hc = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function dc(l, t, e) {
  if (!this.options.ignoreAttributes && typeof l == "string") {
    const s = Jo.getAllMatches(l, hc), i = s.length, n = {};
    for (let r = 0; r < i; r++) {
      const o = this.resolveNameSpace(s[r][1]);
      let a = s[r][4], c = this.options.attributeNamePrefix + o;
      if (o.length)
        if (this.options.transformAttributeName && (c = this.options.transformAttributeName(c)), c === "__proto__" && (c = "#__proto__"), a !== void 0) {
          this.options.trimValues && (a = a.trim()), a = this.replaceEntitiesValue(a);
          const h = this.options.attributeValueProcessor(o, a, t);
          h == null ? n[c] = a : typeof h != typeof a || h !== a ? n[c] = h : n[c] = Qn(
            a,
            this.options.parseAttributeValue,
            this.options.numberParseOptions
          );
        } else
          this.options.allowBooleanAttributes && (n[c] = true);
    }
    if (!Object.keys(n).length)
      return;
    if (this.options.attributesGroupName) {
      const r = {};
      return r[this.options.attributesGroupName] = n, r;
    }
    return n;
  }
}
var uc = function(l) {
  l = l.replace(/\r\n?/g, `
`);
  const t = new Is("!xml");
  let e = t, s = "", i = "";
  for (let n = 0; n < l.length; n++)
    if (l[n] === "<")
      if (l[n + 1] === "/") {
        const o = ss(l, ">", n, "Closing Tag is not closed.");
        let a = l.substring(n + 2, o).trim();
        if (this.options.removeNSPrefix) {
          const d = a.indexOf(":");
          d !== -1 && (a = a.substr(d + 1));
        }
        this.options.transformTagName && (a = this.options.transformTagName(a)), e && (s = this.saveTextToParentTag(s, e, i));
        const c = i.substring(i.lastIndexOf(".") + 1);
        if (a && this.options.unpairedTags.indexOf(a) !== -1)
          throw new Error(`Unpaired tag can not be used as closing tag: </${a}>`);
        let h = 0;
        c && this.options.unpairedTags.indexOf(c) !== -1 ? (h = i.lastIndexOf(".", i.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : h = i.lastIndexOf("."), i = i.substring(0, h), e = this.tagsNodeStack.pop(), s = "", n = o;
      } else if (l[n + 1] === "?") {
        let o = qn(l, n, false, "?>");
        if (!o)
          throw new Error("Pi Tag is not closed.");
        if (s = this.saveTextToParentTag(s, e, i), !(this.options.ignoreDeclaration && o.tagName === "?xml" || this.options.ignorePiTags)) {
          const a = new Is(o.tagName);
          a.add(this.options.textNodeName, ""), o.tagName !== o.tagExp && o.attrExpPresent && (a[":@"] = this.buildAttributesMap(o.tagExp, i, o.tagName)), this.addChild(e, a, i);
        }
        n = o.closeIndex + 1;
      } else if (l.substr(n + 1, 3) === "!--") {
        const o = ss(l, "-->", n + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const a = l.substring(n + 4, o - 2);
          s = this.saveTextToParentTag(s, e, i), e.add(this.options.commentPropName, [{ [this.options.textNodeName]: a }]);
        }
        n = o;
      } else if (l.substr(n + 1, 2) === "!D") {
        const o = nc(l, n);
        this.docTypeEntities = o.entities, n = o.i;
      } else if (l.substr(n + 1, 2) === "![") {
        const o = ss(l, "]]>", n, "CDATA is not closed.") - 2, a = l.substring(n + 9, o);
        s = this.saveTextToParentTag(s, e, i);
        let c = this.parseTextData(a, e.tagname, i, true, false, true, true);
        c == null && (c = ""), this.options.cdataPropName ? e.add(this.options.cdataPropName, [{ [this.options.textNodeName]: a }]) : e.add(this.options.textNodeName, c), n = o + 2;
      } else {
        let o = qn(l, n, this.options.removeNSPrefix), a = o.tagName;
        const c = o.rawTagName;
        let h = o.tagExp, d = o.attrExpPresent, u = o.closeIndex;
        this.options.transformTagName && (a = this.options.transformTagName(a)), e && s && e.tagname !== "!xml" && (s = this.saveTextToParentTag(s, e, i, false));
        const f = e;
        if (f && this.options.unpairedTags.indexOf(f.tagname) !== -1 && (e = this.tagsNodeStack.pop(), i = i.substring(0, i.lastIndexOf("."))), a !== t.tagname && (i += i ? "." + a : a), this.isItStopNode(this.options.stopNodes, i, a)) {
          let g = "";
          if (h.length > 0 && h.lastIndexOf("/") === h.length - 1)
            a[a.length - 1] === "/" ? (a = a.substr(0, a.length - 1), i = i.substr(0, i.length - 1), h = a) : h = h.substr(0, h.length - 1), n = o.closeIndex;
          else if (this.options.unpairedTags.indexOf(a) !== -1)
            n = o.closeIndex;
          else {
            const _ = this.readStopNodeData(l, c, u + 1);
            if (!_)
              throw new Error(`Unexpected end of ${c}`);
            n = _.i, g = _.tagContent;
          }
          const m = new Is(a);
          a !== h && d && (m[":@"] = this.buildAttributesMap(h, i, a)), g && (g = this.parseTextData(g, a, i, true, d, true, true)), i = i.substr(0, i.lastIndexOf(".")), m.add(this.options.textNodeName, g), this.addChild(e, m, i);
        } else {
          if (h.length > 0 && h.lastIndexOf("/") === h.length - 1) {
            a[a.length - 1] === "/" ? (a = a.substr(0, a.length - 1), i = i.substr(0, i.length - 1), h = a) : h = h.substr(0, h.length - 1), this.options.transformTagName && (a = this.options.transformTagName(a));
            const g = new Is(a);
            a !== h && d && (g[":@"] = this.buildAttributesMap(h, i, a)), this.addChild(e, g, i), i = i.substr(0, i.lastIndexOf("."));
          } else {
            const g = new Is(a);
            this.tagsNodeStack.push(e), a !== h && d && (g[":@"] = this.buildAttributesMap(h, i, a)), this.addChild(e, g, i), e = g;
          }
          s = "", n = u;
        }
      }
    else
      s += l[n];
  return t.child;
};
function fc(l, t, e) {
  const s = this.options.updateTag(t.tagname, e, t[":@"]);
  s === false || (typeof s == "string" && (t.tagname = s), l.addChild(t));
}
var pc = function(l) {
  if (this.options.processEntities) {
    for (let t in this.docTypeEntities) {
      const e = this.docTypeEntities[t];
      l = l.replace(e.regx, e.val);
    }
    for (let t in this.lastEntities) {
      const e = this.lastEntities[t];
      l = l.replace(e.regex, e.val);
    }
    if (this.options.htmlEntities)
      for (let t in this.htmlEntities) {
        const e = this.htmlEntities[t];
        l = l.replace(e.regex, e.val);
      }
    l = l.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return l;
};
function mc(l, t, e, s) {
  return l && (s === void 0 && (s = Object.keys(t.child).length === 0), l = this.parseTextData(
    l,
    t.tagname,
    e,
    false,
    t[":@"] ? Object.keys(t[":@"]).length !== 0 : false,
    s
  ), l !== void 0 && l !== "" && t.add(this.options.textNodeName, l), l = ""), l;
}
function gc(l, t, e) {
  const s = "*." + e;
  for (const i in l) {
    const n = l[i];
    if (s === n || t === n)
      return true;
  }
  return false;
}
function _c(l, t, e = ">") {
  let s, i = "";
  for (let n = t; n < l.length; n++) {
    let r = l[n];
    if (s)
      r === s && (s = "");
    else if (r === '"' || r === "'")
      s = r;
    else if (r === e[0])
      if (e[1]) {
        if (l[n + 1] === e[1])
          return {
            data: i,
            index: n
          };
      } else
        return {
          data: i,
          index: n
        };
    else
      r === "	" && (r = " ");
    i += r;
  }
}
function ss(l, t, e, s) {
  const i = l.indexOf(t, e);
  if (i === -1)
    throw new Error(s);
  return i + t.length - 1;
}
function qn(l, t, e, s = ">") {
  const i = _c(l, t + 1, s);
  if (!i)
    return;
  let n = i.data;
  const r = i.index, o = n.search(/\s/);
  let a = n, c = true;
  o !== -1 && (a = n.substring(0, o), n = n.substring(o + 1).trimStart());
  const h = a;
  if (e) {
    const d = a.indexOf(":");
    d !== -1 && (a = a.substr(d + 1), c = a !== i.data.substr(d + 1));
  }
  return {
    tagName: a,
    tagExp: n,
    closeIndex: r,
    attrExpPresent: c,
    rawTagName: h
  };
}
function yc(l, t, e) {
  const s = e;
  let i = 1;
  for (; e < l.length; e++)
    if (l[e] === "<")
      if (l[e + 1] === "/") {
        const n = ss(l, ">", e, `${t} is not closed`);
        if (l.substring(e + 2, n).trim() === t && (i--, i === 0))
          return {
            tagContent: l.substring(s, e),
            i: n
          };
        e = n;
      } else if (l[e + 1] === "?")
        e = ss(l, "?>", e + 1, "StopNode is not closed.");
      else if (l.substr(e + 1, 3) === "!--")
        e = ss(l, "-->", e + 3, "StopNode is not closed.");
      else if (l.substr(e + 1, 2) === "![")
        e = ss(l, "]]>", e, "StopNode is not closed.") - 2;
      else {
        const n = qn(l, e, ">");
        n && ((n && n.tagName) === t && n.tagExp[n.tagExp.length - 1] !== "/" && i++, e = n.closeIndex);
      }
}
function Qn(l, t, e) {
  if (t && typeof l == "string") {
    const s = l.trim();
    return s === "true" ? true : s === "false" ? false : rc(l, e);
  } else
    return Jo.isExist(l) ? l : "";
}
var vc = oc;
var $o = {};
function wc(l, t) {
  return ta(l, t);
}
function ta(l, t, e) {
  let s;
  const i = {};
  for (let n = 0; n < l.length; n++) {
    const r = l[n], o = bc(r);
    let a = "";
    if (e === void 0 ? a = o : a = e + "." + o, o === t.textNodeName)
      s === void 0 ? s = r[o] : s += "" + r[o];
    else {
      if (o === void 0)
        continue;
      if (r[o]) {
        let c = ta(r[o], t, a);
        const h = Sc(c, t);
        r[":@"] ? xc(c, r[":@"], a, t) : Object.keys(c).length === 1 && c[t.textNodeName] !== void 0 && !t.alwaysCreateTextNode ? c = c[t.textNodeName] : Object.keys(c).length === 0 && (t.alwaysCreateTextNode ? c[t.textNodeName] = "" : c = ""), i[o] !== void 0 && i.hasOwnProperty(o) ? (Array.isArray(i[o]) || (i[o] = [i[o]]), i[o].push(c)) : t.isArray(o, a, h) ? i[o] = [c] : i[o] = c;
      }
    }
  }
  return typeof s == "string" ? s.length > 0 && (i[t.textNodeName] = s) : s !== void 0 && (i[t.textNodeName] = s), i;
}
function bc(l) {
  const t = Object.keys(l);
  for (let e = 0; e < t.length; e++) {
    const s = t[e];
    if (s !== ":@")
      return s;
  }
}
function xc(l, t, e, s) {
  if (t) {
    const i = Object.keys(t), n = i.length;
    for (let r = 0; r < n; r++) {
      const o = i[r];
      s.isArray(o, e + "." + o, true, true) ? l[o] = [t[o]] : l[o] = t[o];
    }
  }
}
function Sc(l, t) {
  const { textNodeName: e } = t, s = Object.keys(l).length;
  return !!(s === 0 || s === 1 && (l[e] || typeof l[e] == "boolean" || l[e] === 0));
}
$o.prettify = wc;
var { buildOptions: Ec } = gr;
var Tc = vc;
var { prettify: Cc } = $o;
var Ac = Qo;
var Pc = class {
  constructor(t) {
    this.externalEntities = {}, this.options = Ec(t);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Buffer} xmlData 
   * @param {boolean|Object} validationOption 
   */
  parse(t, e) {
    if (typeof t != "string")
      if (t.toString)
        t = t.toString();
      else
        throw new Error("XML data is accepted in String or Bytes[] form.");
    if (e) {
      e === true && (e = {});
      const n = Ac.validate(t, e);
      if (n !== true)
        throw Error(`${n.err.msg}:${n.err.line}:${n.err.col}`);
    }
    const s = new Tc(this.options);
    s.addExternalEntities(this.externalEntities);
    const i = s.parseXml(t);
    return this.options.preserveOrder || i === void 0 ? i : Cc(i, this.options);
  }
  /**
   * Add Entity which is not by default supported by this library
   * @param {string} key 
   * @param {string} value 
   */
  addEntity(t, e) {
    if (e.indexOf("&") !== -1)
      throw new Error("Entity value can't have '&'");
    if (t.indexOf("&") !== -1 || t.indexOf(";") !== -1)
      throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    if (e === "&")
      throw new Error("An entity with value '&' is not permitted");
    this.externalEntities[t] = e;
  }
};
var Mc = Pc;
var Oc = `
`;
function Dc(l, t) {
  let e = "";
  return t.format && t.indentBy.length > 0 && (e = Oc), ea(l, t, "", e);
}
function ea(l, t, e, s) {
  let i = "", n = false;
  for (let r = 0; r < l.length; r++) {
    const o = l[r], a = Ic(o);
    if (a === void 0)
      continue;
    let c = "";
    if (e.length === 0 ? c = a : c = `${e}.${a}`, a === t.textNodeName) {
      let g = o[a];
      zc(c, t) || (g = t.tagValueProcessor(a, g), g = sa(g, t)), n && (i += s), i += g, n = false;
      continue;
    } else if (a === t.cdataPropName) {
      n && (i += s), i += `<![CDATA[${o[a][0][t.textNodeName]}]]>`, n = false;
      continue;
    } else if (a === t.commentPropName) {
      i += s + `<!--${o[a][0][t.textNodeName]}-->`, n = true;
      continue;
    } else if (a[0] === "?") {
      const g = Nr(o[":@"], t), m = a === "?xml" ? "" : s;
      let _ = o[a][0][t.textNodeName];
      _ = _.length !== 0 ? " " + _ : "", i += m + `<${a}${_}${g}?>`, n = true;
      continue;
    }
    let h = s;
    h !== "" && (h += t.indentBy);
    const d = Nr(o[":@"], t), u = s + `<${a}${d}`, f = ea(o[a], t, c, h);
    t.unpairedTags.indexOf(a) !== -1 ? t.suppressUnpairedNode ? i += u + ">" : i += u + "/>" : (!f || f.length === 0) && t.suppressEmptyNode ? i += u + "/>" : f && f.endsWith(">") ? i += u + `>${f}${s}</${a}>` : (i += u + ">", f && s !== "" && (f.includes("/>") || f.includes("</")) ? i += s + t.indentBy + f + s : i += f, i += `</${a}>`), n = true;
  }
  return i;
}
function Ic(l) {
  const t = Object.keys(l);
  for (let e = 0; e < t.length; e++) {
    const s = t[e];
    if (l.hasOwnProperty(s) && s !== ":@")
      return s;
  }
}
function Nr(l, t) {
  let e = "";
  if (l && !t.ignoreAttributes)
    for (let s in l) {
      if (!l.hasOwnProperty(s))
        continue;
      let i = t.attributeValueProcessor(s, l[s]);
      i = sa(i, t), i === true && t.suppressBooleanAttributes ? e += ` ${s.substr(t.attributeNamePrefix.length)}` : e += ` ${s.substr(t.attributeNamePrefix.length)}="${i}"`;
    }
  return e;
}
function zc(l, t) {
  l = l.substr(0, l.length - t.textNodeName.length - 1);
  let e = l.substr(l.lastIndexOf(".") + 1);
  for (let s in t.stopNodes)
    if (t.stopNodes[s] === l || t.stopNodes[s] === "*." + e)
      return true;
  return false;
}
function sa(l, t) {
  if (l && l.length > 0 && t.processEntities)
    for (let e = 0; e < t.entities.length; e++) {
      const s = t.entities[e];
      l = l.replace(s.regex, s.val);
    }
  return l;
}
var Lc = Dc;
var Nc = Lc;
var kc = {
  attributeNamePrefix: "@_",
  attributesGroupName: false,
  textNodeName: "#text",
  ignoreAttributes: true,
  cdataPropName: false,
  format: false,
  indentBy: "  ",
  suppressEmptyNode: false,
  suppressUnpairedNode: true,
  suppressBooleanAttributes: true,
  tagValueProcessor: function(l, t) {
    return t;
  },
  attributeValueProcessor: function(l, t) {
    return t;
  },
  preserveOrder: false,
  commentPropName: false,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },
    //it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("'", "g"), val: "&apos;" },
    { regex: new RegExp('"', "g"), val: "&quot;" }
  ],
  processEntities: true,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: false
};
function Ge(l) {
  this.options = Object.assign({}, kc, l), this.options.ignoreAttributes || this.options.attributesGroupName ? this.isAttribute = function() {
    return false;
  } : (this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = Uc), this.processTextOrObjNode = Bc, this.options.format ? (this.indentate = Rc, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
    return "";
  }, this.tagEndChar = ">", this.newLine = "");
}
Ge.prototype.build = function(l) {
  return this.options.preserveOrder ? Nc(l, this.options) : (Array.isArray(l) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (l = {
    [this.options.arrayNodeName]: l
  }), this.j2x(l, 0).val);
};
Ge.prototype.j2x = function(l, t) {
  let e = "", s = "";
  for (let i in l)
    if (Object.prototype.hasOwnProperty.call(l, i))
      if (typeof l[i] > "u")
        this.isAttribute(i) && (s += "");
      else if (l[i] === null)
        this.isAttribute(i) ? s += "" : i[0] === "?" ? s += this.indentate(t) + "<" + i + "?" + this.tagEndChar : s += this.indentate(t) + "<" + i + "/" + this.tagEndChar;
      else if (l[i] instanceof Date)
        s += this.buildTextValNode(l[i], i, "", t);
      else if (typeof l[i] != "object") {
        const n = this.isAttribute(i);
        if (n)
          e += this.buildAttrPairStr(n, "" + l[i]);
        else if (i === this.options.textNodeName) {
          let r = this.options.tagValueProcessor(i, "" + l[i]);
          s += this.replaceEntitiesValue(r);
        } else
          s += this.buildTextValNode(l[i], i, "", t);
      } else if (Array.isArray(l[i])) {
        const n = l[i].length;
        let r = "", o = "";
        for (let a = 0; a < n; a++) {
          const c = l[i][a];
          if (!(typeof c > "u"))
            if (c === null)
              i[0] === "?" ? s += this.indentate(t) + "<" + i + "?" + this.tagEndChar : s += this.indentate(t) + "<" + i + "/" + this.tagEndChar;
            else if (typeof c == "object")
              if (this.options.oneListGroup) {
                const h = this.j2x(c, t + 1);
                r += h.val, this.options.attributesGroupName && c.hasOwnProperty(this.options.attributesGroupName) && (o += h.attrStr);
              } else
                r += this.processTextOrObjNode(c, i, t);
            else if (this.options.oneListGroup) {
              let h = this.options.tagValueProcessor(i, c);
              h = this.replaceEntitiesValue(h), r += h;
            } else
              r += this.buildTextValNode(c, i, "", t);
        }
        this.options.oneListGroup && (r = this.buildObjectNode(r, i, o, t)), s += r;
      } else if (this.options.attributesGroupName && i === this.options.attributesGroupName) {
        const n = Object.keys(l[i]), r = n.length;
        for (let o = 0; o < r; o++)
          e += this.buildAttrPairStr(n[o], "" + l[i][n[o]]);
      } else
        s += this.processTextOrObjNode(l[i], i, t);
  return { attrStr: e, val: s };
};
Ge.prototype.buildAttrPairStr = function(l, t) {
  return t = this.options.attributeValueProcessor(l, "" + t), t = this.replaceEntitiesValue(t), this.options.suppressBooleanAttributes && t === "true" ? " " + l : " " + l + '="' + t + '"';
};
function Bc(l, t, e) {
  const s = this.j2x(l, e + 1);
  return l[this.options.textNodeName] !== void 0 && Object.keys(l).length === 1 ? this.buildTextValNode(l[this.options.textNodeName], t, s.attrStr, e) : this.buildObjectNode(s.val, t, s.attrStr, e);
}
Ge.prototype.buildObjectNode = function(l, t, e, s) {
  if (l === "")
    return t[0] === "?" ? this.indentate(s) + "<" + t + e + "?" + this.tagEndChar : this.indentate(s) + "<" + t + e + this.closeTag(t) + this.tagEndChar;
  {
    let i = "</" + t + this.tagEndChar, n = "";
    return t[0] === "?" && (n = "?", i = ""), (e || e === "") && l.indexOf("<") === -1 ? this.indentate(s) + "<" + t + e + n + ">" + l + i : this.options.commentPropName !== false && t === this.options.commentPropName && n.length === 0 ? this.indentate(s) + `<!--${l}-->` + this.newLine : this.indentate(s) + "<" + t + e + n + this.tagEndChar + l + this.indentate(s) + i;
  }
};
Ge.prototype.closeTag = function(l) {
  let t = "";
  return this.options.unpairedTags.indexOf(l) !== -1 ? this.options.suppressUnpairedNode || (t = "/") : this.options.suppressEmptyNode ? t = "/" : t = `></${l}`, t;
};
Ge.prototype.buildTextValNode = function(l, t, e, s) {
  if (this.options.cdataPropName !== false && t === this.options.cdataPropName)
    return this.indentate(s) + `<![CDATA[${l}]]>` + this.newLine;
  if (this.options.commentPropName !== false && t === this.options.commentPropName)
    return this.indentate(s) + `<!--${l}-->` + this.newLine;
  if (t[0] === "?")
    return this.indentate(s) + "<" + t + e + "?" + this.tagEndChar;
  {
    let i = this.options.tagValueProcessor(t, l);
    return i = this.replaceEntitiesValue(i), i === "" ? this.indentate(s) + "<" + t + e + this.closeTag(t) + this.tagEndChar : this.indentate(s) + "<" + t + e + ">" + i + "</" + t + this.tagEndChar;
  }
};
Ge.prototype.replaceEntitiesValue = function(l) {
  if (l && l.length > 0 && this.options.processEntities)
    for (let t = 0; t < this.options.entities.length; t++) {
      const e = this.options.entities[t];
      l = l.replace(e.regex, e.val);
    }
  return l;
};
function Rc(l) {
  return this.options.indentBy.repeat(l);
}
function Uc(l) {
  return l.startsWith(this.options.attributeNamePrefix) && l !== this.options.textNodeName ? l.substr(this.attrPrefixLen) : false;
}
var Fc = Ge;
var Vc = Mc;
var Hc = Fc;
var dn = {
  XMLParser: Vc,
  XMLBuilder: Hc
};
var un = class {
};
E(un, "parser", new dn.XMLParser({
  allowBooleanAttributes: true,
  attributeNamePrefix: "",
  ignoreAttributes: false,
  ignoreDeclaration: true,
  ignorePiTags: true,
  numberParseOptions: { leadingZeros: true, hex: true },
  parseAttributeValue: true,
  preserveOrder: false,
  processEntities: false,
  removeNSPrefix: true,
  trimValues: true
}));
E(un, "builder", new dn.XMLBuilder({
  attributeNamePrefix: "$",
  ignoreAttributes: false,
  suppressBooleanAttributes: false
}));
var Dt = class _Dt {
  /**
   * Creates a new ModelIdMap from the union of multiple ModelIdMaps.
   * @param maps - An array of ModelIdMaps to join.
   * @returns A new ModelIdMap containing all model identifiers and localIds from all input maps.
   */
  static join(t) {
    const e = {};
    for (const s of t)
      for (const i in s)
        if (!e[i])
          e[i] = new Set(s[i]);
        else
          for (const n of s[i])
            e[i].add(n);
    return e;
  }
  /**
   * Creates a new ModelIdMap from the intersection of multiple ModelIdMaps.
   * @param maps - An array of ModelIdMaps.
   * @returns A new ModelIdMap containing only model identifiers and localIds present in all input maps.
   */
  static intersect(t) {
    if (t.length === 0)
      return {};
    let e = _Dt.clone(t[0]);
    for (let s = 1; s < t.length; s++) {
      const i = t[s], n = {};
      for (const r in e)
        if (i[r]) {
          const o = /* @__PURE__ */ new Set();
          for (const a of e[r])
            i[r].has(a) && o.add(a);
          o.size > 0 && (n[r] = o);
        }
      e = n;
    }
    return e;
  }
  /**
   * Creates a deep clone of a ModelIdMap.
   * @param source - The ModelIdMap to clone.
   * @returns A new ModelIdMap with the same model identifiers and localIds as the original.
   */
  static clone(t) {
    const e = {};
    for (const s in t)
      e[s] = new Set(t[s]);
    return e;
  }
  /**
   * Remove all entries from one ModelIdMap to another.
   * @param target - The ModelIdMap to subtract from.
   * @param source - The ModelIdMap to subtract.
   */
  static remove(t, e, s = false) {
    s && (t = _Dt.clone(t));
    for (const i in e)
      if (t[i]) {
        for (const n of e[i])
          t[i].delete(n);
        t[i].size === 0 && delete t[i];
      }
  }
  /**
   * Adds all entries from one ModelIdMap to another.
   * @param target - The ModelIdMap to add to.
   * @param source - The ModelIdMap to add from.
   */
  static add(t, e, s = false) {
    s && (t = _Dt.clone(t));
    for (const i in e)
      if (!t[i])
        t[i] = new Set(e[i]);
      else
        for (const n of e[i])
          t[i].add(n);
  }
  static append(t, e, ...s) {
    let i = t[e];
    i || (i = /* @__PURE__ */ new Set(), t[e] = i);
    for (const n of s)
      i.add(n);
  }
  /**
   * Checks if two ModelIdMaps are equal.
   * @param a - The first ModelIdMap.
   * @param b - The second ModelIdMap.
   * @returns True if the ModelIdMaps are equal, false otherwise.
   */
  static isEqual(t, e) {
    const s = Object.keys(t), i = Object.keys(e);
    if (s.length !== i.length)
      return false;
    for (const n of s) {
      if (!e[n] || t[n].size !== e[n].size)
        return false;
      for (const r of t[n])
        if (!e[n].has(r))
          return false;
    }
    return true;
  }
  /**
   * Checks if a ModelIdMap is empty.
   * @param map - The ModelIdMap to check.
   * @returns True if the ModelIdMap is empty, false otherwise.
   */
  static isEmpty(t) {
    return Object.values(t).reduce(
      (s, i) => s + i.size,
      0
    ) === 0;
  }
  /**
   * Converts a ModelIdMap into a plain JavaScript object with array values.
   * @param map - The ModelIdMap to convert.
   * @returns A plain JavaScript object where each key (model ID) maps to an array of local IDs.
   */
  static toRaw(t) {
    const e = {};
    for (const s in t)
      e[s] = Array.from(t[s]);
    return e;
  }
  /**
   * Creates a ModelIdMap from a plain JavaScript object with array values.
   * @param raw - A plain JavaScript object where each key (model ID) maps to an array of local IDs.
   * @returns A ModelIdMap.
   */
  static fromRaw(t) {
    const e = {};
    for (const s in t)
      e[s] = new Set(t[s]);
    return e;
  }
};
var Es = class extends Map {
  /**
   * Constructs a new DataMap instance.
   *
   * @param iterable - An iterable object containing key-value pairs to populate the map.
   */
  constructor(t) {
    super(t), E(this, "onItemSet", new tt()), E(this, "onItemUpdated", new tt()), E(this, "onItemDeleted", new tt()), E(this, "onCleared", new tt()), E(this, "guard", () => true);
  }
  /**
   * Clears the map and triggers the onCleared event.
   */
  clear() {
    super.clear(), this.onCleared.trigger();
  }
  /**
   * Sets the value for the specified key in the map.
   * If the item is new, then onItemSet is triggered.
   * If the item is already in the map, then onItemUpdated is triggered.
   *
   * @param key - The key of the item to set.
   * @param value - The value of the item to set.
   * @returns The DataMap instance.
   */
  set(t, e) {
    const s = this.has(t);
    if (!(this.guard ?? (() => true))(t, e))
      return this;
    const r = super.set(t, e);
    return s ? (this.onItemUpdated || (this.onItemUpdated = new tt()), this.onItemUpdated.trigger({ key: t, value: e })) : (this.onItemSet || (this.onItemSet = new tt()), this.onItemSet.trigger({ key: t, value: e })), r;
  }
  /**
   * Sets the value in the map with a randomly generated uuidv4 key.
   * Only use this if your keys are strings
   *
   * @param value - The value of the item to set.
   * @returns The key used.
   */
  add(t) {
    const e = Xt.create();
    return this.set(e, t), e;
  }
  /**
   * Deletes the specified key from the map and triggers the onItemDeleted event if the key was found.
   *
   * @param key - The key of the item to delete.
   * @returns True if the key was found and deleted; otherwise, false.
   */
  delete(t) {
    const e = super.delete(t);
    return e && this.onItemDeleted.trigger(t), e;
  }
  /**
   * Clears the map and resets the events.
   */
  dispose() {
    this.clear(), this.onItemSet.reset(), this.onItemDeleted.reset(), this.onCleared.reset();
  }
};
var yn = class {
  static isEntry(t) {
    return (/* @__PURE__ */ new Set([
      "Boolean",
      "Color",
      "Text",
      "Number",
      "Select",
      "Vector3",
      "TextSet",
      "None"
    ])).has(t.type);
  }
  static copySchema(t, e = {}) {
    for (const s in t) {
      const i = t[s];
      this.isEntry(i) ? e[s] = this.copyEntry(i) : (e[s] = {}, this.copySchema(i, e[s]));
    }
    return e;
  }
  static copyEntry(t) {
    if (t.type === "Boolean") {
      const e = t;
      return {
        type: e.type,
        value: e.value
      };
    }
    if (t.type === "Color") {
      const e = t;
      return {
        type: e.type,
        value: e.value.clone()
      };
    }
    if (t.type === "Text") {
      const e = t;
      return {
        type: e.type,
        value: e.value
      };
    }
    if (t.type === "Number") {
      const e = t;
      return {
        type: e.type,
        value: e.value,
        min: e.min,
        max: e.max,
        interpolable: e.interpolable
      };
    }
    if (t.type === "Select") {
      const e = t;
      return {
        type: e.type,
        value: e.value,
        multiple: e.multiple,
        options: new Set(e.options)
      };
    }
    if (t.type === "Vector3") {
      const e = t;
      return {
        type: e.type,
        value: e.value.clone()
      };
    }
    if (t.type === "TextSet") {
      const e = t;
      return {
        type: e.type,
        value: new Set(e.value)
      };
    }
    if (t.type === "None") {
      const e = t;
      return {
        type: e.type,
        value: e.value
      };
    }
    throw new Error("Invalid entry!");
  }
};
var jc = class {
  constructor() {
    E(this, "list", /* @__PURE__ */ new Set());
  }
  /**
   * Adds events to this manager.
   * @param events the events to add.
   */
  add(t) {
    for (const e of t)
      this.list.add(e);
  }
  /**
   * Removes events from this manager.
   * @param events the events to remove.
   */
  remove(t) {
    for (const e of t)
      this.list.delete(e);
  }
  /**
   * Sets all the events managed by this instance as enabled or disabled.
   * @param active whether to turn on or off the events.
   */
  set(t) {
    for (const e of this.list)
      e.enabled = t;
  }
  /**
   * Resets all the events managed by this instance.
   */
  reset() {
    for (const t of this.list)
      t.reset();
  }
};
var fn = class {
  constructor(t, e, s, i) {
    E(this, "_component"), E(this, "name"), E(this, "uuid"), this._component = t, this.name = s, this.uuid = i ?? Xt.create(), e.get(_r).list.set(this.uuid, this);
  }
  get controls() {
    return yn.copySchema(this._config);
  }
  set(t) {
    for (const e in t)
      if (e in this) {
        const s = e;
        this[s] = t[e].value;
      }
  }
  export(t = this._config, e = {}) {
    for (const s in t) {
      const i = t[s];
      if (yn.isEntry(i))
        if (i.type === "Color") {
          const { r, g: o, b: a } = i.value;
          e[s] = { ...i, value: { r, g: o, b: a } };
        } else if (i.type === "Vector3") {
          const { x: r, y: o, z: a } = i.value;
          e[s] = { ...i, value: { x: r, y: o, z: a } };
        } else if (i.type === "TextSet") {
          const r = Array.from(i.value);
          e[s] = { ...i, value: r };
        } else if (i.type === "Select") {
          const r = Array.from(i.options);
          e[s] = { ...i, options: r };
        } else
          e[s] = { ...i };
      else
        e[s] = {}, this.export(i, e[s]);
    }
    return e;
  }
  import(t, e = {}, s = true) {
    for (const i in t) {
      const n = t[i];
      if (yn.isEntry(n))
        if (n.type === "Color") {
          const { r: o, g: a, b: c } = n.value;
          e[i] = { ...n, value: new Color(o, a, c) };
        } else if (n.type === "Vector3") {
          const { x: o, y: a, z: c } = n.value;
          e[i] = { ...n, value: new Vector3(o, a, c) };
        } else
          n.type === "TextSet" ? e[i] = { ...n, value: new Set(n.value) } : n.type === "Select" ? e[i] = { ...n, options: new Set(n.options) } : e[i] = { ...n };
      else
        e[i] = {}, this.import(n, e[i], false);
    }
    s && this.set(e);
  }
};
var ia = class na extends St {
  constructor(t) {
    super(t), E(this, "list", new Es()), E(this, "enabled", true), t.add(na.uuid, this);
  }
};
E(ia, "uuid", "b8c764e0-6b24-4e77-9a32-35fa728ee5b4");
var _r = ia;
var Wc = class {
  constructor(t) {
    E(this, "_event"), E(this, "_position", new Vector2()), E(this, "onDisposed", new tt()), E(this, "updateMouseInfo", (e) => {
      this._event = e;
    }), this.dom = t, this.setupEvents(true);
  }
  /**
   * The real position of the mouse or touch of the Three.js canvas.
   */
  get position() {
    return this.updatePosition(false), this._position.clone();
  }
  /**
   * The raw position of the mouse or touch of the Three.js canvas.
   */
  get rawPosition() {
    return this.updatePosition(true), this._position.clone();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  updatePosition(t) {
    if (this._event) {
      const e = this.dom.getBoundingClientRect();
      this._position.x = this.getPositionX(e, this._event, t), this._position.y = this.getPositionY(e, this._event, t);
    }
  }
  getPositionY(t, e, s) {
    const i = this.getDataObject(e);
    return s ? i.clientY : -((i.clientY - t.top) / (t.bottom - t.top)) * 2 + 1;
  }
  getPositionX(t, e, s) {
    const i = this.getDataObject(e);
    return s ? i.clientX : (i.clientX - t.left) / (t.right - t.left) * 2 - 1;
  }
  getDataObject(t) {
    return t instanceof MouseEvent ? t : t.touches[0];
  }
  setupEvents(t) {
    t ? (this.dom.addEventListener("pointermove", this.updateMouseInfo), this.dom.addEventListener("touchstart", this.updateMouseInfo)) : (this.dom.removeEventListener("pointermove", this.updateMouseInfo), this.dom.removeEventListener("touchstart", this.updateMouseInfo));
  }
};
var ra = class oa extends St {
  constructor(t) {
    super(t), E(this, "onDisposed", new tt()), E(this, "onFragmentsLoaded", new tt()), E(this, "baseCoordinationModel", ""), E(this, "baseCoordinationMatrix", new Matrix4()), E(this, "enabled", true), E(this, "initialized", false), E(this, "_core"), this.components.add(oa.uuid, this);
  }
  /**
   * Map containing all loaded fragment models.
   * The key is the group's unique identifier, and the value is the model itself.
   */
  get list() {
    return this.core.models.list;
  }
  get core() {
    if (!this._core)
      throw new Error("FragmentsManager not initialized. Call init() first.");
    return this._core;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._core && (this.core.dispose(), this._core = void 0), this.baseCoordinationModel = "", this.onFragmentsLoaded.reset(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  init(t) {
    this._core = new cd(t), this.initialized = true, this.core.onModelLoaded.add(async (e) => {
      this.list.size === 1 && (this.baseCoordinationModel = e.modelId, this.baseCoordinationMatrix = await e.getCoordinationMatrix());
    }), this.list.onItemDeleted.add(() => {
      this.list.size > 0 || (this.baseCoordinationModel = "", this.baseCoordinationMatrix = new Matrix4());
    });
  }
  async raycast(t) {
    const e = [];
    for (const n of this.core.models.list.values())
      if (t.snappingClasses && t.snappingClasses.length > 0) {
        const r = await n.raycastWithSnapping(
          t
        );
        if (r && r.length > 0)
          e.push(r[0]);
        else {
          const o = await n.raycast(t);
          o && e.push(o);
        }
      } else {
        const r = await n.raycast(t);
        r && e.push(r);
      }
    if (await Promise.all(e), e.length === 0)
      return;
    let s = e[0], i = s.distance;
    for (let n = 1; n < e.length; n++)
      e[n].distance < i && (i = e[n].distance, s = e[n]);
    return s;
  }
  async getPositions(t) {
    const e = [], s = async (n, r) => {
      const o = await n.getPositions(r);
      for (const a of o)
        e.push(a);
    }, i = [];
    for (const n in t) {
      const r = this.core.models.list.get(n);
      r && i.push(s(r, Array.from(t[n])));
    }
    return await Promise.all(i), e;
  }
  async getBBoxes(t) {
    const e = [], s = async (n, r) => {
      const o = await n.getBoxes(r);
      if (o)
        for (const a of o)
          e.push(a);
    }, i = [];
    for (const n in t) {
      const r = this.core.models.list.get(n);
      r && i.push(s(r, Array.from(t[n])));
    }
    return await Promise.all(i), e;
  }
  async highlight(t, e) {
    await this.forEachModel(e, "highlight", t);
  }
  /**
   * Retrieves data for specified items from multiple models.
   *
   * @param items A map of model IDs to an array of local IDs, specifying which items to retrieve data for.
   * @param config Optional configuration for data retrieval.
   * @returns A record mapping model IDs to an array of item data.
   */
  async getData(t, e) {
    const s = {};
    for (const [i, n] of Object.entries(t)) {
      const r = this.list.get(i);
      if (!r)
        continue;
      const o = await r.getItemsData([...n], e);
      s[i] = o;
    }
    return s;
  }
  async resetHighlight(t) {
    await this.forEachModel(t, "resetHighlight");
  }
  async forEachModel(t, e, ...s) {
    const i = {};
    if (t)
      for (const r in t) {
        const o = t[r];
        i[r] = Array.from(o);
      }
    else
      for (const r of this.core.models.list.keys())
        i[r] = void 0;
    const n = [];
    for (const r in i) {
      const o = this.core.models.list.get(r);
      if (o) {
        const a = i[r], c = o[e](a, ...s);
        n.push(c);
      }
    }
    await Promise.all(n);
  }
  /**
   * Converts a collection of IFC GUIDs to a fragmentIdMap.
   *
   * @param guids - An iterable collection of global IDs to be converted to a fragment ID map.
   *
   * @returns A fragment ID map, where the keys are fragment IDs and the values are the corresponding express IDs.
   */
  async guidsToModelIdMap(t) {
    const e = {};
    for (const [s, i] of this.list) {
      const n = (await i.getLocalIdsByGuids([...t])).filter(
        (r) => r !== null
      );
      e[s] = new Set(n);
    }
    return e;
  }
  /**
   * Converts a fragment ID map to a collection of GUIDs.
   *
   * @param modelIdMap - A ModelIdMap to be converted to a collection of GUIDs.
   *
   * @returns An array of GUIDs.
   */
  async modelIdMapToGuids(t) {
    const e = [];
    for (const [s, i] of Object.entries(t)) {
      const n = this.list.get(s);
      if (!n)
        continue;
      const r = (await n.getGuidsByLocalIds([...i])).filter(
        (o) => o !== null
      );
      e.push(...r);
    }
    return e;
  }
  // /**
  //  * Applies coordinate transformation to the provided models.
  //  * If no models are provided, all groups are used.
  //  * The first model in the list becomes the base model for coordinate transformation.
  //  * All other models are then transformed to match the base model's coordinate system.
  //  *
  //  * @param models - The models to apply coordinate transformation to.
  //  * If not provided, all models are used.
  //  */
  // coordinate(models = Array.from(this.groups.values())) {
  //   const isFirstModel = this.baseCoordinationModel.length === 0;
  //   if (isFirstModel) {
  //     const first = models.pop();
  //     if (!first) {
  //       return;
  //     }
  //     this.baseCoordinationModel = first.uuid;
  //     this.baseCoordinationMatrix = first.coordinationMatrix.clone();
  //   }
  //   if (!models.length) {
  //     return;
  //   }
  //   for (const model of models) {
  //     if (model.coordinationMatrix.equals(this.baseCoordinationMatrix)) {
  //       continue;
  //     }
  //     model.position.set(0, 0, 0);
  //     model.rotation.set(0, 0, 0);
  //     model.scale.set(1, 1, 1);
  //     model.updateMatrix();
  //     this.applyBaseCoordinateSystem(model, model.coordinationMatrix);
  //   }
  // }
  /**
   * Applies the base coordinate system to the provided object.
   *
   * This function takes an object and its original coordinate system as input.
   * It then inverts the original coordinate system and applies the base coordinate system
   * to the object. This ensures that the object's position, rotation, and scale are
   * transformed to match the base coordinate system (which is taken from the first model loaded).
   *
   * @param object - The object to which the base coordinate system will be applied.
   * This should be an instance of THREE.Object3D.
   *
   * @param originalCoordinateSystem - The original coordinate system of the object.
   * This should be a THREE.Matrix4 representing the object's transformation matrix.
   */
  applyBaseCoordinateSystem(t, e) {
    const s = new Matrix4();
    return e && s.copy(e.clone()).invert(), s.multiply(this.baseCoordinationMatrix), t.applyMatrix4(s), s;
  }
};
E(ra, "uuid", "fef46874-46a3-461b-8c44-2922ab77c806");
var ct = ra;
var Xc = class {
  constructor() {
    E(this, "wasm", {
      path: "",
      absolute: false,
      logLevel: LogLevel.LOG_LEVEL_OFF
    }), E(this, "webIfc", {
      COORDINATE_TO_ORIGIN: true
      // OPTIMIZE_PROFILES: true,
    }), E(this, "autoSetWasm", true), E(this, "customLocateFileHandler", null);
  }
};
var Yc = class Kn extends St {
  constructor(t) {
    super(t), E(this, "onDisposed", new tt()), E(this, "onIfcStartedLoading", new tt()), E(this, "onSetup", new tt()), E(this, "settings", new Xc()), E(this, "webIfc", new IfcAPI2()), E(this, "enabled", true), this.components.add(Kn.uuid, this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.webIfc = null, this.onDisposed.trigger(Kn.uuid), this.onDisposed.reset();
  }
  /**
   * Sets up the IfcLoader component with the provided configuration.
   *
   * @param config - Optional configuration settings for the IfcLoader.
   * If not provided, the existing settings will be used.
   *
   * @returns A Promise that resolves when the setup process is completed.
   *
   * @remarks
   * If the `autoSetWasm` option is enabled in the configuration,
   * the method will automatically set the WASM paths for the Web-IFC library.
   *
   * @example
   * ```typescript
   * const ifcLoader = new IfcLoader(components);
   * await ifcLoader.setup({ autoSetWasm: true });
   * ```
   */
  async setup(t) {
    this.settings = { ...this.settings, ...t }, this.settings.autoSetWasm && await this.autoSetWasm(), this.onSetup.trigger();
  }
  /**
   * Loads an IFC file and processes it for 3D visualization.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @param coordinate - Optional boolean indicating whether to coordinate the loaded IFC data. Default is true.
   * @param name - Optional name for the fragments model.
   * @param config - Optional extra data for loading the IFC.
   *
   * @returns A Promise that resolves to the FragmentsModel containing the loaded and processed IFC data.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * const model = await ifcLoader.load(ifcData);
   * ```
   */
  async load(t, e, s, i) {
    const n = this.components.get(ct);
    if (!n.initialized)
      throw new Error("You need to initialize fragments first.");
    this.settings.autoSetWasm && await this.autoSetWasm(), n.core.settings.autoCoordinate = e;
    const r = new Sd();
    r.wasm.path = this.settings.wasm.path, r.wasm.absolute = this.settings.wasm.absolute, i != null && i.instanceCallback && i.instanceCallback(r);
    const o = await r.process({
      ...i == null ? void 0 : i.processData,
      bytes: t
    });
    return await n.core.load(o, {
      modelId: s,
      userData: i == null ? void 0 : i.userData
    });
  }
  /**
   * Reads an IFC file and initializes the Web-IFC library.
   *
   * @param data - The Uint8Array containing the IFC file data.
   *
   * @returns A Promise that resolves when the IFC file is opened and initialized.
   *
   * @remarks
   * This method sets the WASM path and initializes the Web-IFC library based on the provided settings.
   * It also opens the IFC model using the provided data and settings.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * await ifcLoader.readIfcFile(ifcData);
   * ```
   */
  async readIfcFile(t) {
    const { path: e, absolute: s, logLevel: i } = this.settings.wasm;
    return this.webIfc.SetWasmPath(e, s), await this.webIfc.Init(this.settings.customLocateFileHandler || void 0), i && this.webIfc.SetLogLevel(i), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  /**
   * Cleans up the IfcLoader component by resetting the Web-IFC library,
   * clearing the visited fragments and fragment instances maps, and creating a new instance of the Web-IFC library.
   *
   * @remarks
   * This method is called automatically after using the .load() method, so usually you don't need to use it manually.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * ifcLoader.cleanUp();
   * ```
   */
  cleanUp() {
    try {
      this.webIfc.Dispose();
    } catch {
      console.log("Web-ifc wasn't disposed.");
    }
    this.webIfc = null, this.webIfc = new IfcAPI2();
  }
  async autoSetWasm() {
    const t = await fetch(
      `https://unpkg.com/@thatopen/components@${Pa.release}/package.json`
    );
    if (!t.ok) {
      console.warn(
        "Couldn't get openbim-components package.json. Set wasm settings manually."
      );
      return;
    }
    const e = await t.json();
    if (!("web-ifc" in e.peerDependencies))
      console.warn(
        "Couldn't get web-ifc from peer dependencies in openbim-components. Set wasm settings manually."
      );
    else {
      const s = e.peerDependencies["web-ifc"];
      this.settings.wasm.path = `https://unpkg.com/web-ifc@${s}/`, this.settings.wasm.absolute = true;
    }
  }
};
E(Yc, "uuid", "a659add7-1418-4771-a0d6-7d4d438e4624");
var aa = class la extends St {
  constructor(t) {
    super(t), E(this, "enabled", true), this.components.add(la.uuid, this);
  }
  /**
   * Sets the visibility of fragment items within the 3D scene.
   * If no `modelIdMap` parameter is provided, all fragments will be set to the specified visibility.
   * If it is provided, only the specified fragment items will be affected.
   *
   * @param visible - The visibility state to set for the items.
   * @param modelIdMap - An optional map of modelIds and their corresponding itemIds to be affected.
   * If not provided, all fragment items will be affected.
   */
  async set(t, e) {
    const s = this.components.get(ct), i = [];
    if (e)
      for (const [n, r] of Object.entries(e)) {
        const o = s.list.get(n);
        o && i.push(o.setVisible([...r], t));
      }
    else
      for (const n of s.list.values())
        i.push(n.setVisible(void 0, t));
    await Promise.all(i), await s.core.update(true);
  }
  /**
   * Isolates fragments within the 3D scene by hiding all other fragments and showing only the specified ones.
   * It calls the `set` method twice: first to hide all fragments, and then to show only the specified ones.
   *
   * @param modelIdMap - A map of model IDs and their corresponding itemIds to be isolated.
   */
  async isolate(t) {
    await Promise.all([
      this.set(false),
      // Hides all fragments
      this.set(true, t)
      // Shows only the specified fragments
    ]);
  }
  /**
   * Toggles the visibility of specified items in the fragments.
   *
   * @param modelIdMap - An object where the keys are model IDs and the values are arrays of local IDs representing the fragments to be toggled.
   * @returns A promise that resolves when all visibility toggles and the core update are complete.
   */
  async toggle(t) {
    const e = [], s = this.components.get(ct);
    for (const [i, n] of Object.entries(t)) {
      const r = s.list.get(i);
      r && e.push(r.toggleVisible([...n]));
    }
    await Promise.all(e), await s.core.update(true);
  }
  /**
   * Asynchronously retrieves a map of model IDs to their corresponding item IDs based on visibility state.
   *
   * @param state - The visibility state to filter items by.
   * @param modelIds - Optional array of model IDs to filter the items. If not provided, all models will be considered.
   * @returns A promise that resolves to a ModelIdMap record where the keys are model IDs and the values are arrays of item IDs that match the visibility state.
   */
  async getVisibilityMap(t, e) {
    const s = [], i = [], n = this.components.get(ct);
    if (e)
      for (const a of e) {
        const c = n.list.get(a);
        c && (s.push(c.modelId), i.push(c.getItemsByVisibility(t)));
      }
    else
      for (const a of n.list.values())
        s.push(a.modelId), i.push(a.getItemsByVisibility(t));
    const r = await Promise.all(i), o = {};
    for (const [a, c] of s.entries())
      o[c] = r[a];
    return o;
  }
};
E(aa, "uuid", "dd9ccf2d-8a21-4821-b7f6-2949add16a29");
var Gc = aa;
var ca = class Jn extends St {
  constructor(t) {
    super(t), E(this, "enabled", true), E(this, "onDisposed", new tt()), E(this, "list", new Wt()), this.components.add(Jn.uuid, this);
  }
  /** {@link Disposable.dispose} */
  dispose(t = true) {
    this.list.clear(), this.onDisposed.trigger(Jn.uuid), t && (this.onDisposed.reset(), this.list.eventsEnabled = false, this.list.dispose());
  }
  /**
   * Combines all bounding boxes in the `list` property into a single bounding box.
   *
   * @returns A `THREE.Box3` instance representing the union of all bounding boxes in the `list`.
   */
  get() {
    const t = new Box3();
    for (const e of this.list)
      t.union(e);
    return t;
  }
  /**
   * Asynchronously adds bounding boxes to the list by merging boxes from models
   * specified in the provided `ModelIdMap`.
   *
   * @param items - A map where keys are model IDs and values are arrays of local IDs
   *                representing specific parts of the models to include in the bounding box.
   */
  async addFromModelIdMap(t) {
    const e = this.components.get(ct), s = new Box3();
    for (const [i, n] of Object.entries(t)) {
      const r = e.list.get(i);
      if (!r)
        continue;
      const o = await r.getMergedBox([...n]);
      s.union(o);
    }
    this.list.add(s);
  }
  /**
   * Adds bounding boxes from models to the current list based on optional filtering criteria.
   *
   * @param modelIds - An optional array of regular expressions used to filter models by their IDs.
   *                   If provided, only models whose IDs match at least one of the regular expressions
   *                   will have their bounding boxes added to the list. If not, all models will be used.
   */
  addFromModels(t) {
    const e = this.components.get(ct);
    for (const [s, i] of e.list)
      t && !t.some((n) => n.test(s)) || this.list.add(i.box);
  }
  /**
   * Calculates and returns the center point of the bounding box derived from the provided model ID map.
   *
   * @param modelIdMap - A mapping of model IDs and localIds used to generate the bounding box.
   * @returns A `THREE.Vector3` object representing the center point of the bounding box.
   */
  async getCenter(t) {
    this.list.clear(), await this.addFromModelIdMap(t);
    const e = this.get();
    this.list.clear();
    const s = new Vector3();
    return e.getCenter(s), s;
  }
  /**
   * Calculates the camera orientation and position based on the specified orientation
   * and an optional offset factor.
   *
   * @param orientation - Specifies the direction of the camera relative to the bounding box.
   * @param offsetFactor - A multiplier applied to the distance between the camera and the bounding box.
   *                       Defaults to `1`.
   * @returns An object containing:
   *          - `position`: A `THREE.Vector3` representing the calculated camera position.
   *          - `target`: A `THREE.Vector3` representing the center of the bounding box, which the camera should target.
   */
  async getCameraOrientation(t, e = 1) {
    const s = this.components.get(ct);
    this.list.clear();
    for (const [c, h] of s.list)
      this.list.add(h.box);
    const i = this.get();
    this.list.clear();
    const n = new Vector3();
    i.getCenter(n);
    const r = new Vector3();
    i.getSize(r);
    const o = Math.max(r.x, r.y, r.z) * e, a = new Vector3();
    switch (t) {
      case "front":
        a.set(n.x, n.y, n.z + o);
        break;
      case "back":
        a.set(n.x, n.y, n.z - o);
        break;
      case "left":
        a.set(n.x - o, n.y, n.z);
        break;
      case "right":
        a.set(n.x + o, n.y, n.z);
        break;
      case "top":
        a.set(n.x, n.y + o, n.z);
        break;
      case "bottom":
        a.set(n.x, n.y - o, n.z);
        break;
      default:
        a.set(n.x, n.y, n.z + o);
    }
    return { position: a, target: n };
  }
};
E(ca, "uuid", "d1444724-dba6-4cdd-a0c7-68ee1450d166");
var ha = ca;
var Zc = class {
  constructor(t, e) {
    E(this, "description"), E(this, "_components"), E(this, "_queries", []), E(this, "_aggregation", "exclusive"), E(this, "result", null), E(this, "cache", true), E(this, "serializeQueryParameters", (s) => {
      var i;
      return {
        categories: (i = s.categories) == null ? void 0 : i.map((r) => r.source),
        attributes: s.attributes ? {
          aggregation: s.attributes.aggregation,
          queries: s.attributes.queries.map(
            this.serializeAttributeQuery
          )
        } : void 0,
        relation: s.relation ? {
          name: s.relation.name,
          query: s.relation.query ? this.serializeQueryParameters(s.relation.query) : void 0
        } : void 0
      };
    }), E(this, "deserializeQueryParameters", (s) => {
      var i;
      return {
        categories: (i = s.categories) == null ? void 0 : i.map((r) => new RegExp(r)),
        attributes: s.attributes ? {
          aggregation: s.attributes.aggregation,
          queries: s.attributes.queries.map(
            this.deserializeAttributeQuery
          )
        } : void 0,
        relation: s.relation ? {
          name: s.relation.name,
          query: s.relation.query ? this.deserializeQueryParameters(s.relation.query) : void 0
        } : void 0
      };
    }), this._components = t, this.queries = e;
  }
  /**
   * The query parameters used to find items.
   */
  set queries(t) {
    this._queries = t, this.clearCache();
  }
  get queries() {
    return this._queries;
  }
  /**
   * Sets the aggregation value (AND/OR) for the query and resets the cache if the new value differs.
   */
  set aggregation(t) {
    t !== this._aggregation && this.clearCache(), this._aggregation = t;
  }
  get aggregation() {
    return this._aggregation;
  }
  /**
   * Executes the finder query to retrieve items based on the configured query and optional model IDs.
   *
   * @param config - Optional configuration object.
   * @param config.modelIds - Optional array of model IDs to filter the search.
   * @param config.force - Optional boolean to force a new search, bypassing the cache. Defaults to `false`.
   * @returns A promise that resolves to a `ModelIdMap` containing the search results.
   */
  async test(t) {
    const { modelIds: e, force: s } = { force: false, ...t };
    if (this.result && !s)
      return this.result;
    const n = await this._components.get(Xi).getItems(this.queries, {
      modelIds: e,
      aggregation: this.aggregation
    });
    return this.cache && (this.result = n), n;
  }
  /**
   * Clears the cached result of the query, forcing a re-evaluation on the next access.
   */
  clearCache() {
    this.result = null;
  }
  serializeAttributeQuery(t) {
    let e;
    return Array.isArray(t.value) ? e = t.value.map((i) => i.source) : t.value instanceof RegExp ? e = t.value.source : e = t.value, {
      name: t.name.source,
      value: e,
      type: t.type instanceof RegExp ? t.type.source : t.type,
      negate: t.negate,
      itemIds: t.itemIds
    };
  }
  /**
   * Serializes the finder query into a JSON-compatible format.
   * Converts regular expressions to strings.
   *
   * @returns A `SerializedFinderQuery` object representing the serialized query.
   */
  toJSON() {
    return {
      name: "Finder Query",
      description: this.description,
      queries: this.queries.map(this.serializeQueryParameters),
      aggregation: this.aggregation,
      cache: this.cache
    };
  }
  deserializeAttributeQuery(t) {
    let e;
    return Array.isArray(t.value) ? e = t.value.map((i) => new RegExp(i)) : typeof t.value == "string" ? e = new RegExp(t.value) : e = t.value, {
      name: new RegExp(t.name),
      value: e,
      type: t.type ? new RegExp(t.type) : void 0,
      negate: t.negate,
      itemIds: t.itemIds
    };
  }
  /**
   * Deserializes a JSON object into a `FinderQuery` instance.
   *
   * @param data - A `SerializedFinderQuery` object representing the serialized query.
   * @returns A `FinderQuery` instance.
   */
  fromJSON(t) {
    return this.description = t.description, this.aggregation = t.aggregation, this.cache = t.cache, this.queries = t.queries.map(this.deserializeQueryParameters), this;
  }
};
var da = class ua extends St {
  constructor(t) {
    super(t), E(this, "enabled", true), E(this, "list", new Yt()), t.add(ua.uuid, this);
  }
  // private clearCache() {
  //   for (const [, finderQuery] of this.list) {
  //     finderQuery.clearCache();
  //   }
  // }
  /**
   * Retrieves items from specified models based on a query.
   *
   * @param queries - The query parameters to filter items.
   * @param modelIds - Optional array of model IDs to include in the search. If not provided, all models are searched.
   * @returns A map of model IDs to sets of item IDs that match the query.
   */
  async getItems(t, e) {
    const { modelIds: s } = e ?? {}, i = (e == null ? void 0 : e.aggregation) ?? "exclusive", n = this.components.get(ct), r = await Promise.all(
      t.map(async (a) => {
        const c = {};
        return await Promise.all(
          Array.from(n.list).map(async ([h, d]) => {
            if (s && !s.some((f) => f.test(h)))
              return;
            const u = await d.getItemsByQuery(a);
            c[h] = new Set(u);
          })
        ), c;
      })
    );
    return i === "inclusive" ? Dt.join(r) : Dt.intersect(r);
  }
  /**
   * Creates a new FinderQuery instance and adds it to the list of queries.
   *
   * @param name - The name of the query.
   * @param queries - The queries to use.
   * @returns The newly created FinderQuery instance.
   */
  create(t, e) {
    const s = new Zc(this.components, e);
    return this.list.set(t, s), s;
  }
  /**
   * Adds queries based on categories from items that have geometry.
   *
   * @param modelIds - An optional array of model IDs to filter fragments. If not provided, all fragments are processed.
   * @returns An array with the categories used to create the queries
   */
  async addFromCategories(t) {
    const e = /* @__PURE__ */ new Set(), s = this.components.get(ct);
    for (const [i, n] of s.list) {
      if (t && !t.some((a) => a.test(i)))
        continue;
      const r = (await n.getItemsWithGeometryCategories()).filter(
        (a) => a !== null
      ), o = new Set(r);
      for (const a of o)
        this.list.has(a) || (this.create(a, [{ categories: [new RegExp(`^${a}$`)] }]), e.add(a));
    }
    return [...e];
  }
  /**
   * Imports a list of `FinderQuery` instances from a `SerializationResult` containing serialized finder query data.
   *
   * @param result - The `SerializationResult` containing the serialized `SerializedFinderQuery` data.
   * @returns An array of `FinderQuery` instances created from the serialized data. Returns an empty array if the input data is null or undefined.
   */
  import(t) {
    const { data: e } = t, s = [];
    if (!e)
      return s;
    for (const i of e) {
      const { name: n, description: r, queries: o, aggregation: a, cache: c } = i, h = this.create(n, []);
      h.fromJSON({ description: r, queries: o, aggregation: a, cache: c }), s.push(h);
    }
    return s;
  }
  /**
   * Serializes the ItemsFinder's data into a format suitable for export.
   *
   * @returns An object containing an array of serialized finder queries.
   */
  export() {
    const t = [];
    for (const [e, s] of this.list.entries()) {
      const n = {
        ...s.toJSON(),
        name: e
      };
      t.push(n);
    }
    return { data: t };
  }
};
E(da, "uuid", "0da7ad77-f734-42ca-942f-a074adfd1e3a");
var Xi = da;
var fa = class pa extends St {
  constructor(t) {
    super(t), E(this, "enabled", true), E(this, "onDisposed", new tt()), E(this, "list", new Yt()), E(this, "defaultSaveFunction", (s) => "value" in s.Name ? s.Name.value : null), E(this, "onBeforeFragmentsDispose", async (s) => {
      const { key: i, value: n } = s, r = await n.getLocalIds(), o = { [i]: new Set(r) };
      this.removeItems(o);
    }), t.add(pa.uuid, this), this.setupEvents(), t.get(ct).list.onBeforeDelete.add(this.onBeforeFragmentsDispose);
  }
  setupEvents() {
    this.list.onBeforeDelete.add(({ value: t }) => t.dispose());
  }
  getClassificationGroups(t) {
    let e = this.list.get(t);
    return e || (e = new Yt(), this.list.set(t, e)), e;
  }
  getModelItems(t, e, s) {
    const { map: i } = this.getGroupData(t, e);
    let n = i[s];
    return n || (n = /* @__PURE__ */ new Set(), i[s] = n), n;
  }
  /**
   * Retrieves data associated with a specific group within a classification.
   * If the group data does not exist, it creates a new entry.
   *
   * @param classification - The classification string.
   * @param group - The group string within the classification.
   * @returns The data object associated with the group, containing a map and a `get` method.
   */
  getGroupData(t, e) {
    const s = this.components.get(Xi), i = this.getClassificationGroups(t);
    let n = i.get(e);
    return n || (n = {
      map: {},
      // TODO: Evaluate if this is the best option for this
      get() {
        return new Promise((r) => {
          if (!n) {
            r({});
            return;
          }
          if (n.query) {
            const { name: o, config: a } = n.query, c = s.list.get(o);
            if (!c)
              throw new Error(
                "Classifier: the query name associated with the group doesn't exist in the ItemsFinder component"
              );
            c.test(a).then((h) => {
              if (!n) {
                r({});
                return;
              }
              const d = Dt.join([h, n.map]);
              r(d);
            });
          } else
            r(n.map);
        });
      }
    }, i.set(e, n)), n;
  }
  /**
   * Aggregates items based on a classification and query, applying a provided function to each item.
   *
   * @param classification - The classification string used to categorize the items.
   * @param query - The query parameters used to find items.
   * @param config - Optional configuration for data and item processing.
   * @param config.data - Optional data configuration to pass to the item retrieval.
   * @param config.aggregationCallback - Optional function to apply to each item; defaults to `this.defaultSaveFunction` if not provided.
   *                       This function receives the item data and a register function to associate item local IDs with names.
   *                       If no function is provided, the default save function is used.
   *
   * @remarks
   * The `register` function within the `config.func` allows associating item local IDs with a given name under the specified classification.
   * It is used to keep track of which items belong to which classification.
   */
  async aggregateItems(t, e, s) {
    const i = (s == null ? void 0 : s.data) ?? void 0, n = (s == null ? void 0 : s.aggregationCallback) ?? this.defaultSaveFunction, r = this.components.get(ct), a = await this.components.get(Xi).getItems([e], {
      modelIds: s == null ? void 0 : s.modelIds
    });
    for (const [c, h] of Object.entries(a)) {
      const d = r.list.get(c);
      if (!d)
        continue;
      const u = (g, ...m) => {
        const _ = this.getModelItems(t, g, c);
        for (const p of m)
          _.add(p);
      }, f = await d.getItemsData([...h], i);
      for (const g of f)
        n(g, u);
    }
  }
  /**
   * Adds items to a specific group within a classification.
   *
   * @param classification - The classification to which the group belongs.
   * @param group - The group to which the items will be added.
   * @param items - A map of model IDs to add to the group.
   */
  addGroupItems(t, e, s) {
    const { map: i } = this.getGroupData(t, e);
    Dt.add(i, s);
  }
  /**
   * Sets the query for a specific group within a classification.
   *
   * @param classification - The classification to target.
   * @param group - The group within the classification to target.
   * @param query - The query to set for the group.
   */
  setGroupQuery(t, e, s) {
    const i = this.getGroupData(t, e);
    i.query = s;
  }
  /**
   * Asynchronously finds a set of ModelIdMaps based on the provided classification data.
   * @param data An object with classifications as keys and an array of groups as values.
   * @returns A promise that resolves to a ModelIdMap representing the intersection of all ModelIdMaps found.
   */
  async find(t) {
    const e = [];
    for (const [i, n] of Object.entries(t)) {
      const r = [], o = this.list.get(i);
      if (!o)
        continue;
      for (const c of n) {
        const h = o.get(c);
        if (!h)
          continue;
        const d = await h.get();
        r.push(d);
      }
      const a = Dt.join(r);
      e.push(a);
    }
    return Dt.intersect(e);
  }
  /**
   * From the items passing the query, use the specified relation to create groupings
   * This method retrieves and processes related items, applying a custom aggregation callback to register
   * relations between items based on their attributes and local IDs.
   *
   * @param classification - The classification type used to filter items.
   * @param query - Query parameters for filtering items, defined by `FRAGS.ItemsQueryParams`.
   * @param relation - The type of relation to aggregate (e.g., "ContainedInStructure", "HasAssociations").
   * @param config - Optional configuration for the aggregation process.
   * @returns A promise that resolves when the aggregation process is complete.
   * @remarks
   * - The `aggregationCallback` function processes each item and registers relations based on the item's
   *   attribute value and the local ID of its relations.
   * - Items without the specified attribute or relations are ignored during aggregation.
   */
  async aggregateItemRelations(t, e, s, i) {
    const n = (i == null ? void 0 : i.attribute) ?? "Name", r = {
      relations: {
        [s]: { attributes: true, relations: false }
      }
    };
    await this.aggregateItems(t, e, {
      modelIds: i == null ? void 0 : i.modelIds,
      data: r,
      aggregationCallback: (o, a) => {
        if (!(o != null && o[n]))
          return;
        const c = o[n];
        if (!("value" in c))
          return;
        const h = o[s];
        if (Array.isArray(h))
          for (const d of h)
            "value" in d._localId && a(c.value, d._localId.value);
      }
    });
  }
  /**
   * Asynchronously processes and adds classifications by IfcBuildingStorey.
   * @param config - Optional configuration for adding classifications.
   * @returns A promise that resolves once the storeys have been processed and added.
   */
  async byIfcBuildingStorey(t) {
    await this.aggregateItemRelations(
      (t == null ? void 0 : t.classificationName) ?? "Storeys",
      { categories: [/BUILDINGSTOREY/] },
      "ContainsElements",
      { modelIds: t == null ? void 0 : t.modelIds }
    );
  }
  /**
   * Asynchronously processes and adds classifications by category.
   * @param config - Optional configuration for adding classifications.
   * @returns A promise that resolves once the categories have been processed and added.
   */
  async byCategory(t) {
    const s = await this.components.get(Xi).addFromCategories(t == null ? void 0 : t.modelIds);
    for (const i of s)
      this.setGroupQuery((t == null ? void 0 : t.classificationName) ?? "Categories", i, {
        name: i
      });
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.list.clear(), this.components.get(ct).list.onBeforeDelete.remove(this.onBeforeFragmentsDispose), this.onDisposed.trigger();
  }
  /**
   * Removes items from the classifier based on the provided model ID map and configuration.
   *
   * @param modelIdMap - A map containing model IDs to be removed.
   * @param config - Optional configuration for removing items.s.
   * @remarks If no configuration is provided, items will be removed from all classifications
   */
  removeItems(t, e) {
    if (e && e.classificationName) {
      const s = this.list.get(e.classificationName);
      if (!s || e.groupName && !s.get(e.groupName))
        return;
      for (const [, i] of s)
        Dt.remove(i.map, t);
      return;
    }
    for (const [, s] of this.list.entries())
      for (const [, i] of s)
        Dt.remove(i.map, t);
  }
  /**
   * Asynchronously processes models based on the provided configuration and updates classification groups.
   *
   * @param config - Optional configuration for adding classifications. Contains the following properties.
   * @returns A promise that resolves when the processing is complete.
   */
  async byModel(t) {
    const e = this.components.get(ct), s = (t == null ? void 0 : t.classificationName) ?? "Models";
    for (const [i, n] of e.list) {
      if (t && t.modelIds && !t.modelIds.some((a) => a.test(i)))
        continue;
      const r = await n.getItemsIdsWithGeometry(), o = { [i]: new Set(r) };
      this.getGroupData(s, i), this.addGroupItems(s, i, o);
    }
  }
  // /**
  //  * Exports the computed classification to persists them and import them back
  //  * later for faster loading.
  //  */
  // export() {
  //   const exported: ExportedClassification = {};
  //   for (const systemName in this.list) {
  //     exported[systemName] = {};
  //     const system = this.list[systemName];
  //     for (const groupName in system) {
  //       const group = system[groupName];
  //       exported[systemName][groupName] = {
  //         map: FRAGS.FragmentUtils.export(group.map),
  //         name: group.name,
  //         id: group.id,
  //       };
  //     }
  //   }
  //   return exported;
  // }
  // /**
  //  * Imports a classification previously exported with .export().
  //  * @param data the serialized classification to import.
  //  */
  // import(data: ExportedClassification) {
  //   for (const systemName in data) {
  //     if (!this.list[systemName]) {
  //       this.list[systemName] = {};
  //     }
  //     const system = data[systemName];
  //     for (const groupName in system) {
  //       const group = system[groupName];
  //       this.list[systemName][groupName] = {
  //         map: FRAGS.FragmentUtils.import(group.map),
  //         name: group.name,
  //         id: group.id,
  //       };
  //     }
  //   }
  //
};
E(fa, "uuid", "e25a7f3c-46c4-4a14-9d3d-5115f24ebeb7");
var qc = fa;
var Qc = class {
  constructor(t, e) {
    E(this, "enabled", true), E(this, "components"), E(this, "onDisposed", new tt()), E(this, "mouse"), E(this, "three", new Raycaster()), E(this, "world");
    const s = e.renderer;
    if (!s)
      throw new Error("A renderer is needed for the raycaster to work!");
    this.world = e, this.mouse = new Wc(s.three.domElement), this.components = t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.mouse.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  castRayToObjects(t = Array.from(this.world.meshes), e = this.mouse.position) {
    if (!this.world)
      throw new Error("A world is needed to cast rays!");
    const s = this.world.camera.three;
    return this.three.setFromCamera(e, s), this.intersect(t);
  }
  /**
   * Throws a ray from the camera to the mouse or touch event point and returns
   * the first item found. This also takes into account the clipping planes
   * used by the renderer.
   *
   * @param items - the [meshes](https://threejs.org/docs/#api/en/objects/Mesh)
   * to query. If not provided, it will query all the meshes stored in
   * {@link Components.meshes}.
   * @param position - the screen position to use for raycasting. If not provided,
   * the last pointer (mouse/touch) position will be used.
   */
  async castRay(t) {
    const e = t == null ? void 0 : t.snappingClasses, s = (t == null ? void 0 : t.items) ?? Array.from(this.world.meshes), i = (t == null ? void 0 : t.position) ?? this.mouse.position;
    if (!this.world)
      throw new Error("A world is needed to cast rays!");
    const n = this.world.camera.three, r = this.components.get(ct), o = this.world.renderer.three.domElement, a = this.mouse.rawPosition;
    let c = null;
    if (r.initialized && (c = await r.raycast({
      camera: n,
      dom: o,
      mouse: a,
      snappingClasses: e
    }), s.length === 0))
      return c;
    this.three.setFromCamera(i, n);
    const h = this.intersect(s);
    return c ? h && h.distance < c.distance ? h : c : h;
  }
  // /**
  //  * Casts a ray from a given origin in a given direction and returns the first item found.
  //  * This method also takes into account the clipping planes used by the renderer.
  //  *
  //  * @param origin - The origin of the ray.
  //  * @param direction - The direction of the ray.
  //  * @param items - The meshes to query. If not provided, it will query all the meshes stored in {@link World.meshes}.
  //  * @returns The first intersection found or `null` if no intersection was found.
  //  */
  // castRayFromVector(
  //   origin: THREE.Vector3,
  //   direction: THREE.Vector3,
  //   items = Array.from(this.world.meshes),
  // ) {
  //   // TODO: Implement for fragmentsmodel
  //   this.three.set(origin, direction);
  //   return this.intersect(items);
  // }
  intersect(t = Array.from(this.world.meshes)) {
    const e = this.three.intersectObjects(t), s = this.filterClippingPlanes(e);
    return s.length > 0 ? s[0] : null;
  }
  filterClippingPlanes(t) {
    if (!this.world.renderer)
      throw new Error("Renderer not found!");
    const e = this.world.renderer.three;
    if (!e.clippingPlanes)
      return t;
    const s = e.clippingPlanes;
    return t.length <= 0 || !s || (s == null ? void 0 : s.length) <= 0 ? t : t.filter(
      (i) => s.every((n) => n.distanceToPoint(i.point) > 0)
    );
  }
};
var ma = class ga extends St {
  constructor(t) {
    super(t), E(this, "enabled", true), E(this, "list", /* @__PURE__ */ new Map()), E(this, "onDisposed", new tt()), t.add(ga.uuid, this);
  }
  /**
   * Retrieves a SimpleRaycaster instance for the given world.
   * If a SimpleRaycaster instance already exists for the world, it will be returned.
   * Otherwise, a new SimpleRaycaster instance will be created and added to the list.
   *
   * @param world - The world for which to retrieve or create a SimpleRaycaster instance.
   * @returns The SimpleRaycaster instance for the given world.
   */
  get(t) {
    if (this.list.has(t.uuid))
      return this.list.get(t.uuid);
    const e = new Qc(this.components, t);
    return this.list.set(t.uuid, e), t.onDisposed.add(() => {
      this.delete(t);
    }), e;
  }
  /**
   * Deletes the SimpleRaycaster instance associated with the given world.
   * If a SimpleRaycaster instance exists for the given world, it will be disposed and removed from the list.
   *
   * @param world - The world for which to delete the SimpleRaycaster instance.
   * @returns {void}
   */
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
};
E(ma, "uuid", "d5d8bdf0-db25-4952-b951-b643af207ace");
var me = ma;
var Kc = class extends fr {
  constructor() {
    super(...arguments), E(this, "onCameraChanged", new tt()), E(this, "meshes", /* @__PURE__ */ new Set()), E(this, "onAfterUpdate", new tt()), E(this, "onBeforeUpdate", new tt()), E(this, "onDisposed", new tt()), E(this, "isDisposing", false), E(this, "enabled", true), E(this, "_dynamicAnchor", false), E(this, "uuid", Xt.create()), E(this, "name"), E(this, "_scene"), E(this, "_camera"), E(this, "_renderer", null), E(this, "onPointerDown", async (t) => {
      if (!this.camera.hasCameraControls())
        throw new Error(
          "World: can't set dynamic anchor if the camera doesn't have controls."
        );
      const s = await this.components.get(me).get(this).castRay();
      s && s.point && t.button === 0 && this.camera.controls.setOrbitPoint(
        s.point.x,
        s.point.y,
        s.point.z
      );
    }), E(this, "_defaultCamera");
  }
  set dynamicAnchor(t) {
    var e;
    const s = (e = this.renderer) == null ? void 0 : e.three.domElement.parentElement;
    if (!s)
      throw new Error(
        "World: the renderer must have a parentElement to set dynamic anchoring."
      );
    t ? (this.camera.controls && (this.camera.controls.minDistance = 0.01), s.addEventListener("pointerdown", this.onPointerDown)) : s.removeEventListener("pointerdown", this.onPointerDown);
  }
  get dynamicAnchor() {
    return this._dynamicAnchor;
  }
  get defaultCamera() {
    if (!this._defaultCamera)
      throw new Error("World: there is no default camera defined.");
    return this._defaultCamera;
  }
  set defaultCamera(t) {
    this._defaultCamera = t;
  }
  /**
   * Getter for the scene. If no scene is initialized, it throws an error.
   * @returns The current scene.
   */
  get scene() {
    if (!this._scene)
      throw new Error("No scene initialized!");
    return this._scene;
  }
  /**
   * Setter for the scene. It sets the current scene, adds the world to the scene's worlds set,
   * sets the current world in the scene, and triggers the scene's onWorldChanged event with the added action.
   * @param scene - The new scene to be set.
   */
  set scene(t) {
    this._scene = t, t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" });
  }
  /**
   * Getter for the camera. If no camera is initialized, it throws an error.
   * @returns The current camera.
   */
  get camera() {
    if (!this._camera)
      throw new Error("No camera initialized!");
    return this._camera;
  }
  /**
   * Setter for the camera. It sets the current camera, adds the world to the camera's worlds set,
   * sets the current world in the camera, and triggers the camera's onWorldChanged event with the added action.
   * @param camera - The new camera to be set.
   */
  set camera(t) {
    this._camera || (this.defaultCamera = t), this._camera = t, t.currentWorld = this, this.onCameraChanged.trigger(t);
  }
  /**
   * Getter for the renderer.
   * @returns The current renderer or null if no renderer is set. Some worlds don't need a renderer to work (when your mail goal is not to display a 3D viewport to the user).
   */
  get renderer() {
    return this._renderer;
  }
  /**
   * Setter for the renderer. It sets the current renderer, adds the world to the renderer's worlds set,
   * sets the current world in the renderer, and triggers the renderer's onWorldChanged event with the added action.
   * If a new renderer is set, it also triggers the onWorldChanged event with the removed action for the old renderer.
   * @param renderer - The new renderer to be set or null to remove the current renderer.
   */
  set renderer(t) {
    this._renderer = t, t && (t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" }));
  }
  useDefaultCamera() {
    this.camera = this.defaultCamera;
  }
  /** {@link Updateable.update} */
  update(t) {
    this.enabled && (!this._scene || !this._camera || (this.scene.currentWorld = this, this.camera.currentWorld = this, this.renderer && (this.renderer.currentWorld = this), this.onBeforeUpdate.trigger(), this.scene.isUpdateable() && this.scene.update(t), this.camera.isUpdateable() && this.camera.update(t), this.renderer && this.renderer.update(t), this.onAfterUpdate.trigger()));
  }
  /** {@link Disposable.dispose} */
  dispose(t = true) {
    if (this.enabled = false, this.isDisposing = true, this.scene.onWorldChanged.trigger({ world: this, action: "removed" }), this.camera.onWorldChanged.trigger({ world: this, action: "removed" }), this.renderer && this.renderer.onWorldChanged.trigger({ world: this, action: "removed" }), t) {
      const s = this.components.get(De);
      this.scene.dispose(), this.camera.isDisposeable() && this.camera.dispose(), this.renderer && this.renderer.dispose();
      for (const i of this.meshes)
        s.destroy(i);
      this.meshes.clear();
    }
    this._scene = null, this._camera = null, this._renderer = null, this.components.get(wa).list.delete(this.uuid), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
var Jc = class extends Al {
  /**
   * Constructor for the SimpleRenderer class.
   *
   * @param components - The components instance.
   * @param container - The HTML container where the THREE.js canvas will be rendered.
   * @param parameters - Optional parameters for the THREE.js WebGLRenderer.
   */
  constructor(t, e, s) {
    super(t), E(this, "enabled", true), E(this, "container"), E(this, "three"), E(this, "_canvas"), E(this, "_parameters"), E(this, "_resizeObserver", null), E(this, "onContainerUpdated", new tt()), E(this, "_resizing", false), E(this, "resize", (r) => {
      if (this._resizing)
        return;
      this._resizing = true, this.onContainerUpdated.trigger();
      const o = r ? r.x : this.container.clientWidth, a = r ? r.y : this.container.clientHeight;
      this.three.setSize(o, a), this.onResize.trigger(new Vector2(o, a)), this._resizing = false;
    }), E(this, "resizeEvent", () => {
      this.resize();
    }), E(this, "onContextLost", (r) => {
      r.preventDefault(), this.enabled = false;
    }), E(this, "onContextBack", () => {
      this.three.setRenderTarget(null), this.three.dispose(), this.three = new WebGLRenderer({
        canvas: this._canvas,
        antialias: true,
        alpha: true,
        ...this._parameters
      }), this.enabled = true;
    }), this.container = e, this._parameters = s, this.three = new WebGLRenderer({
      antialias: true,
      alpha: true,
      ...s
    }), this.three.setPixelRatio(Math.min(window.devicePixelRatio, 2)), this.setupRenderer(), this.setupEvents(true), this.resize(), this._canvas = this.three.domElement;
    const i = this.three.getContext(), { canvas: n } = i;
    n.addEventListener("webglcontextlost", this.onContextLost, false), n.addEventListener("webglcontextrestored", this.onContextBack, false);
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled || !this.currentWorld)
      return;
    this.onBeforeUpdate.trigger(this);
    const t = this.currentWorld.scene.three, e = this.currentWorld.camera.three;
    this.three.render(t, e), this.onAfterUpdate.trigger(this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false, this.setupEvents(false), this.three.domElement.remove(), this.three.forceContextLoss(), this.three.dispose(), this.onResize.reset(), this.onAfterUpdate.reset(), this.onBeforeUpdate.reset(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /** {@link Resizeable.getSize}. */
  getSize() {
    return new Vector2(
      this.three.domElement.clientWidth,
      this.three.domElement.clientHeight
    );
  }
  /**
   * Sets up and manages the event listeners for the renderer.
   *
   * @param active - A boolean indicating whether to activate or deactivate the event listeners.
   *
   * @throws Will throw an error if the renderer does not have an HTML container.
   */
  setupEvents(t) {
    const e = this.three.domElement.parentElement;
    if (!e)
      throw new Error("This renderer needs to have an HTML container!");
    this._resizeObserver && (this._resizeObserver.disconnect(), this._resizeObserver = null), window.removeEventListener("resize", this.resizeEvent), t && (this._resizeObserver = new ResizeObserver(this.resizeEvent), this._resizeObserver.observe(e), window.addEventListener("resize", this.resizeEvent));
  }
  setupRenderer() {
    this.three.localClippingEnabled = true, this.container && this.container.appendChild(this.three.domElement), this.onContainerUpdated.trigger();
  }
};
var Pt = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
};
var V = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  SCREEN_PAN: 4,
  OFFSET: 8,
  DOLLY: 16,
  ZOOM: 32,
  TOUCH_ROTATE: 64,
  TOUCH_TRUCK: 128,
  TOUCH_SCREEN_PAN: 256,
  TOUCH_OFFSET: 512,
  TOUCH_DOLLY: 1024,
  TOUCH_ZOOM: 2048,
  TOUCH_DOLLY_TRUCK: 4096,
  TOUCH_DOLLY_SCREEN_PAN: 8192,
  TOUCH_DOLLY_OFFSET: 16384,
  TOUCH_DOLLY_ROTATE: 32768,
  TOUCH_ZOOM_TRUCK: 65536,
  TOUCH_ZOOM_OFFSET: 131072,
  TOUCH_ZOOM_SCREEN_PAN: 262144,
  TOUCH_ZOOM_ROTATE: 524288
});
var os = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function Je(l) {
  return l.isPerspectiveCamera;
}
function Re(l) {
  return l.isOrthographicCamera;
}
var as = Math.PI * 2;
var kr = Math.PI / 2;
var _a = 1e-5;
var zs = Math.PI / 180;
function de(l, t, e) {
  return Math.max(t, Math.min(e, l));
}
function Et(l, t = _a) {
  return Math.abs(l) < t;
}
function wt(l, t, e = _a) {
  return Et(l - t, e);
}
function Br(l, t) {
  return Math.round(l / t) * t;
}
function Ls(l) {
  return isFinite(l) ? l : l < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function Ns(l) {
  return Math.abs(l) < Number.MAX_VALUE ? l : l * (1 / 0);
}
function di(l, t, e, s, i = 1 / 0, n) {
  s = Math.max(1e-4, s);
  const r = 2 / s, o = r * n, a = 1 / (1 + o + 0.48 * o * o + 0.235 * o * o * o);
  let c = l - t;
  const h = t, d = i * s;
  c = de(c, -d, d), t = l - c;
  const u = (e.value + r * c) * n;
  e.value = (e.value - r * u) * a;
  let f = t + (c + u) * a;
  return h - l > 0 == f > h && (f = h, e.value = (f - h) / n), f;
}
function Rr(l, t, e, s, i = 1 / 0, n, r) {
  s = Math.max(1e-4, s);
  const o = 2 / s, a = o * n, c = 1 / (1 + a + 0.48 * a * a + 0.235 * a * a * a);
  let h = t.x, d = t.y, u = t.z, f = l.x - h, g = l.y - d, m = l.z - u;
  const _ = h, p = d, y = u, b = i * s, x = b * b, S = f * f + g * g + m * m;
  if (S > x) {
    const N = Math.sqrt(S);
    f = f / N * b, g = g / N * b, m = m / N * b;
  }
  h = l.x - f, d = l.y - g, u = l.z - m;
  const C = (e.x + o * f) * n, P = (e.y + o * g) * n, O = (e.z + o * m) * n;
  e.x = (e.x - o * C) * c, e.y = (e.y - o * P) * c, e.z = (e.z - o * O) * c, r.x = h + (f + C) * c, r.y = d + (g + P) * c, r.z = u + (m + O) * c;
  const z = _ - l.x, k = p - l.y, H = y - l.z, T = r.x - _, L = r.y - p, w = r.z - y;
  return z * T + k * L + H * w > 0 && (r.x = _, r.y = p, r.z = y, e.x = (r.x - _) / n, e.y = (r.y - p) / n, e.z = (r.z - y) / n), r;
}
function vn(l, t) {
  t.set(0, 0), l.forEach((e) => {
    t.x += e.clientX, t.y += e.clientY;
  }), t.x /= l.length, t.y /= l.length;
}
function wn(l, t) {
  return Re(l) ? (console.warn(`${t} is not supported in OrthographicCamera`), true) : false;
}
var $c = class {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(t, e) {
    const s = this._listeners;
    s[t] === void 0 && (s[t] = []), s[t].indexOf(e) === -1 && s[t].push(e);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(t, e) {
    const s = this._listeners;
    return s[t] !== void 0 && s[t].indexOf(e) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(t, e) {
    const i = this._listeners[t];
    if (i !== void 0) {
      const n = i.indexOf(e);
      n !== -1 && i.splice(n, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(t) {
    if (!t) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[t]) && (this._listeners[t].length = 0);
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(t) {
    const s = this._listeners[t.type];
    if (s !== void 0) {
      t.target = this;
      const i = s.slice(0);
      for (let n = 0, r = i.length; n < r; n++)
        i[n].call(this, t);
    }
  }
};
var bn;
var th = "2.10.1";
var ui = 1 / 8;
var eh = /Mac/.test((bn = globalThis == null ? void 0 : globalThis.navigator) === null || bn === void 0 ? void 0 : bn.platform);
var lt;
var Ur;
var fi;
var xn;
var Kt;
var ut;
var _t;
var ls;
var ks;
var _e;
var ye;
var $e;
var Fr;
var Vr;
var se;
var Bs;
var cs;
var Hr;
var Sn;
var jr;
var En;
var Tn;
var pi;
var Wt2 = class _Wt extends $c {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(t) {
    lt = t.THREE, Ur = Object.freeze(new lt.Vector3(0, 0, 0)), fi = Object.freeze(new lt.Vector3(0, 1, 0)), xn = Object.freeze(new lt.Vector3(0, 0, 1)), Kt = new lt.Vector2(), ut = new lt.Vector3(), _t = new lt.Vector3(), ls = new lt.Vector3(), ks = new lt.Vector3(), _e = new lt.Vector3(), ye = new lt.Vector3(), $e = new lt.Vector3(), Fr = new lt.Vector3(), Vr = new lt.Vector3(), se = new lt.Spherical(), Bs = new lt.Spherical(), cs = new lt.Box3(), Hr = new lt.Box3(), Sn = new lt.Sphere(), jr = new lt.Quaternion(), En = new lt.Quaternion(), Tn = new lt.Matrix4(), pi = new lt.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return V;
  }
  /**
   * @deprecated Use `cameraControls.mouseButtons.left = CameraControls.ACTION.SCREEN_PAN` instead.
   */
  set verticalDragToForward(t) {
    console.warn("camera-controls: `verticalDragToForward` was removed. Use `mouseButtons.left = CameraControls.ACTION.SCREEN_PAN` instead.");
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(t, e) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = false, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = false, this.truckSpeed = 2, this.dollyToCursor = false, this.dragToOffset = false, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = true, this._state = V.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = true, this._boundaryEnclosesCamera = false, this._needsUpdate = true, this._updatedLastTime = false, this._elementRect = new DOMRect(), this._isDragging = false, this._dragNeedsUpdate = true, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._isUserControllingOffset = false, this._isUserControllingZoom = false, this._lastDollyDirection = os.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new lt.Vector3(), this._focalOffsetVelocity = new lt.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (p, y, b, x) => {
      let S, C;
      if (Je(this._camera)) {
        const P = ut.copy(this._camera.position).sub(this._target), O = this._camera.getEffectiveFOV() * zs, z = P.length() * Math.tan(O * 0.5);
        S = this.truckSpeed * p * z / this._elementRect.height, C = this.truckSpeed * y * z / this._elementRect.height;
      } else if (Re(this._camera)) {
        const P = this._camera;
        S = this.truckSpeed * p * (P.right - P.left) / P.zoom / this._elementRect.width, C = this.truckSpeed * y * (P.top - P.bottom) / P.zoom / this._elementRect.height;
      } else
        return;
      x ? (b ? this.setFocalOffset(this._focalOffsetEnd.x + S, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(S, 0, true), this.forward(-C, true)) : b ? this.setFocalOffset(this._focalOffsetEnd.x + S, this._focalOffsetEnd.y + C, this._focalOffsetEnd.z, true) : this.truck(S, C, true);
    }, this._rotateInternal = (p, y) => {
      const b = as * this.azimuthRotateSpeed * p / this._elementRect.height, x = as * this.polarRotateSpeed * y / this._elementRect.height;
      this.rotate(b, x, true);
    }, this._dollyInternal = (p, y, b) => {
      const x = Math.pow(0.95, -p * this.dollySpeed), S = this._sphericalEnd.radius, C = this._sphericalEnd.radius * x, P = de(C, this.minDistance, this.maxDistance), O = P - C;
      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(C, true) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(O, true), this._dollyToNoClamp(P, true)) : this._dollyToNoClamp(P, true), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? C : P) - S, this._dollyControlCoord.set(y, b)), this._lastDollyDirection = Math.sign(-p);
    }, this._zoomInternal = (p, y, b) => {
      const x = Math.pow(0.95, p * this.dollySpeed), S = this._zoom, C = this._zoom * x;
      this.zoomTo(C, true), this.dollyToCursor && (this._changedZoom += C - S, this._dollyControlCoord.set(y, b));
    }, typeof lt > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = t, this._yAxisUpSpace = new lt.Quaternion().setFromUnitVectors(this._camera.up, fi), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = V.NONE, this._target = new lt.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new lt.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new lt.Spherical().setFromVector3(ut.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
      new lt.Vector3(),
      new lt.Vector3(),
      new lt.Vector3(),
      new lt.Vector3()
    ], this._updateNearPlaneCorners(), this._boundary = new lt.Box3(new lt.Vector3(-1 / 0, -1 / 0, -1 / 0), new lt.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new lt.Vector2(), this.mouseButtons = {
      left: V.ROTATE,
      middle: V.DOLLY,
      right: V.TRUCK,
      wheel: Je(this._camera) ? V.DOLLY : Re(this._camera) ? V.ZOOM : V.NONE
    }, this.touches = {
      one: V.TOUCH_ROTATE,
      two: Je(this._camera) ? V.TOUCH_DOLLY_TRUCK : Re(this._camera) ? V.TOUCH_ZOOM_TRUCK : V.NONE,
      three: V.TOUCH_TRUCK
    };
    const s = new lt.Vector2(), i = new lt.Vector2(), n = new lt.Vector2(), r = (p) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const x = this._domElement.getBoundingClientRect(), S = p.clientX / x.width, C = p.clientY / x.height;
        if (S < this._interactiveArea.left || S > this._interactiveArea.right || C < this._interactiveArea.top || C > this._interactiveArea.bottom)
          return;
      }
      const y = p.pointerType !== "mouse" ? null : (p.buttons & Pt.LEFT) === Pt.LEFT ? Pt.LEFT : (p.buttons & Pt.MIDDLE) === Pt.MIDDLE ? Pt.MIDDLE : (p.buttons & Pt.RIGHT) === Pt.RIGHT ? Pt.RIGHT : null;
      if (y !== null) {
        const x = this._findPointerByMouseButton(y);
        x && this._disposePointer(x);
      }
      if ((p.buttons & Pt.LEFT) === Pt.LEFT && this._lockedPointer)
        return;
      const b = {
        pointerId: p.pointerId,
        clientX: p.clientX,
        clientY: p.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: y
      };
      this._activePointers.push(b), this._domElement.ownerDocument.removeEventListener("pointermove", o, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", a), this._domElement.ownerDocument.addEventListener("pointermove", o, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", a), this._isDragging = true, u(p);
    }, o = (p) => {
      p.cancelable && p.preventDefault();
      const y = p.pointerId, b = this._lockedPointer || this._findPointerById(y);
      if (b) {
        if (b.clientX = p.clientX, b.clientY = p.clientY, b.deltaX = p.movementX, b.deltaY = p.movementY, this._state = 0, p.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          (!this._isDragging && this._lockedPointer || this._isDragging && (p.buttons & Pt.LEFT) === Pt.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (p.buttons & Pt.MIDDLE) === Pt.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (p.buttons & Pt.RIGHT) === Pt.RIGHT && (this._state = this._state | this.mouseButtons.right);
        f();
      }
    }, a = (p) => {
      const y = this._findPointerById(p.pointerId);
      if (!(y && y === this._lockedPointer)) {
        if (y && this._disposePointer(y), p.pointerType === "touch")
          switch (this._activePointers.length) {
            case 0:
              this._state = V.NONE;
              break;
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          this._state = V.NONE;
        g();
      }
    };
    let c = -1;
    const h = (p) => {
      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === V.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const C = this._domElement.getBoundingClientRect(), P = p.clientX / C.width, O = p.clientY / C.height;
        if (P < this._interactiveArea.left || P > this._interactiveArea.right || O < this._interactiveArea.top || O > this._interactiveArea.bottom)
          return;
      }
      if (p.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === V.ROTATE || this.mouseButtons.wheel === V.TRUCK) {
        const C = performance.now();
        c - C < 1e3 && this._getClientRect(this._elementRect), c = C;
      }
      const y = eh ? -1 : -3, b = p.deltaMode === 1 || p.ctrlKey ? p.deltaY / y : p.deltaY / (y * 10), x = this.dollyToCursor ? (p.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, S = this.dollyToCursor ? (p.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case V.ROTATE: {
          this._rotateInternal(p.deltaX, p.deltaY), this._isUserControllingRotate = true;
          break;
        }
        case V.TRUCK: {
          this._truckInternal(p.deltaX, p.deltaY, false, false), this._isUserControllingTruck = true;
          break;
        }
        case V.SCREEN_PAN: {
          this._truckInternal(p.deltaX, p.deltaY, false, true), this._isUserControllingTruck = true;
          break;
        }
        case V.OFFSET: {
          this._truckInternal(p.deltaX, p.deltaY, true, false), this._isUserControllingOffset = true;
          break;
        }
        case V.DOLLY: {
          this._dollyInternal(-b, x, S), this._isUserControllingDolly = true;
          break;
        }
        case V.ZOOM: {
          this._zoomInternal(-b, x, S), this._isUserControllingZoom = true;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, d = (p) => {
      if (!(!this._domElement || !this._enabled)) {
        if (this.mouseButtons.right === _Wt.ACTION.NONE) {
          const y = p instanceof PointerEvent ? p.pointerId : 0, b = this._findPointerById(y);
          b && this._disposePointer(b), this._domElement.ownerDocument.removeEventListener("pointermove", o, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", a);
          return;
        }
        p.preventDefault();
      }
    }, u = (p) => {
      if (!this._enabled)
        return;
      if (vn(this._activePointers, Kt), this._getClientRect(this._elementRect), s.copy(Kt), i.copy(Kt), this._activePointers.length >= 2) {
        const b = Kt.x - this._activePointers[1].clientX, x = Kt.y - this._activePointers[1].clientY, S = Math.sqrt(b * b + x * x);
        n.set(0, S);
        const C = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, P = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        i.set(C, P);
      }
      if (this._state = 0, !p)
        this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
      else if ("pointerType" in p && p.pointerType === "touch")
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      else
        !this._lockedPointer && (p.buttons & Pt.LEFT) === Pt.LEFT && (this._state = this._state | this.mouseButtons.left), (p.buttons & Pt.MIDDLE) === Pt.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (p.buttons & Pt.RIGHT) === Pt.RIGHT && (this._state = this._state | this.mouseButtons.right);
      ((this._state & V.ROTATE) === V.ROTATE || (this._state & V.TOUCH_ROTATE) === V.TOUCH_ROTATE || (this._state & V.TOUCH_DOLLY_ROTATE) === V.TOUCH_DOLLY_ROTATE || (this._state & V.TOUCH_ZOOM_ROTATE) === V.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & V.TRUCK) === V.TRUCK || (this._state & V.SCREEN_PAN) === V.SCREEN_PAN || (this._state & V.TOUCH_TRUCK) === V.TOUCH_TRUCK || (this._state & V.TOUCH_SCREEN_PAN) === V.TOUCH_SCREEN_PAN || (this._state & V.TOUCH_DOLLY_TRUCK) === V.TOUCH_DOLLY_TRUCK || (this._state & V.TOUCH_DOLLY_SCREEN_PAN) === V.TOUCH_DOLLY_SCREEN_PAN || (this._state & V.TOUCH_ZOOM_TRUCK) === V.TOUCH_ZOOM_TRUCK || (this._state & V.TOUCH_ZOOM_SCREEN_PAN) === V.TOUCH_DOLLY_SCREEN_PAN) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & V.DOLLY) === V.DOLLY || (this._state & V.TOUCH_DOLLY) === V.TOUCH_DOLLY || (this._state & V.TOUCH_DOLLY_TRUCK) === V.TOUCH_DOLLY_TRUCK || (this._state & V.TOUCH_DOLLY_SCREEN_PAN) === V.TOUCH_DOLLY_SCREEN_PAN || (this._state & V.TOUCH_DOLLY_OFFSET) === V.TOUCH_DOLLY_OFFSET || (this._state & V.TOUCH_DOLLY_ROTATE) === V.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & V.ZOOM) === V.ZOOM || (this._state & V.TOUCH_ZOOM) === V.TOUCH_ZOOM || (this._state & V.TOUCH_ZOOM_TRUCK) === V.TOUCH_ZOOM_TRUCK || (this._state & V.TOUCH_ZOOM_SCREEN_PAN) === V.TOUCH_ZOOM_SCREEN_PAN || (this._state & V.TOUCH_ZOOM_OFFSET) === V.TOUCH_ZOOM_OFFSET || (this._state & V.TOUCH_ZOOM_ROTATE) === V.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & V.OFFSET) === V.OFFSET || (this._state & V.TOUCH_OFFSET) === V.TOUCH_OFFSET || (this._state & V.TOUCH_DOLLY_OFFSET) === V.TOUCH_DOLLY_OFFSET || (this._state & V.TOUCH_ZOOM_OFFSET) === V.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
    }, f = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = false, vn(this._activePointers, Kt);
      const y = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, b = y ? -y.deltaX : i.x - Kt.x, x = y ? -y.deltaY : i.y - Kt.y;
      if (i.copy(Kt), ((this._state & V.ROTATE) === V.ROTATE || (this._state & V.TOUCH_ROTATE) === V.TOUCH_ROTATE || (this._state & V.TOUCH_DOLLY_ROTATE) === V.TOUCH_DOLLY_ROTATE || (this._state & V.TOUCH_ZOOM_ROTATE) === V.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(b, x), this._isUserControllingRotate = true), (this._state & V.DOLLY) === V.DOLLY || (this._state & V.ZOOM) === V.ZOOM) {
        const S = this.dollyToCursor ? (s.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, C = this.dollyToCursor ? (s.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, P = this.dollyDragInverted ? -1 : 1;
        (this._state & V.DOLLY) === V.DOLLY ? (this._dollyInternal(P * x * ui, S, C), this._isUserControllingDolly = true) : (this._zoomInternal(P * x * ui, S, C), this._isUserControllingZoom = true);
      }
      if ((this._state & V.TOUCH_DOLLY) === V.TOUCH_DOLLY || (this._state & V.TOUCH_ZOOM) === V.TOUCH_ZOOM || (this._state & V.TOUCH_DOLLY_TRUCK) === V.TOUCH_DOLLY_TRUCK || (this._state & V.TOUCH_ZOOM_TRUCK) === V.TOUCH_ZOOM_TRUCK || (this._state & V.TOUCH_DOLLY_SCREEN_PAN) === V.TOUCH_DOLLY_SCREEN_PAN || (this._state & V.TOUCH_ZOOM_SCREEN_PAN) === V.TOUCH_ZOOM_SCREEN_PAN || (this._state & V.TOUCH_DOLLY_OFFSET) === V.TOUCH_DOLLY_OFFSET || (this._state & V.TOUCH_ZOOM_OFFSET) === V.TOUCH_ZOOM_OFFSET || (this._state & V.TOUCH_DOLLY_ROTATE) === V.TOUCH_DOLLY_ROTATE || (this._state & V.TOUCH_ZOOM_ROTATE) === V.TOUCH_ZOOM_ROTATE) {
        const S = Kt.x - this._activePointers[1].clientX, C = Kt.y - this._activePointers[1].clientY, P = Math.sqrt(S * S + C * C), O = n.y - P;
        n.set(0, P);
        const z = this.dollyToCursor ? (i.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, k = this.dollyToCursor ? (i.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & V.TOUCH_DOLLY) === V.TOUCH_DOLLY || (this._state & V.TOUCH_DOLLY_ROTATE) === V.TOUCH_DOLLY_ROTATE || (this._state & V.TOUCH_DOLLY_TRUCK) === V.TOUCH_DOLLY_TRUCK || (this._state & V.TOUCH_DOLLY_SCREEN_PAN) === V.TOUCH_DOLLY_SCREEN_PAN || (this._state & V.TOUCH_DOLLY_OFFSET) === V.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(O * ui, z, k), this._isUserControllingDolly = true) : (this._zoomInternal(O * ui, z, k), this._isUserControllingZoom = true);
      }
      ((this._state & V.TRUCK) === V.TRUCK || (this._state & V.TOUCH_TRUCK) === V.TOUCH_TRUCK || (this._state & V.TOUCH_DOLLY_TRUCK) === V.TOUCH_DOLLY_TRUCK || (this._state & V.TOUCH_ZOOM_TRUCK) === V.TOUCH_ZOOM_TRUCK) && (this._truckInternal(b, x, false, false), this._isUserControllingTruck = true), ((this._state & V.SCREEN_PAN) === V.SCREEN_PAN || (this._state & V.TOUCH_SCREEN_PAN) === V.TOUCH_SCREEN_PAN || (this._state & V.TOUCH_DOLLY_SCREEN_PAN) === V.TOUCH_DOLLY_SCREEN_PAN || (this._state & V.TOUCH_ZOOM_SCREEN_PAN) === V.TOUCH_ZOOM_SCREEN_PAN) && (this._truckInternal(b, x, false, true), this._isUserControllingTruck = true), ((this._state & V.OFFSET) === V.OFFSET || (this._state & V.TOUCH_OFFSET) === V.TOUCH_OFFSET || (this._state & V.TOUCH_DOLLY_OFFSET) === V.TOUCH_DOLLY_OFFSET || (this._state & V.TOUCH_ZOOM_OFFSET) === V.TOUCH_ZOOM_OFFSET) && (this._truckInternal(b, x, true, false), this._isUserControllingOffset = true), this.dispatchEvent({ type: "control" });
    }, g = () => {
      vn(this._activePointers, Kt), i.copy(Kt), this._dragNeedsUpdate = false, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = false), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", o, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", a), this.dispatchEvent({ type: "controlend" }));
    };
    this.lockPointer = () => {
      !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", o, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", a), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", m), this._domElement.ownerDocument.addEventListener("pointerlockerror", _), this._domElement.ownerDocument.addEventListener("pointermove", o, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", a), u());
    }, this.unlockPointer = () => {
      var p, y, b;
      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), (p = this._domElement) === null || p === void 0 || p.ownerDocument.exitPointerLock(), (y = this._domElement) === null || y === void 0 || y.ownerDocument.removeEventListener("pointerlockchange", m), (b = this._domElement) === null || b === void 0 || b.ownerDocument.removeEventListener("pointerlockerror", _), this.cancel();
    };
    const m = () => {
      this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();
    }, _ = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (p) => {
      this._domElement = p, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", r), this._domElement.addEventListener("pointercancel", a), this._domElement.addEventListener("wheel", h, { passive: false }), this._domElement.addEventListener("contextmenu", d);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", r), this._domElement.removeEventListener("pointercancel", a), this._domElement.removeEventListener("wheel", h, { passive: false }), this._domElement.removeEventListener("contextmenu", d), this._domElement.ownerDocument.removeEventListener("pointermove", o, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", a), this._domElement.ownerDocument.removeEventListener("pointerlockchange", m), this._domElement.ownerDocument.removeEventListener("pointerlockerror", _));
    }, this.cancel = () => {
      this._state !== V.NONE && (this._state = V.NONE, this._activePointers.length = 0, g());
    }, e && this.connect(e), this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(t) {
    this._camera = t, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    this._enabled = t, this._domElement && (t ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(t) {
    this._spherical.radius === t && this._sphericalEnd.radius === t || (this._spherical.radius = t, this._sphericalEnd.radius = t, this._needsUpdate = true);
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(t) {
    this._spherical.theta === t && this._sphericalEnd.theta === t || (this._spherical.theta = t, this._sphericalEnd.theta = t, this._needsUpdate = true);
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(t) {
    this._spherical.phi === t && this._sphericalEnd.phi === t || (this._spherical.phi = t, this._sphericalEnd.phi = t, this._needsUpdate = true);
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(t) {
    this._boundaryEnclosesCamera = t, this._needsUpdate = true;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(t) {
    this._interactiveArea.width = de(t.width, 0, 1), this._interactiveArea.height = de(t.height, 0, 1), this._interactiveArea.x = de(t.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = de(t.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. ¹ |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera. ¹ |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` ². |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(t, e) {
    super.addEventListener(t, e);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(t, e) {
    super.removeEventListener(t, e);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(t, e, s = false) {
    return this.rotateTo(this._sphericalEnd.theta + t, this._sphericalEnd.phi + e, s);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(t, e = false) {
    return this.rotateTo(t, this._sphericalEnd.phi, e);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(t, e = false) {
    return this.rotateTo(this._sphericalEnd.theta, t, e);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0º
   *         \
   * 90º -----+----- -90º
   *           \
   *           180º
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0º                     |
   * | left      | 90º (`Math.PI / 2`)    |
   * | right     | -90º (`- Math.PI / 2`) |
   * | back      | 180º (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180º
   *      |
   *      90º
   *      |
   *      0º
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180º (`Math.PI`)       |
   * | horizontal from view | 90º (`Math.PI / 2`)    |
   * | bottom/floor         | 0º                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(t, e, s = false) {
    this._isUserControllingRotate = false;
    const i = de(t, this.minAzimuthAngle, this.maxAzimuthAngle), n = de(e, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = i, this._sphericalEnd.phi = n, this._sphericalEnd.makeSafe(), this._needsUpdate = true, s || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const r = !s || wt(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && wt(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(t, e = false) {
    return this.dollyTo(this._sphericalEnd.radius - t, e);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(t, e = false) {
    return this._isUserControllingDolly = false, this._lastDollyDirection = os.NONE, this._changedDolly = 0, this._dollyToNoClamp(de(t, this.minDistance, this.maxDistance), e);
  }
  _dollyToNoClamp(t, e = false) {
    const s = this._sphericalEnd.radius;
    if (this.colliderMeshes.length >= 1) {
      const r = this._collisionTest(), o = wt(r, this._spherical.radius);
      if (!(s > t) && o)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(t, r);
    } else
      this._sphericalEnd.radius = t;
    this._needsUpdate = true, e || (this._spherical.radius = this._sphericalEnd.radius);
    const n = !e || wt(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(t, e = false) {
    this._targetEnd.add(this._getCameraDirection(ks).multiplyScalar(t)), e || this._target.copy(this._targetEnd);
    const s = !e || wt(this._target.x, this._targetEnd.x, this.restThreshold) && wt(this._target.y, this._targetEnd.y, this.restThreshold) && wt(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(s);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(t, e = false) {
    return this.zoomTo(this._zoomEnd + t, e);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(t, e = false) {
    this._isUserControllingZoom = false, this._zoomEnd = de(t, this.minZoom, this.maxZoom), this._needsUpdate = true, e || (this._zoom = this._zoomEnd);
    const s = !e || wt(this._zoom, this._zoomEnd, this.restThreshold);
    return this._changedZoom = 0, this._createOnRestPromise(s);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(t, e, s = false) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(t, e, s);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(t, e, s = false) {
    this._camera.updateMatrix(), _e.setFromMatrixColumn(this._camera.matrix, 0), ye.setFromMatrixColumn(this._camera.matrix, 1), _e.multiplyScalar(t), ye.multiplyScalar(-e);
    const i = ut.copy(_e).add(ye), n = _t.copy(this._targetEnd).add(i);
    return this.moveTo(n.x, n.y, n.z, s);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(t, e = false) {
    ut.setFromMatrixColumn(this._camera.matrix, 0), ut.crossVectors(this._camera.up, ut), ut.multiplyScalar(t);
    const s = _t.copy(this._targetEnd).add(ut);
    return this.moveTo(s.x, s.y, s.z, e);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(t, e = false) {
    return ut.copy(this._camera.up).multiplyScalar(t), this.moveTo(this._targetEnd.x + ut.x, this._targetEnd.y + ut.y, this._targetEnd.z + ut.z, e);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(t, e, s, i = false) {
    this._isUserControllingTruck = false;
    const n = ut.set(t, e, s).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, n, this.boundaryFriction), this._needsUpdate = true, i || this._target.copy(this._targetEnd);
    const r = !i || wt(this._target.x, this._targetEnd.x, this.restThreshold) && wt(this._target.y, this._targetEnd.y, this.restThreshold) && wt(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(t, e, s, i = false) {
    const o = ut.set(t, e, s).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
    return this.setPosition(o.x, o.y, o.z, i);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(t, e, { cover: s = false, paddingLeft: i = 0, paddingRight: n = 0, paddingBottom: r = 0, paddingTop: o = 0 } = {}) {
    const a = [], c = t.isBox3 ? cs.copy(t) : cs.setFromObject(t);
    c.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const h = Br(this._sphericalEnd.theta, kr), d = Br(this._sphericalEnd.phi, kr);
    a.push(this.rotateTo(h, d, e));
    const u = ut.setFromSpherical(this._sphericalEnd).normalize(), f = jr.setFromUnitVectors(u, xn), g = wt(Math.abs(u.y), 1);
    g && f.multiply(En.setFromAxisAngle(fi, h)), f.multiply(this._yAxisUpSpaceInverse);
    const m = Hr.makeEmpty();
    _t.copy(c.min).applyQuaternion(f), m.expandByPoint(_t), _t.copy(c.min).setX(c.max.x).applyQuaternion(f), m.expandByPoint(_t), _t.copy(c.min).setY(c.max.y).applyQuaternion(f), m.expandByPoint(_t), _t.copy(c.max).setZ(c.min.z).applyQuaternion(f), m.expandByPoint(_t), _t.copy(c.min).setZ(c.max.z).applyQuaternion(f), m.expandByPoint(_t), _t.copy(c.max).setY(c.min.y).applyQuaternion(f), m.expandByPoint(_t), _t.copy(c.max).setX(c.min.x).applyQuaternion(f), m.expandByPoint(_t), _t.copy(c.max).applyQuaternion(f), m.expandByPoint(_t), m.min.x -= i, m.min.y -= r, m.max.x += n, m.max.y += o, f.setFromUnitVectors(xn, u), g && f.premultiply(En.invert()), f.premultiply(this._yAxisUpSpace);
    const _ = m.getSize(ut), p = m.getCenter(_t).applyQuaternion(f);
    if (Je(this._camera)) {
      const y = this.getDistanceToFitBox(_.x, _.y, _.z, s);
      a.push(this.moveTo(p.x, p.y, p.z, e)), a.push(this.dollyTo(y, e)), a.push(this.setFocalOffset(0, 0, 0, e));
    } else if (Re(this._camera)) {
      const y = this._camera, b = y.right - y.left, x = y.top - y.bottom, S = s ? Math.max(b / _.x, x / _.y) : Math.min(b / _.x, x / _.y);
      a.push(this.moveTo(p.x, p.y, p.z, e)), a.push(this.zoomTo(S, e)), a.push(this.setFocalOffset(0, 0, 0, e));
    }
    return Promise.all(a);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(t, e) {
    const s = [], n = "isObject3D" in t ? _Wt.createBoundingSphere(t, Sn) : Sn.copy(t);
    if (s.push(this.moveTo(n.center.x, n.center.y, n.center.z, e)), Je(this._camera)) {
      const r = this.getDistanceToFitSphere(n.radius);
      s.push(this.dollyTo(r, e));
    } else if (Re(this._camera)) {
      const r = this._camera.right - this._camera.left, o = this._camera.top - this._camera.bottom, a = 2 * n.radius, c = Math.min(r / a, o / a);
      s.push(this.zoomTo(c, e));
    }
    return s.push(this.setFocalOffset(0, 0, 0, e)), Promise.all(s);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(t, e, s, i, n, r, o = false) {
    this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._lastDollyDirection = os.NONE, this._changedDolly = 0;
    const a = _t.set(i, n, r), c = ut.set(t, e, s);
    this._targetEnd.copy(a), this._sphericalEnd.setFromVector3(c.sub(a).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = true, o || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const h = !o || wt(this._target.x, this._targetEnd.x, this.restThreshold) && wt(this._target.y, this._targetEnd.y, this.restThreshold) && wt(this._target.z, this._targetEnd.z, this.restThreshold) && wt(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && wt(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && wt(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(h);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(t, e, s, i, n, r, o, a, c, h, d, u, f, g = false) {
    this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._lastDollyDirection = os.NONE, this._changedDolly = 0;
    const m = ut.set(i, n, r), _ = _t.set(t, e, s);
    se.setFromVector3(_.sub(m).applyQuaternion(this._yAxisUpSpace));
    const p = ls.set(h, d, u), y = _t.set(o, a, c);
    Bs.setFromVector3(y.sub(p).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(m.lerp(p, f));
    const b = Bs.theta - se.theta, x = Bs.phi - se.phi, S = Bs.radius - se.radius;
    this._sphericalEnd.set(se.radius + S * f, se.phi + x * f, se.theta + b * f), this.normalizeRotations(), this._needsUpdate = true, g || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const C = !g || wt(this._target.x, this._targetEnd.x, this.restThreshold) && wt(this._target.y, this._targetEnd.y, this.restThreshold) && wt(this._target.z, this._targetEnd.z, this.restThreshold) && wt(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && wt(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && wt(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(C);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(t, e, s, i = false) {
    return this.setLookAt(t, e, s, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, i);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(t, e, s, i = false) {
    const n = this.getPosition(ut), r = this.setLookAt(n.x, n.y, n.z, t, e, s, i);
    return this._sphericalEnd.phi = de(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), r;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(t, e, s, i = false) {
    this._isUserControllingOffset = false, this._focalOffsetEnd.set(t, e, s), this._needsUpdate = true, i || this._focalOffset.copy(this._focalOffsetEnd);
    const n = !i || wt(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && wt(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && wt(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(t, e, s) {
    this._camera.updateMatrixWorld(), _e.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), ye.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), $e.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const i = ut.set(t, e, s), n = i.distanceTo(this._camera.position), r = i.sub(this._camera.position);
    _e.multiplyScalar(r.x), ye.multiplyScalar(r.y), $e.multiplyScalar(r.z), ut.copy(_e).add(ye).add($e), ut.z = ut.z + n, this.dollyTo(n, false), this.setFocalOffset(-ut.x, ut.y, -ut.z, false), this.moveTo(t, e, s, false);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(t) {
    if (!t) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = true;
      return;
    }
    this._boundary.copy(t), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = true;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(t, e, s, i) {
    if (t === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new lt.Vector4(), typeof t == "number" ? this._viewport.set(t, e, s, i) : this._viewport.copy(t);
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(t, e, s, i = false) {
    if (wn(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const n = t / e, r = this._camera.getEffectiveFOV() * zs, o = this._camera.aspect;
    return ((i ? n > o : n < o) ? e : t / o) * 0.5 / Math.tan(r * 0.5) + s * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(t) {
    if (wn(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const e = this._camera.getEffectiveFOV() * zs, s = Math.atan(Math.tan(e * 0.5) * this._camera.aspect) * 2, i = 1 < this._camera.aspect ? e : s;
    return t / Math.sin(i * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(t, e = true) {
    return (t && t.isVector3 ? t : new lt.Vector3()).copy(e ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(t, e = true) {
    return (t && t.isVector3 ? t : new lt.Vector3()).setFromSpherical(e ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(e ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(t, e = true) {
    return (t || new lt.Spherical()).copy(e ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(t, e = true) {
    return (t && t.isVector3 ? t : new lt.Vector3()).copy(e ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % as, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += as), this._spherical.theta += as * Math.round((this._sphericalEnd.theta - this._spherical.theta) / as);
  }
  /**
   * stop all transitions.
   */
  stop() {
    this._focalOffset.copy(this._focalOffsetEnd), this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd), this._zoom = this._zoomEnd;
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(t = false) {
    if (!wt(this._camera.up.x, this._cameraUp0.x) || !wt(this._camera.up.y, this._cameraUp0.y) || !wt(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const s = this.getPosition(ut);
      this.updateCameraUp(), this.setPosition(s.x, s.y, s.z);
    }
    const e = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, t),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, t),
      this.zoomTo(this._zoom0, t)
    ];
    return Promise.all(e);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, fi), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const t = ut.subVectors(this._target, this._camera.position).normalize(), e = _t.crossVectors(t, this._camera.up);
    this._camera.up.crossVectors(e, t).normalize(), this._camera.updateMatrixWorld();
    const s = this.getPosition(ut);
    this.updateCameraUp(), this.setPosition(s.x, s.y, s.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(t) {
    const e = this._sphericalEnd.theta - this._spherical.theta, s = this._sphericalEnd.phi - this._spherical.phi, i = this._sphericalEnd.radius - this._spherical.radius, n = Fr.subVectors(this._targetEnd, this._target), r = Vr.subVectors(this._focalOffsetEnd, this._focalOffset), o = this._zoomEnd - this._zoom;
    if (Et(e))
      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
    else {
      const d = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = di(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, d, 1 / 0, t), this._needsUpdate = true;
    }
    if (Et(s))
      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
    else {
      const d = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = di(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, d, 1 / 0, t), this._needsUpdate = true;
    }
    if (Et(i))
      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
    else {
      const d = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = di(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, d, this.maxSpeed, t), this._needsUpdate = true;
    }
    if (Et(n.x) && Et(n.y) && Et(n.z))
      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const d = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      Rr(this._target, this._targetEnd, this._targetVelocity, d, this.maxSpeed, t, this._target), this._needsUpdate = true;
    }
    if (Et(r.x) && Et(r.y) && Et(r.z))
      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
    else {
      const d = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      Rr(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, d, this.maxSpeed, t, this._focalOffset), this._needsUpdate = true;
    }
    if (Et(o))
      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
    else {
      const d = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = di(this._zoom, this._zoomEnd, this._zoomVelocity, d, 1 / 0, t);
    }
    if (this.dollyToCursor) {
      if (Je(this._camera) && this._changedDolly !== 0) {
        const d = this._spherical.radius - this._lastDistance, u = this._camera, f = this._getCameraDirection(ks), g = ut.copy(f).cross(u.up).normalize();
        g.lengthSq() === 0 && (g.x = 1);
        const m = _t.crossVectors(g, f), _ = this._sphericalEnd.radius * Math.tan(u.getEffectiveFOV() * zs * 0.5), y = (this._sphericalEnd.radius - d - this._sphericalEnd.radius) / this._sphericalEnd.radius, b = ls.copy(this._targetEnd).add(g.multiplyScalar(this._dollyControlCoord.x * _ * u.aspect)).add(m.multiplyScalar(this._dollyControlCoord.y * _)), x = ut.copy(this._targetEnd).lerp(b, y), S = this._lastDollyDirection === os.IN && this._spherical.radius <= this.minDistance, C = this._lastDollyDirection === os.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (S || C)) {
          this._sphericalEnd.radius -= d, this._spherical.radius -= d;
          const O = _t.copy(f).multiplyScalar(-d);
          x.add(O);
        }
        this._boundary.clampPoint(x, x);
        const P = _t.subVectors(x, this._targetEnd);
        this._targetEnd.copy(x), this._target.add(P), this._changedDolly -= d, Et(this._changedDolly) && (this._changedDolly = 0);
      } else if (Re(this._camera) && this._changedZoom !== 0) {
        const d = this._zoom - this._lastZoom, u = this._camera, f = ut.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (u.near + u.far) / (u.near - u.far)).unproject(u), g = _t.set(0, 0, -1).applyQuaternion(u.quaternion), m = ls.copy(f).add(g.multiplyScalar(-f.dot(u.up))), p = -(this._zoom - d - this._zoom) / this._zoom, y = this._getCameraDirection(ks), b = this._targetEnd.dot(y), x = ut.copy(this._targetEnd).lerp(m, p), S = x.dot(y), C = y.multiplyScalar(S - b);
        x.sub(C), this._boundary.clampPoint(x, x);
        const P = _t.subVectors(x, this._targetEnd);
        this._targetEnd.copy(x), this._target.add(P), this._changedZoom -= d, Et(this._changedZoom) && (this._changedZoom = 0);
      }
    }
    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true), this._dragNeedsUpdate = true;
    const a = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, a), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!Et(this._focalOffset.x) || !Et(this._focalOffset.y) || !Et(this._focalOffset.z)) && (_e.setFromMatrixColumn(this._camera.matrix, 0), ye.setFromMatrixColumn(this._camera.matrix, 1), $e.setFromMatrixColumn(this._camera.matrix, 2), _e.multiplyScalar(this._focalOffset.x), ye.multiplyScalar(-this._focalOffset.y), $e.multiplyScalar(this._focalOffset.z), ut.copy(_e).add(ye).add($e), this._camera.position.add(ut), this._camera.updateMatrixWorld()), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), ut.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const h = this._needsUpdate;
    return h && !this._updatedLastTime ? (this._hasRested = false, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : h ? (this.dispatchEvent({ type: "update" }), Et(e, this.restThreshold) && Et(s, this.restThreshold) && Et(i, this.restThreshold) && Et(n.x, this.restThreshold) && Et(n.y, this.restThreshold) && Et(n.z, this.restThreshold) && Et(r.x, this.restThreshold) && Et(r.y, this.restThreshold) && Et(r.z, this.restThreshold) && Et(o, this.restThreshold) && !this._hasRested && (this._hasRested = true, this.dispatchEvent({ type: "rest" }))) : !h && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = h, this._needsUpdate = false, h;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: Ls(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: Ls(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: Ls(this.maxPolarAngle),
      minAzimuthAngle: Ls(this.minAzimuthAngle),
      maxAzimuthAngle: Ls(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      target: this._targetEnd.toArray(),
      position: ut.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(t, e = false) {
    const s = JSON.parse(t);
    this.enabled = s.enabled, this.minDistance = s.minDistance, this.maxDistance = Ns(s.maxDistance), this.minZoom = s.minZoom, this.maxZoom = Ns(s.maxZoom), this.minPolarAngle = s.minPolarAngle, this.maxPolarAngle = Ns(s.maxPolarAngle), this.minAzimuthAngle = Ns(s.minAzimuthAngle), this.maxAzimuthAngle = Ns(s.maxAzimuthAngle), this.smoothTime = s.smoothTime, this.draggingSmoothTime = s.draggingSmoothTime, this.dollySpeed = s.dollySpeed, this.truckSpeed = s.truckSpeed, this.dollyToCursor = s.dollyToCursor, this._target0.fromArray(s.target0), this._position0.fromArray(s.position0), this._zoom0 = s.zoom0, this._focalOffset0.fromArray(s.focalOffset0), this.moveTo(s.target[0], s.target[1], s.target[2], e), se.setFromVector3(ut.fromArray(s.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(se.theta, se.phi, e), this.dollyTo(se.radius, e), this.zoomTo(s.zoom, e), this.setFocalOffset(s.focalOffset[0], s.focalOffset[1], s.focalOffset[2], e), this._needsUpdate = true;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(t) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    t.setAttribute("data-camera-controls-version", th), this._addAllEventListeners(t), this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0);
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners(), this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(t) {
    return t.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(t) {
    return this._getTargetDirection(t).negate();
  }
  _findPointerById(t) {
    return this._activePointers.find((e) => e.pointerId === t);
  }
  _findPointerByMouseButton(t) {
    return this._activePointers.find((e) => e.mouseButton === t);
  }
  _disposePointer(t) {
    this._activePointers.splice(this._activePointers.indexOf(t), 1);
  }
  _encloseToBoundary(t, e, s) {
    const i = e.lengthSq();
    if (i === 0)
      return t;
    const n = _t.copy(e).add(t), o = this._boundary.clampPoint(n, ls).sub(n), a = o.lengthSq();
    if (a === 0)
      return t.add(e);
    if (a === i)
      return t;
    if (s === 0)
      return t.add(e).add(o);
    {
      const c = 1 + s * a / e.dot(o);
      return t.add(_t.copy(e).multiplyScalar(c)).add(o.multiplyScalar(1 - s));
    }
  }
  _updateNearPlaneCorners() {
    if (Je(this._camera)) {
      const t = this._camera, e = t.near, s = t.getEffectiveFOV() * zs, i = Math.tan(s * 0.5) * e, n = i * t.aspect;
      this._nearPlaneCorners[0].set(-n, -i, 0), this._nearPlaneCorners[1].set(n, -i, 0), this._nearPlaneCorners[2].set(n, i, 0), this._nearPlaneCorners[3].set(-n, i, 0);
    } else if (Re(this._camera)) {
      const t = this._camera, e = 1 / t.zoom, s = t.left * e, i = t.right * e, n = t.top * e, r = t.bottom * e;
      this._nearPlaneCorners[0].set(s, n, 0), this._nearPlaneCorners[1].set(i, n, 0), this._nearPlaneCorners[2].set(i, r, 0), this._nearPlaneCorners[3].set(s, r, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let t = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || wn(this._camera, "_collisionTest"))
      return t;
    const s = this._getTargetDirection(ks);
    Tn.lookAt(Ur, s, this._camera.up);
    for (let i = 0; i < 4; i++) {
      const n = _t.copy(this._nearPlaneCorners[i]);
      n.applyMatrix4(Tn);
      const r = ls.addVectors(this._target, n);
      pi.set(r, s), pi.far = this._spherical.radius + 1;
      const o = pi.intersectObjects(this.colliderMeshes);
      o.length !== 0 && o[0].distance < t && (t = o[0].distance);
    }
    return t;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(t) {
    if (!this._domElement)
      return;
    const e = this._domElement.getBoundingClientRect();
    return t.x = e.left, t.y = e.top, this._viewport ? (t.x += this._viewport.x, t.y += e.height - this._viewport.w - this._viewport.y, t.width = this._viewport.z, t.height = this._viewport.w) : (t.width = e.width, t.height = e.height), t;
  }
  _createOnRestPromise(t) {
    return t ? Promise.resolve() : (this._hasRested = false, this.dispatchEvent({ type: "transitionstart" }), new Promise((e) => {
      const s = () => {
        this.removeEventListener("rest", s), e();
      };
      this.addEventListener("rest", s);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(t) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(t) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(t) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(t, e = new lt.Sphere()) {
    const s = e, i = s.center;
    cs.makeEmpty(), t.traverseVisible((r) => {
      r.isMesh && cs.expandByObject(r);
    }), cs.getCenter(i);
    let n = 0;
    return t.traverseVisible((r) => {
      if (!r.isMesh)
        return;
      const o = r;
      if (!o.geometry)
        return;
      const a = o.geometry.clone();
      a.applyMatrix4(o.matrixWorld);
      const h = a.attributes.position;
      for (let d = 0, u = h.count; d < u; d++)
        ut.fromBufferAttribute(h, d), n = Math.max(n, i.distanceToSquared(ut));
    }), s.radius = Math.sqrt(n), s;
  }
};
var ni = class _ni extends Cl {
  constructor(t) {
    super(t), E(this, "onBeforeUpdate", new tt()), E(this, "onAfterUpdate", new tt()), E(this, "onAspectUpdated", new tt()), E(this, "onDisposed", new tt()), E(this, "three"), E(this, "_allControls", /* @__PURE__ */ new Map()), E(this, "updateAspect", () => {
      var e;
      if (!(!this.currentWorld || !this.currentWorld.renderer)) {
        if (this.three instanceof OrthographicCamera) {
          this.onAspectUpdated.trigger();
          return;
        }
        if ((e = this.currentWorld.renderer) != null && e.isResizeable()) {
          const s = this.currentWorld.renderer.getSize();
          this.three.aspect = s.width / s.height, this.three.updateProjectionMatrix(), this.onAspectUpdated.trigger();
        }
      }
    }), this.three = this.setupCamera(), this.setupEvents(true), this.worlds.onItemSet.add(({ value: e }) => {
      const s = this.newCameraControls();
      this._allControls.set(e.uuid, s);
    }), this.worlds.onBeforeDelete.add(({ value: e }) => {
      const s = this._allControls.get(e.uuid);
      s && (s.dispose(), this._allControls.delete(e.uuid));
    });
  }
  /**
   * The object that controls the camera. An instance of
   * [yomotsu's cameracontrols](https://github.com/yomotsu/camera-controls).
   * Transforming the camera directly will have no effect: you need to use this
   * object to move, rotate, look at objects, etc.
   */
  get controls() {
    if (!this.currentWorld)
      throw new Error("This camera needs a world to work!");
    const t = this._allControls.get(this.currentWorld.uuid);
    if (!t)
      throw new Error("Controls not found!");
    return t;
  }
  /**
   * Getter for the enabled state of the camera controls.
   * If the current world is null, it returns false.
   * Otherwise, it returns the enabled state of the camera controls.
   *
   * @returns {boolean} The enabled state of the camera controls.
   */
  get enabled() {
    return this.currentWorld === null ? false : this.controls.enabled;
  }
  /**
   * Setter for the enabled state of the camera controls.
   * If the current world is not null, it sets the enabled state of the camera controls to the provided value.
   *
   * @param {boolean} enabled - The new enabled state of the camera controls.
   */
  set enabled(t) {
    this.currentWorld !== null && (this.controls.enabled = t);
  }
  set currentWorld(t) {
    if (super.currentWorld = t, !t)
      return;
    this.worlds.get(t.uuid) || this.worlds.set(t.uuid, t);
  }
  get currentWorld() {
    return this._currentWorld;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.onAspectUpdated.reset(), this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.three.removeFromParent(), this.onDisposed.trigger(), this.onDisposed.reset();
    for (const [t, e] of this._allControls)
      e.dispose();
    this.worlds.clear();
  }
  async fitToItems(t) {
    const e = await this.getItemsBounding(t);
    await this.controls.fitToSphere(e, true);
  }
  async setOrbitToItems(t) {
    const e = await this.getItemsBounding(t);
    this.controls.setOrbitPoint(
      e.center.x,
      e.center.y,
      e.center.z
    );
  }
  /** {@link Updateable.update} */
  update(t) {
    this.enabled && (this.onBeforeUpdate.trigger(this), this.controls.update(t), this.onAfterUpdate.trigger(this));
  }
  async getItemsBounding(t) {
    const e = this.components.get(ct), s = this.components.get(ha);
    s.list.clear();
    const i = new Sphere();
    if (t)
      await s.addFromModelIdMap(t);
    else
      for (const [, n] of e.list)
        s.list.add(n.box);
    return s.get().getBoundingSphere(i), s.list.clear(), i;
  }
  setupCamera() {
    const t = window.innerWidth / window.innerHeight, e = new PerspectiveCamera(60, t, 1, 1e3);
    return e.position.set(50, 50, 50), e.lookAt(new Vector3(0, 0, 0)), e;
  }
  newCameraControls() {
    if (!this.currentWorld)
      throw new Error("This camera needs a world to work!");
    if (!this.currentWorld.renderer)
      throw new Error("This camera needs a renderer to work!");
    Wt2.install({ THREE: _ni.getSubsetOfThree() });
    const { domElement: t } = this.currentWorld.renderer.three, e = new Wt2(this.three, t);
    return e.smoothTime = 0.2, e.dollyToCursor = true, e.infinityDolly = true, e.minDistance = 6, e;
  }
  setupEvents(t) {
    t ? window.addEventListener("resize", this.updateAspect) : window.removeEventListener("resize", this.updateAspect);
  }
  static getSubsetOfThree() {
    return {
      MOUSE,
      Vector2,
      Vector3,
      Vector4,
      Quaternion,
      Matrix4,
      Spherical,
      Box3,
      Sphere,
      Raycaster,
      MathUtils
    };
  }
};
var ya = class va extends St {
  constructor(t) {
    super(t), E(this, "onAfterUpdate", new tt()), E(this, "onBeforeUpdate", new tt()), E(this, "onDisposed", new tt()), E(this, "list", new Es()), E(this, "enabled", true), t.add(va.uuid, this);
  }
  /**
   * Creates a new instance of a SimpleWorld and adds it to the list of worlds.
   *
   * @template T - The type of the scene, extending from BaseScene. Defaults to BaseScene.
   * @template U - The type of the camera, extending from BaseCamera. Defaults to BaseCamera.
   * @template S - The type of the renderer, extending from BaseRenderer. Defaults to BaseRenderer.
   *
   * @throws {Error} - Throws an error if a world with the same UUID already exists in the list.
   */
  create() {
    const t = new Kc(this.components), e = t.uuid;
    if (this.list.has(e))
      throw new Error("There is already a world with this name!");
    return this.list.set(e, t), t;
  }
  /**
   * Deletes a world from the list of worlds.
   *
   * @param {World} world - The world to be deleted.
   *
   * @throws {Error} - Throws an error if the provided world is not found in the list.
   */
  delete(t) {
    if (!this.list.has(t.uuid))
      throw new Error("The provided world is not found in the list!");
    this.list.delete(t.uuid), t.dispose();
  }
  /**
   * Disposes of the Worlds component and all its managed worlds.
   * This method sets the enabled flag to false, disposes of all worlds, clears the list,
   * and triggers the onDisposed event.
   */
  dispose() {
    this.enabled = false;
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
  /** {@link Updateable.update} */
  update(t) {
    if (this.enabled)
      for (const [e, s] of this.list)
        s.update(t);
  }
};
E(ya, "uuid", "fdb61dc4-2ec1-4966-b83d-54ea795fad4a");
var wa = ya;
var sh = class extends fn {
  constructor() {
    super(...arguments), E(this, "_config", {
      visible: {
        value: true,
        type: "Boolean"
      },
      color: {
        value: new Color(),
        type: "Color"
      },
      primarySize: {
        type: "Number",
        interpolable: true,
        value: 1,
        min: 0,
        max: 1e3
      },
      secondarySize: {
        type: "Number",
        interpolable: true,
        value: 10,
        min: 0,
        max: 1e3
      },
      distance: {
        type: "Number",
        interpolable: true,
        value: 500,
        min: 0,
        max: 500
      }
    });
  }
  /**
   * Whether the grid is visible or not.
   */
  get visible() {
    return this._config.visible.value;
  }
  /**
   * Whether the grid is visible or not.
   */
  set visible(t) {
    this._config.visible.value = t, this._component.visible = t;
  }
  /**
   * The color of the grid lines.
   */
  get color() {
    return this._config.color.value;
  }
  /**
   * The color of the grid lines.
   */
  set color(t) {
    this._config.color.value = t, this._component.material.uniforms.uColor.value = t, this._component.material.uniformsNeedUpdate = true;
  }
  /**
   * The size of the primary grid lines.
   */
  get primarySize() {
    return this._config.primarySize.value;
  }
  /**
   * The size of the primary grid lines.
   */
  set primarySize(t) {
    this._config.primarySize.value = t, this._component.material.uniforms.uSize1.value = t, this._component.material.uniformsNeedUpdate = true;
  }
  /**
   * The size of the secondary grid lines.
   */
  get secondarySize() {
    return this._config.secondarySize.value;
  }
  /**
   * The size of the secondary grid lines.
   */
  set secondarySize(t) {
    this._config.secondarySize.value = t, this._component.material.uniforms.uSize2.value = t, this._component.material.uniformsNeedUpdate = true;
  }
  /**
   * The distance at which the grid lines start to fade away.
   */
  get distance() {
    return this._config.distance.value;
  }
  /**
   * The distance at which the grid lines start to fade away.
   */
  set distance(t) {
    this._config.distance.value = t, this._component.material.uniforms.uDistance.value = t, this._component.material.uniformsNeedUpdate = true;
  }
};
var ih = class {
  constructor(t, e) {
    E(this, "onDisposed", new tt()), E(this, "onSetup", new tt()), E(this, "isSetup", false), E(this, "world"), E(this, "components"), E(this, "config"), E(this, "_defaultConfig", {
      visible: true,
      color: new Color(12303291),
      primarySize: 1,
      secondarySize: 10,
      distance: 500
    }), E(this, "three"), E(this, "_fade", 3), E(this, "updateZoom", () => {
      this.world.camera instanceof ni && (this.material.uniforms.uZoom.value = this.world.camera.three.zoom);
    }), this.world = e;
    const { color: s, primarySize: i, secondarySize: n, distance: r } = this._defaultConfig;
    this.components = t, this.config = new sh(this, this.components, "Grid");
    const o = new PlaneGeometry(2, 2, 1, 1), a = new ShaderMaterial({
      side: DoubleSide,
      uniforms: {
        uSize1: {
          value: i
        },
        uSize2: {
          value: n
        },
        uColor: {
          value: s
        },
        uDistance: {
          value: r
        },
        uFade: {
          value: this._fade
        },
        uZoom: {
          value: 1
        }
      },
      transparent: true,
      vertexShader: `
            
            varying vec3 worldPosition;
            
            uniform float uDistance;
            
            void main() {
            
                    vec3 pos = position.xzy * uDistance;
                    pos.xz += cameraPosition.xz;
                    
                    worldPosition = pos;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            
            }
            `,
      fragmentShader: `
            
            varying vec3 worldPosition;
            
            uniform float uZoom;
            uniform float uFade;
            uniform float uSize1;
            uniform float uSize2;
            uniform vec3 uColor;
            uniform float uDistance;
                
                
                
                float getGrid(float size) {
                
                    vec2 r = worldPosition.xz / size;
                    
                    
                    vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
                    float line = min(grid.x, grid.y);
                    
                
                    return 1.0 - min(line, 1.0);
                }
                
            void main() {
            
                    
                    float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / uDistance, 1.0);
                    
                    float g1 = getGrid(uSize1);
                    float g2 = getGrid(uSize2);
                    
                    // Ortho camera fades the grid away when zooming out
                    float minZoom = step(0.2, uZoom);
                    float zoomFactor = pow(min(uZoom, 1.), 2.) * minZoom;
                    
                    gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, uFade));
                    gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2) * zoomFactor;
                    
                    if ( gl_FragColor.a <= 0.0 ) discard;
                    
            
            }
            
            `,
      extensions: {
        derivatives: true
      }
    });
    this.three = new Mesh(o, a), this.three.frustumCulled = false, e.scene.three.add(this.three), this.setupEvents(true);
  }
  /** {@link Hideable.visible} */
  get visible() {
    return this.three.visible;
  }
  /** {@link Hideable.visible} */
  set visible(t) {
    this.three.visible = t, t ? this.world.scene.three.add(this.three) : this.three.removeFromParent();
  }
  /** The material of the grid. */
  get material() {
    return this.three.material;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  get fade() {
    return this._fade === 3;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  set fade(t) {
    this._fade = t ? 3 : 0, this.material.uniforms.uFade.value = this._fade;
  }
  /** {@link Configurable.setup} */
  setup(t) {
    const e = { ...this._defaultConfig, ...t };
    this.config.visible = true, this.config.color = e.color, this.config.primarySize = e.primarySize, this.config.secondarySize = e.secondarySize, this.config.distance = e.distance, this.isSetup = true, this.onSetup.trigger();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.components.get(_r).list.delete(this.config.uuid), this.components.get(De).destroy(this.three), this.onDisposed.trigger(), this.onDisposed.reset(), this.world = null, this.components = null;
  }
  setupEvents(t) {
    if (this.world.isDisposing || !(this.world.camera instanceof ni))
      return;
    const e = this.world.camera.controls;
    t ? e.addEventListener("update", this.updateZoom) : e.removeEventListener("update", this.updateZoom);
  }
};
var nh = class ba extends St {
  constructor(t) {
    super(t), E(this, "list", /* @__PURE__ */ new Map()), E(this, "onDisposed", new tt()), E(this, "enabled", true), t.add(ba.uuid, this);
  }
  /**
   * Creates a new grid for the given world.
   * Throws an error if a grid already exists for the world.
   *
   * @param world - The world to create the grid for.
   * @returns The newly created grid.
   *
   * @throws Will throw an error if a grid already exists for the given world.
   */
  create(t) {
    if (this.list.has(t.uuid))
      throw new Error("This world already has a grid!");
    const e = new ih(this.components, t);
    return this.list.set(t.uuid, e), t.onDisposed.add(() => {
      this.delete(t);
    }), e;
  }
  /**
   * Deletes the grid associated with the given world.
   * If a grid does not exist for the given world, this method does nothing.
   *
   * @param world - The world for which to delete the grid.
   *
   * @remarks
   * This method will dispose of the grid and remove it from the internal list.
   * If the world is disposed before calling this method, the grid will be automatically deleted.
   */
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
E(nh, "uuid", "d1e814d5-b81c-4452-87a2-f039375e0489");
var xa = 0;
var rh = 1;
var oh = 2;
var Wr = 2;
var Cn = 1.25;
var Xr = 1;
var Yi = 6 * 4 + 4 + 4;
var pn = 65535;
var ah = Math.pow(2, -24);
var An = Symbol("SKIP_GENERATION");
function lh(l) {
  return l.index ? l.index.count : l.attributes.position.count;
}
function Cs(l) {
  return lh(l) / 3;
}
function ch(l, t = ArrayBuffer) {
  return l > 65535 ? new Uint32Array(new t(4 * l)) : new Uint16Array(new t(2 * l));
}
function hh(l, t) {
  if (!l.index) {
    const e = l.attributes.position.count, s = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, i = ch(e, s);
    l.setIndex(new BufferAttribute(i, 1));
    for (let n = 0; n < e; n++)
      i[n] = n;
  }
}
function Sa(l) {
  const t = Cs(l), e = l.drawRange, s = e.start / 3, i = (e.start + e.count) / 3, n = Math.max(0, s), r = Math.min(t, i) - n;
  return [{
    offset: Math.floor(n),
    count: Math.floor(r)
  }];
}
function Ea(l) {
  if (!l.groups || !l.groups.length)
    return Sa(l);
  const t = [], e = /* @__PURE__ */ new Set(), s = l.drawRange, i = s.start / 3, n = (s.start + s.count) / 3;
  for (const o of l.groups) {
    const a = o.start / 3, c = (o.start + o.count) / 3;
    e.add(Math.max(i, a)), e.add(Math.min(n, c));
  }
  const r = Array.from(e.values()).sort((o, a) => o - a);
  for (let o = 0; o < r.length - 1; o++) {
    const a = r[o], c = r[o + 1];
    t.push({
      offset: Math.floor(a),
      count: Math.floor(c - a)
    });
  }
  return t;
}
function dh(l) {
  if (l.groups.length === 0)
    return false;
  const t = Cs(l), e = Ea(l).sort((n, r) => n.offset - r.offset), s = e[e.length - 1];
  s.count = Math.min(t - s.offset, s.count);
  let i = 0;
  return e.forEach(({ count: n }) => i += n), t !== i;
}
function Mt(l, t, e) {
  return e.min.x = t[l], e.min.y = t[l + 1], e.min.z = t[l + 2], e.max.x = t[l + 3], e.max.y = t[l + 4], e.max.z = t[l + 5], e;
}
function uh(l) {
  l[0] = l[1] = l[2] = 1 / 0, l[3] = l[4] = l[5] = -1 / 0;
}
function Yr(l) {
  let t = -1, e = -1 / 0;
  for (let s = 0; s < 3; s++) {
    const i = l[s + 3] - l[s];
    i > e && (e = i, t = s);
  }
  return t;
}
function Gr(l, t) {
  t.set(l);
}
function Zr(l, t, e) {
  let s, i;
  for (let n = 0; n < 3; n++) {
    const r = n + 3;
    s = l[n], i = t[n], e[n] = s < i ? s : i, s = l[r], i = t[r], e[r] = s > i ? s : i;
  }
}
function mi(l, t, e) {
  for (let s = 0; s < 3; s++) {
    const i = t[l + 2 * s], n = t[l + 2 * s + 1], r = i - n, o = i + n;
    r < e[s] && (e[s] = r), o > e[s + 3] && (e[s + 3] = o);
  }
}
function Rs(l) {
  const t = l[3] - l[0], e = l[4] - l[1], s = l[5] - l[2];
  return 2 * (t * e + e * s + s * t);
}
function Pn(l, t, e, s, i = null) {
  let n = 1 / 0, r = 1 / 0, o = 1 / 0, a = -1 / 0, c = -1 / 0, h = -1 / 0, d = 1 / 0, u = 1 / 0, f = 1 / 0, g = -1 / 0, m = -1 / 0, _ = -1 / 0;
  const p = i !== null;
  for (let y = t * 6, b = (t + e) * 6; y < b; y += 6) {
    const x = l[y + 0], S = l[y + 1], C = x - S, P = x + S;
    C < n && (n = C), P > a && (a = P), p && x < d && (d = x), p && x > g && (g = x);
    const O = l[y + 2], z = l[y + 3], k = O - z, H = O + z;
    k < r && (r = k), H > c && (c = H), p && O < u && (u = O), p && O > m && (m = O);
    const T = l[y + 4], L = l[y + 5], w = T - L, N = T + L;
    w < o && (o = w), N > h && (h = N), p && T < f && (f = T), p && T > _ && (_ = T);
  }
  s[0] = n, s[1] = r, s[2] = o, s[3] = a, s[4] = c, s[5] = h, p && (i[0] = d, i[1] = u, i[2] = f, i[3] = g, i[4] = m, i[5] = _);
}
function fh(l, t, e, s) {
  let i = 1 / 0, n = 1 / 0, r = 1 / 0, o = -1 / 0, a = -1 / 0, c = -1 / 0;
  for (let h = t * 6, d = (t + e) * 6; h < d; h += 6) {
    const u = l[h + 0];
    u < i && (i = u), u > o && (o = u);
    const f = l[h + 2];
    f < n && (n = f), f > a && (a = f);
    const g = l[h + 4];
    g < r && (r = g), g > c && (c = g);
  }
  s[0] = i, s[1] = n, s[2] = r, s[3] = o, s[4] = a, s[5] = c;
}
function ph(l, t) {
  uh(t);
  const e = l.attributes.position, s = l.index ? l.index.array : null, i = Cs(l), n = new Float32Array(i * 6), r = e.normalized, o = e.array, a = e.offset || 0;
  let c = 3;
  e.isInterleavedBufferAttribute && (c = e.data.stride);
  const h = ["getX", "getY", "getZ"];
  for (let d = 0; d < i; d++) {
    const u = d * 3, f = d * 6;
    let g = u + 0, m = u + 1, _ = u + 2;
    s && (g = s[g], m = s[m], _ = s[_]), r || (g = g * c + a, m = m * c + a, _ = _ * c + a);
    for (let p = 0; p < 3; p++) {
      let y, b, x;
      r ? (y = e[h[p]](g), b = e[h[p]](m), x = e[h[p]](_)) : (y = o[g + p], b = o[m + p], x = o[_ + p]);
      let S = y;
      b < S && (S = b), x < S && (S = x);
      let C = y;
      b > C && (C = b), x > C && (C = x);
      const P = (C - S) / 2, O = p * 2;
      n[f + O + 0] = S + P, n[f + O + 1] = P + (Math.abs(S) + P) * ah, S < t[p] && (t[p] = S), C > t[p + 3] && (t[p + 3] = C);
    }
  }
  return n;
}
var Me = 32;
var mh = (l, t) => l.candidate - t.candidate;
var ke = new Array(Me).fill().map(() => ({
  count: 0,
  bounds: new Float32Array(6),
  rightCacheBounds: new Float32Array(6),
  leftCacheBounds: new Float32Array(6),
  candidate: 0
}));
var gi = new Float32Array(6);
function gh(l, t, e, s, i, n) {
  let r = -1, o = 0;
  if (n === xa)
    r = Yr(t), r !== -1 && (o = (t[r] + t[r + 3]) / 2);
  else if (n === rh)
    r = Yr(l), r !== -1 && (o = _h(e, s, i, r));
  else if (n === oh) {
    const a = Rs(l);
    let c = Cn * i;
    const h = s * 6, d = (s + i) * 6;
    for (let u = 0; u < 3; u++) {
      const f = t[u], _ = (t[u + 3] - f) / Me;
      if (i < Me / 4) {
        const p = [...ke];
        p.length = i;
        let y = 0;
        for (let x = h; x < d; x += 6, y++) {
          const S = p[y];
          S.candidate = e[x + 2 * u], S.count = 0;
          const {
            bounds: C,
            leftCacheBounds: P,
            rightCacheBounds: O
          } = S;
          for (let z = 0; z < 3; z++)
            O[z] = 1 / 0, O[z + 3] = -1 / 0, P[z] = 1 / 0, P[z + 3] = -1 / 0, C[z] = 1 / 0, C[z + 3] = -1 / 0;
          mi(x, e, C);
        }
        p.sort(mh);
        let b = i;
        for (let x = 0; x < b; x++) {
          const S = p[x];
          for (; x + 1 < b && p[x + 1].candidate === S.candidate; )
            p.splice(x + 1, 1), b--;
        }
        for (let x = h; x < d; x += 6) {
          const S = e[x + 2 * u];
          for (let C = 0; C < b; C++) {
            const P = p[C];
            S >= P.candidate ? mi(x, e, P.rightCacheBounds) : (mi(x, e, P.leftCacheBounds), P.count++);
          }
        }
        for (let x = 0; x < b; x++) {
          const S = p[x], C = S.count, P = i - S.count, O = S.leftCacheBounds, z = S.rightCacheBounds;
          let k = 0;
          C !== 0 && (k = Rs(O) / a);
          let H = 0;
          P !== 0 && (H = Rs(z) / a);
          const T = Xr + Cn * (k * C + H * P);
          T < c && (r = u, c = T, o = S.candidate);
        }
      } else {
        for (let b = 0; b < Me; b++) {
          const x = ke[b];
          x.count = 0, x.candidate = f + _ + b * _;
          const S = x.bounds;
          for (let C = 0; C < 3; C++)
            S[C] = 1 / 0, S[C + 3] = -1 / 0;
        }
        for (let b = h; b < d; b += 6) {
          let C = ~~((e[b + 2 * u] - f) / _);
          C >= Me && (C = Me - 1);
          const P = ke[C];
          P.count++, mi(b, e, P.bounds);
        }
        const p = ke[Me - 1];
        Gr(p.bounds, p.rightCacheBounds);
        for (let b = Me - 2; b >= 0; b--) {
          const x = ke[b], S = ke[b + 1];
          Zr(x.bounds, S.rightCacheBounds, x.rightCacheBounds);
        }
        let y = 0;
        for (let b = 0; b < Me - 1; b++) {
          const x = ke[b], S = x.count, C = x.bounds, O = ke[b + 1].rightCacheBounds;
          S !== 0 && (y === 0 ? Gr(C, gi) : Zr(C, gi, gi)), y += S;
          let z = 0, k = 0;
          y !== 0 && (z = Rs(gi) / a);
          const H = i - y;
          H !== 0 && (k = Rs(O) / a);
          const T = Xr + Cn * (z * y + k * H);
          T < c && (r = u, c = T, o = x.candidate);
        }
      }
    }
  } else
    console.warn(`MeshBVH: Invalid build strategy value ${n} used.`);
  return { axis: r, pos: o };
}
function _h(l, t, e, s) {
  let i = 0;
  for (let n = t, r = t + e; n < r; n++)
    i += l[n * 6 + s * 2];
  return i / e;
}
var _i = class {
  constructor() {
  }
};
function yh(l, t, e, s, i, n) {
  let r = s, o = s + i - 1;
  const a = n.pos, c = n.axis * 2;
  for (; ; ) {
    for (; r <= o && e[r * 6 + c] < a; )
      r++;
    for (; r <= o && e[o * 6 + c] >= a; )
      o--;
    if (r < o) {
      for (let h = 0; h < 3; h++) {
        let d = t[r * 3 + h];
        t[r * 3 + h] = t[o * 3 + h], t[o * 3 + h] = d;
      }
      for (let h = 0; h < 6; h++) {
        let d = e[r * 6 + h];
        e[r * 6 + h] = e[o * 6 + h], e[o * 6 + h] = d;
      }
      r++, o--;
    } else
      return r;
  }
}
function vh(l, t, e, s, i, n) {
  let r = s, o = s + i - 1;
  const a = n.pos, c = n.axis * 2;
  for (; ; ) {
    for (; r <= o && e[r * 6 + c] < a; )
      r++;
    for (; r <= o && e[o * 6 + c] >= a; )
      o--;
    if (r < o) {
      let h = l[r];
      l[r] = l[o], l[o] = h;
      for (let d = 0; d < 6; d++) {
        let u = e[r * 6 + d];
        e[r * 6 + d] = e[o * 6 + d], e[o * 6 + d] = u;
      }
      r++, o--;
    } else
      return r;
  }
}
function wh(l, t) {
  const e = (l.index ? l.index.count : l.attributes.position.count) / 3, s = e > 2 ** 16, i = s ? 4 : 2, n = t ? new SharedArrayBuffer(e * i) : new ArrayBuffer(e * i), r = s ? new Uint32Array(n) : new Uint16Array(n);
  for (let o = 0, a = r.length; o < a; o++)
    r[o] = o;
  return r;
}
function bh(l, t) {
  const e = l.geometry, s = e.index ? e.index.array : null, i = t.maxDepth, n = t.verbose, r = t.maxLeafTris, o = t.strategy, a = t.onProgress, c = Cs(e), h = l._indirectBuffer;
  let d = false;
  const u = new Float32Array(6), f = new Float32Array(6), g = ph(e, u), m = t.indirect ? vh : yh, _ = [], p = t.indirect ? Sa(e) : Ea(e);
  if (p.length === 1) {
    const x = p[0], S = new _i();
    S.boundingData = u, fh(g, x.offset, x.count, f), b(S, x.offset, x.count, f), _.push(S);
  } else
    for (let x of p) {
      const S = new _i();
      S.boundingData = new Float32Array(6), Pn(g, x.offset, x.count, S.boundingData, f), b(S, x.offset, x.count, f), _.push(S);
    }
  return _;
  function y(x) {
    a && a(x / c);
  }
  function b(x, S, C, P = null, O = 0) {
    if (!d && O >= i && (d = true, n && (console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`), console.warn(e))), C <= r || O >= i)
      return y(S + C), x.offset = S, x.count = C, x;
    const z = gh(x.boundingData, P, g, S, C, o);
    if (z.axis === -1)
      return y(S + C), x.offset = S, x.count = C, x;
    const k = m(h, s, g, S, C, z);
    if (k === S || k === S + C)
      y(S + C), x.offset = S, x.count = C;
    else {
      x.splitAxis = z.axis;
      const H = new _i(), T = S, L = k - S;
      x.left = H, H.boundingData = new Float32Array(6), Pn(g, T, L, H.boundingData, f), b(H, T, L, f, O + 1);
      const w = new _i(), N = k, K = C - L;
      x.right = w, w.boundingData = new Float32Array(6), Pn(g, N, K, w.boundingData, f), b(w, N, K, f, O + 1);
    }
    return x;
  }
}
function xh(l, t) {
  const e = l.geometry;
  t.indirect && (l._indirectBuffer = wh(e, t.useSharedArrayBuffer), dh(e) && !t.verbose && console.warn(
    'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
  )), l._indirectBuffer || hh(e, t);
  const s = bh(l, t);
  let i, n, r;
  const o = [], a = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  for (let d = 0; d < s.length; d++) {
    const u = s[d];
    let f = c(u);
    const g = new a(Yi * f);
    i = new Float32Array(g), n = new Uint32Array(g), r = new Uint16Array(g), h(0, u), o.push(g);
  }
  l._roots = o;
  return;
  function c(d) {
    return d.count ? 1 : 1 + c(d.left) + c(d.right);
  }
  function h(d, u) {
    const f = d / 4, g = d / 2, m = !!u.count, _ = u.boundingData;
    for (let p = 0; p < 6; p++)
      i[f + p] = _[p];
    if (m) {
      const p = u.offset, y = u.count;
      return n[f + 6] = p, r[g + 14] = y, r[g + 15] = pn, d + Yi;
    } else {
      const p = u.left, y = u.right, b = u.splitAxis;
      let x;
      if (x = h(d + Yi, p), x / 4 > Math.pow(2, 32))
        throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
      return n[f + 6] = x / 4, x = h(x, y), n[f + 7] = b, x;
    }
  }
}
var Ie = class {
  constructor() {
    this.min = 1 / 0, this.max = -1 / 0;
  }
  setFromPointsField(t, e) {
    let s = 1 / 0, i = -1 / 0;
    for (let n = 0, r = t.length; n < r; n++) {
      const a = t[n][e];
      s = a < s ? a : s, i = a > i ? a : i;
    }
    this.min = s, this.max = i;
  }
  setFromPoints(t, e) {
    let s = 1 / 0, i = -1 / 0;
    for (let n = 0, r = e.length; n < r; n++) {
      const o = e[n], a = t.dot(o);
      s = a < s ? a : s, i = a > i ? a : i;
    }
    this.min = s, this.max = i;
  }
  isSeparated(t) {
    return this.min > t.max || t.min > this.max;
  }
};
Ie.prototype.setFromBox = function() {
  const l = new Vector3();
  return function(e, s) {
    const i = s.min, n = s.max;
    let r = 1 / 0, o = -1 / 0;
    for (let a = 0; a <= 1; a++)
      for (let c = 0; c <= 1; c++)
        for (let h = 0; h <= 1; h++) {
          l.x = i.x * a + n.x * (1 - a), l.y = i.y * c + n.y * (1 - c), l.z = i.z * h + n.z * (1 - h);
          const d = e.dot(l);
          r = Math.min(d, r), o = Math.max(d, o);
        }
    this.min = r, this.max = o;
  };
}();
var Sh = function() {
  const l = new Vector3(), t = new Vector3(), e = new Vector3();
  return function(i, n, r) {
    const o = i.start, a = l, c = n.start, h = t;
    e.subVectors(o, c), l.subVectors(i.end, i.start), t.subVectors(n.end, n.start);
    const d = e.dot(h), u = h.dot(a), f = h.dot(h), g = e.dot(a), _ = a.dot(a) * f - u * u;
    let p, y;
    _ !== 0 ? p = (d * u - g * f) / _ : p = 0, y = (d + p * u) / f, r.x = p, r.y = y;
  };
}();
var yr = function() {
  const l = new Vector2(), t = new Vector3(), e = new Vector3();
  return function(i, n, r, o) {
    Sh(i, n, l);
    let a = l.x, c = l.y;
    if (a >= 0 && a <= 1 && c >= 0 && c <= 1) {
      i.at(a, r), n.at(c, o);
      return;
    } else if (a >= 0 && a <= 1) {
      c < 0 ? n.at(0, o) : n.at(1, o), i.closestPointToPoint(o, true, r);
      return;
    } else if (c >= 0 && c <= 1) {
      a < 0 ? i.at(0, r) : i.at(1, r), n.closestPointToPoint(r, true, o);
      return;
    } else {
      let h;
      a < 0 ? h = i.start : h = i.end;
      let d;
      c < 0 ? d = n.start : d = n.end;
      const u = t, f = e;
      if (i.closestPointToPoint(d, true, t), n.closestPointToPoint(h, true, e), u.distanceToSquared(d) <= f.distanceToSquared(h)) {
        r.copy(u), o.copy(d);
        return;
      } else {
        r.copy(h), o.copy(f);
        return;
      }
    }
  };
}();
var Eh = function() {
  const l = new Vector3(), t = new Vector3(), e = new Plane(), s = new Line3();
  return function(n, r) {
    const { radius: o, center: a } = n, { a: c, b: h, c: d } = r;
    if (s.start = c, s.end = h, s.closestPointToPoint(a, true, l).distanceTo(a) <= o || (s.start = c, s.end = d, s.closestPointToPoint(a, true, l).distanceTo(a) <= o) || (s.start = h, s.end = d, s.closestPointToPoint(a, true, l).distanceTo(a) <= o))
      return true;
    const m = r.getPlane(e);
    if (Math.abs(m.distanceToPoint(a)) <= o) {
      const p = m.projectPoint(a, t);
      if (r.containsPoint(p))
        return true;
    }
    return false;
  };
}();
var Th = 1e-15;
function Mn(l) {
  return Math.abs(l) < Th;
}
var ge = class extends Triangle {
  constructor(...t) {
    super(...t), this.isExtendedTriangle = true, this.satAxes = new Array(4).fill().map(() => new Vector3()), this.satBounds = new Array(4).fill().map(() => new Ie()), this.points = [this.a, this.b, this.c], this.sphere = new Sphere(), this.plane = new Plane(), this.needsUpdate = true;
  }
  intersectsSphere(t) {
    return Eh(t, this);
  }
  update() {
    const t = this.a, e = this.b, s = this.c, i = this.points, n = this.satAxes, r = this.satBounds, o = n[0], a = r[0];
    this.getNormal(o), a.setFromPoints(o, i);
    const c = n[1], h = r[1];
    c.subVectors(t, e), h.setFromPoints(c, i);
    const d = n[2], u = r[2];
    d.subVectors(e, s), u.setFromPoints(d, i);
    const f = n[3], g = r[3];
    f.subVectors(s, t), g.setFromPoints(f, i), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(o, t), this.needsUpdate = false;
  }
};
ge.prototype.closestPointToSegment = function() {
  const l = new Vector3(), t = new Vector3(), e = new Line3();
  return function(i, n = null, r = null) {
    const { start: o, end: a } = i, c = this.points;
    let h, d = 1 / 0;
    for (let u = 0; u < 3; u++) {
      const f = (u + 1) % 3;
      e.start.copy(c[u]), e.end.copy(c[f]), yr(e, i, l, t), h = l.distanceToSquared(t), h < d && (d = h, n && n.copy(l), r && r.copy(t));
    }
    return this.closestPointToPoint(o, l), h = o.distanceToSquared(l), h < d && (d = h, n && n.copy(l), r && r.copy(o)), this.closestPointToPoint(a, l), h = a.distanceToSquared(l), h < d && (d = h, n && n.copy(l), r && r.copy(a)), Math.sqrt(d);
  };
}();
ge.prototype.intersectsTriangle = function() {
  const l = new ge(), t = new Array(3), e = new Array(3), s = new Ie(), i = new Ie(), n = new Vector3(), r = new Vector3(), o = new Vector3(), a = new Vector3(), c = new Vector3(), h = new Line3(), d = new Line3(), u = new Line3(), f = new Vector3();
  function g(m, _, p) {
    const y = m.points;
    let b = 0, x = -1;
    for (let S = 0; S < 3; S++) {
      const { start: C, end: P } = h;
      C.copy(y[S]), P.copy(y[(S + 1) % 3]), h.delta(r);
      const O = Mn(_.distanceToPoint(C));
      if (Mn(_.normal.dot(r)) && O) {
        p.copy(h), b = 2;
        break;
      }
      const z = _.intersectLine(h, f);
      if (!z && O && f.copy(C), (z || O) && !Mn(f.distanceTo(P))) {
        if (b <= 1)
          (b === 1 ? p.start : p.end).copy(f), O && (x = b);
        else if (b >= 2) {
          (x === 1 ? p.start : p.end).copy(f), b = 2;
          break;
        }
        if (b++, b === 2 && x === -1)
          break;
      }
    }
    return b;
  }
  return function(_, p = null, y = false) {
    this.needsUpdate && this.update(), _.isExtendedTriangle ? _.needsUpdate && _.update() : (l.copy(_), l.update(), _ = l);
    const b = this.plane, x = _.plane;
    if (Math.abs(b.normal.dot(x.normal)) > 1 - 1e-10) {
      const S = this.satBounds, C = this.satAxes;
      e[0] = _.a, e[1] = _.b, e[2] = _.c;
      for (let z = 0; z < 4; z++) {
        const k = S[z], H = C[z];
        if (s.setFromPoints(H, e), k.isSeparated(s))
          return false;
      }
      const P = _.satBounds, O = _.satAxes;
      t[0] = this.a, t[1] = this.b, t[2] = this.c;
      for (let z = 0; z < 4; z++) {
        const k = P[z], H = O[z];
        if (s.setFromPoints(H, t), k.isSeparated(s))
          return false;
      }
      for (let z = 0; z < 4; z++) {
        const k = C[z];
        for (let H = 0; H < 4; H++) {
          const T = O[H];
          if (n.crossVectors(k, T), s.setFromPoints(n, t), i.setFromPoints(n, e), s.isSeparated(i))
            return false;
        }
      }
      return p && (y || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), p.start.set(0, 0, 0), p.end.set(0, 0, 0)), true;
    } else {
      const S = g(this, x, d);
      if (S === 1 && _.containsPoint(d.end))
        return p && (p.start.copy(d.end), p.end.copy(d.end)), true;
      if (S !== 2)
        return false;
      const C = g(_, b, u);
      if (C === 1 && this.containsPoint(u.end))
        return p && (p.start.copy(u.end), p.end.copy(u.end)), true;
      if (C !== 2)
        return false;
      if (d.delta(o), u.delta(a), o.dot(a) < 0) {
        let L = u.start;
        u.start = u.end, u.end = L;
      }
      const P = d.start.dot(o), O = d.end.dot(o), z = u.start.dot(o), k = u.end.dot(o), H = O < z, T = P < k;
      return P !== k && z !== O && H === T ? false : (p && (c.subVectors(d.start, u.start), c.dot(o) > 0 ? p.start.copy(d.start) : p.start.copy(u.start), c.subVectors(d.end, u.end), c.dot(o) < 0 ? p.end.copy(d.end) : p.end.copy(u.end)), true);
    }
  };
}();
ge.prototype.distanceToPoint = function() {
  const l = new Vector3();
  return function(e) {
    return this.closestPointToPoint(e, l), e.distanceTo(l);
  };
}();
ge.prototype.distanceToTriangle = function() {
  const l = new Vector3(), t = new Vector3(), e = ["a", "b", "c"], s = new Line3(), i = new Line3();
  return function(r, o = null, a = null) {
    const c = o || a ? s : null;
    if (this.intersectsTriangle(r, c))
      return (o || a) && (o && c.getCenter(o), a && c.getCenter(a)), 0;
    let h = 1 / 0;
    for (let d = 0; d < 3; d++) {
      let u;
      const f = e[d], g = r[f];
      this.closestPointToPoint(g, l), u = g.distanceToSquared(l), u < h && (h = u, o && o.copy(l), a && a.copy(g));
      const m = this[f];
      r.closestPointToPoint(m, l), u = m.distanceToSquared(l), u < h && (h = u, o && o.copy(m), a && a.copy(l));
    }
    for (let d = 0; d < 3; d++) {
      const u = e[d], f = e[(d + 1) % 3];
      s.set(this[u], this[f]);
      for (let g = 0; g < 3; g++) {
        const m = e[g], _ = e[(g + 1) % 3];
        i.set(r[m], r[_]), yr(s, i, l, t);
        const p = l.distanceToSquared(t);
        p < h && (h = p, o && o.copy(l), a && a.copy(t));
      }
    }
    return Math.sqrt(h);
  };
}();
var qt = class {
  constructor(t, e, s) {
    this.isOrientedBox = true, this.min = new Vector3(), this.max = new Vector3(), this.matrix = new Matrix4(), this.invMatrix = new Matrix4(), this.points = new Array(8).fill().map(() => new Vector3()), this.satAxes = new Array(3).fill().map(() => new Vector3()), this.satBounds = new Array(3).fill().map(() => new Ie()), this.alignedSatBounds = new Array(3).fill().map(() => new Ie()), this.needsUpdate = false, t && this.min.copy(t), e && this.max.copy(e), s && this.matrix.copy(s);
  }
  set(t, e, s) {
    this.min.copy(t), this.max.copy(e), this.matrix.copy(s), this.needsUpdate = true;
  }
  copy(t) {
    this.min.copy(t.min), this.max.copy(t.max), this.matrix.copy(t.matrix), this.needsUpdate = true;
  }
};
qt.prototype.update = /* @__PURE__ */ function() {
  return function() {
    const t = this.matrix, e = this.min, s = this.max, i = this.points;
    for (let c = 0; c <= 1; c++)
      for (let h = 0; h <= 1; h++)
        for (let d = 0; d <= 1; d++) {
          const u = 1 * c | 2 * h | 4 * d, f = i[u];
          f.x = c ? s.x : e.x, f.y = h ? s.y : e.y, f.z = d ? s.z : e.z, f.applyMatrix4(t);
        }
    const n = this.satBounds, r = this.satAxes, o = i[0];
    for (let c = 0; c < 3; c++) {
      const h = r[c], d = n[c], u = 1 << c, f = i[u];
      h.subVectors(o, f), d.setFromPoints(h, i);
    }
    const a = this.alignedSatBounds;
    a[0].setFromPointsField(i, "x"), a[1].setFromPointsField(i, "y"), a[2].setFromPointsField(i, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = false;
  };
}();
qt.prototype.intersectsBox = function() {
  const l = new Ie();
  return function(e) {
    this.needsUpdate && this.update();
    const s = e.min, i = e.max, n = this.satBounds, r = this.satAxes, o = this.alignedSatBounds;
    if (l.min = s.x, l.max = i.x, o[0].isSeparated(l) || (l.min = s.y, l.max = i.y, o[1].isSeparated(l)) || (l.min = s.z, l.max = i.z, o[2].isSeparated(l)))
      return false;
    for (let a = 0; a < 3; a++) {
      const c = r[a], h = n[a];
      if (l.setFromBox(c, e), h.isSeparated(l))
        return false;
    }
    return true;
  };
}();
qt.prototype.intersectsTriangle = function() {
  const l = new ge(), t = new Array(3), e = new Ie(), s = new Ie(), i = new Vector3();
  return function(r) {
    this.needsUpdate && this.update(), r.isExtendedTriangle ? r.needsUpdate && r.update() : (l.copy(r), l.update(), r = l);
    const o = this.satBounds, a = this.satAxes;
    t[0] = r.a, t[1] = r.b, t[2] = r.c;
    for (let u = 0; u < 3; u++) {
      const f = o[u], g = a[u];
      if (e.setFromPoints(g, t), f.isSeparated(e))
        return false;
    }
    const c = r.satBounds, h = r.satAxes, d = this.points;
    for (let u = 0; u < 3; u++) {
      const f = c[u], g = h[u];
      if (e.setFromPoints(g, d), f.isSeparated(e))
        return false;
    }
    for (let u = 0; u < 3; u++) {
      const f = a[u];
      for (let g = 0; g < 4; g++) {
        const m = h[g];
        if (i.crossVectors(f, m), e.setFromPoints(i, t), s.setFromPoints(i, d), e.isSeparated(s))
          return false;
      }
    }
    return true;
  };
}();
qt.prototype.closestPointToPoint = /* @__PURE__ */ function() {
  return function(t, e) {
    return this.needsUpdate && this.update(), e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), e;
  };
}();
qt.prototype.distanceToPoint = function() {
  const l = new Vector3();
  return function(e) {
    return this.closestPointToPoint(e, l), e.distanceTo(l);
  };
}();
qt.prototype.distanceToBox = function() {
  const l = ["x", "y", "z"], t = new Array(12).fill().map(() => new Line3()), e = new Array(12).fill().map(() => new Line3()), s = new Vector3(), i = new Vector3();
  return function(r, o = 0, a = null, c = null) {
    if (this.needsUpdate && this.update(), this.intersectsBox(r))
      return (a || c) && (r.getCenter(i), this.closestPointToPoint(i, s), r.closestPointToPoint(s, i), a && a.copy(s), c && c.copy(i)), 0;
    const h = o * o, d = r.min, u = r.max, f = this.points;
    let g = 1 / 0;
    for (let _ = 0; _ < 8; _++) {
      const p = f[_];
      i.copy(p).clamp(d, u);
      const y = p.distanceToSquared(i);
      if (y < g && (g = y, a && a.copy(p), c && c.copy(i), y < h))
        return Math.sqrt(y);
    }
    let m = 0;
    for (let _ = 0; _ < 3; _++)
      for (let p = 0; p <= 1; p++)
        for (let y = 0; y <= 1; y++) {
          const b = (_ + 1) % 3, x = (_ + 2) % 3, S = p << b | y << x, C = 1 << _ | p << b | y << x, P = f[S], O = f[C];
          t[m].set(P, O);
          const k = l[_], H = l[b], T = l[x], L = e[m], w = L.start, N = L.end;
          w[k] = d[k], w[H] = p ? d[H] : u[H], w[T] = y ? d[T] : u[H], N[k] = u[k], N[H] = p ? d[H] : u[H], N[T] = y ? d[T] : u[H], m++;
        }
    for (let _ = 0; _ <= 1; _++)
      for (let p = 0; p <= 1; p++)
        for (let y = 0; y <= 1; y++) {
          i.x = _ ? u.x : d.x, i.y = p ? u.y : d.y, i.z = y ? u.z : d.z, this.closestPointToPoint(i, s);
          const b = i.distanceToSquared(s);
          if (b < g && (g = b, a && a.copy(s), c && c.copy(i), b < h))
            return Math.sqrt(b);
        }
    for (let _ = 0; _ < 12; _++) {
      const p = t[_];
      for (let y = 0; y < 12; y++) {
        const b = e[y];
        yr(p, b, s, i);
        const x = s.distanceToSquared(i);
        if (x < g && (g = x, a && a.copy(s), c && c.copy(i), x < h))
          return Math.sqrt(x);
      }
    }
    return Math.sqrt(g);
  };
}();
var vr = class {
  constructor(t) {
    this._getNewPrimitive = t, this._primitives = [];
  }
  getPrimitive() {
    const t = this._primitives;
    return t.length === 0 ? this._getNewPrimitive() : t.pop();
  }
  releasePrimitive(t) {
    this._primitives.push(t);
  }
};
var Ch = class extends vr {
  constructor() {
    super(() => new ge());
  }
};
var ne = new Ch();
function te(l, t) {
  return t[l + 15] === 65535;
}
function ee(l, t) {
  return t[l + 6];
}
function re(l, t) {
  return t[l + 14];
}
function oe(l) {
  return l + 8;
}
function ae(l, t) {
  return t[l + 6];
}
function Ta(l, t) {
  return t[l + 7];
}
var Ah = class {
  constructor() {
    this.float32Array = null, this.uint16Array = null, this.uint32Array = null;
    const t = [];
    let e = null;
    this.setBuffer = (s) => {
      e && t.push(e), e = s, this.float32Array = new Float32Array(s), this.uint16Array = new Uint16Array(s), this.uint32Array = new Uint32Array(s);
    }, this.clearBuffer = () => {
      e = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, t.length !== 0 && this.setBuffer(t.pop());
    };
  }
};
var Tt = new Ah();
var He;
var xs;
var hs = [];
var yi = new vr(() => new Box3());
function Ph(l, t, e, s, i, n) {
  He = yi.getPrimitive(), xs = yi.getPrimitive(), hs.push(He, xs), Tt.setBuffer(l._roots[t]);
  const r = $n(0, l.geometry, e, s, i, n);
  Tt.clearBuffer(), yi.releasePrimitive(He), yi.releasePrimitive(xs), hs.pop(), hs.pop();
  const o = hs.length;
  return o > 0 && (xs = hs[o - 1], He = hs[o - 2]), r;
}
function $n(l, t, e, s, i = null, n = 0, r = 0) {
  const { float32Array: o, uint16Array: a, uint32Array: c } = Tt;
  let h = l * 2;
  if (te(h, a)) {
    const u = ee(l, c), f = re(h, a);
    return Mt(l, o, He), s(u, f, false, r, n + l, He);
  } else {
    let u = function(T) {
      const { uint16Array: L, uint32Array: w } = Tt;
      let N = T * 2;
      for (; !te(N, L); )
        T = oe(T), N = T * 2;
      return ee(T, w);
    }, f = function(T) {
      const { uint16Array: L, uint32Array: w } = Tt;
      let N = T * 2;
      for (; !te(N, L); )
        T = ae(T, w), N = T * 2;
      return ee(T, w) + re(N, L);
    };
    const g = oe(l), m = ae(l, c);
    let _ = g, p = m, y, b, x, S;
    if (i && (x = He, S = xs, Mt(_, o, x), Mt(p, o, S), y = i(x), b = i(S), b < y)) {
      _ = m, p = g;
      const T = y;
      y = b, b = T, x = S;
    }
    x || (x = He, Mt(_, o, x));
    const C = te(_ * 2, a), P = e(x, C, y, r + 1, n + _);
    let O;
    if (P === Wr) {
      const T = u(_), w = f(_) - T;
      O = s(T, w, true, r + 1, n + _, x);
    } else
      O = P && $n(
        _,
        t,
        e,
        s,
        i,
        n,
        r + 1
      );
    if (O)
      return true;
    S = xs, Mt(p, o, S);
    const z = te(p * 2, a), k = e(S, z, b, r + 1, n + p);
    let H;
    if (k === Wr) {
      const T = u(p), w = f(p) - T;
      H = s(T, w, true, r + 1, n + p, S);
    } else
      H = k && $n(
        p,
        t,
        e,
        s,
        i,
        n,
        r + 1
      );
    return !!H;
  }
}
var Us = new Vector3();
var On = new Vector3();
function Mh(l, t, e = {}, s = 0, i = 1 / 0) {
  const n = s * s, r = i * i;
  let o = 1 / 0, a = null;
  if (l.shapecast(
    {
      boundsTraverseOrder: (h) => (Us.copy(t).clamp(h.min, h.max), Us.distanceToSquared(t)),
      intersectsBounds: (h, d, u) => u < o && u < r,
      intersectsTriangle: (h, d) => {
        h.closestPointToPoint(t, Us);
        const u = t.distanceToSquared(Us);
        return u < o && (On.copy(Us), o = u, a = d), u < n;
      }
    }
  ), o === 1 / 0)
    return null;
  const c = Math.sqrt(o);
  return e.point ? e.point.copy(On) : e.point = On.clone(), e.distance = c, e.faceIndex = a, e;
}
var ds = new Vector3();
var us = new Vector3();
var fs = new Vector3();
var vi = new Vector2();
var wi = new Vector2();
var bi = new Vector2();
var qr = new Vector3();
var Qr = new Vector3();
var Kr = new Vector3();
var xi = new Vector3();
function Oh(l, t, e, s, i, n) {
  let r;
  return n === BackSide ? r = l.intersectTriangle(s, e, t, true, i) : r = l.intersectTriangle(t, e, s, n !== DoubleSide, i), r === null ? null : {
    distance: l.origin.distanceTo(i),
    point: i.clone()
  };
}
function Dh(l, t, e, s, i, n, r, o, a) {
  ds.fromBufferAttribute(t, n), us.fromBufferAttribute(t, r), fs.fromBufferAttribute(t, o);
  const c = Oh(l, ds, us, fs, xi, a);
  if (c) {
    s && (vi.fromBufferAttribute(s, n), wi.fromBufferAttribute(s, r), bi.fromBufferAttribute(s, o), c.uv = Triangle.getInterpolation(xi, ds, us, fs, vi, wi, bi, new Vector2())), i && (vi.fromBufferAttribute(i, n), wi.fromBufferAttribute(i, r), bi.fromBufferAttribute(i, o), c.uv1 = Triangle.getInterpolation(xi, ds, us, fs, vi, wi, bi, new Vector2())), e && (qr.fromBufferAttribute(e, n), Qr.fromBufferAttribute(e, r), Kr.fromBufferAttribute(e, o), c.normal = Triangle.getInterpolation(xi, ds, us, fs, qr, Qr, Kr, new Vector3()), c.normal.dot(l.direction) > 0 && c.normal.multiplyScalar(-1));
    const h = {
      a: n,
      b: r,
      c: o,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(ds, us, fs, h.normal), c.face = h, c.faceIndex = n;
  }
  return c;
}
function mn(l, t, e, s, i) {
  const n = s * 3;
  let r = n + 0, o = n + 1, a = n + 2;
  const c = l.index;
  l.index && (r = c.getX(r), o = c.getX(o), a = c.getX(a));
  const { position: h, normal: d, uv: u, uv1: f } = l.attributes, g = Dh(e, h, d, u, f, r, o, a, t);
  return g ? (g.faceIndex = s, i && i.push(g), g) : null;
}
function Lt(l, t, e, s) {
  const i = l.a, n = l.b, r = l.c;
  let o = t, a = t + 1, c = t + 2;
  e && (o = e.getX(o), a = e.getX(a), c = e.getX(c)), i.x = s.getX(o), i.y = s.getY(o), i.z = s.getZ(o), n.x = s.getX(a), n.y = s.getY(a), n.z = s.getZ(a), r.x = s.getX(c), r.y = s.getY(c), r.z = s.getZ(c);
}
function Ih(l, t, e, s, i, n) {
  const { geometry: r, _indirectBuffer: o } = l;
  for (let a = s, c = s + i; a < c; a++)
    mn(r, t, e, a, n);
}
function zh(l, t, e, s, i) {
  const { geometry: n, _indirectBuffer: r } = l;
  let o = 1 / 0, a = null;
  for (let c = s, h = s + i; c < h; c++) {
    let d;
    d = mn(n, t, e, c), d && d.distance < o && (a = d, o = d.distance);
  }
  return a;
}
function Lh(l, t, e, s, i, n, r) {
  const { geometry: o } = e, { index: a } = o, c = o.attributes.position;
  for (let h = l, d = t + l; h < d; h++) {
    let u;
    if (u = h, Lt(r, u * 3, a, c), r.needsUpdate = true, s(r, u, i, n))
      return true;
  }
  return false;
}
function Nh(l, t = null) {
  t && Array.isArray(t) && (t = new Set(t));
  const e = l.geometry, s = e.index ? e.index.array : null, i = e.attributes.position;
  let n, r, o, a, c = 0;
  const h = l._roots;
  for (let u = 0, f = h.length; u < f; u++)
    n = h[u], r = new Uint32Array(n), o = new Uint16Array(n), a = new Float32Array(n), d(0, c), c += n.byteLength;
  function d(u, f, g = false) {
    const m = u * 2;
    if (o[m + 15] === pn) {
      const p = r[u + 6], y = o[m + 14];
      let b = 1 / 0, x = 1 / 0, S = 1 / 0, C = -1 / 0, P = -1 / 0, O = -1 / 0;
      for (let z = 3 * p, k = 3 * (p + y); z < k; z++) {
        let H = s[z];
        const T = i.getX(H), L = i.getY(H), w = i.getZ(H);
        T < b && (b = T), T > C && (C = T), L < x && (x = L), L > P && (P = L), w < S && (S = w), w > O && (O = w);
      }
      return a[u + 0] !== b || a[u + 1] !== x || a[u + 2] !== S || a[u + 3] !== C || a[u + 4] !== P || a[u + 5] !== O ? (a[u + 0] = b, a[u + 1] = x, a[u + 2] = S, a[u + 3] = C, a[u + 4] = P, a[u + 5] = O, true) : false;
    } else {
      const p = u + 8, y = r[u + 6], b = p + f, x = y + f;
      let S = g, C = false, P = false;
      t ? S || (C = t.has(b), P = t.has(x), S = !C && !P) : (C = true, P = true);
      const O = S || C, z = S || P;
      let k = false;
      O && (k = d(p, f, S));
      let H = false;
      z && (H = d(y, f, S));
      const T = k || H;
      if (T)
        for (let L = 0; L < 3; L++) {
          const w = p + L, N = y + L, K = a[w], W = a[w + 3], st = a[N], j = a[N + 3];
          a[u + L] = K < st ? K : st, a[u + L + 3] = W > j ? W : j;
        }
      return T;
    }
  }
}
var Jr = new Box3();
function Xe(l, t, e, s) {
  return Mt(l, t, Jr), e.intersectBox(Jr, s);
}
function kh(l, t, e, s, i, n) {
  const { geometry: r, _indirectBuffer: o } = l;
  for (let a = s, c = s + i; a < c; a++) {
    let h = o ? o[a] : a;
    mn(r, t, e, h, n);
  }
}
function Bh(l, t, e, s, i) {
  const { geometry: n, _indirectBuffer: r } = l;
  let o = 1 / 0, a = null;
  for (let c = s, h = s + i; c < h; c++) {
    let d;
    d = mn(n, t, e, r ? r[c] : c), d && d.distance < o && (a = d, o = d.distance);
  }
  return a;
}
function Rh(l, t, e, s, i, n, r) {
  const { geometry: o } = e, { index: a } = o, c = o.attributes.position;
  for (let h = l, d = t + l; h < d; h++) {
    let u;
    if (u = e.resolveTriangleIndex(h), Lt(r, u * 3, a, c), r.needsUpdate = true, s(r, u, i, n))
      return true;
  }
  return false;
}
var $r = new Vector3();
function Uh(l, t, e, s, i) {
  Tt.setBuffer(l._roots[t]), tr(0, l, e, s, i), Tt.clearBuffer();
}
function tr(l, t, e, s, i) {
  const { float32Array: n, uint16Array: r, uint32Array: o } = Tt, a = l * 2;
  if (te(a, r)) {
    const h = ee(l, o), d = re(a, r);
    Ih(t, e, s, h, d, i);
  } else {
    const h = oe(l);
    Xe(h, n, s, $r) && tr(h, t, e, s, i);
    const d = ae(l, o);
    Xe(d, n, s, $r) && tr(d, t, e, s, i);
  }
}
var to = new Vector3();
var Fh = ["x", "y", "z"];
function Vh(l, t, e, s) {
  Tt.setBuffer(l._roots[t]);
  const i = er(0, l, e, s);
  return Tt.clearBuffer(), i;
}
function er(l, t, e, s) {
  const { float32Array: i, uint16Array: n, uint32Array: r } = Tt;
  let o = l * 2;
  if (te(o, n)) {
    const c = ee(l, r), h = re(o, n);
    return zh(t, e, s, c, h);
  } else {
    const c = Ta(l, r), h = Fh[c], u = s.direction[h] >= 0;
    let f, g;
    u ? (f = oe(l), g = ae(l, r)) : (f = ae(l, r), g = oe(l));
    const _ = Xe(f, i, s, to) ? er(f, t, e, s) : null;
    if (_) {
      const b = _.point[h];
      if (u ? b <= i[g + c] : (
        // min bounding data
        b >= i[g + c + 3]
      ))
        return _;
    }
    const y = Xe(g, i, s, to) ? er(g, t, e, s) : null;
    return _ && y ? _.distance <= y.distance ? _ : y : _ || y || null;
  }
}
var Si = new Box3();
var ps = new ge();
var ms = new ge();
var Fs = new Matrix4();
var eo = new qt();
var Ei = new qt();
function Hh(l, t, e, s) {
  Tt.setBuffer(l._roots[t]);
  const i = sr(0, l, e, s);
  return Tt.clearBuffer(), i;
}
function sr(l, t, e, s, i = null) {
  const { float32Array: n, uint16Array: r, uint32Array: o } = Tt;
  let a = l * 2;
  if (i === null && (e.boundingBox || e.computeBoundingBox(), eo.set(e.boundingBox.min, e.boundingBox.max, s), i = eo), te(a, r)) {
    const h = t.geometry, d = h.index, u = h.attributes.position, f = e.index, g = e.attributes.position, m = ee(l, o), _ = re(a, r);
    if (Fs.copy(s).invert(), e.boundsTree)
      return Mt(l, n, Ei), Ei.matrix.copy(Fs), Ei.needsUpdate = true, e.boundsTree.shapecast({
        intersectsBounds: (y) => Ei.intersectsBox(y),
        intersectsTriangle: (y) => {
          y.a.applyMatrix4(s), y.b.applyMatrix4(s), y.c.applyMatrix4(s), y.needsUpdate = true;
          for (let b = m * 3, x = (_ + m) * 3; b < x; b += 3)
            if (Lt(ms, b, d, u), ms.needsUpdate = true, y.intersectsTriangle(ms))
              return true;
          return false;
        }
      });
    for (let p = m * 3, y = (_ + m) * 3; p < y; p += 3) {
      Lt(ps, p, d, u), ps.a.applyMatrix4(Fs), ps.b.applyMatrix4(Fs), ps.c.applyMatrix4(Fs), ps.needsUpdate = true;
      for (let b = 0, x = f.count; b < x; b += 3)
        if (Lt(ms, b, f, g), ms.needsUpdate = true, ps.intersectsTriangle(ms))
          return true;
    }
  } else {
    const h = l + 8, d = o[l + 6];
    return Mt(h, n, Si), !!(i.intersectsBox(Si) && sr(h, t, e, s, i) || (Mt(d, n, Si), i.intersectsBox(Si) && sr(d, t, e, s, i)));
  }
}
var Ti = new Matrix4();
var Dn = new qt();
var Vs = new qt();
var jh = new Vector3();
var Wh = new Vector3();
var Xh = new Vector3();
var Yh = new Vector3();
function Gh(l, t, e, s = {}, i = {}, n = 0, r = 1 / 0) {
  t.boundingBox || t.computeBoundingBox(), Dn.set(t.boundingBox.min, t.boundingBox.max, e), Dn.needsUpdate = true;
  const o = l.geometry, a = o.attributes.position, c = o.index, h = t.attributes.position, d = t.index, u = ne.getPrimitive(), f = ne.getPrimitive();
  let g = jh, m = Wh, _ = null, p = null;
  i && (_ = Xh, p = Yh);
  let y = 1 / 0, b = null, x = null;
  return Ti.copy(e).invert(), Vs.matrix.copy(Ti), l.shapecast(
    {
      boundsTraverseOrder: (S) => Dn.distanceToBox(S),
      intersectsBounds: (S, C, P) => P < y && P < r ? (C && (Vs.min.copy(S.min), Vs.max.copy(S.max), Vs.needsUpdate = true), true) : false,
      intersectsRange: (S, C) => {
        if (t.boundsTree)
          return t.boundsTree.shapecast({
            boundsTraverseOrder: (O) => Vs.distanceToBox(O),
            intersectsBounds: (O, z, k) => k < y && k < r,
            intersectsRange: (O, z) => {
              for (let k = O, H = O + z; k < H; k++) {
                Lt(f, 3 * k, d, h), f.a.applyMatrix4(e), f.b.applyMatrix4(e), f.c.applyMatrix4(e), f.needsUpdate = true;
                for (let T = S, L = S + C; T < L; T++) {
                  Lt(u, 3 * T, c, a), u.needsUpdate = true;
                  const w = u.distanceToTriangle(f, g, _);
                  if (w < y && (m.copy(g), p && p.copy(_), y = w, b = T, x = k), w < n)
                    return true;
                }
              }
            }
          });
        {
          const P = Cs(t);
          for (let O = 0, z = P; O < z; O++) {
            Lt(f, 3 * O, d, h), f.a.applyMatrix4(e), f.b.applyMatrix4(e), f.c.applyMatrix4(e), f.needsUpdate = true;
            for (let k = S, H = S + C; k < H; k++) {
              Lt(u, 3 * k, c, a), u.needsUpdate = true;
              const T = u.distanceToTriangle(f, g, _);
              if (T < y && (m.copy(g), p && p.copy(_), y = T, b = k, x = O), T < n)
                return true;
            }
          }
        }
      }
    }
  ), ne.releasePrimitive(u), ne.releasePrimitive(f), y === 1 / 0 ? null : (s.point ? s.point.copy(m) : s.point = m.clone(), s.distance = y, s.faceIndex = b, i && (i.point ? i.point.copy(p) : i.point = p.clone(), i.point.applyMatrix4(Ti), m.applyMatrix4(Ti), i.distance = m.sub(i.point).length(), i.faceIndex = x), s);
}
function Zh(l, t = null) {
  t && Array.isArray(t) && (t = new Set(t));
  const e = l.geometry, s = e.index ? e.index.array : null, i = e.attributes.position;
  let n, r, o, a, c = 0;
  const h = l._roots;
  for (let u = 0, f = h.length; u < f; u++)
    n = h[u], r = new Uint32Array(n), o = new Uint16Array(n), a = new Float32Array(n), d(0, c), c += n.byteLength;
  function d(u, f, g = false) {
    const m = u * 2;
    if (o[m + 15] === pn) {
      const p = r[u + 6], y = o[m + 14];
      let b = 1 / 0, x = 1 / 0, S = 1 / 0, C = -1 / 0, P = -1 / 0, O = -1 / 0;
      for (let z = p, k = p + y; z < k; z++) {
        const H = 3 * l.resolveTriangleIndex(z);
        for (let T = 0; T < 3; T++) {
          let L = H + T;
          L = s ? s[L] : L;
          const w = i.getX(L), N = i.getY(L), K = i.getZ(L);
          w < b && (b = w), w > C && (C = w), N < x && (x = N), N > P && (P = N), K < S && (S = K), K > O && (O = K);
        }
      }
      return a[u + 0] !== b || a[u + 1] !== x || a[u + 2] !== S || a[u + 3] !== C || a[u + 4] !== P || a[u + 5] !== O ? (a[u + 0] = b, a[u + 1] = x, a[u + 2] = S, a[u + 3] = C, a[u + 4] = P, a[u + 5] = O, true) : false;
    } else {
      const p = u + 8, y = r[u + 6], b = p + f, x = y + f;
      let S = g, C = false, P = false;
      t ? S || (C = t.has(b), P = t.has(x), S = !C && !P) : (C = true, P = true);
      const O = S || C, z = S || P;
      let k = false;
      O && (k = d(p, f, S));
      let H = false;
      z && (H = d(y, f, S));
      const T = k || H;
      if (T)
        for (let L = 0; L < 3; L++) {
          const w = p + L, N = y + L, K = a[w], W = a[w + 3], st = a[N], j = a[N + 3];
          a[u + L] = K < st ? K : st, a[u + L + 3] = W > j ? W : j;
        }
      return T;
    }
  }
}
var so = new Vector3();
function qh(l, t, e, s, i) {
  Tt.setBuffer(l._roots[t]), ir(0, l, e, s, i), Tt.clearBuffer();
}
function ir(l, t, e, s, i) {
  const { float32Array: n, uint16Array: r, uint32Array: o } = Tt, a = l * 2;
  if (te(a, r)) {
    const h = ee(l, o), d = re(a, r);
    kh(t, e, s, h, d, i);
  } else {
    const h = oe(l);
    Xe(h, n, s, so) && ir(h, t, e, s, i);
    const d = ae(l, o);
    Xe(d, n, s, so) && ir(d, t, e, s, i);
  }
}
var io = new Vector3();
var Qh = ["x", "y", "z"];
function Kh(l, t, e, s) {
  Tt.setBuffer(l._roots[t]);
  const i = nr(0, l, e, s);
  return Tt.clearBuffer(), i;
}
function nr(l, t, e, s) {
  const { float32Array: i, uint16Array: n, uint32Array: r } = Tt;
  let o = l * 2;
  if (te(o, n)) {
    const c = ee(l, r), h = re(o, n);
    return Bh(t, e, s, c, h);
  } else {
    const c = Ta(l, r), h = Qh[c], u = s.direction[h] >= 0;
    let f, g;
    u ? (f = oe(l), g = ae(l, r)) : (f = ae(l, r), g = oe(l));
    const _ = Xe(f, i, s, io) ? nr(f, t, e, s) : null;
    if (_) {
      const b = _.point[h];
      if (u ? b <= i[g + c] : (
        // min bounding data
        b >= i[g + c + 3]
      ))
        return _;
    }
    const y = Xe(g, i, s, io) ? nr(g, t, e, s) : null;
    return _ && y ? _.distance <= y.distance ? _ : y : _ || y || null;
  }
}
var Ci = new Box3();
var gs = new ge();
var _s = new ge();
var Hs = new Matrix4();
var no = new qt();
var Ai = new qt();
function Jh(l, t, e, s) {
  Tt.setBuffer(l._roots[t]);
  const i = rr(0, l, e, s);
  return Tt.clearBuffer(), i;
}
function rr(l, t, e, s, i = null) {
  const { float32Array: n, uint16Array: r, uint32Array: o } = Tt;
  let a = l * 2;
  if (i === null && (e.boundingBox || e.computeBoundingBox(), no.set(e.boundingBox.min, e.boundingBox.max, s), i = no), te(a, r)) {
    const h = t.geometry, d = h.index, u = h.attributes.position, f = e.index, g = e.attributes.position, m = ee(l, o), _ = re(a, r);
    if (Hs.copy(s).invert(), e.boundsTree)
      return Mt(l, n, Ai), Ai.matrix.copy(Hs), Ai.needsUpdate = true, e.boundsTree.shapecast({
        intersectsBounds: (y) => Ai.intersectsBox(y),
        intersectsTriangle: (y) => {
          y.a.applyMatrix4(s), y.b.applyMatrix4(s), y.c.applyMatrix4(s), y.needsUpdate = true;
          for (let b = m, x = _ + m; b < x; b++)
            if (Lt(_s, 3 * t.resolveTriangleIndex(b), d, u), _s.needsUpdate = true, y.intersectsTriangle(_s))
              return true;
          return false;
        }
      });
    for (let p = m, y = _ + m; p < y; p++) {
      const b = t.resolveTriangleIndex(p);
      Lt(gs, 3 * b, d, u), gs.a.applyMatrix4(Hs), gs.b.applyMatrix4(Hs), gs.c.applyMatrix4(Hs), gs.needsUpdate = true;
      for (let x = 0, S = f.count; x < S; x += 3)
        if (Lt(_s, x, f, g), _s.needsUpdate = true, gs.intersectsTriangle(_s))
          return true;
    }
  } else {
    const h = l + 8, d = o[l + 6];
    return Mt(h, n, Ci), !!(i.intersectsBox(Ci) && rr(h, t, e, s, i) || (Mt(d, n, Ci), i.intersectsBox(Ci) && rr(d, t, e, s, i)));
  }
}
var Pi = new Matrix4();
var In = new qt();
var js = new qt();
var $h = new Vector3();
var td = new Vector3();
var ed = new Vector3();
var sd = new Vector3();
function id(l, t, e, s = {}, i = {}, n = 0, r = 1 / 0) {
  t.boundingBox || t.computeBoundingBox(), In.set(t.boundingBox.min, t.boundingBox.max, e), In.needsUpdate = true;
  const o = l.geometry, a = o.attributes.position, c = o.index, h = t.attributes.position, d = t.index, u = ne.getPrimitive(), f = ne.getPrimitive();
  let g = $h, m = td, _ = null, p = null;
  i && (_ = ed, p = sd);
  let y = 1 / 0, b = null, x = null;
  return Pi.copy(e).invert(), js.matrix.copy(Pi), l.shapecast(
    {
      boundsTraverseOrder: (S) => In.distanceToBox(S),
      intersectsBounds: (S, C, P) => P < y && P < r ? (C && (js.min.copy(S.min), js.max.copy(S.max), js.needsUpdate = true), true) : false,
      intersectsRange: (S, C) => {
        if (t.boundsTree) {
          const P = t.boundsTree;
          return P.shapecast({
            boundsTraverseOrder: (O) => js.distanceToBox(O),
            intersectsBounds: (O, z, k) => k < y && k < r,
            intersectsRange: (O, z) => {
              for (let k = O, H = O + z; k < H; k++) {
                const T = P.resolveTriangleIndex(k);
                Lt(f, 3 * T, d, h), f.a.applyMatrix4(e), f.b.applyMatrix4(e), f.c.applyMatrix4(e), f.needsUpdate = true;
                for (let L = S, w = S + C; L < w; L++) {
                  const N = l.resolveTriangleIndex(L);
                  Lt(u, 3 * N, c, a), u.needsUpdate = true;
                  const K = u.distanceToTriangle(f, g, _);
                  if (K < y && (m.copy(g), p && p.copy(_), y = K, b = L, x = k), K < n)
                    return true;
                }
              }
            }
          });
        } else {
          const P = Cs(t);
          for (let O = 0, z = P; O < z; O++) {
            Lt(f, 3 * O, d, h), f.a.applyMatrix4(e), f.b.applyMatrix4(e), f.c.applyMatrix4(e), f.needsUpdate = true;
            for (let k = S, H = S + C; k < H; k++) {
              const T = l.resolveTriangleIndex(k);
              Lt(u, 3 * T, c, a), u.needsUpdate = true;
              const L = u.distanceToTriangle(f, g, _);
              if (L < y && (m.copy(g), p && p.copy(_), y = L, b = k, x = O), L < n)
                return true;
            }
          }
        }
      }
    }
  ), ne.releasePrimitive(u), ne.releasePrimitive(f), y === 1 / 0 ? null : (s.point ? s.point.copy(m) : s.point = m.clone(), s.distance = y, s.faceIndex = b, i && (i.point ? i.point.copy(p) : i.point = p.clone(), i.point.applyMatrix4(Pi), m.applyMatrix4(Pi), i.distance = m.sub(i.point).length(), i.faceIndex = x), s);
}
function nd() {
  return typeof SharedArrayBuffer < "u";
}
var Qs = new Tt.constructor();
var $i = new Tt.constructor();
var Fe = new vr(() => new Box3());
var ys = new Box3();
var vs = new Box3();
var zn = new Box3();
var Ln = new Box3();
var Nn = false;
function rd(l, t, e, s) {
  if (Nn)
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  Nn = true;
  const i = l._roots, n = t._roots;
  let r, o = 0, a = 0;
  const c = new Matrix4().copy(e).invert();
  for (let h = 0, d = i.length; h < d; h++) {
    Qs.setBuffer(i[h]), a = 0;
    const u = Fe.getPrimitive();
    Mt(0, Qs.float32Array, u), u.applyMatrix4(c);
    for (let f = 0, g = n.length; f < g && ($i.setBuffer(n[h]), r = ue(
      0,
      0,
      e,
      c,
      s,
      o,
      a,
      0,
      0,
      u
    ), $i.clearBuffer(), a += n[f].length, !r); f++)
      ;
    if (Fe.releasePrimitive(u), Qs.clearBuffer(), o += i[h].length, r)
      break;
  }
  return Nn = false, r;
}
function ue(l, t, e, s, i, n = 0, r = 0, o = 0, a = 0, c = null, h = false) {
  let d, u;
  h ? (d = $i, u = Qs) : (d = Qs, u = $i);
  const f = d.float32Array, g = d.uint32Array, m = d.uint16Array, _ = u.float32Array, p = u.uint32Array, y = u.uint16Array, b = l * 2, x = t * 2, S = te(b, m), C = te(x, y);
  let P = false;
  if (C && S)
    h ? P = i(
      ee(t, p),
      re(t * 2, y),
      ee(l, g),
      re(l * 2, m),
      a,
      r + t,
      o,
      n + l
    ) : P = i(
      ee(l, g),
      re(l * 2, m),
      ee(t, p),
      re(t * 2, y),
      o,
      n + l,
      a,
      r + t
    );
  else if (C) {
    const O = Fe.getPrimitive();
    Mt(t, _, O), O.applyMatrix4(e);
    const z = oe(l), k = ae(l, g);
    Mt(z, f, ys), Mt(k, f, vs);
    const H = O.intersectsBox(ys), T = O.intersectsBox(vs);
    P = H && ue(
      t,
      z,
      s,
      e,
      i,
      r,
      n,
      a,
      o + 1,
      O,
      !h
    ) || T && ue(
      t,
      k,
      s,
      e,
      i,
      r,
      n,
      a,
      o + 1,
      O,
      !h
    ), Fe.releasePrimitive(O);
  } else {
    const O = oe(t), z = ae(t, p);
    Mt(O, _, zn), Mt(z, _, Ln);
    const k = c.intersectsBox(zn), H = c.intersectsBox(Ln);
    if (k && H)
      P = ue(
        l,
        O,
        e,
        s,
        i,
        n,
        r,
        o,
        a + 1,
        c,
        h
      ) || ue(
        l,
        z,
        e,
        s,
        i,
        n,
        r,
        o,
        a + 1,
        c,
        h
      );
    else if (k)
      if (S)
        P = ue(
          l,
          O,
          e,
          s,
          i,
          n,
          r,
          o,
          a + 1,
          c,
          h
        );
      else {
        const T = Fe.getPrimitive();
        T.copy(zn).applyMatrix4(e);
        const L = oe(l), w = ae(l, g);
        Mt(L, f, ys), Mt(w, f, vs);
        const N = T.intersectsBox(ys), K = T.intersectsBox(vs);
        P = N && ue(
          O,
          L,
          s,
          e,
          i,
          r,
          n,
          a,
          o + 1,
          T,
          !h
        ) || K && ue(
          O,
          w,
          s,
          e,
          i,
          r,
          n,
          a,
          o + 1,
          T,
          !h
        ), Fe.releasePrimitive(T);
      }
    else if (H)
      if (S)
        P = ue(
          l,
          z,
          e,
          s,
          i,
          n,
          r,
          o,
          a + 1,
          c,
          h
        );
      else {
        const T = Fe.getPrimitive();
        T.copy(Ln).applyMatrix4(e);
        const L = oe(l), w = ae(l, g);
        Mt(L, f, ys), Mt(w, f, vs);
        const N = T.intersectsBox(ys), K = T.intersectsBox(vs);
        P = N && ue(
          z,
          L,
          s,
          e,
          i,
          r,
          n,
          a,
          o + 1,
          T,
          !h
        ) || K && ue(
          z,
          w,
          s,
          e,
          i,
          r,
          n,
          a,
          o + 1,
          T,
          !h
        ), Fe.releasePrimitive(T);
      }
  }
  return P;
}
var Mi = new qt();
var ro = new Box3();
var wr = class _wr {
  static serialize(t, e = {}) {
    e = {
      cloneBuffers: true,
      ...e
    };
    const s = t.geometry, i = t._roots, n = t._indirectBuffer, r = s.getIndex();
    let o;
    return e.cloneBuffers ? o = {
      roots: i.map((a) => a.slice()),
      index: r.array.slice(),
      indirectBuffer: n ? n.slice() : null
    } : o = {
      roots: i,
      index: r.array,
      indirectBuffer: n
    }, o;
  }
  static deserialize(t, e, s = {}) {
    s = {
      setIndex: true,
      indirect: !!t.indirectBuffer,
      ...s
    };
    const { index: i, roots: n, indirectBuffer: r } = t, o = new _wr(e, { ...s, [An]: true });
    if (o._roots = n, o._indirectBuffer = r || null, s.setIndex) {
      const a = e.getIndex();
      if (a === null) {
        const c = new BufferAttribute(t.index, 1, false);
        e.setIndex(c);
      } else
        a.array !== i && (a.array.set(i), a.needsUpdate = true);
    }
    return o;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(t, e = {}) {
    if (t.isBufferGeometry) {
      if (t.index && t.index.isInterleavedBufferAttribute)
        throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    } else
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    if (e = Object.assign({
      strategy: xa,
      maxDepth: 40,
      maxLeafTris: 10,
      verbose: true,
      useSharedArrayBuffer: false,
      setBoundingBox: true,
      onProgress: null,
      indirect: false,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [An]: false
    }, e), e.useSharedArrayBuffer && !nd())
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    this.geometry = t, this._roots = null, this._indirectBuffer = null, e[An] || (xh(this, e), !t.boundingBox && e.setBoundingBox && (t.boundingBox = this.getBoundingBox(new Box3())));
    const { _indirectBuffer: s } = this;
    this.resolveTriangleIndex = e.indirect ? (i) => s[i] : (i) => i;
  }
  refit(t = null) {
    return (this.indirect ? Zh : Nh)(this, t);
  }
  traverse(t, e = 0) {
    const s = this._roots[e], i = new Uint32Array(s), n = new Uint16Array(s);
    r(0);
    function r(o, a = 0) {
      const c = o * 2, h = n[c + 15] === pn;
      if (h) {
        const d = i[o + 6], u = n[c + 14];
        t(a, h, new Float32Array(s, o * 4, 6), d, u);
      } else {
        const d = o + Yi / 4, u = i[o + 6], f = i[o + 7];
        t(a, h, new Float32Array(s, o * 4, 6), f) || (r(d, a + 1), r(u, a + 1));
      }
    }
  }
  /* Core Cast Functions */
  raycast(t, e = FrontSide) {
    const s = this._roots, i = this.geometry, n = [], r = e.isMaterial, o = Array.isArray(e), a = i.groups, c = r ? e.side : e, h = this.indirect ? qh : Uh;
    for (let d = 0, u = s.length; d < u; d++) {
      const f = o ? e[a[d].materialIndex].side : c, g = n.length;
      if (h(this, d, f, t, n), o) {
        const m = a[d].materialIndex;
        for (let _ = g, p = n.length; _ < p; _++)
          n[_].face.materialIndex = m;
      }
    }
    return n;
  }
  raycastFirst(t, e = FrontSide) {
    const s = this._roots, i = this.geometry, n = e.isMaterial, r = Array.isArray(e);
    let o = null;
    const a = i.groups, c = n ? e.side : e, h = this.indirect ? Kh : Vh;
    for (let d = 0, u = s.length; d < u; d++) {
      const f = r ? e[a[d].materialIndex].side : c, g = h(this, d, f, t);
      g != null && (o == null || g.distance < o.distance) && (o = g, r && (g.face.materialIndex = a[d].materialIndex));
    }
    return o;
  }
  intersectsGeometry(t, e) {
    let s = false;
    const i = this._roots, n = this.indirect ? Jh : Hh;
    for (let r = 0, o = i.length; r < o && (s = n(this, r, t, e), !s); r++)
      ;
    return s;
  }
  shapecast(t) {
    const e = ne.getPrimitive(), s = this.indirect ? Rh : Lh;
    let {
      boundsTraverseOrder: i,
      intersectsBounds: n,
      intersectsRange: r,
      intersectsTriangle: o
    } = t;
    if (r && o) {
      const d = r;
      r = (u, f, g, m, _) => d(u, f, g, m, _) ? true : s(u, f, this, o, g, m, e);
    } else
      r || (o ? r = (d, u, f, g) => s(d, u, this, o, f, g, e) : r = (d, u, f) => f);
    let a = false, c = 0;
    const h = this._roots;
    for (let d = 0, u = h.length; d < u; d++) {
      const f = h[d];
      if (a = Ph(this, d, n, r, i, c), a)
        break;
      c += f.byteLength;
    }
    return ne.releasePrimitive(e), a;
  }
  bvhcast(t, e, s) {
    let {
      intersectsRanges: i,
      intersectsTriangles: n
    } = s;
    const r = ne.getPrimitive(), o = this.geometry.index, a = this.geometry.attributes.position, c = this.indirect ? (g) => {
      const m = this.resolveTriangleIndex(g);
      Lt(r, m * 3, o, a);
    } : (g) => {
      Lt(r, g * 3, o, a);
    }, h = ne.getPrimitive(), d = t.geometry.index, u = t.geometry.attributes.position, f = t.indirect ? (g) => {
      const m = t.resolveTriangleIndex(g);
      Lt(h, m * 3, d, u);
    } : (g) => {
      Lt(h, g * 3, d, u);
    };
    if (n) {
      const g = (m, _, p, y, b, x, S, C) => {
        for (let P = p, O = p + y; P < O; P++) {
          f(P), h.a.applyMatrix4(e), h.b.applyMatrix4(e), h.c.applyMatrix4(e), h.needsUpdate = true;
          for (let z = m, k = m + _; z < k; z++)
            if (c(z), r.needsUpdate = true, n(r, h, z, P, b, x, S, C))
              return true;
        }
        return false;
      };
      if (i) {
        const m = i;
        i = function(_, p, y, b, x, S, C, P) {
          return m(_, p, y, b, x, S, C, P) ? true : g(_, p, y, b, x, S, C, P);
        };
      } else
        i = g;
    }
    return rd(this, t, e, i);
  }
  /* Derived Cast Functions */
  intersectsBox(t, e) {
    return Mi.set(t.min, t.max, e), Mi.needsUpdate = true, this.shapecast(
      {
        intersectsBounds: (s) => Mi.intersectsBox(s),
        intersectsTriangle: (s) => Mi.intersectsTriangle(s)
      }
    );
  }
  intersectsSphere(t) {
    return this.shapecast(
      {
        intersectsBounds: (e) => t.intersectsBox(e),
        intersectsTriangle: (e) => e.intersectsSphere(t)
      }
    );
  }
  closestPointToGeometry(t, e, s = {}, i = {}, n = 0, r = 1 / 0) {
    return (this.indirect ? id : Gh)(
      this,
      t,
      e,
      s,
      i,
      n,
      r
    );
  }
  closestPointToPoint(t, e = {}, s = 0, i = 1 / 0) {
    return Mh(
      this,
      t,
      e,
      s,
      i
    );
  }
  getBoundingBox(t) {
    return t.makeEmpty(), this._roots.forEach((s) => {
      Mt(0, new Float32Array(s), ro), t.union(ro);
    }), t;
  }
};
function oo(l, t, e) {
  return l === null || (l.point.applyMatrix4(t.matrixWorld), l.distance = l.point.distanceTo(e.ray.origin), l.object = t, l.distance < e.near || l.distance > e.far) ? null : l;
}
var kn = new Ray();
var ao = new Matrix4();
var od = Mesh.prototype.raycast;
function ad(l, t) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0)
      return;
    ao.copy(this.matrixWorld).invert(), kn.copy(l.ray).applyMatrix4(ao);
    const e = this.geometry.boundsTree;
    if (l.firstHitOnly === true) {
      const s = oo(e.raycastFirst(kn, this.material), this, l);
      s && t.push(s);
    } else {
      const s = e.raycast(kn, this.material);
      for (let i = 0, n = s.length; i < n; i++) {
        const r = oo(s[i], this, l);
        r && t.push(r);
      }
    }
  } else
    od.call(this, l, t);
}
function ld(l) {
  return this.boundsTree = new wr(this, l), this.boundsTree;
}
function cd2() {
  this.boundsTree = null;
}
var Ca = class Aa {
  constructor() {
    E(this, "onDisposed", new tt()), E(this, "list", /* @__PURE__ */ new Map()), E(this, "enabled", false), E(this, "_clock"), E(this, "onInit", new tt()), E(this, "update", () => {
      if (!this.enabled)
        return;
      const t = this._clock.getDelta();
      for (const [e, s] of this.list)
        s.enabled && s.isUpdateable() && s.update(t);
      requestAnimationFrame(this.update);
    }), this._clock = new Clock(), Aa.setupBVH();
  }
  /**
   * Adds a component to the list of components.
   * Throws an error if a component with the same UUID already exists.
   *
   * @param uuid - The unique identifier of the component.
   * @param instance - The instance of the component to be added.
   *
   * @throws Will throw an error if a component with the same UUID already exists.
   */
  add(t, e) {
    if (this.list.has(t))
      throw new Error(
        "You're trying to add a component that already exists in the components instance. Use Components.get() instead."
      );
    Xt.validate(t), this.list.set(t, e);
  }
  /**
   * Retrieves a component instance by its constructor function.
   * If the component does not exist in the list, it will be created and added.
   *
   * @template U - The type of the component to retrieve.
   * @param Component - The constructor function of the component to retrieve.
   *
   * @returns The instance of the requested component.
   *
   * @throws Will throw an error if a component with the same UUID already exists.
   */
  get(t) {
    const e = t.uuid;
    if (!this.list.has(e)) {
      const s = new t(this);
      return s.isDisposeable() && s.onDisposed.add(() => this.list.delete(e)), this.list.has(e) || this.add(e, s), s;
    }
    return this.list.get(e);
  }
  /**
   * Initializes the Components instance.
   * This method starts the animation loop, sets the enabled flag to true,
   * and calls the update method.
   */
  init() {
    this.enabled = true;
    for (const [t, e] of this.list.entries())
      e.enabled = true;
    this._clock.start(), this.update(), this.onInit.trigger();
  }
  /**
   * Disposes the memory of all the components and tools of this instance of
   * the library. A memory leak will be created if:
   *
   * - An instance of the library ends up out of scope and this function isn't
   * called. This is especially relevant in Single Page Applications (React,
   * Angular, Vue, etc).
   *
   * - Any of the objects of this instance (meshes, geometries,materials, etc) is
   * referenced by a reference type (object or array).
   *
   * You can learn more about how Three.js handles memory leaks
   * [here](https://threejs.org/docs/#manual/en/introduction/How-to-dispose-of-objects).
   *
   */
  dispose() {
    this.enabled = false;
    let t;
    for (const [e, s] of this.list) {
      if (s.enabled = false, e === ct.uuid) {
        t = s;
        continue;
      }
      s.isDisposeable() && s.dispose();
    }
    t == null || t.dispose(), this._clock.stop(), this.onDisposed.trigger();
  }
  static setupBVH() {
    BufferGeometry.prototype.computeBoundsTree = ld, BufferGeometry.prototype.disposeBoundsTree = cd2, Mesh.prototype.raycast = ad;
  }
};
E(Ca, "release", "2.4.3");
var Pa = Ca;
var hd = class {
  constructor(t) {
    E(this, "enabled", false), E(this, "id", "FirstPerson"), this.camera = t;
  }
  /** {@link NavigationMode.set} */
  set(t) {
    if (this.enabled = t, t) {
      if (this.camera.projection.current !== "Perspective") {
        this.camera.set("Orbit");
        return;
      }
      this.setupFirstPersonCamera();
    }
  }
  setupFirstPersonCamera() {
    const t = this.camera.controls, e = new Vector3();
    t.distance--, t.getPosition(e), t.minDistance = 1, t.maxDistance = 1, t.distance = 1, t.moveTo(
      e.x,
      e.y,
      e.z
    ), t.truckSpeed = 50, t.mouseButtons.wheel = Wt2.ACTION.DOLLY, t.touches.two = Wt2.ACTION.TOUCH_ZOOM_TRUCK;
  }
};
var dd = class {
  constructor(t) {
    E(this, "enabled", true), E(this, "id", "Orbit"), this.camera = t, this.activateOrbitControls();
  }
  /** {@link NavigationMode.set} */
  set(t) {
    this.enabled = t, t && this.activateOrbitControls();
  }
  activateOrbitControls() {
    const t = this.camera.controls;
    t.minDistance = 1, t.maxDistance = 300;
    const e = new Vector3();
    t.getPosition(e);
    const s = e.length();
    t.distance = s, t.truckSpeed = 2;
    const { rotation: i } = this.camera.three, n = new Vector3(0, 0, -1).applyEuler(i), r = e.addScaledVector(n, s);
    t.moveTo(r.x, r.y, r.z);
  }
};
var ud = class {
  constructor(t) {
    E(this, "enabled", false), E(this, "id", "Plan"), E(this, "mouseAction1"), E(this, "mouseAction2"), E(this, "mouseInitialized", false), E(this, "defaultAzimuthSpeed"), E(this, "defaultPolarSpeed"), this.camera = t, this.defaultAzimuthSpeed = t.controls.azimuthRotateSpeed, this.defaultPolarSpeed = t.controls.polarRotateSpeed;
  }
  /** {@link NavigationMode.set} */
  set(t) {
    this.enabled = t;
    const e = this.camera.controls;
    e.azimuthRotateSpeed = t ? 0 : this.defaultAzimuthSpeed, e.polarRotateSpeed = t ? 0 : this.defaultPolarSpeed, this.mouseInitialized || (this.mouseAction1 = e.touches.one, this.mouseAction2 = e.touches.two, this.mouseInitialized = true), t ? (e.mouseButtons.left = Wt2.ACTION.TRUCK, e.touches.one = Wt2.ACTION.TOUCH_TRUCK, e.touches.two = Wt2.ACTION.TOUCH_ZOOM) : (e.mouseButtons.left = Wt2.ACTION.ROTATE, e.touches.one = this.mouseAction1, e.touches.two = this.mouseAction2);
  }
};
var fd = class {
  constructor(t) {
    E(this, "onChanged", new tt()), E(this, "current", "Perspective"), E(this, "camera"), E(this, "matchOrthoDistanceEnabled", false), E(this, "_component"), E(this, "_previousDistance", -1), this._component = t, this.camera = t.three;
  }
  /**
   * Sets the {@link CameraProjection} of the {@link OrthoPerspectiveCamera}.
   *
   * @param projection - the new projection to set. If it is the current projection,
   * it will have no effect.
   */
  async set(t) {
    this.current !== t && (t === "Orthographic" ? this.setOrthoCamera() : await this.setPerspectiveCamera(), this.onChanged.trigger(this.camera));
  }
  /**
   * Changes the current {@link CameraProjection} from Ortographic to Perspective
   * and vice versa.
   */
  async toggle() {
    const e = this.current === "Perspective" ? "Orthographic" : "Perspective";
    await this.set(e);
  }
  setOrthoCamera() {
    if (this._component.mode === null || this._component.mode.id === "FirstPerson")
      return;
    this._previousDistance = this._component.controls.distance, this._component.controls.distance = 200;
    const t = this.getPerspectiveDims();
    if (!t)
      return;
    const { width: e, height: s } = t;
    this.setupOrthoCamera(s, e), this.camera = this._component.threeOrtho, this.current = "Orthographic";
  }
  getPerspectiveDims() {
    const t = this._component.currentWorld;
    if (!t || !t.renderer)
      return null;
    const e = new Vector3();
    this._component.threePersp.getWorldDirection(e);
    const s = new Vector3();
    this._component.controls.getTarget(s);
    const n = s.clone().sub(this._component.threePersp.position).dot(e), r = t.renderer.getSize(), o = r.x / r.y, a = this._component.threePersp, c = n * 2 * Math.atan(a.fov * (Math.PI / 180) / 2);
    return { width: c * o, height: c };
  }
  setupOrthoCamera(t, e) {
    this._component.controls.mouseButtons.wheel = Wt2.ACTION.ZOOM, this._component.controls.mouseButtons.middle = Wt2.ACTION.ZOOM;
    const s = this._component.threePersp, i = this._component.threeOrtho;
    i.zoom = 1, i.left = e / -2, i.right = e / 2, i.top = t / 2, i.bottom = t / -2, i.updateProjectionMatrix(), i.position.copy(s.position), i.quaternion.copy(s.quaternion), this._component.controls.camera = i;
  }
  getDistance() {
    const t = this._component.threePersp, e = this._component.threeOrtho;
    return (e.top - e.bottom) / e.zoom / (2 * Math.atan(t.fov * (Math.PI / 180) / 2));
  }
  async setPerspectiveCamera() {
    this._component.controls.mouseButtons.wheel = Wt2.ACTION.DOLLY, this._component.controls.mouseButtons.middle = Wt2.ACTION.DOLLY;
    const t = this._component.threePersp, e = this._component.threeOrtho;
    t.position.copy(e.position), t.quaternion.copy(e.quaternion), this._component.controls.mouseButtons.wheel = Wt2.ACTION.DOLLY, this.matchOrthoDistanceEnabled ? this._component.controls.distance = this.getDistance() : this._component.controls.distance = this._previousDistance, await this._component.controls.zoomTo(1), t.updateProjectionMatrix(), this._component.controls.camera = t, this.camera = t, this.current = "Perspective";
  }
};
var Ma = class extends ni {
  constructor(t) {
    super(t), E(this, "projection"), E(this, "threeOrtho"), E(this, "threePersp"), E(this, "_userInputButtons", {}), E(this, "_frustumSize", 50), E(this, "_navigationModes", /* @__PURE__ */ new Map()), E(this, "_mode", null), E(this, "previousSize", null), this.threePersp = this.three, this.threeOrtho = this.newOrthoCamera(), this.projection = new fd(this), this.onAspectUpdated.add(() => {
      this.setOrthoPerspCameraAspect();
    }), this.projection.onChanged.add(
      (e) => {
        this.three = e, this.updateAspect();
      }
    ), this.worlds.onItemSet.add(() => {
      this._navigationModes.clear(), this._navigationModes.set("Orbit", new dd(this)), this._navigationModes.set("FirstPerson", new hd(this)), this._navigationModes.set("Plan", new ud(this)), this._mode = this._navigationModes.get("Orbit"), this.mode.set(true, { preventTargetAdjustment: true }), this.currentWorld && this.currentWorld.renderer && (this.previousSize = this.currentWorld.renderer.getSize().clone());
    }), this.worlds.onItemDeleted.add(() => {
      this._navigationModes.clear();
    });
  }
  /**
   * Getter for the current navigation mode.
   * Throws an error if the mode is not found or the camera is not initialized.
   *
   * @returns {NavigationMode} The current navigation mode.
   *
   * @throws {Error} Throws an error if the mode is not found or the camera is not initialized.
   */
  get mode() {
    if (!this._mode)
      throw new Error("Mode not found, camera not initialized");
    return this._mode;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose(), this.threeOrtho.removeFromParent();
  }
  /**
   * Sets a new {@link NavigationMode} and disables the previous one.
   *
   * @param mode - The {@link NavigationMode} to set.
   */
  set(t) {
    if (this.mode !== null && this.mode.id !== t) {
      if (this.mode.set(false), !this._navigationModes.has(t))
        throw new Error("The specified mode does not exist!");
      this._mode = this._navigationModes.get(t), this.mode.set(true);
    }
  }
  /**
   * Make the camera view fit all the specified meshes.
   *
   * @param meshes the meshes to fit. If it is not defined, it will
   * evaluate {@link Components.meshes}.
   * @param offset the distance to the fit object
   */
  async fit(t, e = 1.5) {
    if (!this.enabled)
      return;
    const s = Number.MAX_VALUE, i = Number.MIN_VALUE, n = new Vector3(s, s, s), r = new Vector3(i, i, i);
    for (const f of t) {
      const g = new Box3().setFromObject(f);
      g.min.x < n.x && (n.x = g.min.x), g.min.y < n.y && (n.y = g.min.y), g.min.z < n.z && (n.z = g.min.z), g.max.x > r.x && (r.x = g.max.x), g.max.y > r.y && (r.y = g.max.y), g.max.z > r.z && (r.z = g.max.z);
    }
    const o = new Box3(n, r), a = this.components.get(ct);
    if (a.initialized)
      for (const [, f] of a.list) {
        const g = f.box;
        g.min.x < n.x && (n.x = g.min.x), g.min.y < n.y && (n.y = g.min.y), g.min.z < n.z && (n.z = g.min.z), g.max.x > r.x && (r.x = g.max.x), g.max.y > r.y && (r.y = g.max.y), g.max.z > r.z && (r.z = g.max.z);
      }
    const c = new Vector3();
    o.getSize(c);
    const h = new Vector3();
    o.getCenter(h);
    const d = Math.max(c.x, c.y, c.z) * e, u = new Sphere(h, d);
    await this.controls.fitToSphere(u, true);
  }
  /**
   * Allows or prevents all user input.
   *
   * @param active - whether to enable or disable user inputs.
   */
  setUserInput(t) {
    t ? this.enableUserInput() : this.disableUserInput();
  }
  disableUserInput() {
    this._userInputButtons.left = this.controls.mouseButtons.left, this._userInputButtons.right = this.controls.mouseButtons.right, this._userInputButtons.middle = this.controls.mouseButtons.middle, this._userInputButtons.wheel = this.controls.mouseButtons.wheel, this.controls.mouseButtons.left = 0, this.controls.mouseButtons.right = 0, this.controls.mouseButtons.middle = 0, this.controls.mouseButtons.wheel = 0;
  }
  enableUserInput() {
    Object.keys(this._userInputButtons).length !== 0 && (this.controls.mouseButtons.left = this._userInputButtons.left, this.controls.mouseButtons.right = this._userInputButtons.right, this.controls.mouseButtons.middle = this._userInputButtons.middle, this.controls.mouseButtons.wheel = this._userInputButtons.wheel);
  }
  newOrthoCamera() {
    const t = window.innerWidth / window.innerHeight;
    return new OrthographicCamera(
      this._frustumSize * t / -2,
      this._frustumSize * t / 2,
      this._frustumSize / 2,
      this._frustumSize / -2,
      0.1,
      1e3
    );
  }
  setOrthoPerspCameraAspect() {
    if (!this.currentWorld || !this.currentWorld.renderer || !this.previousSize)
      return;
    const t = this.currentWorld.renderer.getSize(), e = this.threeOrtho.top, s = this.threeOrtho.right, i = t.y / this.previousSize.y, n = t.x / this.previousSize.x, r = e * i, o = s * n;
    this.threeOrtho.left = -o, this.threeOrtho.right = o, this.threeOrtho.top = r, this.threeOrtho.bottom = -r, this.threeOrtho.updateProjectionMatrix(), this.previousSize.copy(t);
  }
};
function Oi(l) {
  throw new Error('Could not dynamically require "' + l + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Oa = { exports: {} };
(function(l, t) {
  (function(e) {
    l.exports = e();
  })(function() {
    return function e(s, i, n) {
      function r(c, h) {
        if (!i[c]) {
          if (!s[c]) {
            var d = typeof Oi == "function" && Oi;
            if (!h && d)
              return d(c, true);
            if (o)
              return o(c, true);
            var u = new Error("Cannot find module '" + c + "'");
            throw u.code = "MODULE_NOT_FOUND", u;
          }
          var f = i[c] = { exports: {} };
          s[c][0].call(f.exports, function(g) {
            var m = s[c][1][g];
            return r(m || g);
          }, f, f.exports, e, s, i, n);
        }
        return i[c].exports;
      }
      for (var o = typeof Oi == "function" && Oi, a = 0; a < n.length; a++)
        r(n[a]);
      return r;
    }({ 1: [function(e, s, i) {
      var n = e("./utils"), r = e("./support"), o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      i.encode = function(a) {
        for (var c, h, d, u, f, g, m, _ = [], p = 0, y = a.length, b = y, x = n.getTypeOf(a) !== "string"; p < a.length; )
          b = y - p, d = x ? (c = a[p++], h = p < y ? a[p++] : 0, p < y ? a[p++] : 0) : (c = a.charCodeAt(p++), h = p < y ? a.charCodeAt(p++) : 0, p < y ? a.charCodeAt(p++) : 0), u = c >> 2, f = (3 & c) << 4 | h >> 4, g = 1 < b ? (15 & h) << 2 | d >> 6 : 64, m = 2 < b ? 63 & d : 64, _.push(o.charAt(u) + o.charAt(f) + o.charAt(g) + o.charAt(m));
        return _.join("");
      }, i.decode = function(a) {
        var c, h, d, u, f, g, m = 0, _ = 0, p = "data:";
        if (a.substr(0, p.length) === p)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var y, b = 3 * (a = a.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (a.charAt(a.length - 1) === o.charAt(64) && b--, a.charAt(a.length - 2) === o.charAt(64) && b--, b % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (y = r.uint8array ? new Uint8Array(0 | b) : new Array(0 | b); m < a.length; )
          c = o.indexOf(a.charAt(m++)) << 2 | (u = o.indexOf(a.charAt(m++))) >> 4, h = (15 & u) << 4 | (f = o.indexOf(a.charAt(m++))) >> 2, d = (3 & f) << 6 | (g = o.indexOf(a.charAt(m++))), y[_++] = c, f !== 64 && (y[_++] = h), g !== 64 && (y[_++] = d);
        return y;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(e, s, i) {
      var n = e("./external"), r = e("./stream/DataWorker"), o = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
      function c(h, d, u, f, g) {
        this.compressedSize = h, this.uncompressedSize = d, this.crc32 = u, this.compression = f, this.compressedContent = g;
      }
      c.prototype = { getContentWorker: function() {
        var h = new r(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), d = this;
        return h.on("end", function() {
          if (this.streamInfo.data_length !== d.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), h;
      }, getCompressedWorker: function() {
        return new r(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, c.createWorkerFrom = function(h, d, u) {
        return h.pipe(new o()).pipe(new a("uncompressedSize")).pipe(d.compressWorker(u)).pipe(new a("compressedSize")).withStreamInfo("compression", d);
      }, s.exports = c;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, s, i) {
      var n = e("./stream/GenericWorker");
      i.STORE = { magic: "\0\0", compressWorker: function() {
        return new n("STORE compression");
      }, uncompressWorker: function() {
        return new n("STORE decompression");
      } }, i.DEFLATE = e("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, s, i) {
      var n = e("./utils"), r = function() {
        for (var o, a = [], c = 0; c < 256; c++) {
          o = c;
          for (var h = 0; h < 8; h++)
            o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
          a[c] = o;
        }
        return a;
      }();
      s.exports = function(o, a) {
        return o !== void 0 && o.length ? n.getTypeOf(o) !== "string" ? function(c, h, d, u) {
          var f = r, g = u + d;
          c ^= -1;
          for (var m = u; m < g; m++)
            c = c >>> 8 ^ f[255 & (c ^ h[m])];
          return -1 ^ c;
        }(0 | a, o, o.length, 0) : function(c, h, d, u) {
          var f = r, g = u + d;
          c ^= -1;
          for (var m = u; m < g; m++)
            c = c >>> 8 ^ f[255 & (c ^ h.charCodeAt(m))];
          return -1 ^ c;
        }(0 | a, o, o.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(e, s, i) {
      i.base64 = false, i.binary = false, i.dir = false, i.createFolders = true, i.date = null, i.compression = null, i.compressionOptions = null, i.comment = null, i.unixPermissions = null, i.dosPermissions = null;
    }, {}], 6: [function(e, s, i) {
      var n = null;
      n = typeof Promise < "u" ? Promise : e("lie"), s.exports = { Promise: n };
    }, { lie: 37 }], 7: [function(e, s, i) {
      var n = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", r = e("pako"), o = e("./utils"), a = e("./stream/GenericWorker"), c = n ? "uint8array" : "array";
      function h(d, u) {
        a.call(this, "FlateWorker/" + d), this._pako = null, this._pakoAction = d, this._pakoOptions = u, this.meta = {};
      }
      i.magic = "\b\0", o.inherits(h, a), h.prototype.processChunk = function(d) {
        this.meta = d.meta, this._pako === null && this._createPako(), this._pako.push(o.transformTo(c, d.data), false);
      }, h.prototype.flush = function() {
        a.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], true);
      }, h.prototype.cleanUp = function() {
        a.prototype.cleanUp.call(this), this._pako = null;
      }, h.prototype._createPako = function() {
        this._pako = new r[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
        var d = this;
        this._pako.onData = function(u) {
          d.push({ data: u, meta: d.meta });
        };
      }, i.compressWorker = function(d) {
        return new h("Deflate", d);
      }, i.uncompressWorker = function() {
        return new h("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, s, i) {
      function n(f, g) {
        var m, _ = "";
        for (m = 0; m < g; m++)
          _ += String.fromCharCode(255 & f), f >>>= 8;
        return _;
      }
      function r(f, g, m, _, p, y) {
        var b, x, S = f.file, C = f.compression, P = y !== c.utf8encode, O = o.transformTo("string", y(S.name)), z = o.transformTo("string", c.utf8encode(S.name)), k = S.comment, H = o.transformTo("string", y(k)), T = o.transformTo("string", c.utf8encode(k)), L = z.length !== S.name.length, w = T.length !== k.length, N = "", K = "", W = "", st = S.dir, j = S.date, it = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        g && !m || (it.crc32 = f.crc32, it.compressedSize = f.compressedSize, it.uncompressedSize = f.uncompressedSize);
        var U = 0;
        g && (U |= 8), P || !L && !w || (U |= 2048);
        var R = 0, rt = 0;
        st && (R |= 16), p === "UNIX" ? (rt = 798, R |= function(J, pt) {
          var gt = J;
          return J || (gt = pt ? 16893 : 33204), (65535 & gt) << 16;
        }(S.unixPermissions, st)) : (rt = 20, R |= function(J) {
          return 63 & (J || 0);
        }(S.dosPermissions)), b = j.getUTCHours(), b <<= 6, b |= j.getUTCMinutes(), b <<= 5, b |= j.getUTCSeconds() / 2, x = j.getUTCFullYear() - 1980, x <<= 4, x |= j.getUTCMonth() + 1, x <<= 5, x |= j.getUTCDate(), L && (K = n(1, 1) + n(h(O), 4) + z, N += "up" + n(K.length, 2) + K), w && (W = n(1, 1) + n(h(H), 4) + T, N += "uc" + n(W.length, 2) + W);
        var Q = "";
        return Q += `
\0`, Q += n(U, 2), Q += C.magic, Q += n(b, 2), Q += n(x, 2), Q += n(it.crc32, 4), Q += n(it.compressedSize, 4), Q += n(it.uncompressedSize, 4), Q += n(O.length, 2), Q += n(N.length, 2), { fileRecord: d.LOCAL_FILE_HEADER + Q + O + N, dirRecord: d.CENTRAL_FILE_HEADER + n(rt, 2) + Q + n(H.length, 2) + "\0\0\0\0" + n(R, 4) + n(_, 4) + O + N + H };
      }
      var o = e("../utils"), a = e("../stream/GenericWorker"), c = e("../utf8"), h = e("../crc32"), d = e("../signature");
      function u(f, g, m, _) {
        a.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = g, this.zipPlatform = m, this.encodeFileName = _, this.streamFiles = f, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      o.inherits(u, a), u.prototype.push = function(f) {
        var g = f.meta.percent || 0, m = this.entriesCount, _ = this._sources.length;
        this.accumulate ? this.contentBuffer.push(f) : (this.bytesWritten += f.data.length, a.prototype.push.call(this, { data: f.data, meta: { currentFile: this.currentFile, percent: m ? (g + 100 * (m - _ - 1)) / m : 100 } }));
      }, u.prototype.openedSource = function(f) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = f.file.name;
        var g = this.streamFiles && !f.file.dir;
        if (g) {
          var m = r(f, g, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: m.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = true;
      }, u.prototype.closedSource = function(f) {
        this.accumulate = false;
        var g = this.streamFiles && !f.file.dir, m = r(f, g, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(m.dirRecord), g)
          this.push({ data: function(_) {
            return d.DATA_DESCRIPTOR + n(_.crc32, 4) + n(_.compressedSize, 4) + n(_.uncompressedSize, 4);
          }(f), meta: { percent: 100 } });
        else
          for (this.push({ data: m.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, u.prototype.flush = function() {
        for (var f = this.bytesWritten, g = 0; g < this.dirRecords.length; g++)
          this.push({ data: this.dirRecords[g], meta: { percent: 100 } });
        var m = this.bytesWritten - f, _ = function(p, y, b, x, S) {
          var C = o.transformTo("string", S(x));
          return d.CENTRAL_DIRECTORY_END + "\0\0\0\0" + n(p, 2) + n(p, 2) + n(y, 4) + n(b, 4) + n(C.length, 2) + C;
        }(this.dirRecords.length, m, f, this.zipComment, this.encodeFileName);
        this.push({ data: _, meta: { percent: 100 } });
      }, u.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, u.prototype.registerPrevious = function(f) {
        this._sources.push(f);
        var g = this;
        return f.on("data", function(m) {
          g.processChunk(m);
        }), f.on("end", function() {
          g.closedSource(g.previous.streamInfo), g._sources.length ? g.prepareNextSource() : g.end();
        }), f.on("error", function(m) {
          g.error(m);
        }), this;
      }, u.prototype.resume = function() {
        return !!a.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
      }, u.prototype.error = function(f) {
        var g = this._sources;
        if (!a.prototype.error.call(this, f))
          return false;
        for (var m = 0; m < g.length; m++)
          try {
            g[m].error(f);
          } catch {
          }
        return true;
      }, u.prototype.lock = function() {
        a.prototype.lock.call(this);
        for (var f = this._sources, g = 0; g < f.length; g++)
          f[g].lock();
      }, s.exports = u;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, s, i) {
      var n = e("../compressions"), r = e("./ZipFileWorker");
      i.generateWorker = function(o, a, c) {
        var h = new r(a.streamFiles, c, a.platform, a.encodeFileName), d = 0;
        try {
          o.forEach(function(u, f) {
            d++;
            var g = function(y, b) {
              var x = y || b, S = n[x];
              if (!S)
                throw new Error(x + " is not a valid compression method !");
              return S;
            }(f.options.compression, a.compression), m = f.options.compressionOptions || a.compressionOptions || {}, _ = f.dir, p = f.date;
            f._compressWorker(g, m).withStreamInfo("file", { name: u, dir: _, date: p, comment: f.comment || "", unixPermissions: f.unixPermissions, dosPermissions: f.dosPermissions }).pipe(h);
          }), h.entriesCount = d;
        } catch (u) {
          h.error(u);
        }
        return h;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, s, i) {
      function n() {
        if (!(this instanceof n))
          return new n();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var r = new n();
          for (var o in this)
            typeof this[o] != "function" && (r[o] = this[o]);
          return r;
        };
      }
      (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(r, o) {
        return new n().loadAsync(r, o);
      }, n.external = e("./external"), s.exports = n;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, s, i) {
      var n = e("./utils"), r = e("./external"), o = e("./utf8"), a = e("./zipEntries"), c = e("./stream/Crc32Probe"), h = e("./nodejsUtils");
      function d(u) {
        return new r.Promise(function(f, g) {
          var m = u.decompressed.getContentWorker().pipe(new c());
          m.on("error", function(_) {
            g(_);
          }).on("end", function() {
            m.streamInfo.crc32 !== u.decompressed.crc32 ? g(new Error("Corrupted zip : CRC32 mismatch")) : f();
          }).resume();
        });
      }
      s.exports = function(u, f) {
        var g = this;
        return f = n.extend(f || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: o.utf8decode }), h.isNode && h.isStream(u) ? r.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : n.prepareContent("the loaded zip file", u, true, f.optimizedBinaryString, f.base64).then(function(m) {
          var _ = new a(f);
          return _.load(m), _;
        }).then(function(m) {
          var _ = [r.Promise.resolve(m)], p = m.files;
          if (f.checkCRC32)
            for (var y = 0; y < p.length; y++)
              _.push(d(p[y]));
          return r.Promise.all(_);
        }).then(function(m) {
          for (var _ = m.shift(), p = _.files, y = 0; y < p.length; y++) {
            var b = p[y], x = b.fileNameStr, S = n.resolve(b.fileNameStr);
            g.file(S, b.decompressed, { binary: true, optimizedBinaryString: true, date: b.date, dir: b.dir, comment: b.fileCommentStr.length ? b.fileCommentStr : null, unixPermissions: b.unixPermissions, dosPermissions: b.dosPermissions, createFolders: f.createFolders }), b.dir || (g.file(S).unsafeOriginalName = x);
          }
          return _.zipComment.length && (g.comment = _.zipComment), g;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, s, i) {
      var n = e("../utils"), r = e("../stream/GenericWorker");
      function o(a, c) {
        r.call(this, "Nodejs stream input adapter for " + a), this._upstreamEnded = false, this._bindStream(c);
      }
      n.inherits(o, r), o.prototype._bindStream = function(a) {
        var c = this;
        (this._stream = a).pause(), a.on("data", function(h) {
          c.push({ data: h, meta: { percent: 0 } });
        }).on("error", function(h) {
          c.isPaused ? this.generatedError = h : c.error(h);
        }).on("end", function() {
          c.isPaused ? c._upstreamEnded = true : c.end();
        });
      }, o.prototype.pause = function() {
        return !!r.prototype.pause.call(this) && (this._stream.pause(), true);
      }, o.prototype.resume = function() {
        return !!r.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
      }, s.exports = o;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, s, i) {
      var n = e("readable-stream").Readable;
      function r(o, a, c) {
        n.call(this, a), this._helper = o;
        var h = this;
        o.on("data", function(d, u) {
          h.push(d) || h._helper.pause(), c && c(u);
        }).on("error", function(d) {
          h.emit("error", d);
        }).on("end", function() {
          h.push(null);
        });
      }
      e("../utils").inherits(r, n), r.prototype._read = function() {
        this._helper.resume();
      }, s.exports = r;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, s, i) {
      s.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(n, r) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(n, r);
        if (typeof n == "number")
          throw new Error('The "data" argument must not be a number');
        return new Buffer(n, r);
      }, allocBuffer: function(n) {
        if (Buffer.alloc)
          return Buffer.alloc(n);
        var r = new Buffer(n);
        return r.fill(0), r;
      }, isBuffer: function(n) {
        return Buffer.isBuffer(n);
      }, isStream: function(n) {
        return n && typeof n.on == "function" && typeof n.pause == "function" && typeof n.resume == "function";
      } };
    }, {}], 15: [function(e, s, i) {
      function n(S, C, P) {
        var O, z = o.getTypeOf(C), k = o.extend(P || {}, h);
        k.date = k.date || /* @__PURE__ */ new Date(), k.compression !== null && (k.compression = k.compression.toUpperCase()), typeof k.unixPermissions == "string" && (k.unixPermissions = parseInt(k.unixPermissions, 8)), k.unixPermissions && 16384 & k.unixPermissions && (k.dir = true), k.dosPermissions && 16 & k.dosPermissions && (k.dir = true), k.dir && (S = p(S)), k.createFolders && (O = _(S)) && y.call(this, O, true);
        var H = z === "string" && k.binary === false && k.base64 === false;
        P && P.binary !== void 0 || (k.binary = !H), (C instanceof d && C.uncompressedSize === 0 || k.dir || !C || C.length === 0) && (k.base64 = false, k.binary = true, C = "", k.compression = "STORE", z = "string");
        var T = null;
        T = C instanceof d || C instanceof a ? C : g.isNode && g.isStream(C) ? new m(S, C) : o.prepareContent(S, C, k.binary, k.optimizedBinaryString, k.base64);
        var L = new u(S, T, k);
        this.files[S] = L;
      }
      var r = e("./utf8"), o = e("./utils"), a = e("./stream/GenericWorker"), c = e("./stream/StreamHelper"), h = e("./defaults"), d = e("./compressedObject"), u = e("./zipObject"), f = e("./generate"), g = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(S) {
        S.slice(-1) === "/" && (S = S.substring(0, S.length - 1));
        var C = S.lastIndexOf("/");
        return 0 < C ? S.substring(0, C) : "";
      }, p = function(S) {
        return S.slice(-1) !== "/" && (S += "/"), S;
      }, y = function(S, C) {
        return C = C !== void 0 ? C : h.createFolders, S = p(S), this.files[S] || n.call(this, S, null, { dir: true, createFolders: C }), this.files[S];
      };
      function b(S) {
        return Object.prototype.toString.call(S) === "[object RegExp]";
      }
      var x = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(S) {
        var C, P, O;
        for (C in this.files)
          O = this.files[C], (P = C.slice(this.root.length, C.length)) && C.slice(0, this.root.length) === this.root && S(P, O);
      }, filter: function(S) {
        var C = [];
        return this.forEach(function(P, O) {
          S(P, O) && C.push(O);
        }), C;
      }, file: function(S, C, P) {
        if (arguments.length !== 1)
          return S = this.root + S, n.call(this, S, C, P), this;
        if (b(S)) {
          var O = S;
          return this.filter(function(k, H) {
            return !H.dir && O.test(k);
          });
        }
        var z = this.files[this.root + S];
        return z && !z.dir ? z : null;
      }, folder: function(S) {
        if (!S)
          return this;
        if (b(S))
          return this.filter(function(z, k) {
            return k.dir && S.test(z);
          });
        var C = this.root + S, P = y.call(this, C), O = this.clone();
        return O.root = P.name, O;
      }, remove: function(S) {
        S = this.root + S;
        var C = this.files[S];
        if (C || (S.slice(-1) !== "/" && (S += "/"), C = this.files[S]), C && !C.dir)
          delete this.files[S];
        else
          for (var P = this.filter(function(z, k) {
            return k.name.slice(0, S.length) === S;
          }), O = 0; O < P.length; O++)
            delete this.files[P[O].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(S) {
        var C, P = {};
        try {
          if ((P = o.extend(S || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: r.utf8encode })).type = P.type.toLowerCase(), P.compression = P.compression.toUpperCase(), P.type === "binarystring" && (P.type = "string"), !P.type)
            throw new Error("No output type specified.");
          o.checkSupport(P.type), P.platform !== "darwin" && P.platform !== "freebsd" && P.platform !== "linux" && P.platform !== "sunos" || (P.platform = "UNIX"), P.platform === "win32" && (P.platform = "DOS");
          var O = P.comment || this.comment || "";
          C = f.generateWorker(this, P, O);
        } catch (z) {
          (C = new a("error")).error(z);
        }
        return new c(C, P.type || "string", P.mimeType);
      }, generateAsync: function(S, C) {
        return this.generateInternalStream(S).accumulate(C);
      }, generateNodeStream: function(S, C) {
        return (S = S || {}).type || (S.type = "nodebuffer"), this.generateInternalStream(S).toNodejsStream(C);
      } };
      s.exports = x;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, s, i) {
      s.exports = e("stream");
    }, { stream: void 0 }], 17: [function(e, s, i) {
      var n = e("./DataReader");
      function r(o) {
        n.call(this, o);
        for (var a = 0; a < this.data.length; a++)
          o[a] = 255 & o[a];
      }
      e("../utils").inherits(r, n), r.prototype.byteAt = function(o) {
        return this.data[this.zero + o];
      }, r.prototype.lastIndexOfSignature = function(o) {
        for (var a = o.charCodeAt(0), c = o.charCodeAt(1), h = o.charCodeAt(2), d = o.charCodeAt(3), u = this.length - 4; 0 <= u; --u)
          if (this.data[u] === a && this.data[u + 1] === c && this.data[u + 2] === h && this.data[u + 3] === d)
            return u - this.zero;
        return -1;
      }, r.prototype.readAndCheckSignature = function(o) {
        var a = o.charCodeAt(0), c = o.charCodeAt(1), h = o.charCodeAt(2), d = o.charCodeAt(3), u = this.readData(4);
        return a === u[0] && c === u[1] && h === u[2] && d === u[3];
      }, r.prototype.readData = function(o) {
        if (this.checkOffset(o), o === 0)
          return [];
        var a = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, a;
      }, s.exports = r;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, s, i) {
      var n = e("../utils");
      function r(o) {
        this.data = o, this.length = o.length, this.index = 0, this.zero = 0;
      }
      r.prototype = { checkOffset: function(o) {
        this.checkIndex(this.index + o);
      }, checkIndex: function(o) {
        if (this.length < this.zero + o || o < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + o + "). Corrupted zip ?");
      }, setIndex: function(o) {
        this.checkIndex(o), this.index = o;
      }, skip: function(o) {
        this.setIndex(this.index + o);
      }, byteAt: function() {
      }, readInt: function(o) {
        var a, c = 0;
        for (this.checkOffset(o), a = this.index + o - 1; a >= this.index; a--)
          c = (c << 8) + this.byteAt(a);
        return this.index += o, c;
      }, readString: function(o) {
        return n.transformTo("string", this.readData(o));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var o = this.readInt(4);
        return new Date(Date.UTC(1980 + (o >> 25 & 127), (o >> 21 & 15) - 1, o >> 16 & 31, o >> 11 & 31, o >> 5 & 63, (31 & o) << 1));
      } }, s.exports = r;
    }, { "../utils": 32 }], 19: [function(e, s, i) {
      var n = e("./Uint8ArrayReader");
      function r(o) {
        n.call(this, o);
      }
      e("../utils").inherits(r, n), r.prototype.readData = function(o) {
        this.checkOffset(o);
        var a = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, a;
      }, s.exports = r;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, s, i) {
      var n = e("./DataReader");
      function r(o) {
        n.call(this, o);
      }
      e("../utils").inherits(r, n), r.prototype.byteAt = function(o) {
        return this.data.charCodeAt(this.zero + o);
      }, r.prototype.lastIndexOfSignature = function(o) {
        return this.data.lastIndexOf(o) - this.zero;
      }, r.prototype.readAndCheckSignature = function(o) {
        return o === this.readData(4);
      }, r.prototype.readData = function(o) {
        this.checkOffset(o);
        var a = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, a;
      }, s.exports = r;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, s, i) {
      var n = e("./ArrayReader");
      function r(o) {
        n.call(this, o);
      }
      e("../utils").inherits(r, n), r.prototype.readData = function(o) {
        if (this.checkOffset(o), o === 0)
          return new Uint8Array(0);
        var a = this.data.subarray(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, a;
      }, s.exports = r;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, s, i) {
      var n = e("../utils"), r = e("../support"), o = e("./ArrayReader"), a = e("./StringReader"), c = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
      s.exports = function(d) {
        var u = n.getTypeOf(d);
        return n.checkSupport(u), u !== "string" || r.uint8array ? u === "nodebuffer" ? new c(d) : r.uint8array ? new h(n.transformTo("uint8array", d)) : new o(n.transformTo("array", d)) : new a(d);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, s, i) {
      i.LOCAL_FILE_HEADER = "PK", i.CENTRAL_FILE_HEADER = "PK", i.CENTRAL_DIRECTORY_END = "PK", i.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", i.ZIP64_CENTRAL_DIRECTORY_END = "PK", i.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(e, s, i) {
      var n = e("./GenericWorker"), r = e("../utils");
      function o(a) {
        n.call(this, "ConvertWorker to " + a), this.destType = a;
      }
      r.inherits(o, n), o.prototype.processChunk = function(a) {
        this.push({ data: r.transformTo(this.destType, a.data), meta: a.meta });
      }, s.exports = o;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, s, i) {
      var n = e("./GenericWorker"), r = e("../crc32");
      function o() {
        n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      e("../utils").inherits(o, n), o.prototype.processChunk = function(a) {
        this.streamInfo.crc32 = r(a.data, this.streamInfo.crc32 || 0), this.push(a);
      }, s.exports = o;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, s, i) {
      var n = e("../utils"), r = e("./GenericWorker");
      function o(a) {
        r.call(this, "DataLengthProbe for " + a), this.propName = a, this.withStreamInfo(a, 0);
      }
      n.inherits(o, r), o.prototype.processChunk = function(a) {
        if (a) {
          var c = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = c + a.data.length;
        }
        r.prototype.processChunk.call(this, a);
      }, s.exports = o;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, s, i) {
      var n = e("../utils"), r = e("./GenericWorker");
      function o(a) {
        r.call(this, "DataWorker");
        var c = this;
        this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, a.then(function(h) {
          c.dataIsReady = true, c.data = h, c.max = h && h.length || 0, c.type = n.getTypeOf(h), c.isPaused || c._tickAndRepeat();
        }, function(h) {
          c.error(h);
        });
      }
      n.inherits(o, r), o.prototype.cleanUp = function() {
        r.prototype.cleanUp.call(this), this.data = null;
      }, o.prototype.resume = function() {
        return !!r.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
      }, o.prototype._tickAndRepeat = function() {
        this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
      }, o.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return false;
        var a = null, c = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            a = this.data.substring(this.index, c);
            break;
          case "uint8array":
            a = this.data.subarray(this.index, c);
            break;
          case "array":
          case "nodebuffer":
            a = this.data.slice(this.index, c);
        }
        return this.index = c, this.push({ data: a, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, s.exports = o;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, s, i) {
      function n(r) {
        this.name = r || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      n.prototype = { push: function(r) {
        this.emit("data", r);
      }, end: function() {
        if (this.isFinished)
          return false;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = true;
        } catch (r) {
          this.emit("error", r);
        }
        return true;
      }, error: function(r) {
        return !this.isFinished && (this.isPaused ? this.generatedError = r : (this.isFinished = true, this.emit("error", r), this.previous && this.previous.error(r), this.cleanUp()), true);
      }, on: function(r, o) {
        return this._listeners[r].push(o), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(r, o) {
        if (this._listeners[r])
          for (var a = 0; a < this._listeners[r].length; a++)
            this._listeners[r][a].call(this, o);
      }, pipe: function(r) {
        return r.registerPrevious(this);
      }, registerPrevious: function(r) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = r.streamInfo, this.mergeStreamInfo(), this.previous = r;
        var o = this;
        return r.on("data", function(a) {
          o.processChunk(a);
        }), r.on("end", function() {
          o.end();
        }), r.on("error", function(a) {
          o.error(a);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return false;
        var r = this.isPaused = false;
        return this.generatedError && (this.error(this.generatedError), r = true), this.previous && this.previous.resume(), !r;
      }, flush: function() {
      }, processChunk: function(r) {
        this.push(r);
      }, withStreamInfo: function(r, o) {
        return this.extraStreamInfo[r] = o, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var r in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, r) && (this.streamInfo[r] = this.extraStreamInfo[r]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = true, this.previous && this.previous.lock();
      }, toString: function() {
        var r = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + r : r;
      } }, s.exports = n;
    }, {}], 29: [function(e, s, i) {
      var n = e("../utils"), r = e("./ConvertWorker"), o = e("./GenericWorker"), a = e("../base64"), c = e("../support"), h = e("../external"), d = null;
      if (c.nodestream)
        try {
          d = e("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
      function u(g, m) {
        return new h.Promise(function(_, p) {
          var y = [], b = g._internalType, x = g._outputType, S = g._mimeType;
          g.on("data", function(C, P) {
            y.push(C), m && m(P);
          }).on("error", function(C) {
            y = [], p(C);
          }).on("end", function() {
            try {
              var C = function(P, O, z) {
                switch (P) {
                  case "blob":
                    return n.newBlob(n.transformTo("arraybuffer", O), z);
                  case "base64":
                    return a.encode(O);
                  default:
                    return n.transformTo(P, O);
                }
              }(x, function(P, O) {
                var z, k = 0, H = null, T = 0;
                for (z = 0; z < O.length; z++)
                  T += O[z].length;
                switch (P) {
                  case "string":
                    return O.join("");
                  case "array":
                    return Array.prototype.concat.apply([], O);
                  case "uint8array":
                    for (H = new Uint8Array(T), z = 0; z < O.length; z++)
                      H.set(O[z], k), k += O[z].length;
                    return H;
                  case "nodebuffer":
                    return Buffer.concat(O);
                  default:
                    throw new Error("concat : unsupported type '" + P + "'");
                }
              }(b, y), S);
              _(C);
            } catch (P) {
              p(P);
            }
            y = [];
          }).resume();
        });
      }
      function f(g, m, _) {
        var p = m;
        switch (m) {
          case "blob":
          case "arraybuffer":
            p = "uint8array";
            break;
          case "base64":
            p = "string";
        }
        try {
          this._internalType = p, this._outputType = m, this._mimeType = _, n.checkSupport(p), this._worker = g.pipe(new r(p)), g.lock();
        } catch (y) {
          this._worker = new o("error"), this._worker.error(y);
        }
      }
      f.prototype = { accumulate: function(g) {
        return u(this, g);
      }, on: function(g, m) {
        var _ = this;
        return g === "data" ? this._worker.on(g, function(p) {
          m.call(_, p.data, p.meta);
        }) : this._worker.on(g, function() {
          n.delay(m, arguments, _);
        }), this;
      }, resume: function() {
        return n.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(g) {
        if (n.checkSupport("nodestream"), this._outputType !== "nodebuffer")
          throw new Error(this._outputType + " is not supported by this method");
        return new d(this, { objectMode: this._outputType !== "nodebuffer" }, g);
      } }, s.exports = f;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, s, i) {
      if (i.base64 = true, i.array = true, i.string = true, i.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", i.nodebuffer = typeof Buffer < "u", i.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
        i.blob = false;
      else {
        var n = new ArrayBuffer(0);
        try {
          i.blob = new Blob([n], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var r = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            r.append(n), i.blob = r.getBlob("application/zip").size === 0;
          } catch {
            i.blob = false;
          }
        }
      }
      try {
        i.nodestream = !!e("readable-stream").Readable;
      } catch {
        i.nodestream = false;
      }
    }, { "readable-stream": 16 }], 31: [function(e, s, i) {
      for (var n = e("./utils"), r = e("./support"), o = e("./nodejsUtils"), a = e("./stream/GenericWorker"), c = new Array(256), h = 0; h < 256; h++)
        c[h] = 252 <= h ? 6 : 248 <= h ? 5 : 240 <= h ? 4 : 224 <= h ? 3 : 192 <= h ? 2 : 1;
      c[254] = c[254] = 1;
      function d() {
        a.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function u() {
        a.call(this, "utf-8 encode");
      }
      i.utf8encode = function(f) {
        return r.nodebuffer ? o.newBufferFrom(f, "utf-8") : function(g) {
          var m, _, p, y, b, x = g.length, S = 0;
          for (y = 0; y < x; y++)
            (64512 & (_ = g.charCodeAt(y))) == 55296 && y + 1 < x && (64512 & (p = g.charCodeAt(y + 1))) == 56320 && (_ = 65536 + (_ - 55296 << 10) + (p - 56320), y++), S += _ < 128 ? 1 : _ < 2048 ? 2 : _ < 65536 ? 3 : 4;
          for (m = r.uint8array ? new Uint8Array(S) : new Array(S), y = b = 0; b < S; y++)
            (64512 & (_ = g.charCodeAt(y))) == 55296 && y + 1 < x && (64512 & (p = g.charCodeAt(y + 1))) == 56320 && (_ = 65536 + (_ - 55296 << 10) + (p - 56320), y++), _ < 128 ? m[b++] = _ : (_ < 2048 ? m[b++] = 192 | _ >>> 6 : (_ < 65536 ? m[b++] = 224 | _ >>> 12 : (m[b++] = 240 | _ >>> 18, m[b++] = 128 | _ >>> 12 & 63), m[b++] = 128 | _ >>> 6 & 63), m[b++] = 128 | 63 & _);
          return m;
        }(f);
      }, i.utf8decode = function(f) {
        return r.nodebuffer ? n.transformTo("nodebuffer", f).toString("utf-8") : function(g) {
          var m, _, p, y, b = g.length, x = new Array(2 * b);
          for (m = _ = 0; m < b; )
            if ((p = g[m++]) < 128)
              x[_++] = p;
            else if (4 < (y = c[p]))
              x[_++] = 65533, m += y - 1;
            else {
              for (p &= y === 2 ? 31 : y === 3 ? 15 : 7; 1 < y && m < b; )
                p = p << 6 | 63 & g[m++], y--;
              1 < y ? x[_++] = 65533 : p < 65536 ? x[_++] = p : (p -= 65536, x[_++] = 55296 | p >> 10 & 1023, x[_++] = 56320 | 1023 & p);
            }
          return x.length !== _ && (x.subarray ? x = x.subarray(0, _) : x.length = _), n.applyFromCharCode(x);
        }(f = n.transformTo(r.uint8array ? "uint8array" : "array", f));
      }, n.inherits(d, a), d.prototype.processChunk = function(f) {
        var g = n.transformTo(r.uint8array ? "uint8array" : "array", f.data);
        if (this.leftOver && this.leftOver.length) {
          if (r.uint8array) {
            var m = g;
            (g = new Uint8Array(m.length + this.leftOver.length)).set(this.leftOver, 0), g.set(m, this.leftOver.length);
          } else
            g = this.leftOver.concat(g);
          this.leftOver = null;
        }
        var _ = function(y, b) {
          var x;
          for ((b = b || y.length) > y.length && (b = y.length), x = b - 1; 0 <= x && (192 & y[x]) == 128; )
            x--;
          return x < 0 || x === 0 ? b : x + c[y[x]] > b ? x : b;
        }(g), p = g;
        _ !== g.length && (r.uint8array ? (p = g.subarray(0, _), this.leftOver = g.subarray(_, g.length)) : (p = g.slice(0, _), this.leftOver = g.slice(_, g.length))), this.push({ data: i.utf8decode(p), meta: f.meta });
      }, d.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: i.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, i.Utf8DecodeWorker = d, n.inherits(u, a), u.prototype.processChunk = function(f) {
        this.push({ data: i.utf8encode(f.data), meta: f.meta });
      }, i.Utf8EncodeWorker = u;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, s, i) {
      var n = e("./support"), r = e("./base64"), o = e("./nodejsUtils"), a = e("./external");
      function c(m) {
        return m;
      }
      function h(m, _) {
        for (var p = 0; p < m.length; ++p)
          _[p] = 255 & m.charCodeAt(p);
        return _;
      }
      e("setimmediate"), i.newBlob = function(m, _) {
        i.checkSupport("blob");
        try {
          return new Blob([m], { type: _ });
        } catch {
          try {
            var p = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return p.append(m), p.getBlob(_);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var d = { stringifyByChunk: function(m, _, p) {
        var y = [], b = 0, x = m.length;
        if (x <= p)
          return String.fromCharCode.apply(null, m);
        for (; b < x; )
          _ === "array" || _ === "nodebuffer" ? y.push(String.fromCharCode.apply(null, m.slice(b, Math.min(b + p, x)))) : y.push(String.fromCharCode.apply(null, m.subarray(b, Math.min(b + p, x)))), b += p;
        return y.join("");
      }, stringifyByChar: function(m) {
        for (var _ = "", p = 0; p < m.length; p++)
          _ += String.fromCharCode(m[p]);
        return _;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return n.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return false;
        }
      }(), nodebuffer: function() {
        try {
          return n.nodebuffer && String.fromCharCode.apply(null, o.allocBuffer(1)).length === 1;
        } catch {
          return false;
        }
      }() } };
      function u(m) {
        var _ = 65536, p = i.getTypeOf(m), y = true;
        if (p === "uint8array" ? y = d.applyCanBeUsed.uint8array : p === "nodebuffer" && (y = d.applyCanBeUsed.nodebuffer), y)
          for (; 1 < _; )
            try {
              return d.stringifyByChunk(m, p, _);
            } catch {
              _ = Math.floor(_ / 2);
            }
        return d.stringifyByChar(m);
      }
      function f(m, _) {
        for (var p = 0; p < m.length; p++)
          _[p] = m[p];
        return _;
      }
      i.applyFromCharCode = u;
      var g = {};
      g.string = { string: c, array: function(m) {
        return h(m, new Array(m.length));
      }, arraybuffer: function(m) {
        return g.string.uint8array(m).buffer;
      }, uint8array: function(m) {
        return h(m, new Uint8Array(m.length));
      }, nodebuffer: function(m) {
        return h(m, o.allocBuffer(m.length));
      } }, g.array = { string: u, array: c, arraybuffer: function(m) {
        return new Uint8Array(m).buffer;
      }, uint8array: function(m) {
        return new Uint8Array(m);
      }, nodebuffer: function(m) {
        return o.newBufferFrom(m);
      } }, g.arraybuffer = { string: function(m) {
        return u(new Uint8Array(m));
      }, array: function(m) {
        return f(new Uint8Array(m), new Array(m.byteLength));
      }, arraybuffer: c, uint8array: function(m) {
        return new Uint8Array(m);
      }, nodebuffer: function(m) {
        return o.newBufferFrom(new Uint8Array(m));
      } }, g.uint8array = { string: u, array: function(m) {
        return f(m, new Array(m.length));
      }, arraybuffer: function(m) {
        return m.buffer;
      }, uint8array: c, nodebuffer: function(m) {
        return o.newBufferFrom(m);
      } }, g.nodebuffer = { string: u, array: function(m) {
        return f(m, new Array(m.length));
      }, arraybuffer: function(m) {
        return g.nodebuffer.uint8array(m).buffer;
      }, uint8array: function(m) {
        return f(m, new Uint8Array(m.length));
      }, nodebuffer: c }, i.transformTo = function(m, _) {
        if (_ = _ || "", !m)
          return _;
        i.checkSupport(m);
        var p = i.getTypeOf(_);
        return g[p][m](_);
      }, i.resolve = function(m) {
        for (var _ = m.split("/"), p = [], y = 0; y < _.length; y++) {
          var b = _[y];
          b === "." || b === "" && y !== 0 && y !== _.length - 1 || (b === ".." ? p.pop() : p.push(b));
        }
        return p.join("/");
      }, i.getTypeOf = function(m) {
        return typeof m == "string" ? "string" : Object.prototype.toString.call(m) === "[object Array]" ? "array" : n.nodebuffer && o.isBuffer(m) ? "nodebuffer" : n.uint8array && m instanceof Uint8Array ? "uint8array" : n.arraybuffer && m instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, i.checkSupport = function(m) {
        if (!n[m.toLowerCase()])
          throw new Error(m + " is not supported by this platform");
      }, i.MAX_VALUE_16BITS = 65535, i.MAX_VALUE_32BITS = -1, i.pretty = function(m) {
        var _, p, y = "";
        for (p = 0; p < (m || "").length; p++)
          y += "\\x" + ((_ = m.charCodeAt(p)) < 16 ? "0" : "") + _.toString(16).toUpperCase();
        return y;
      }, i.delay = function(m, _, p) {
        setImmediate(function() {
          m.apply(p || null, _ || []);
        });
      }, i.inherits = function(m, _) {
        function p() {
        }
        p.prototype = _.prototype, m.prototype = new p();
      }, i.extend = function() {
        var m, _, p = {};
        for (m = 0; m < arguments.length; m++)
          for (_ in arguments[m])
            Object.prototype.hasOwnProperty.call(arguments[m], _) && p[_] === void 0 && (p[_] = arguments[m][_]);
        return p;
      }, i.prepareContent = function(m, _, p, y, b) {
        return a.Promise.resolve(_).then(function(x) {
          return n.blob && (x instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(x)) !== -1) && typeof FileReader < "u" ? new a.Promise(function(S, C) {
            var P = new FileReader();
            P.onload = function(O) {
              S(O.target.result);
            }, P.onerror = function(O) {
              C(O.target.error);
            }, P.readAsArrayBuffer(x);
          }) : x;
        }).then(function(x) {
          var S = i.getTypeOf(x);
          return S ? (S === "arraybuffer" ? x = i.transformTo("uint8array", x) : S === "string" && (b ? x = r.decode(x) : p && y !== true && (x = function(C) {
            return h(C, n.uint8array ? new Uint8Array(C.length) : new Array(C.length));
          }(x))), x) : a.Promise.reject(new Error("Can't read the data of '" + m + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, s, i) {
      var n = e("./reader/readerFor"), r = e("./utils"), o = e("./signature"), a = e("./zipEntry"), c = e("./support");
      function h(d) {
        this.files = [], this.loadOptions = d;
      }
      h.prototype = { checkSignature: function(d) {
        if (!this.reader.readAndCheckSignature(d)) {
          this.reader.index -= 4;
          var u = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + r.pretty(u) + ", expected " + r.pretty(d) + ")");
        }
      }, isSignature: function(d, u) {
        var f = this.reader.index;
        this.reader.setIndex(d);
        var g = this.reader.readString(4) === u;
        return this.reader.setIndex(f), g;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var d = this.reader.readData(this.zipCommentLength), u = c.uint8array ? "uint8array" : "array", f = r.transformTo(u, d);
        this.zipComment = this.loadOptions.decodeFileName(f);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var d, u, f, g = this.zip64EndOfCentralSize - 44; 0 < g; )
          d = this.reader.readInt(2), u = this.reader.readInt(4), f = this.reader.readData(u), this.zip64ExtensibleData[d] = { id: d, length: u, value: f };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var d, u;
        for (d = 0; d < this.files.length; d++)
          u = this.files[d], this.reader.setIndex(u.localHeaderOffset), this.checkSignature(o.LOCAL_FILE_HEADER), u.readLocalPart(this.reader), u.handleUTF8(), u.processAttributes();
      }, readCentralDir: function() {
        var d;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(o.CENTRAL_FILE_HEADER); )
          (d = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(d);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var d = this.reader.lastIndexOfSignature(o.CENTRAL_DIRECTORY_END);
        if (d < 0)
          throw this.isSignature(0, o.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(d);
        var u = d;
        if (this.checkSignature(o.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === r.MAX_VALUE_16BITS || this.diskWithCentralDirStart === r.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === r.MAX_VALUE_16BITS || this.centralDirRecords === r.MAX_VALUE_16BITS || this.centralDirSize === r.MAX_VALUE_32BITS || this.centralDirOffset === r.MAX_VALUE_32BITS) {
          if (this.zip64 = true, (d = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(d), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, o.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var f = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (f += 20, f += 12 + this.zip64EndOfCentralSize);
        var g = u - f;
        if (0 < g)
          this.isSignature(u, o.CENTRAL_FILE_HEADER) || (this.reader.zero = g);
        else if (g < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(g) + " bytes.");
      }, prepareReader: function(d) {
        this.reader = n(d);
      }, load: function(d) {
        this.prepareReader(d), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, s.exports = h;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, s, i) {
      var n = e("./reader/readerFor"), r = e("./utils"), o = e("./compressedObject"), a = e("./crc32"), c = e("./utf8"), h = e("./compressions"), d = e("./support");
      function u(f, g) {
        this.options = f, this.loadOptions = g;
      }
      u.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(f) {
        var g, m;
        if (f.skip(22), this.fileNameLength = f.readInt(2), m = f.readInt(2), this.fileName = f.readData(this.fileNameLength), f.skip(m), this.compressedSize === -1 || this.uncompressedSize === -1)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((g = function(_) {
          for (var p in h)
            if (Object.prototype.hasOwnProperty.call(h, p) && h[p].magic === _)
              return h[p];
          return null;
        }(this.compressionMethod)) === null)
          throw new Error("Corrupted zip : compression " + r.pretty(this.compressionMethod) + " unknown (inner file : " + r.transformTo("string", this.fileName) + ")");
        this.decompressed = new o(this.compressedSize, this.uncompressedSize, this.crc32, g, f.readData(this.compressedSize));
      }, readCentralPart: function(f) {
        this.versionMadeBy = f.readInt(2), f.skip(2), this.bitFlag = f.readInt(2), this.compressionMethod = f.readString(2), this.date = f.readDate(), this.crc32 = f.readInt(4), this.compressedSize = f.readInt(4), this.uncompressedSize = f.readInt(4);
        var g = f.readInt(2);
        if (this.extraFieldsLength = f.readInt(2), this.fileCommentLength = f.readInt(2), this.diskNumberStart = f.readInt(2), this.internalFileAttributes = f.readInt(2), this.externalFileAttributes = f.readInt(4), this.localHeaderOffset = f.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        f.skip(g), this.readExtraFields(f), this.parseZIP64ExtraField(f), this.fileComment = f.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var f = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), f == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), f == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = true);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var f = n(this.extraFields[1].value);
          this.uncompressedSize === r.MAX_VALUE_32BITS && (this.uncompressedSize = f.readInt(8)), this.compressedSize === r.MAX_VALUE_32BITS && (this.compressedSize = f.readInt(8)), this.localHeaderOffset === r.MAX_VALUE_32BITS && (this.localHeaderOffset = f.readInt(8)), this.diskNumberStart === r.MAX_VALUE_32BITS && (this.diskNumberStart = f.readInt(4));
        }
      }, readExtraFields: function(f) {
        var g, m, _, p = f.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); f.index + 4 < p; )
          g = f.readInt(2), m = f.readInt(2), _ = f.readData(m), this.extraFields[g] = { id: g, length: m, value: _ };
        f.setIndex(p);
      }, handleUTF8: function() {
        var f = d.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = c.utf8decode(this.fileName), this.fileCommentStr = c.utf8decode(this.fileComment);
        else {
          var g = this.findExtraFieldUnicodePath();
          if (g !== null)
            this.fileNameStr = g;
          else {
            var m = r.transformTo(f, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(m);
          }
          var _ = this.findExtraFieldUnicodeComment();
          if (_ !== null)
            this.fileCommentStr = _;
          else {
            var p = r.transformTo(f, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(p);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var f = this.extraFields[28789];
        if (f) {
          var g = n(f.value);
          return g.readInt(1) !== 1 || a(this.fileName) !== g.readInt(4) ? null : c.utf8decode(g.readData(f.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var f = this.extraFields[25461];
        if (f) {
          var g = n(f.value);
          return g.readInt(1) !== 1 || a(this.fileComment) !== g.readInt(4) ? null : c.utf8decode(g.readData(f.length - 5));
        }
        return null;
      } }, s.exports = u;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, s, i) {
      function n(g, m, _) {
        this.name = g, this.dir = _.dir, this.date = _.date, this.comment = _.comment, this.unixPermissions = _.unixPermissions, this.dosPermissions = _.dosPermissions, this._data = m, this._dataBinary = _.binary, this.options = { compression: _.compression, compressionOptions: _.compressionOptions };
      }
      var r = e("./stream/StreamHelper"), o = e("./stream/DataWorker"), a = e("./utf8"), c = e("./compressedObject"), h = e("./stream/GenericWorker");
      n.prototype = { internalStream: function(g) {
        var m = null, _ = "string";
        try {
          if (!g)
            throw new Error("No output type specified.");
          var p = (_ = g.toLowerCase()) === "string" || _ === "text";
          _ !== "binarystring" && _ !== "text" || (_ = "string"), m = this._decompressWorker();
          var y = !this._dataBinary;
          y && !p && (m = m.pipe(new a.Utf8EncodeWorker())), !y && p && (m = m.pipe(new a.Utf8DecodeWorker()));
        } catch (b) {
          (m = new h("error")).error(b);
        }
        return new r(m, _, "");
      }, async: function(g, m) {
        return this.internalStream(g).accumulate(m);
      }, nodeStream: function(g, m) {
        return this.internalStream(g || "nodebuffer").toNodejsStream(m);
      }, _compressWorker: function(g, m) {
        if (this._data instanceof c && this._data.compression.magic === g.magic)
          return this._data.getCompressedWorker();
        var _ = this._decompressWorker();
        return this._dataBinary || (_ = _.pipe(new a.Utf8EncodeWorker())), c.createWorkerFrom(_, g, m);
      }, _decompressWorker: function() {
        return this._data instanceof c ? this._data.getContentWorker() : this._data instanceof h ? this._data : new o(this._data);
      } };
      for (var d = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], u = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, f = 0; f < d.length; f++)
        n.prototype[d[f]] = u;
      s.exports = n;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, s, i) {
      (function(n) {
        var r, o, a = n.MutationObserver || n.WebKitMutationObserver;
        if (a) {
          var c = 0, h = new a(g), d = n.document.createTextNode("");
          h.observe(d, { characterData: true }), r = function() {
            d.data = c = ++c % 2;
          };
        } else if (n.setImmediate || n.MessageChannel === void 0)
          r = "document" in n && "onreadystatechange" in n.document.createElement("script") ? function() {
            var m = n.document.createElement("script");
            m.onreadystatechange = function() {
              g(), m.onreadystatechange = null, m.parentNode.removeChild(m), m = null;
            }, n.document.documentElement.appendChild(m);
          } : function() {
            setTimeout(g, 0);
          };
        else {
          var u = new n.MessageChannel();
          u.port1.onmessage = g, r = function() {
            u.port2.postMessage(0);
          };
        }
        var f = [];
        function g() {
          var m, _;
          o = true;
          for (var p = f.length; p; ) {
            for (_ = f, f = [], m = -1; ++m < p; )
              _[m]();
            p = f.length;
          }
          o = false;
        }
        s.exports = function(m) {
          f.push(m) !== 1 || o || r();
        };
      }).call(this, typeof hi < "u" ? hi : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(e, s, i) {
      var n = e("immediate");
      function r() {
      }
      var o = {}, a = ["REJECTED"], c = ["FULFILLED"], h = ["PENDING"];
      function d(p) {
        if (typeof p != "function")
          throw new TypeError("resolver must be a function");
        this.state = h, this.queue = [], this.outcome = void 0, p !== r && m(this, p);
      }
      function u(p, y, b) {
        this.promise = p, typeof y == "function" && (this.onFulfilled = y, this.callFulfilled = this.otherCallFulfilled), typeof b == "function" && (this.onRejected = b, this.callRejected = this.otherCallRejected);
      }
      function f(p, y, b) {
        n(function() {
          var x;
          try {
            x = y(b);
          } catch (S) {
            return o.reject(p, S);
          }
          x === p ? o.reject(p, new TypeError("Cannot resolve promise with itself")) : o.resolve(p, x);
        });
      }
      function g(p) {
        var y = p && p.then;
        if (p && (typeof p == "object" || typeof p == "function") && typeof y == "function")
          return function() {
            y.apply(p, arguments);
          };
      }
      function m(p, y) {
        var b = false;
        function x(P) {
          b || (b = true, o.reject(p, P));
        }
        function S(P) {
          b || (b = true, o.resolve(p, P));
        }
        var C = _(function() {
          y(S, x);
        });
        C.status === "error" && x(C.value);
      }
      function _(p, y) {
        var b = {};
        try {
          b.value = p(y), b.status = "success";
        } catch (x) {
          b.status = "error", b.value = x;
        }
        return b;
      }
      (s.exports = d).prototype.finally = function(p) {
        if (typeof p != "function")
          return this;
        var y = this.constructor;
        return this.then(function(b) {
          return y.resolve(p()).then(function() {
            return b;
          });
        }, function(b) {
          return y.resolve(p()).then(function() {
            throw b;
          });
        });
      }, d.prototype.catch = function(p) {
        return this.then(null, p);
      }, d.prototype.then = function(p, y) {
        if (typeof p != "function" && this.state === c || typeof y != "function" && this.state === a)
          return this;
        var b = new this.constructor(r);
        return this.state !== h ? f(b, this.state === c ? p : y, this.outcome) : this.queue.push(new u(b, p, y)), b;
      }, u.prototype.callFulfilled = function(p) {
        o.resolve(this.promise, p);
      }, u.prototype.otherCallFulfilled = function(p) {
        f(this.promise, this.onFulfilled, p);
      }, u.prototype.callRejected = function(p) {
        o.reject(this.promise, p);
      }, u.prototype.otherCallRejected = function(p) {
        f(this.promise, this.onRejected, p);
      }, o.resolve = function(p, y) {
        var b = _(g, y);
        if (b.status === "error")
          return o.reject(p, b.value);
        var x = b.value;
        if (x)
          m(p, x);
        else {
          p.state = c, p.outcome = y;
          for (var S = -1, C = p.queue.length; ++S < C; )
            p.queue[S].callFulfilled(y);
        }
        return p;
      }, o.reject = function(p, y) {
        p.state = a, p.outcome = y;
        for (var b = -1, x = p.queue.length; ++b < x; )
          p.queue[b].callRejected(y);
        return p;
      }, d.resolve = function(p) {
        return p instanceof this ? p : o.resolve(new this(r), p);
      }, d.reject = function(p) {
        var y = new this(r);
        return o.reject(y, p);
      }, d.all = function(p) {
        var y = this;
        if (Object.prototype.toString.call(p) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var b = p.length, x = false;
        if (!b)
          return this.resolve([]);
        for (var S = new Array(b), C = 0, P = -1, O = new this(r); ++P < b; )
          z(p[P], P);
        return O;
        function z(k, H) {
          y.resolve(k).then(function(T) {
            S[H] = T, ++C !== b || x || (x = true, o.resolve(O, S));
          }, function(T) {
            x || (x = true, o.reject(O, T));
          });
        }
      }, d.race = function(p) {
        var y = this;
        if (Object.prototype.toString.call(p) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var b = p.length, x = false;
        if (!b)
          return this.resolve([]);
        for (var S = -1, C = new this(r); ++S < b; )
          P = p[S], y.resolve(P).then(function(O) {
            x || (x = true, o.resolve(C, O));
          }, function(O) {
            x || (x = true, o.reject(C, O));
          });
        var P;
        return C;
      };
    }, { immediate: 36 }], 38: [function(e, s, i) {
      var n = {};
      (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), s.exports = n;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, s, i) {
      var n = e("./zlib/deflate"), r = e("./utils/common"), o = e("./utils/strings"), a = e("./zlib/messages"), c = e("./zlib/zstream"), h = Object.prototype.toString, d = 0, u = -1, f = 0, g = 8;
      function m(p) {
        if (!(this instanceof m))
          return new m(p);
        this.options = r.assign({ level: u, method: g, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: f, to: "" }, p || {});
        var y = this.options;
        y.raw && 0 < y.windowBits ? y.windowBits = -y.windowBits : y.gzip && 0 < y.windowBits && y.windowBits < 16 && (y.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
        var b = n.deflateInit2(this.strm, y.level, y.method, y.windowBits, y.memLevel, y.strategy);
        if (b !== d)
          throw new Error(a[b]);
        if (y.header && n.deflateSetHeader(this.strm, y.header), y.dictionary) {
          var x;
          if (x = typeof y.dictionary == "string" ? o.string2buf(y.dictionary) : h.call(y.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(y.dictionary) : y.dictionary, (b = n.deflateSetDictionary(this.strm, x)) !== d)
            throw new Error(a[b]);
          this._dict_set = true;
        }
      }
      function _(p, y) {
        var b = new m(y);
        if (b.push(p, true), b.err)
          throw b.msg || a[b.err];
        return b.result;
      }
      m.prototype.push = function(p, y) {
        var b, x, S = this.strm, C = this.options.chunkSize;
        if (this.ended)
          return false;
        x = y === ~~y ? y : y === true ? 4 : 0, typeof p == "string" ? S.input = o.string2buf(p) : h.call(p) === "[object ArrayBuffer]" ? S.input = new Uint8Array(p) : S.input = p, S.next_in = 0, S.avail_in = S.input.length;
        do {
          if (S.avail_out === 0 && (S.output = new r.Buf8(C), S.next_out = 0, S.avail_out = C), (b = n.deflate(S, x)) !== 1 && b !== d)
            return this.onEnd(b), !(this.ended = true);
          S.avail_out !== 0 && (S.avail_in !== 0 || x !== 4 && x !== 2) || (this.options.to === "string" ? this.onData(o.buf2binstring(r.shrinkBuf(S.output, S.next_out))) : this.onData(r.shrinkBuf(S.output, S.next_out)));
        } while ((0 < S.avail_in || S.avail_out === 0) && b !== 1);
        return x === 4 ? (b = n.deflateEnd(this.strm), this.onEnd(b), this.ended = true, b === d) : x !== 2 || (this.onEnd(d), !(S.avail_out = 0));
      }, m.prototype.onData = function(p) {
        this.chunks.push(p);
      }, m.prototype.onEnd = function(p) {
        p === d && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = r.flattenChunks(this.chunks)), this.chunks = [], this.err = p, this.msg = this.strm.msg;
      }, i.Deflate = m, i.deflate = _, i.deflateRaw = function(p, y) {
        return (y = y || {}).raw = true, _(p, y);
      }, i.gzip = function(p, y) {
        return (y = y || {}).gzip = true, _(p, y);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, s, i) {
      var n = e("./zlib/inflate"), r = e("./utils/common"), o = e("./utils/strings"), a = e("./zlib/constants"), c = e("./zlib/messages"), h = e("./zlib/zstream"), d = e("./zlib/gzheader"), u = Object.prototype.toString;
      function f(m) {
        if (!(this instanceof f))
          return new f(m);
        this.options = r.assign({ chunkSize: 16384, windowBits: 0, to: "" }, m || {});
        var _ = this.options;
        _.raw && 0 <= _.windowBits && _.windowBits < 16 && (_.windowBits = -_.windowBits, _.windowBits === 0 && (_.windowBits = -15)), !(0 <= _.windowBits && _.windowBits < 16) || m && m.windowBits || (_.windowBits += 32), 15 < _.windowBits && _.windowBits < 48 && !(15 & _.windowBits) && (_.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new h(), this.strm.avail_out = 0;
        var p = n.inflateInit2(this.strm, _.windowBits);
        if (p !== a.Z_OK)
          throw new Error(c[p]);
        this.header = new d(), n.inflateGetHeader(this.strm, this.header);
      }
      function g(m, _) {
        var p = new f(_);
        if (p.push(m, true), p.err)
          throw p.msg || c[p.err];
        return p.result;
      }
      f.prototype.push = function(m, _) {
        var p, y, b, x, S, C, P = this.strm, O = this.options.chunkSize, z = this.options.dictionary, k = false;
        if (this.ended)
          return false;
        y = _ === ~~_ ? _ : _ === true ? a.Z_FINISH : a.Z_NO_FLUSH, typeof m == "string" ? P.input = o.binstring2buf(m) : u.call(m) === "[object ArrayBuffer]" ? P.input = new Uint8Array(m) : P.input = m, P.next_in = 0, P.avail_in = P.input.length;
        do {
          if (P.avail_out === 0 && (P.output = new r.Buf8(O), P.next_out = 0, P.avail_out = O), (p = n.inflate(P, a.Z_NO_FLUSH)) === a.Z_NEED_DICT && z && (C = typeof z == "string" ? o.string2buf(z) : u.call(z) === "[object ArrayBuffer]" ? new Uint8Array(z) : z, p = n.inflateSetDictionary(this.strm, C)), p === a.Z_BUF_ERROR && k === true && (p = a.Z_OK, k = false), p !== a.Z_STREAM_END && p !== a.Z_OK)
            return this.onEnd(p), !(this.ended = true);
          P.next_out && (P.avail_out !== 0 && p !== a.Z_STREAM_END && (P.avail_in !== 0 || y !== a.Z_FINISH && y !== a.Z_SYNC_FLUSH) || (this.options.to === "string" ? (b = o.utf8border(P.output, P.next_out), x = P.next_out - b, S = o.buf2string(P.output, b), P.next_out = x, P.avail_out = O - x, x && r.arraySet(P.output, P.output, b, x, 0), this.onData(S)) : this.onData(r.shrinkBuf(P.output, P.next_out)))), P.avail_in === 0 && P.avail_out === 0 && (k = true);
        } while ((0 < P.avail_in || P.avail_out === 0) && p !== a.Z_STREAM_END);
        return p === a.Z_STREAM_END && (y = a.Z_FINISH), y === a.Z_FINISH ? (p = n.inflateEnd(this.strm), this.onEnd(p), this.ended = true, p === a.Z_OK) : y !== a.Z_SYNC_FLUSH || (this.onEnd(a.Z_OK), !(P.avail_out = 0));
      }, f.prototype.onData = function(m) {
        this.chunks.push(m);
      }, f.prototype.onEnd = function(m) {
        m === a.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = r.flattenChunks(this.chunks)), this.chunks = [], this.err = m, this.msg = this.strm.msg;
      }, i.Inflate = f, i.inflate = g, i.inflateRaw = function(m, _) {
        return (_ = _ || {}).raw = true, g(m, _);
      }, i.ungzip = g;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, s, i) {
      var n = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      i.assign = function(a) {
        for (var c = Array.prototype.slice.call(arguments, 1); c.length; ) {
          var h = c.shift();
          if (h) {
            if (typeof h != "object")
              throw new TypeError(h + "must be non-object");
            for (var d in h)
              h.hasOwnProperty(d) && (a[d] = h[d]);
          }
        }
        return a;
      }, i.shrinkBuf = function(a, c) {
        return a.length === c ? a : a.subarray ? a.subarray(0, c) : (a.length = c, a);
      };
      var r = { arraySet: function(a, c, h, d, u) {
        if (c.subarray && a.subarray)
          a.set(c.subarray(h, h + d), u);
        else
          for (var f = 0; f < d; f++)
            a[u + f] = c[h + f];
      }, flattenChunks: function(a) {
        var c, h, d, u, f, g;
        for (c = d = 0, h = a.length; c < h; c++)
          d += a[c].length;
        for (g = new Uint8Array(d), c = u = 0, h = a.length; c < h; c++)
          f = a[c], g.set(f, u), u += f.length;
        return g;
      } }, o = { arraySet: function(a, c, h, d, u) {
        for (var f = 0; f < d; f++)
          a[u + f] = c[h + f];
      }, flattenChunks: function(a) {
        return [].concat.apply([], a);
      } };
      i.setTyped = function(a) {
        a ? (i.Buf8 = Uint8Array, i.Buf16 = Uint16Array, i.Buf32 = Int32Array, i.assign(i, r)) : (i.Buf8 = Array, i.Buf16 = Array, i.Buf32 = Array, i.assign(i, o));
      }, i.setTyped(n);
    }, {}], 42: [function(e, s, i) {
      var n = e("./common"), r = true, o = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        r = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        o = false;
      }
      for (var a = new n.Buf8(256), c = 0; c < 256; c++)
        a[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
      function h(d, u) {
        if (u < 65537 && (d.subarray && o || !d.subarray && r))
          return String.fromCharCode.apply(null, n.shrinkBuf(d, u));
        for (var f = "", g = 0; g < u; g++)
          f += String.fromCharCode(d[g]);
        return f;
      }
      a[254] = a[254] = 1, i.string2buf = function(d) {
        var u, f, g, m, _, p = d.length, y = 0;
        for (m = 0; m < p; m++)
          (64512 & (f = d.charCodeAt(m))) == 55296 && m + 1 < p && (64512 & (g = d.charCodeAt(m + 1))) == 56320 && (f = 65536 + (f - 55296 << 10) + (g - 56320), m++), y += f < 128 ? 1 : f < 2048 ? 2 : f < 65536 ? 3 : 4;
        for (u = new n.Buf8(y), m = _ = 0; _ < y; m++)
          (64512 & (f = d.charCodeAt(m))) == 55296 && m + 1 < p && (64512 & (g = d.charCodeAt(m + 1))) == 56320 && (f = 65536 + (f - 55296 << 10) + (g - 56320), m++), f < 128 ? u[_++] = f : (f < 2048 ? u[_++] = 192 | f >>> 6 : (f < 65536 ? u[_++] = 224 | f >>> 12 : (u[_++] = 240 | f >>> 18, u[_++] = 128 | f >>> 12 & 63), u[_++] = 128 | f >>> 6 & 63), u[_++] = 128 | 63 & f);
        return u;
      }, i.buf2binstring = function(d) {
        return h(d, d.length);
      }, i.binstring2buf = function(d) {
        for (var u = new n.Buf8(d.length), f = 0, g = u.length; f < g; f++)
          u[f] = d.charCodeAt(f);
        return u;
      }, i.buf2string = function(d, u) {
        var f, g, m, _, p = u || d.length, y = new Array(2 * p);
        for (f = g = 0; f < p; )
          if ((m = d[f++]) < 128)
            y[g++] = m;
          else if (4 < (_ = a[m]))
            y[g++] = 65533, f += _ - 1;
          else {
            for (m &= _ === 2 ? 31 : _ === 3 ? 15 : 7; 1 < _ && f < p; )
              m = m << 6 | 63 & d[f++], _--;
            1 < _ ? y[g++] = 65533 : m < 65536 ? y[g++] = m : (m -= 65536, y[g++] = 55296 | m >> 10 & 1023, y[g++] = 56320 | 1023 & m);
          }
        return h(y, g);
      }, i.utf8border = function(d, u) {
        var f;
        for ((u = u || d.length) > d.length && (u = d.length), f = u - 1; 0 <= f && (192 & d[f]) == 128; )
          f--;
        return f < 0 || f === 0 ? u : f + a[d[f]] > u ? f : u;
      };
    }, { "./common": 41 }], 43: [function(e, s, i) {
      s.exports = function(n, r, o, a) {
        for (var c = 65535 & n | 0, h = n >>> 16 & 65535 | 0, d = 0; o !== 0; ) {
          for (o -= d = 2e3 < o ? 2e3 : o; h = h + (c = c + r[a++] | 0) | 0, --d; )
            ;
          c %= 65521, h %= 65521;
        }
        return c | h << 16 | 0;
      };
    }, {}], 44: [function(e, s, i) {
      s.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(e, s, i) {
      var n = function() {
        for (var r, o = [], a = 0; a < 256; a++) {
          r = a;
          for (var c = 0; c < 8; c++)
            r = 1 & r ? 3988292384 ^ r >>> 1 : r >>> 1;
          o[a] = r;
        }
        return o;
      }();
      s.exports = function(r, o, a, c) {
        var h = n, d = c + a;
        r ^= -1;
        for (var u = c; u < d; u++)
          r = r >>> 8 ^ h[255 & (r ^ o[u])];
        return -1 ^ r;
      };
    }, {}], 46: [function(e, s, i) {
      var n, r = e("../utils/common"), o = e("./trees"), a = e("./adler32"), c = e("./crc32"), h = e("./messages"), d = 0, u = 4, f = 0, g = -2, m = -1, _ = 4, p = 2, y = 8, b = 9, x = 286, S = 30, C = 19, P = 2 * x + 1, O = 15, z = 3, k = 258, H = k + z + 1, T = 42, L = 113, w = 1, N = 2, K = 3, W = 4;
      function st(v, Y) {
        return v.msg = h[Y], Y;
      }
      function j(v) {
        return (v << 1) - (4 < v ? 9 : 0);
      }
      function it(v) {
        for (var Y = v.length; 0 <= --Y; )
          v[Y] = 0;
      }
      function U(v) {
        var Y = v.state, X = Y.pending;
        X > v.avail_out && (X = v.avail_out), X !== 0 && (r.arraySet(v.output, Y.pending_buf, Y.pending_out, X, v.next_out), v.next_out += X, Y.pending_out += X, v.total_out += X, v.avail_out -= X, Y.pending -= X, Y.pending === 0 && (Y.pending_out = 0));
      }
      function R(v, Y) {
        o._tr_flush_block(v, 0 <= v.block_start ? v.block_start : -1, v.strstart - v.block_start, Y), v.block_start = v.strstart, U(v.strm);
      }
      function rt(v, Y) {
        v.pending_buf[v.pending++] = Y;
      }
      function Q(v, Y) {
        v.pending_buf[v.pending++] = Y >>> 8 & 255, v.pending_buf[v.pending++] = 255 & Y;
      }
      function J(v, Y) {
        var X, I, M = v.max_chain_length, B = v.strstart, G = v.prev_length, Z = v.nice_match, F = v.strstart > v.w_size - H ? v.strstart - (v.w_size - H) : 0, $ = v.window, nt = v.w_mask, et = v.prev, at = v.strstart + k, vt = $[B + G - 1], ft = $[B + G];
        v.prev_length >= v.good_match && (M >>= 2), Z > v.lookahead && (Z = v.lookahead);
        do
          if ($[(X = Y) + G] === ft && $[X + G - 1] === vt && $[X] === $[B] && $[++X] === $[B + 1]) {
            B += 2, X++;
            do
              ;
            while ($[++B] === $[++X] && $[++B] === $[++X] && $[++B] === $[++X] && $[++B] === $[++X] && $[++B] === $[++X] && $[++B] === $[++X] && $[++B] === $[++X] && $[++B] === $[++X] && B < at);
            if (I = k - (at - B), B = at - k, G < I) {
              if (v.match_start = Y, Z <= (G = I))
                break;
              vt = $[B + G - 1], ft = $[B + G];
            }
          }
        while ((Y = et[Y & nt]) > F && --M != 0);
        return G <= v.lookahead ? G : v.lookahead;
      }
      function pt(v) {
        var Y, X, I, M, B, G, Z, F, $, nt, et = v.w_size;
        do {
          if (M = v.window_size - v.lookahead - v.strstart, v.strstart >= et + (et - H)) {
            for (r.arraySet(v.window, v.window, et, et, 0), v.match_start -= et, v.strstart -= et, v.block_start -= et, Y = X = v.hash_size; I = v.head[--Y], v.head[Y] = et <= I ? I - et : 0, --X; )
              ;
            for (Y = X = et; I = v.prev[--Y], v.prev[Y] = et <= I ? I - et : 0, --X; )
              ;
            M += et;
          }
          if (v.strm.avail_in === 0)
            break;
          if (G = v.strm, Z = v.window, F = v.strstart + v.lookahead, $ = M, nt = void 0, nt = G.avail_in, $ < nt && (nt = $), X = nt === 0 ? 0 : (G.avail_in -= nt, r.arraySet(Z, G.input, G.next_in, nt, F), G.state.wrap === 1 ? G.adler = a(G.adler, Z, nt, F) : G.state.wrap === 2 && (G.adler = c(G.adler, Z, nt, F)), G.next_in += nt, G.total_in += nt, nt), v.lookahead += X, v.lookahead + v.insert >= z)
            for (B = v.strstart - v.insert, v.ins_h = v.window[B], v.ins_h = (v.ins_h << v.hash_shift ^ v.window[B + 1]) & v.hash_mask; v.insert && (v.ins_h = (v.ins_h << v.hash_shift ^ v.window[B + z - 1]) & v.hash_mask, v.prev[B & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = B, B++, v.insert--, !(v.lookahead + v.insert < z)); )
              ;
        } while (v.lookahead < H && v.strm.avail_in !== 0);
      }
      function gt(v, Y) {
        for (var X, I; ; ) {
          if (v.lookahead < H) {
            if (pt(v), v.lookahead < H && Y === d)
              return w;
            if (v.lookahead === 0)
              break;
          }
          if (X = 0, v.lookahead >= z && (v.ins_h = (v.ins_h << v.hash_shift ^ v.window[v.strstart + z - 1]) & v.hash_mask, X = v.prev[v.strstart & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = v.strstart), X !== 0 && v.strstart - X <= v.w_size - H && (v.match_length = J(v, X)), v.match_length >= z)
            if (I = o._tr_tally(v, v.strstart - v.match_start, v.match_length - z), v.lookahead -= v.match_length, v.match_length <= v.max_lazy_match && v.lookahead >= z) {
              for (v.match_length--; v.strstart++, v.ins_h = (v.ins_h << v.hash_shift ^ v.window[v.strstart + z - 1]) & v.hash_mask, X = v.prev[v.strstart & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = v.strstart, --v.match_length != 0; )
                ;
              v.strstart++;
            } else
              v.strstart += v.match_length, v.match_length = 0, v.ins_h = v.window[v.strstart], v.ins_h = (v.ins_h << v.hash_shift ^ v.window[v.strstart + 1]) & v.hash_mask;
          else
            I = o._tr_tally(v, 0, v.window[v.strstart]), v.lookahead--, v.strstart++;
          if (I && (R(v, false), v.strm.avail_out === 0))
            return w;
        }
        return v.insert = v.strstart < z - 1 ? v.strstart : z - 1, Y === u ? (R(v, true), v.strm.avail_out === 0 ? K : W) : v.last_lit && (R(v, false), v.strm.avail_out === 0) ? w : N;
      }
      function ht(v, Y) {
        for (var X, I, M; ; ) {
          if (v.lookahead < H) {
            if (pt(v), v.lookahead < H && Y === d)
              return w;
            if (v.lookahead === 0)
              break;
          }
          if (X = 0, v.lookahead >= z && (v.ins_h = (v.ins_h << v.hash_shift ^ v.window[v.strstart + z - 1]) & v.hash_mask, X = v.prev[v.strstart & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = v.strstart), v.prev_length = v.match_length, v.prev_match = v.match_start, v.match_length = z - 1, X !== 0 && v.prev_length < v.max_lazy_match && v.strstart - X <= v.w_size - H && (v.match_length = J(v, X), v.match_length <= 5 && (v.strategy === 1 || v.match_length === z && 4096 < v.strstart - v.match_start) && (v.match_length = z - 1)), v.prev_length >= z && v.match_length <= v.prev_length) {
            for (M = v.strstart + v.lookahead - z, I = o._tr_tally(v, v.strstart - 1 - v.prev_match, v.prev_length - z), v.lookahead -= v.prev_length - 1, v.prev_length -= 2; ++v.strstart <= M && (v.ins_h = (v.ins_h << v.hash_shift ^ v.window[v.strstart + z - 1]) & v.hash_mask, X = v.prev[v.strstart & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = v.strstart), --v.prev_length != 0; )
              ;
            if (v.match_available = 0, v.match_length = z - 1, v.strstart++, I && (R(v, false), v.strm.avail_out === 0))
              return w;
          } else if (v.match_available) {
            if ((I = o._tr_tally(v, 0, v.window[v.strstart - 1])) && R(v, false), v.strstart++, v.lookahead--, v.strm.avail_out === 0)
              return w;
          } else
            v.match_available = 1, v.strstart++, v.lookahead--;
        }
        return v.match_available && (I = o._tr_tally(v, 0, v.window[v.strstart - 1]), v.match_available = 0), v.insert = v.strstart < z - 1 ? v.strstart : z - 1, Y === u ? (R(v, true), v.strm.avail_out === 0 ? K : W) : v.last_lit && (R(v, false), v.strm.avail_out === 0) ? w : N;
      }
      function dt(v, Y, X, I, M) {
        this.good_length = v, this.max_lazy = Y, this.nice_length = X, this.max_chain = I, this.func = M;
      }
      function mt() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = y, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new r.Buf16(2 * P), this.dyn_dtree = new r.Buf16(2 * (2 * S + 1)), this.bl_tree = new r.Buf16(2 * (2 * C + 1)), it(this.dyn_ltree), it(this.dyn_dtree), it(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new r.Buf16(O + 1), this.heap = new r.Buf16(2 * x + 1), it(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new r.Buf16(2 * x + 1), it(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function yt(v) {
        var Y;
        return v && v.state ? (v.total_in = v.total_out = 0, v.data_type = p, (Y = v.state).pending = 0, Y.pending_out = 0, Y.wrap < 0 && (Y.wrap = -Y.wrap), Y.status = Y.wrap ? T : L, v.adler = Y.wrap === 2 ? 0 : 1, Y.last_flush = d, o._tr_init(Y), f) : st(v, g);
      }
      function It(v) {
        var Y = yt(v);
        return Y === f && function(X) {
          X.window_size = 2 * X.w_size, it(X.head), X.max_lazy_match = n[X.level].max_lazy, X.good_match = n[X.level].good_length, X.nice_match = n[X.level].nice_length, X.max_chain_length = n[X.level].max_chain, X.strstart = 0, X.block_start = 0, X.lookahead = 0, X.insert = 0, X.match_length = X.prev_length = z - 1, X.match_available = 0, X.ins_h = 0;
        }(v.state), Y;
      }
      function zt(v, Y, X, I, M, B) {
        if (!v)
          return g;
        var G = 1;
        if (Y === m && (Y = 6), I < 0 ? (G = 0, I = -I) : 15 < I && (G = 2, I -= 16), M < 1 || b < M || X !== y || I < 8 || 15 < I || Y < 0 || 9 < Y || B < 0 || _ < B)
          return st(v, g);
        I === 8 && (I = 9);
        var Z = new mt();
        return (v.state = Z).strm = v, Z.wrap = G, Z.gzhead = null, Z.w_bits = I, Z.w_size = 1 << Z.w_bits, Z.w_mask = Z.w_size - 1, Z.hash_bits = M + 7, Z.hash_size = 1 << Z.hash_bits, Z.hash_mask = Z.hash_size - 1, Z.hash_shift = ~~((Z.hash_bits + z - 1) / z), Z.window = new r.Buf8(2 * Z.w_size), Z.head = new r.Buf16(Z.hash_size), Z.prev = new r.Buf16(Z.w_size), Z.lit_bufsize = 1 << M + 6, Z.pending_buf_size = 4 * Z.lit_bufsize, Z.pending_buf = new r.Buf8(Z.pending_buf_size), Z.d_buf = 1 * Z.lit_bufsize, Z.l_buf = 3 * Z.lit_bufsize, Z.level = Y, Z.strategy = B, Z.method = X, It(v);
      }
      n = [new dt(0, 0, 0, 0, function(v, Y) {
        var X = 65535;
        for (X > v.pending_buf_size - 5 && (X = v.pending_buf_size - 5); ; ) {
          if (v.lookahead <= 1) {
            if (pt(v), v.lookahead === 0 && Y === d)
              return w;
            if (v.lookahead === 0)
              break;
          }
          v.strstart += v.lookahead, v.lookahead = 0;
          var I = v.block_start + X;
          if ((v.strstart === 0 || v.strstart >= I) && (v.lookahead = v.strstart - I, v.strstart = I, R(v, false), v.strm.avail_out === 0) || v.strstart - v.block_start >= v.w_size - H && (R(v, false), v.strm.avail_out === 0))
            return w;
        }
        return v.insert = 0, Y === u ? (R(v, true), v.strm.avail_out === 0 ? K : W) : (v.strstart > v.block_start && (R(v, false), v.strm.avail_out), w);
      }), new dt(4, 4, 8, 4, gt), new dt(4, 5, 16, 8, gt), new dt(4, 6, 32, 32, gt), new dt(4, 4, 16, 16, ht), new dt(8, 16, 32, 32, ht), new dt(8, 16, 128, 128, ht), new dt(8, 32, 128, 256, ht), new dt(32, 128, 258, 1024, ht), new dt(32, 258, 258, 4096, ht)], i.deflateInit = function(v, Y) {
        return zt(v, Y, y, 15, 8, 0);
      }, i.deflateInit2 = zt, i.deflateReset = It, i.deflateResetKeep = yt, i.deflateSetHeader = function(v, Y) {
        return v && v.state ? v.state.wrap !== 2 ? g : (v.state.gzhead = Y, f) : g;
      }, i.deflate = function(v, Y) {
        var X, I, M, B;
        if (!v || !v.state || 5 < Y || Y < 0)
          return v ? st(v, g) : g;
        if (I = v.state, !v.output || !v.input && v.avail_in !== 0 || I.status === 666 && Y !== u)
          return st(v, v.avail_out === 0 ? -5 : g);
        if (I.strm = v, X = I.last_flush, I.last_flush = Y, I.status === T)
          if (I.wrap === 2)
            v.adler = 0, rt(I, 31), rt(I, 139), rt(I, 8), I.gzhead ? (rt(I, (I.gzhead.text ? 1 : 0) + (I.gzhead.hcrc ? 2 : 0) + (I.gzhead.extra ? 4 : 0) + (I.gzhead.name ? 8 : 0) + (I.gzhead.comment ? 16 : 0)), rt(I, 255 & I.gzhead.time), rt(I, I.gzhead.time >> 8 & 255), rt(I, I.gzhead.time >> 16 & 255), rt(I, I.gzhead.time >> 24 & 255), rt(I, I.level === 9 ? 2 : 2 <= I.strategy || I.level < 2 ? 4 : 0), rt(I, 255 & I.gzhead.os), I.gzhead.extra && I.gzhead.extra.length && (rt(I, 255 & I.gzhead.extra.length), rt(I, I.gzhead.extra.length >> 8 & 255)), I.gzhead.hcrc && (v.adler = c(v.adler, I.pending_buf, I.pending, 0)), I.gzindex = 0, I.status = 69) : (rt(I, 0), rt(I, 0), rt(I, 0), rt(I, 0), rt(I, 0), rt(I, I.level === 9 ? 2 : 2 <= I.strategy || I.level < 2 ? 4 : 0), rt(I, 3), I.status = L);
          else {
            var G = y + (I.w_bits - 8 << 4) << 8;
            G |= (2 <= I.strategy || I.level < 2 ? 0 : I.level < 6 ? 1 : I.level === 6 ? 2 : 3) << 6, I.strstart !== 0 && (G |= 32), G += 31 - G % 31, I.status = L, Q(I, G), I.strstart !== 0 && (Q(I, v.adler >>> 16), Q(I, 65535 & v.adler)), v.adler = 1;
          }
        if (I.status === 69)
          if (I.gzhead.extra) {
            for (M = I.pending; I.gzindex < (65535 & I.gzhead.extra.length) && (I.pending !== I.pending_buf_size || (I.gzhead.hcrc && I.pending > M && (v.adler = c(v.adler, I.pending_buf, I.pending - M, M)), U(v), M = I.pending, I.pending !== I.pending_buf_size)); )
              rt(I, 255 & I.gzhead.extra[I.gzindex]), I.gzindex++;
            I.gzhead.hcrc && I.pending > M && (v.adler = c(v.adler, I.pending_buf, I.pending - M, M)), I.gzindex === I.gzhead.extra.length && (I.gzindex = 0, I.status = 73);
          } else
            I.status = 73;
        if (I.status === 73)
          if (I.gzhead.name) {
            M = I.pending;
            do {
              if (I.pending === I.pending_buf_size && (I.gzhead.hcrc && I.pending > M && (v.adler = c(v.adler, I.pending_buf, I.pending - M, M)), U(v), M = I.pending, I.pending === I.pending_buf_size)) {
                B = 1;
                break;
              }
              B = I.gzindex < I.gzhead.name.length ? 255 & I.gzhead.name.charCodeAt(I.gzindex++) : 0, rt(I, B);
            } while (B !== 0);
            I.gzhead.hcrc && I.pending > M && (v.adler = c(v.adler, I.pending_buf, I.pending - M, M)), B === 0 && (I.gzindex = 0, I.status = 91);
          } else
            I.status = 91;
        if (I.status === 91)
          if (I.gzhead.comment) {
            M = I.pending;
            do {
              if (I.pending === I.pending_buf_size && (I.gzhead.hcrc && I.pending > M && (v.adler = c(v.adler, I.pending_buf, I.pending - M, M)), U(v), M = I.pending, I.pending === I.pending_buf_size)) {
                B = 1;
                break;
              }
              B = I.gzindex < I.gzhead.comment.length ? 255 & I.gzhead.comment.charCodeAt(I.gzindex++) : 0, rt(I, B);
            } while (B !== 0);
            I.gzhead.hcrc && I.pending > M && (v.adler = c(v.adler, I.pending_buf, I.pending - M, M)), B === 0 && (I.status = 103);
          } else
            I.status = 103;
        if (I.status === 103 && (I.gzhead.hcrc ? (I.pending + 2 > I.pending_buf_size && U(v), I.pending + 2 <= I.pending_buf_size && (rt(I, 255 & v.adler), rt(I, v.adler >> 8 & 255), v.adler = 0, I.status = L)) : I.status = L), I.pending !== 0) {
          if (U(v), v.avail_out === 0)
            return I.last_flush = -1, f;
        } else if (v.avail_in === 0 && j(Y) <= j(X) && Y !== u)
          return st(v, -5);
        if (I.status === 666 && v.avail_in !== 0)
          return st(v, -5);
        if (v.avail_in !== 0 || I.lookahead !== 0 || Y !== d && I.status !== 666) {
          var Z = I.strategy === 2 ? function(F, $) {
            for (var nt; ; ) {
              if (F.lookahead === 0 && (pt(F), F.lookahead === 0)) {
                if ($ === d)
                  return w;
                break;
              }
              if (F.match_length = 0, nt = o._tr_tally(F, 0, F.window[F.strstart]), F.lookahead--, F.strstart++, nt && (R(F, false), F.strm.avail_out === 0))
                return w;
            }
            return F.insert = 0, $ === u ? (R(F, true), F.strm.avail_out === 0 ? K : W) : F.last_lit && (R(F, false), F.strm.avail_out === 0) ? w : N;
          }(I, Y) : I.strategy === 3 ? function(F, $) {
            for (var nt, et, at, vt, ft = F.window; ; ) {
              if (F.lookahead <= k) {
                if (pt(F), F.lookahead <= k && $ === d)
                  return w;
                if (F.lookahead === 0)
                  break;
              }
              if (F.match_length = 0, F.lookahead >= z && 0 < F.strstart && (et = ft[at = F.strstart - 1]) === ft[++at] && et === ft[++at] && et === ft[++at]) {
                vt = F.strstart + k;
                do
                  ;
                while (et === ft[++at] && et === ft[++at] && et === ft[++at] && et === ft[++at] && et === ft[++at] && et === ft[++at] && et === ft[++at] && et === ft[++at] && at < vt);
                F.match_length = k - (vt - at), F.match_length > F.lookahead && (F.match_length = F.lookahead);
              }
              if (F.match_length >= z ? (nt = o._tr_tally(F, 1, F.match_length - z), F.lookahead -= F.match_length, F.strstart += F.match_length, F.match_length = 0) : (nt = o._tr_tally(F, 0, F.window[F.strstart]), F.lookahead--, F.strstart++), nt && (R(F, false), F.strm.avail_out === 0))
                return w;
            }
            return F.insert = 0, $ === u ? (R(F, true), F.strm.avail_out === 0 ? K : W) : F.last_lit && (R(F, false), F.strm.avail_out === 0) ? w : N;
          }(I, Y) : n[I.level].func(I, Y);
          if (Z !== K && Z !== W || (I.status = 666), Z === w || Z === K)
            return v.avail_out === 0 && (I.last_flush = -1), f;
          if (Z === N && (Y === 1 ? o._tr_align(I) : Y !== 5 && (o._tr_stored_block(I, 0, 0, false), Y === 3 && (it(I.head), I.lookahead === 0 && (I.strstart = 0, I.block_start = 0, I.insert = 0))), U(v), v.avail_out === 0))
            return I.last_flush = -1, f;
        }
        return Y !== u ? f : I.wrap <= 0 ? 1 : (I.wrap === 2 ? (rt(I, 255 & v.adler), rt(I, v.adler >> 8 & 255), rt(I, v.adler >> 16 & 255), rt(I, v.adler >> 24 & 255), rt(I, 255 & v.total_in), rt(I, v.total_in >> 8 & 255), rt(I, v.total_in >> 16 & 255), rt(I, v.total_in >> 24 & 255)) : (Q(I, v.adler >>> 16), Q(I, 65535 & v.adler)), U(v), 0 < I.wrap && (I.wrap = -I.wrap), I.pending !== 0 ? f : 1);
      }, i.deflateEnd = function(v) {
        var Y;
        return v && v.state ? (Y = v.state.status) !== T && Y !== 69 && Y !== 73 && Y !== 91 && Y !== 103 && Y !== L && Y !== 666 ? st(v, g) : (v.state = null, Y === L ? st(v, -3) : f) : g;
      }, i.deflateSetDictionary = function(v, Y) {
        var X, I, M, B, G, Z, F, $, nt = Y.length;
        if (!v || !v.state || (B = (X = v.state).wrap) === 2 || B === 1 && X.status !== T || X.lookahead)
          return g;
        for (B === 1 && (v.adler = a(v.adler, Y, nt, 0)), X.wrap = 0, nt >= X.w_size && (B === 0 && (it(X.head), X.strstart = 0, X.block_start = 0, X.insert = 0), $ = new r.Buf8(X.w_size), r.arraySet($, Y, nt - X.w_size, X.w_size, 0), Y = $, nt = X.w_size), G = v.avail_in, Z = v.next_in, F = v.input, v.avail_in = nt, v.next_in = 0, v.input = Y, pt(X); X.lookahead >= z; ) {
          for (I = X.strstart, M = X.lookahead - (z - 1); X.ins_h = (X.ins_h << X.hash_shift ^ X.window[I + z - 1]) & X.hash_mask, X.prev[I & X.w_mask] = X.head[X.ins_h], X.head[X.ins_h] = I, I++, --M; )
            ;
          X.strstart = I, X.lookahead = z - 1, pt(X);
        }
        return X.strstart += X.lookahead, X.block_start = X.strstart, X.insert = X.lookahead, X.lookahead = 0, X.match_length = X.prev_length = z - 1, X.match_available = 0, v.next_in = Z, v.input = F, v.avail_in = G, X.wrap = B, f;
      }, i.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, s, i) {
      s.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      };
    }, {}], 48: [function(e, s, i) {
      s.exports = function(n, r) {
        var o, a, c, h, d, u, f, g, m, _, p, y, b, x, S, C, P, O, z, k, H, T, L, w, N;
        o = n.state, a = n.next_in, w = n.input, c = a + (n.avail_in - 5), h = n.next_out, N = n.output, d = h - (r - n.avail_out), u = h + (n.avail_out - 257), f = o.dmax, g = o.wsize, m = o.whave, _ = o.wnext, p = o.window, y = o.hold, b = o.bits, x = o.lencode, S = o.distcode, C = (1 << o.lenbits) - 1, P = (1 << o.distbits) - 1;
        t:
          do {
            b < 15 && (y += w[a++] << b, b += 8, y += w[a++] << b, b += 8), O = x[y & C];
            e:
              for (; ; ) {
                if (y >>>= z = O >>> 24, b -= z, (z = O >>> 16 & 255) === 0)
                  N[h++] = 65535 & O;
                else {
                  if (!(16 & z)) {
                    if (!(64 & z)) {
                      O = x[(65535 & O) + (y & (1 << z) - 1)];
                      continue e;
                    }
                    if (32 & z) {
                      o.mode = 12;
                      break t;
                    }
                    n.msg = "invalid literal/length code", o.mode = 30;
                    break t;
                  }
                  k = 65535 & O, (z &= 15) && (b < z && (y += w[a++] << b, b += 8), k += y & (1 << z) - 1, y >>>= z, b -= z), b < 15 && (y += w[a++] << b, b += 8, y += w[a++] << b, b += 8), O = S[y & P];
                  s:
                    for (; ; ) {
                      if (y >>>= z = O >>> 24, b -= z, !(16 & (z = O >>> 16 & 255))) {
                        if (!(64 & z)) {
                          O = S[(65535 & O) + (y & (1 << z) - 1)];
                          continue s;
                        }
                        n.msg = "invalid distance code", o.mode = 30;
                        break t;
                      }
                      if (H = 65535 & O, b < (z &= 15) && (y += w[a++] << b, (b += 8) < z && (y += w[a++] << b, b += 8)), f < (H += y & (1 << z) - 1)) {
                        n.msg = "invalid distance too far back", o.mode = 30;
                        break t;
                      }
                      if (y >>>= z, b -= z, (z = h - d) < H) {
                        if (m < (z = H - z) && o.sane) {
                          n.msg = "invalid distance too far back", o.mode = 30;
                          break t;
                        }
                        if (L = p, (T = 0) === _) {
                          if (T += g - z, z < k) {
                            for (k -= z; N[h++] = p[T++], --z; )
                              ;
                            T = h - H, L = N;
                          }
                        } else if (_ < z) {
                          if (T += g + _ - z, (z -= _) < k) {
                            for (k -= z; N[h++] = p[T++], --z; )
                              ;
                            if (T = 0, _ < k) {
                              for (k -= z = _; N[h++] = p[T++], --z; )
                                ;
                              T = h - H, L = N;
                            }
                          }
                        } else if (T += _ - z, z < k) {
                          for (k -= z; N[h++] = p[T++], --z; )
                            ;
                          T = h - H, L = N;
                        }
                        for (; 2 < k; )
                          N[h++] = L[T++], N[h++] = L[T++], N[h++] = L[T++], k -= 3;
                        k && (N[h++] = L[T++], 1 < k && (N[h++] = L[T++]));
                      } else {
                        for (T = h - H; N[h++] = N[T++], N[h++] = N[T++], N[h++] = N[T++], 2 < (k -= 3); )
                          ;
                        k && (N[h++] = N[T++], 1 < k && (N[h++] = N[T++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (a < c && h < u);
        a -= k = b >> 3, y &= (1 << (b -= k << 3)) - 1, n.next_in = a, n.next_out = h, n.avail_in = a < c ? c - a + 5 : 5 - (a - c), n.avail_out = h < u ? u - h + 257 : 257 - (h - u), o.hold = y, o.bits = b;
      };
    }, {}], 49: [function(e, s, i) {
      var n = e("../utils/common"), r = e("./adler32"), o = e("./crc32"), a = e("./inffast"), c = e("./inftrees"), h = 1, d = 2, u = 0, f = -2, g = 1, m = 852, _ = 592;
      function p(T) {
        return (T >>> 24 & 255) + (T >>> 8 & 65280) + ((65280 & T) << 8) + ((255 & T) << 24);
      }
      function y() {
        this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new n.Buf16(320), this.work = new n.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function b(T) {
        var L;
        return T && T.state ? (L = T.state, T.total_in = T.total_out = L.total = 0, T.msg = "", L.wrap && (T.adler = 1 & L.wrap), L.mode = g, L.last = 0, L.havedict = 0, L.dmax = 32768, L.head = null, L.hold = 0, L.bits = 0, L.lencode = L.lendyn = new n.Buf32(m), L.distcode = L.distdyn = new n.Buf32(_), L.sane = 1, L.back = -1, u) : f;
      }
      function x(T) {
        var L;
        return T && T.state ? ((L = T.state).wsize = 0, L.whave = 0, L.wnext = 0, b(T)) : f;
      }
      function S(T, L) {
        var w, N;
        return T && T.state ? (N = T.state, L < 0 ? (w = 0, L = -L) : (w = 1 + (L >> 4), L < 48 && (L &= 15)), L && (L < 8 || 15 < L) ? f : (N.window !== null && N.wbits !== L && (N.window = null), N.wrap = w, N.wbits = L, x(T))) : f;
      }
      function C(T, L) {
        var w, N;
        return T ? (N = new y(), (T.state = N).window = null, (w = S(T, L)) !== u && (T.state = null), w) : f;
      }
      var P, O, z = true;
      function k(T) {
        if (z) {
          var L;
          for (P = new n.Buf32(512), O = new n.Buf32(32), L = 0; L < 144; )
            T.lens[L++] = 8;
          for (; L < 256; )
            T.lens[L++] = 9;
          for (; L < 280; )
            T.lens[L++] = 7;
          for (; L < 288; )
            T.lens[L++] = 8;
          for (c(h, T.lens, 0, 288, P, 0, T.work, { bits: 9 }), L = 0; L < 32; )
            T.lens[L++] = 5;
          c(d, T.lens, 0, 32, O, 0, T.work, { bits: 5 }), z = false;
        }
        T.lencode = P, T.lenbits = 9, T.distcode = O, T.distbits = 5;
      }
      function H(T, L, w, N) {
        var K, W = T.state;
        return W.window === null && (W.wsize = 1 << W.wbits, W.wnext = 0, W.whave = 0, W.window = new n.Buf8(W.wsize)), N >= W.wsize ? (n.arraySet(W.window, L, w - W.wsize, W.wsize, 0), W.wnext = 0, W.whave = W.wsize) : (N < (K = W.wsize - W.wnext) && (K = N), n.arraySet(W.window, L, w - N, K, W.wnext), (N -= K) ? (n.arraySet(W.window, L, w - N, N, 0), W.wnext = N, W.whave = W.wsize) : (W.wnext += K, W.wnext === W.wsize && (W.wnext = 0), W.whave < W.wsize && (W.whave += K))), 0;
      }
      i.inflateReset = x, i.inflateReset2 = S, i.inflateResetKeep = b, i.inflateInit = function(T) {
        return C(T, 15);
      }, i.inflateInit2 = C, i.inflate = function(T, L) {
        var w, N, K, W, st, j, it, U, R, rt, Q, J, pt, gt, ht, dt, mt, yt, It, zt, v, Y, X, I, M = 0, B = new n.Buf8(4), G = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!T || !T.state || !T.output || !T.input && T.avail_in !== 0)
          return f;
        (w = T.state).mode === 12 && (w.mode = 13), st = T.next_out, K = T.output, it = T.avail_out, W = T.next_in, N = T.input, j = T.avail_in, U = w.hold, R = w.bits, rt = j, Q = it, Y = u;
        t:
          for (; ; )
            switch (w.mode) {
              case g:
                if (w.wrap === 0) {
                  w.mode = 13;
                  break;
                }
                for (; R < 16; ) {
                  if (j === 0)
                    break t;
                  j--, U += N[W++] << R, R += 8;
                }
                if (2 & w.wrap && U === 35615) {
                  B[w.check = 0] = 255 & U, B[1] = U >>> 8 & 255, w.check = o(w.check, B, 2, 0), R = U = 0, w.mode = 2;
                  break;
                }
                if (w.flags = 0, w.head && (w.head.done = false), !(1 & w.wrap) || (((255 & U) << 8) + (U >> 8)) % 31) {
                  T.msg = "incorrect header check", w.mode = 30;
                  break;
                }
                if ((15 & U) != 8) {
                  T.msg = "unknown compression method", w.mode = 30;
                  break;
                }
                if (R -= 4, v = 8 + (15 & (U >>>= 4)), w.wbits === 0)
                  w.wbits = v;
                else if (v > w.wbits) {
                  T.msg = "invalid window size", w.mode = 30;
                  break;
                }
                w.dmax = 1 << v, T.adler = w.check = 1, w.mode = 512 & U ? 10 : 12, R = U = 0;
                break;
              case 2:
                for (; R < 16; ) {
                  if (j === 0)
                    break t;
                  j--, U += N[W++] << R, R += 8;
                }
                if (w.flags = U, (255 & w.flags) != 8) {
                  T.msg = "unknown compression method", w.mode = 30;
                  break;
                }
                if (57344 & w.flags) {
                  T.msg = "unknown header flags set", w.mode = 30;
                  break;
                }
                w.head && (w.head.text = U >> 8 & 1), 512 & w.flags && (B[0] = 255 & U, B[1] = U >>> 8 & 255, w.check = o(w.check, B, 2, 0)), R = U = 0, w.mode = 3;
              case 3:
                for (; R < 32; ) {
                  if (j === 0)
                    break t;
                  j--, U += N[W++] << R, R += 8;
                }
                w.head && (w.head.time = U), 512 & w.flags && (B[0] = 255 & U, B[1] = U >>> 8 & 255, B[2] = U >>> 16 & 255, B[3] = U >>> 24 & 255, w.check = o(w.check, B, 4, 0)), R = U = 0, w.mode = 4;
              case 4:
                for (; R < 16; ) {
                  if (j === 0)
                    break t;
                  j--, U += N[W++] << R, R += 8;
                }
                w.head && (w.head.xflags = 255 & U, w.head.os = U >> 8), 512 & w.flags && (B[0] = 255 & U, B[1] = U >>> 8 & 255, w.check = o(w.check, B, 2, 0)), R = U = 0, w.mode = 5;
              case 5:
                if (1024 & w.flags) {
                  for (; R < 16; ) {
                    if (j === 0)
                      break t;
                    j--, U += N[W++] << R, R += 8;
                  }
                  w.length = U, w.head && (w.head.extra_len = U), 512 & w.flags && (B[0] = 255 & U, B[1] = U >>> 8 & 255, w.check = o(w.check, B, 2, 0)), R = U = 0;
                } else
                  w.head && (w.head.extra = null);
                w.mode = 6;
              case 6:
                if (1024 & w.flags && (j < (J = w.length) && (J = j), J && (w.head && (v = w.head.extra_len - w.length, w.head.extra || (w.head.extra = new Array(w.head.extra_len)), n.arraySet(w.head.extra, N, W, J, v)), 512 & w.flags && (w.check = o(w.check, N, J, W)), j -= J, W += J, w.length -= J), w.length))
                  break t;
                w.length = 0, w.mode = 7;
              case 7:
                if (2048 & w.flags) {
                  if (j === 0)
                    break t;
                  for (J = 0; v = N[W + J++], w.head && v && w.length < 65536 && (w.head.name += String.fromCharCode(v)), v && J < j; )
                    ;
                  if (512 & w.flags && (w.check = o(w.check, N, J, W)), j -= J, W += J, v)
                    break t;
                } else
                  w.head && (w.head.name = null);
                w.length = 0, w.mode = 8;
              case 8:
                if (4096 & w.flags) {
                  if (j === 0)
                    break t;
                  for (J = 0; v = N[W + J++], w.head && v && w.length < 65536 && (w.head.comment += String.fromCharCode(v)), v && J < j; )
                    ;
                  if (512 & w.flags && (w.check = o(w.check, N, J, W)), j -= J, W += J, v)
                    break t;
                } else
                  w.head && (w.head.comment = null);
                w.mode = 9;
              case 9:
                if (512 & w.flags) {
                  for (; R < 16; ) {
                    if (j === 0)
                      break t;
                    j--, U += N[W++] << R, R += 8;
                  }
                  if (U !== (65535 & w.check)) {
                    T.msg = "header crc mismatch", w.mode = 30;
                    break;
                  }
                  R = U = 0;
                }
                w.head && (w.head.hcrc = w.flags >> 9 & 1, w.head.done = true), T.adler = w.check = 0, w.mode = 12;
                break;
              case 10:
                for (; R < 32; ) {
                  if (j === 0)
                    break t;
                  j--, U += N[W++] << R, R += 8;
                }
                T.adler = w.check = p(U), R = U = 0, w.mode = 11;
              case 11:
                if (w.havedict === 0)
                  return T.next_out = st, T.avail_out = it, T.next_in = W, T.avail_in = j, w.hold = U, w.bits = R, 2;
                T.adler = w.check = 1, w.mode = 12;
              case 12:
                if (L === 5 || L === 6)
                  break t;
              case 13:
                if (w.last) {
                  U >>>= 7 & R, R -= 7 & R, w.mode = 27;
                  break;
                }
                for (; R < 3; ) {
                  if (j === 0)
                    break t;
                  j--, U += N[W++] << R, R += 8;
                }
                switch (w.last = 1 & U, R -= 1, 3 & (U >>>= 1)) {
                  case 0:
                    w.mode = 14;
                    break;
                  case 1:
                    if (k(w), w.mode = 20, L !== 6)
                      break;
                    U >>>= 2, R -= 2;
                    break t;
                  case 2:
                    w.mode = 17;
                    break;
                  case 3:
                    T.msg = "invalid block type", w.mode = 30;
                }
                U >>>= 2, R -= 2;
                break;
              case 14:
                for (U >>>= 7 & R, R -= 7 & R; R < 32; ) {
                  if (j === 0)
                    break t;
                  j--, U += N[W++] << R, R += 8;
                }
                if ((65535 & U) != (U >>> 16 ^ 65535)) {
                  T.msg = "invalid stored block lengths", w.mode = 30;
                  break;
                }
                if (w.length = 65535 & U, R = U = 0, w.mode = 15, L === 6)
                  break t;
              case 15:
                w.mode = 16;
              case 16:
                if (J = w.length) {
                  if (j < J && (J = j), it < J && (J = it), J === 0)
                    break t;
                  n.arraySet(K, N, W, J, st), j -= J, W += J, it -= J, st += J, w.length -= J;
                  break;
                }
                w.mode = 12;
                break;
              case 17:
                for (; R < 14; ) {
                  if (j === 0)
                    break t;
                  j--, U += N[W++] << R, R += 8;
                }
                if (w.nlen = 257 + (31 & U), U >>>= 5, R -= 5, w.ndist = 1 + (31 & U), U >>>= 5, R -= 5, w.ncode = 4 + (15 & U), U >>>= 4, R -= 4, 286 < w.nlen || 30 < w.ndist) {
                  T.msg = "too many length or distance symbols", w.mode = 30;
                  break;
                }
                w.have = 0, w.mode = 18;
              case 18:
                for (; w.have < w.ncode; ) {
                  for (; R < 3; ) {
                    if (j === 0)
                      break t;
                    j--, U += N[W++] << R, R += 8;
                  }
                  w.lens[G[w.have++]] = 7 & U, U >>>= 3, R -= 3;
                }
                for (; w.have < 19; )
                  w.lens[G[w.have++]] = 0;
                if (w.lencode = w.lendyn, w.lenbits = 7, X = { bits: w.lenbits }, Y = c(0, w.lens, 0, 19, w.lencode, 0, w.work, X), w.lenbits = X.bits, Y) {
                  T.msg = "invalid code lengths set", w.mode = 30;
                  break;
                }
                w.have = 0, w.mode = 19;
              case 19:
                for (; w.have < w.nlen + w.ndist; ) {
                  for (; dt = (M = w.lencode[U & (1 << w.lenbits) - 1]) >>> 16 & 255, mt = 65535 & M, !((ht = M >>> 24) <= R); ) {
                    if (j === 0)
                      break t;
                    j--, U += N[W++] << R, R += 8;
                  }
                  if (mt < 16)
                    U >>>= ht, R -= ht, w.lens[w.have++] = mt;
                  else {
                    if (mt === 16) {
                      for (I = ht + 2; R < I; ) {
                        if (j === 0)
                          break t;
                        j--, U += N[W++] << R, R += 8;
                      }
                      if (U >>>= ht, R -= ht, w.have === 0) {
                        T.msg = "invalid bit length repeat", w.mode = 30;
                        break;
                      }
                      v = w.lens[w.have - 1], J = 3 + (3 & U), U >>>= 2, R -= 2;
                    } else if (mt === 17) {
                      for (I = ht + 3; R < I; ) {
                        if (j === 0)
                          break t;
                        j--, U += N[W++] << R, R += 8;
                      }
                      R -= ht, v = 0, J = 3 + (7 & (U >>>= ht)), U >>>= 3, R -= 3;
                    } else {
                      for (I = ht + 7; R < I; ) {
                        if (j === 0)
                          break t;
                        j--, U += N[W++] << R, R += 8;
                      }
                      R -= ht, v = 0, J = 11 + (127 & (U >>>= ht)), U >>>= 7, R -= 7;
                    }
                    if (w.have + J > w.nlen + w.ndist) {
                      T.msg = "invalid bit length repeat", w.mode = 30;
                      break;
                    }
                    for (; J--; )
                      w.lens[w.have++] = v;
                  }
                }
                if (w.mode === 30)
                  break;
                if (w.lens[256] === 0) {
                  T.msg = "invalid code -- missing end-of-block", w.mode = 30;
                  break;
                }
                if (w.lenbits = 9, X = { bits: w.lenbits }, Y = c(h, w.lens, 0, w.nlen, w.lencode, 0, w.work, X), w.lenbits = X.bits, Y) {
                  T.msg = "invalid literal/lengths set", w.mode = 30;
                  break;
                }
                if (w.distbits = 6, w.distcode = w.distdyn, X = { bits: w.distbits }, Y = c(d, w.lens, w.nlen, w.ndist, w.distcode, 0, w.work, X), w.distbits = X.bits, Y) {
                  T.msg = "invalid distances set", w.mode = 30;
                  break;
                }
                if (w.mode = 20, L === 6)
                  break t;
              case 20:
                w.mode = 21;
              case 21:
                if (6 <= j && 258 <= it) {
                  T.next_out = st, T.avail_out = it, T.next_in = W, T.avail_in = j, w.hold = U, w.bits = R, a(T, Q), st = T.next_out, K = T.output, it = T.avail_out, W = T.next_in, N = T.input, j = T.avail_in, U = w.hold, R = w.bits, w.mode === 12 && (w.back = -1);
                  break;
                }
                for (w.back = 0; dt = (M = w.lencode[U & (1 << w.lenbits) - 1]) >>> 16 & 255, mt = 65535 & M, !((ht = M >>> 24) <= R); ) {
                  if (j === 0)
                    break t;
                  j--, U += N[W++] << R, R += 8;
                }
                if (dt && !(240 & dt)) {
                  for (yt = ht, It = dt, zt = mt; dt = (M = w.lencode[zt + ((U & (1 << yt + It) - 1) >> yt)]) >>> 16 & 255, mt = 65535 & M, !(yt + (ht = M >>> 24) <= R); ) {
                    if (j === 0)
                      break t;
                    j--, U += N[W++] << R, R += 8;
                  }
                  U >>>= yt, R -= yt, w.back += yt;
                }
                if (U >>>= ht, R -= ht, w.back += ht, w.length = mt, dt === 0) {
                  w.mode = 26;
                  break;
                }
                if (32 & dt) {
                  w.back = -1, w.mode = 12;
                  break;
                }
                if (64 & dt) {
                  T.msg = "invalid literal/length code", w.mode = 30;
                  break;
                }
                w.extra = 15 & dt, w.mode = 22;
              case 22:
                if (w.extra) {
                  for (I = w.extra; R < I; ) {
                    if (j === 0)
                      break t;
                    j--, U += N[W++] << R, R += 8;
                  }
                  w.length += U & (1 << w.extra) - 1, U >>>= w.extra, R -= w.extra, w.back += w.extra;
                }
                w.was = w.length, w.mode = 23;
              case 23:
                for (; dt = (M = w.distcode[U & (1 << w.distbits) - 1]) >>> 16 & 255, mt = 65535 & M, !((ht = M >>> 24) <= R); ) {
                  if (j === 0)
                    break t;
                  j--, U += N[W++] << R, R += 8;
                }
                if (!(240 & dt)) {
                  for (yt = ht, It = dt, zt = mt; dt = (M = w.distcode[zt + ((U & (1 << yt + It) - 1) >> yt)]) >>> 16 & 255, mt = 65535 & M, !(yt + (ht = M >>> 24) <= R); ) {
                    if (j === 0)
                      break t;
                    j--, U += N[W++] << R, R += 8;
                  }
                  U >>>= yt, R -= yt, w.back += yt;
                }
                if (U >>>= ht, R -= ht, w.back += ht, 64 & dt) {
                  T.msg = "invalid distance code", w.mode = 30;
                  break;
                }
                w.offset = mt, w.extra = 15 & dt, w.mode = 24;
              case 24:
                if (w.extra) {
                  for (I = w.extra; R < I; ) {
                    if (j === 0)
                      break t;
                    j--, U += N[W++] << R, R += 8;
                  }
                  w.offset += U & (1 << w.extra) - 1, U >>>= w.extra, R -= w.extra, w.back += w.extra;
                }
                if (w.offset > w.dmax) {
                  T.msg = "invalid distance too far back", w.mode = 30;
                  break;
                }
                w.mode = 25;
              case 25:
                if (it === 0)
                  break t;
                if (J = Q - it, w.offset > J) {
                  if ((J = w.offset - J) > w.whave && w.sane) {
                    T.msg = "invalid distance too far back", w.mode = 30;
                    break;
                  }
                  pt = J > w.wnext ? (J -= w.wnext, w.wsize - J) : w.wnext - J, J > w.length && (J = w.length), gt = w.window;
                } else
                  gt = K, pt = st - w.offset, J = w.length;
                for (it < J && (J = it), it -= J, w.length -= J; K[st++] = gt[pt++], --J; )
                  ;
                w.length === 0 && (w.mode = 21);
                break;
              case 26:
                if (it === 0)
                  break t;
                K[st++] = w.length, it--, w.mode = 21;
                break;
              case 27:
                if (w.wrap) {
                  for (; R < 32; ) {
                    if (j === 0)
                      break t;
                    j--, U |= N[W++] << R, R += 8;
                  }
                  if (Q -= it, T.total_out += Q, w.total += Q, Q && (T.adler = w.check = w.flags ? o(w.check, K, Q, st - Q) : r(w.check, K, Q, st - Q)), Q = it, (w.flags ? U : p(U)) !== w.check) {
                    T.msg = "incorrect data check", w.mode = 30;
                    break;
                  }
                  R = U = 0;
                }
                w.mode = 28;
              case 28:
                if (w.wrap && w.flags) {
                  for (; R < 32; ) {
                    if (j === 0)
                      break t;
                    j--, U += N[W++] << R, R += 8;
                  }
                  if (U !== (4294967295 & w.total)) {
                    T.msg = "incorrect length check", w.mode = 30;
                    break;
                  }
                  R = U = 0;
                }
                w.mode = 29;
              case 29:
                Y = 1;
                break t;
              case 30:
                Y = -3;
                break t;
              case 31:
                return -4;
              case 32:
              default:
                return f;
            }
        return T.next_out = st, T.avail_out = it, T.next_in = W, T.avail_in = j, w.hold = U, w.bits = R, (w.wsize || Q !== T.avail_out && w.mode < 30 && (w.mode < 27 || L !== 4)) && H(T, T.output, T.next_out, Q - T.avail_out) ? (w.mode = 31, -4) : (rt -= T.avail_in, Q -= T.avail_out, T.total_in += rt, T.total_out += Q, w.total += Q, w.wrap && Q && (T.adler = w.check = w.flags ? o(w.check, K, Q, T.next_out - Q) : r(w.check, K, Q, T.next_out - Q)), T.data_type = w.bits + (w.last ? 64 : 0) + (w.mode === 12 ? 128 : 0) + (w.mode === 20 || w.mode === 15 ? 256 : 0), (rt == 0 && Q === 0 || L === 4) && Y === u && (Y = -5), Y);
      }, i.inflateEnd = function(T) {
        if (!T || !T.state)
          return f;
        var L = T.state;
        return L.window && (L.window = null), T.state = null, u;
      }, i.inflateGetHeader = function(T, L) {
        var w;
        return T && T.state && 2 & (w = T.state).wrap ? ((w.head = L).done = false, u) : f;
      }, i.inflateSetDictionary = function(T, L) {
        var w, N = L.length;
        return T && T.state ? (w = T.state).wrap !== 0 && w.mode !== 11 ? f : w.mode === 11 && r(1, L, N, 0) !== w.check ? -3 : H(T, L, N, N) ? (w.mode = 31, -4) : (w.havedict = 1, u) : f;
      }, i.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, s, i) {
      var n = e("../utils/common"), r = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], o = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], a = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], c = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      s.exports = function(h, d, u, f, g, m, _, p) {
        var y, b, x, S, C, P, O, z, k, H = p.bits, T = 0, L = 0, w = 0, N = 0, K = 0, W = 0, st = 0, j = 0, it = 0, U = 0, R = null, rt = 0, Q = new n.Buf16(16), J = new n.Buf16(16), pt = null, gt = 0;
        for (T = 0; T <= 15; T++)
          Q[T] = 0;
        for (L = 0; L < f; L++)
          Q[d[u + L]]++;
        for (K = H, N = 15; 1 <= N && Q[N] === 0; N--)
          ;
        if (N < K && (K = N), N === 0)
          return g[m++] = 20971520, g[m++] = 20971520, p.bits = 1, 0;
        for (w = 1; w < N && Q[w] === 0; w++)
          ;
        for (K < w && (K = w), T = j = 1; T <= 15; T++)
          if (j <<= 1, (j -= Q[T]) < 0)
            return -1;
        if (0 < j && (h === 0 || N !== 1))
          return -1;
        for (J[1] = 0, T = 1; T < 15; T++)
          J[T + 1] = J[T] + Q[T];
        for (L = 0; L < f; L++)
          d[u + L] !== 0 && (_[J[d[u + L]]++] = L);
        if (P = h === 0 ? (R = pt = _, 19) : h === 1 ? (R = r, rt -= 257, pt = o, gt -= 257, 256) : (R = a, pt = c, -1), T = w, C = m, st = L = U = 0, x = -1, S = (it = 1 << (W = K)) - 1, h === 1 && 852 < it || h === 2 && 592 < it)
          return 1;
        for (; ; ) {
          for (O = T - st, k = _[L] < P ? (z = 0, _[L]) : _[L] > P ? (z = pt[gt + _[L]], R[rt + _[L]]) : (z = 96, 0), y = 1 << T - st, w = b = 1 << W; g[C + (U >> st) + (b -= y)] = O << 24 | z << 16 | k | 0, b !== 0; )
            ;
          for (y = 1 << T - 1; U & y; )
            y >>= 1;
          if (y !== 0 ? (U &= y - 1, U += y) : U = 0, L++, --Q[T] == 0) {
            if (T === N)
              break;
            T = d[u + _[L]];
          }
          if (K < T && (U & S) !== x) {
            for (st === 0 && (st = K), C += w, j = 1 << (W = T - st); W + st < N && !((j -= Q[W + st]) <= 0); )
              W++, j <<= 1;
            if (it += 1 << W, h === 1 && 852 < it || h === 2 && 592 < it)
              return 1;
            g[x = U & S] = K << 24 | W << 16 | C - m | 0;
          }
        }
        return U !== 0 && (g[C + U] = T - st << 24 | 64 << 16 | 0), p.bits = K, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(e, s, i) {
      s.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(e, s, i) {
      var n = e("../utils/common"), r = 0, o = 1;
      function a(M) {
        for (var B = M.length; 0 <= --B; )
          M[B] = 0;
      }
      var c = 0, h = 29, d = 256, u = d + 1 + h, f = 30, g = 19, m = 2 * u + 1, _ = 15, p = 16, y = 7, b = 256, x = 16, S = 17, C = 18, P = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], O = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], z = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], k = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], H = new Array(2 * (u + 2));
      a(H);
      var T = new Array(2 * f);
      a(T);
      var L = new Array(512);
      a(L);
      var w = new Array(256);
      a(w);
      var N = new Array(h);
      a(N);
      var K, W, st, j = new Array(f);
      function it(M, B, G, Z, F) {
        this.static_tree = M, this.extra_bits = B, this.extra_base = G, this.elems = Z, this.max_length = F, this.has_stree = M && M.length;
      }
      function U(M, B) {
        this.dyn_tree = M, this.max_code = 0, this.stat_desc = B;
      }
      function R(M) {
        return M < 256 ? L[M] : L[256 + (M >>> 7)];
      }
      function rt(M, B) {
        M.pending_buf[M.pending++] = 255 & B, M.pending_buf[M.pending++] = B >>> 8 & 255;
      }
      function Q(M, B, G) {
        M.bi_valid > p - G ? (M.bi_buf |= B << M.bi_valid & 65535, rt(M, M.bi_buf), M.bi_buf = B >> p - M.bi_valid, M.bi_valid += G - p) : (M.bi_buf |= B << M.bi_valid & 65535, M.bi_valid += G);
      }
      function J(M, B, G) {
        Q(M, G[2 * B], G[2 * B + 1]);
      }
      function pt(M, B) {
        for (var G = 0; G |= 1 & M, M >>>= 1, G <<= 1, 0 < --B; )
          ;
        return G >>> 1;
      }
      function gt(M, B, G) {
        var Z, F, $ = new Array(_ + 1), nt = 0;
        for (Z = 1; Z <= _; Z++)
          $[Z] = nt = nt + G[Z - 1] << 1;
        for (F = 0; F <= B; F++) {
          var et = M[2 * F + 1];
          et !== 0 && (M[2 * F] = pt($[et]++, et));
        }
      }
      function ht(M) {
        var B;
        for (B = 0; B < u; B++)
          M.dyn_ltree[2 * B] = 0;
        for (B = 0; B < f; B++)
          M.dyn_dtree[2 * B] = 0;
        for (B = 0; B < g; B++)
          M.bl_tree[2 * B] = 0;
        M.dyn_ltree[2 * b] = 1, M.opt_len = M.static_len = 0, M.last_lit = M.matches = 0;
      }
      function dt(M) {
        8 < M.bi_valid ? rt(M, M.bi_buf) : 0 < M.bi_valid && (M.pending_buf[M.pending++] = M.bi_buf), M.bi_buf = 0, M.bi_valid = 0;
      }
      function mt(M, B, G, Z) {
        var F = 2 * B, $ = 2 * G;
        return M[F] < M[$] || M[F] === M[$] && Z[B] <= Z[G];
      }
      function yt(M, B, G) {
        for (var Z = M.heap[G], F = G << 1; F <= M.heap_len && (F < M.heap_len && mt(B, M.heap[F + 1], M.heap[F], M.depth) && F++, !mt(B, Z, M.heap[F], M.depth)); )
          M.heap[G] = M.heap[F], G = F, F <<= 1;
        M.heap[G] = Z;
      }
      function It(M, B, G) {
        var Z, F, $, nt, et = 0;
        if (M.last_lit !== 0)
          for (; Z = M.pending_buf[M.d_buf + 2 * et] << 8 | M.pending_buf[M.d_buf + 2 * et + 1], F = M.pending_buf[M.l_buf + et], et++, Z === 0 ? J(M, F, B) : (J(M, ($ = w[F]) + d + 1, B), (nt = P[$]) !== 0 && Q(M, F -= N[$], nt), J(M, $ = R(--Z), G), (nt = O[$]) !== 0 && Q(M, Z -= j[$], nt)), et < M.last_lit; )
            ;
        J(M, b, B);
      }
      function zt(M, B) {
        var G, Z, F, $ = B.dyn_tree, nt = B.stat_desc.static_tree, et = B.stat_desc.has_stree, at = B.stat_desc.elems, vt = -1;
        for (M.heap_len = 0, M.heap_max = m, G = 0; G < at; G++)
          $[2 * G] !== 0 ? (M.heap[++M.heap_len] = vt = G, M.depth[G] = 0) : $[2 * G + 1] = 0;
        for (; M.heap_len < 2; )
          $[2 * (F = M.heap[++M.heap_len] = vt < 2 ? ++vt : 0)] = 1, M.depth[F] = 0, M.opt_len--, et && (M.static_len -= nt[2 * F + 1]);
        for (B.max_code = vt, G = M.heap_len >> 1; 1 <= G; G--)
          yt(M, $, G);
        for (F = at; G = M.heap[1], M.heap[1] = M.heap[M.heap_len--], yt(M, $, 1), Z = M.heap[1], M.heap[--M.heap_max] = G, M.heap[--M.heap_max] = Z, $[2 * F] = $[2 * G] + $[2 * Z], M.depth[F] = (M.depth[G] >= M.depth[Z] ? M.depth[G] : M.depth[Z]) + 1, $[2 * G + 1] = $[2 * Z + 1] = F, M.heap[1] = F++, yt(M, $, 1), 2 <= M.heap_len; )
          ;
        M.heap[--M.heap_max] = M.heap[1], function(ft, Nt) {
          var ce, Ht, Ze, At, rs, Ps, he = Nt.dyn_tree, ze2 = Nt.max_code, qe = Nt.stat_desc.static_tree, Qe = Nt.stat_desc.has_stree, Ke = Nt.stat_desc.extra_bits, Le = Nt.stat_desc.extra_base, Ms = Nt.stat_desc.max_length, oi = 0;
          for (At = 0; At <= _; At++)
            ft.bl_count[At] = 0;
          for (he[2 * ft.heap[ft.heap_max] + 1] = 0, ce = ft.heap_max + 1; ce < m; ce++)
            Ms < (At = he[2 * he[2 * (Ht = ft.heap[ce]) + 1] + 1] + 1) && (At = Ms, oi++), he[2 * Ht + 1] = At, ze2 < Ht || (ft.bl_count[At]++, rs = 0, Le <= Ht && (rs = Ke[Ht - Le]), Ps = he[2 * Ht], ft.opt_len += Ps * (At + rs), Qe && (ft.static_len += Ps * (qe[2 * Ht + 1] + rs)));
          if (oi !== 0) {
            do {
              for (At = Ms - 1; ft.bl_count[At] === 0; )
                At--;
              ft.bl_count[At]--, ft.bl_count[At + 1] += 2, ft.bl_count[Ms]--, oi -= 2;
            } while (0 < oi);
            for (At = Ms; At !== 0; At--)
              for (Ht = ft.bl_count[At]; Ht !== 0; )
                ze2 < (Ze = ft.heap[--ce]) || (he[2 * Ze + 1] !== At && (ft.opt_len += (At - he[2 * Ze + 1]) * he[2 * Ze], he[2 * Ze + 1] = At), Ht--);
          }
        }(M, B), gt($, vt, M.bl_count);
      }
      function v(M, B, G) {
        var Z, F, $ = -1, nt = B[1], et = 0, at = 7, vt = 4;
        for (nt === 0 && (at = 138, vt = 3), B[2 * (G + 1) + 1] = 65535, Z = 0; Z <= G; Z++)
          F = nt, nt = B[2 * (Z + 1) + 1], ++et < at && F === nt || (et < vt ? M.bl_tree[2 * F] += et : F !== 0 ? (F !== $ && M.bl_tree[2 * F]++, M.bl_tree[2 * x]++) : et <= 10 ? M.bl_tree[2 * S]++ : M.bl_tree[2 * C]++, $ = F, vt = (et = 0) === nt ? (at = 138, 3) : F === nt ? (at = 6, 3) : (at = 7, 4));
      }
      function Y(M, B, G) {
        var Z, F, $ = -1, nt = B[1], et = 0, at = 7, vt = 4;
        for (nt === 0 && (at = 138, vt = 3), Z = 0; Z <= G; Z++)
          if (F = nt, nt = B[2 * (Z + 1) + 1], !(++et < at && F === nt)) {
            if (et < vt)
              for (; J(M, F, M.bl_tree), --et != 0; )
                ;
            else
              F !== 0 ? (F !== $ && (J(M, F, M.bl_tree), et--), J(M, x, M.bl_tree), Q(M, et - 3, 2)) : et <= 10 ? (J(M, S, M.bl_tree), Q(M, et - 3, 3)) : (J(M, C, M.bl_tree), Q(M, et - 11, 7));
            $ = F, vt = (et = 0) === nt ? (at = 138, 3) : F === nt ? (at = 6, 3) : (at = 7, 4);
          }
      }
      a(j);
      var X = false;
      function I(M, B, G, Z) {
        Q(M, (c << 1) + (Z ? 1 : 0), 3), function(F, $, nt, et) {
          dt(F), rt(F, nt), rt(F, ~nt), n.arraySet(F.pending_buf, F.window, $, nt, F.pending), F.pending += nt;
        }(M, B, G);
      }
      i._tr_init = function(M) {
        X || (function() {
          var B, G, Z, F, $, nt = new Array(_ + 1);
          for (F = Z = 0; F < h - 1; F++)
            for (N[F] = Z, B = 0; B < 1 << P[F]; B++)
              w[Z++] = F;
          for (w[Z - 1] = F, F = $ = 0; F < 16; F++)
            for (j[F] = $, B = 0; B < 1 << O[F]; B++)
              L[$++] = F;
          for ($ >>= 7; F < f; F++)
            for (j[F] = $ << 7, B = 0; B < 1 << O[F] - 7; B++)
              L[256 + $++] = F;
          for (G = 0; G <= _; G++)
            nt[G] = 0;
          for (B = 0; B <= 143; )
            H[2 * B + 1] = 8, B++, nt[8]++;
          for (; B <= 255; )
            H[2 * B + 1] = 9, B++, nt[9]++;
          for (; B <= 279; )
            H[2 * B + 1] = 7, B++, nt[7]++;
          for (; B <= 287; )
            H[2 * B + 1] = 8, B++, nt[8]++;
          for (gt(H, u + 1, nt), B = 0; B < f; B++)
            T[2 * B + 1] = 5, T[2 * B] = pt(B, 5);
          K = new it(H, P, d + 1, u, _), W = new it(T, O, 0, f, _), st = new it(new Array(0), z, 0, g, y);
        }(), X = true), M.l_desc = new U(M.dyn_ltree, K), M.d_desc = new U(M.dyn_dtree, W), M.bl_desc = new U(M.bl_tree, st), M.bi_buf = 0, M.bi_valid = 0, ht(M);
      }, i._tr_stored_block = I, i._tr_flush_block = function(M, B, G, Z) {
        var F, $, nt = 0;
        0 < M.level ? (M.strm.data_type === 2 && (M.strm.data_type = function(et) {
          var at, vt = 4093624447;
          for (at = 0; at <= 31; at++, vt >>>= 1)
            if (1 & vt && et.dyn_ltree[2 * at] !== 0)
              return r;
          if (et.dyn_ltree[18] !== 0 || et.dyn_ltree[20] !== 0 || et.dyn_ltree[26] !== 0)
            return o;
          for (at = 32; at < d; at++)
            if (et.dyn_ltree[2 * at] !== 0)
              return o;
          return r;
        }(M)), zt(M, M.l_desc), zt(M, M.d_desc), nt = function(et) {
          var at;
          for (v(et, et.dyn_ltree, et.l_desc.max_code), v(et, et.dyn_dtree, et.d_desc.max_code), zt(et, et.bl_desc), at = g - 1; 3 <= at && et.bl_tree[2 * k[at] + 1] === 0; at--)
            ;
          return et.opt_len += 3 * (at + 1) + 5 + 5 + 4, at;
        }(M), F = M.opt_len + 3 + 7 >>> 3, ($ = M.static_len + 3 + 7 >>> 3) <= F && (F = $)) : F = $ = G + 5, G + 4 <= F && B !== -1 ? I(M, B, G, Z) : M.strategy === 4 || $ === F ? (Q(M, 2 + (Z ? 1 : 0), 3), It(M, H, T)) : (Q(M, 4 + (Z ? 1 : 0), 3), function(et, at, vt, ft) {
          var Nt;
          for (Q(et, at - 257, 5), Q(et, vt - 1, 5), Q(et, ft - 4, 4), Nt = 0; Nt < ft; Nt++)
            Q(et, et.bl_tree[2 * k[Nt] + 1], 3);
          Y(et, et.dyn_ltree, at - 1), Y(et, et.dyn_dtree, vt - 1);
        }(M, M.l_desc.max_code + 1, M.d_desc.max_code + 1, nt + 1), It(M, M.dyn_ltree, M.dyn_dtree)), ht(M), Z && dt(M);
      }, i._tr_tally = function(M, B, G) {
        return M.pending_buf[M.d_buf + 2 * M.last_lit] = B >>> 8 & 255, M.pending_buf[M.d_buf + 2 * M.last_lit + 1] = 255 & B, M.pending_buf[M.l_buf + M.last_lit] = 255 & G, M.last_lit++, B === 0 ? M.dyn_ltree[2 * G]++ : (M.matches++, B--, M.dyn_ltree[2 * (w[G] + d + 1)]++, M.dyn_dtree[2 * R(B)]++), M.last_lit === M.lit_bufsize - 1;
      }, i._tr_align = function(M) {
        Q(M, 2, 3), J(M, b, H), function(B) {
          B.bi_valid === 16 ? (rt(B, B.bi_buf), B.bi_buf = 0, B.bi_valid = 0) : 8 <= B.bi_valid && (B.pending_buf[B.pending++] = 255 & B.bi_buf, B.bi_buf >>= 8, B.bi_valid -= 8);
        }(M);
      };
    }, { "../utils/common": 41 }], 53: [function(e, s, i) {
      s.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(e, s, i) {
      (function(n) {
        (function(r, o) {
          if (!r.setImmediate) {
            var a, c, h, d, u = 1, f = {}, g = false, m = r.document, _ = Object.getPrototypeOf && Object.getPrototypeOf(r);
            _ = _ && _.setTimeout ? _ : r, a = {}.toString.call(r.process) === "[object process]" ? function(x) {
              process.nextTick(function() {
                y(x);
              });
            } : function() {
              if (r.postMessage && !r.importScripts) {
                var x = true, S = r.onmessage;
                return r.onmessage = function() {
                  x = false;
                }, r.postMessage("", "*"), r.onmessage = S, x;
              }
            }() ? (d = "setImmediate$" + Math.random() + "$", r.addEventListener ? r.addEventListener("message", b, false) : r.attachEvent("onmessage", b), function(x) {
              r.postMessage(d + x, "*");
            }) : r.MessageChannel ? ((h = new MessageChannel()).port1.onmessage = function(x) {
              y(x.data);
            }, function(x) {
              h.port2.postMessage(x);
            }) : m && "onreadystatechange" in m.createElement("script") ? (c = m.documentElement, function(x) {
              var S = m.createElement("script");
              S.onreadystatechange = function() {
                y(x), S.onreadystatechange = null, c.removeChild(S), S = null;
              }, c.appendChild(S);
            }) : function(x) {
              setTimeout(y, 0, x);
            }, _.setImmediate = function(x) {
              typeof x != "function" && (x = new Function("" + x));
              for (var S = new Array(arguments.length - 1), C = 0; C < S.length; C++)
                S[C] = arguments[C + 1];
              var P = { callback: x, args: S };
              return f[u] = P, a(u), u++;
            }, _.clearImmediate = p;
          }
          function p(x) {
            delete f[x];
          }
          function y(x) {
            if (g)
              setTimeout(y, 0, x);
            else {
              var S = f[x];
              if (S) {
                g = true;
                try {
                  (function(C) {
                    var P = C.callback, O = C.args;
                    switch (O.length) {
                      case 0:
                        P();
                        break;
                      case 1:
                        P(O[0]);
                        break;
                      case 2:
                        P(O[0], O[1]);
                        break;
                      case 3:
                        P(O[0], O[1], O[2]);
                        break;
                      default:
                        P.apply(o, O);
                    }
                  })(S);
                } finally {
                  p(x), g = false;
                }
              }
            }
          }
          function b(x) {
            x.source === r && typeof x.data == "string" && x.data.indexOf(d) === 0 && y(+x.data.slice(d.length));
          }
        })(typeof self > "u" ? n === void 0 ? this : n : self);
      }).call(this, typeof hi < "u" ? hi : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(Oa);
var pd = Oa.exports;
var lo = Pl(pd);
var or = class {
  /**
   * Constructs a new BCF Topic Comment instance.
   * @param components - The Components instance.
   * @param text - The initial comment text.
   */
  constructor(t, e) {
    E(this, "date", /* @__PURE__ */ new Date()), E(this, "author"), E(this, "guid", Xt.create()), E(this, "viewpoint"), E(this, "modifiedAuthor"), E(this, "modifiedDate"), E(this, "topic"), E(this, "_components"), E(this, "_comment", ""), this._components = t, this._comment = e;
    const s = this._components.get(Bt);
    this.author = s.config.author;
  }
  /**
   * Sets the comment text and updates the modified date and author.
   * The author will be the one defined in BCFTopics.config.author
   * @param value - The new comment text.
   */
  set comment(t) {
    var e;
    const s = this._components.get(Bt);
    this._comment = t, this.modifiedDate = /* @__PURE__ */ new Date(), this.modifiedAuthor = s.config.author, (e = this.topic) == null || e.comments.set(this.guid, this);
  }
  /**
   * Gets the comment text.
   * @returns The comment text.
   */
  get comment() {
    return this._comment;
  }
  toJSON() {
    var t, e;
    const s = {
      guid: this.guid,
      date: this.date.toISOString(),
      author: this.author,
      comment: this.comment,
      topic_guid: (t = this.topic) == null ? void 0 : t.guid,
      viewpoint_guid: this.viewpoint,
      modified_date: (e = this.modifiedDate) == null ? void 0 : e.toISOString(),
      modified_author: this.modifiedAuthor
    };
    for (const [i, n] of Object.entries(s))
      n === void 0 && delete s[i];
    return s;
  }
};
var Da = class Ue {
  /**
   * Initializes a new instance of the `Topic` class representing a BCF (BIM Collaboration Format) topic.
   * It provides methods and properties to manage and serialize BCF topics.
   *
   * @remarks
   * The default creationUser is the one set in BCFTopics.config.author
   * It should not be created manually. Better use BCFTopics.create().
   *
   * @param components - The `Components` instance that provides access to other components and services.
   */
  constructor(t) {
    E(this, "guid", Xt.create()), E(this, "title", Ue.default.title), E(this, "creationDate", /* @__PURE__ */ new Date()), E(this, "creationAuthor", ""), E(this, "viewpoints", new _n()), E(this, "relatedTopics", new _n()), E(this, "comments", new Es()), E(this, "documentReferences", new _n()), E(this, "customData", {}), E(this, "description"), E(this, "serverAssignedId"), E(this, "dueDate"), E(this, "modifiedAuthor"), E(this, "modifiedDate"), E(this, "index"), E(this, "_type", Ue.default.type), E(this, "_status", Ue.default.status), E(this, "_priority", Ue.default.priority), E(this, "_stage", Ue.default.stage), E(this, "_assignedTo", Ue.default.assignedTo), E(this, "_labels", Ue.default.labels ?? /* @__PURE__ */ new Set()), E(this, "_components"), this._components = t;
    const e = t.get(Bt);
    this.creationAuthor = e.config.author, this.relatedTopics.guard = (s) => s !== this.guid;
  }
  set type(t) {
    const e = this._components.get(Bt), { strict: s, types: i } = e.config;
    (!s || i.has(t)) && (this._type = t);
  }
  get type() {
    return this._type;
  }
  set status(t) {
    const e = this._components.get(Bt), { strict: s, statuses: i } = e.config;
    (!s || i.has(t)) && (this._status = t);
  }
  get status() {
    return this._status;
  }
  set priority(t) {
    const e = this._components.get(Bt);
    if (t) {
      const { strict: s, priorities: i } = e.config;
      if (!(s ? i.has(t) : true))
        return;
      this._priority = t;
    } else
      this._priority = t;
  }
  get priority() {
    return this._priority;
  }
  set stage(t) {
    const e = this._components.get(Bt);
    if (t) {
      const { strict: s, stages: i } = e.config;
      if (!(s ? i.has(t) : true))
        return;
      this._stage = t;
    } else
      this._stage = t;
  }
  get stage() {
    return this._stage;
  }
  set assignedTo(t) {
    const e = this._components.get(Bt);
    if (t) {
      const { strict: s, users: i } = e.config;
      if (!(s ? i.has(t) : true))
        return;
      this._assignedTo = t;
    } else
      this._assignedTo = t;
  }
  get assignedTo() {
    return this._assignedTo;
  }
  set labels(t) {
    const e = this._components.get(Bt), { strict: s, labels: i } = e.config;
    if (s) {
      const n = /* @__PURE__ */ new Set();
      for (const r of t)
        (!s || i.has(r)) && n.add(r);
      this._labels = n;
    } else
      this._labels = t;
  }
  get labels() {
    return this._labels;
  }
  get _managerVersion() {
    return this._components.get(Bt).config.version;
  }
  /**
   * Sets properties of the BCF Topic based on the provided data.
   *
   * @remarks
   * This method iterates over the provided `data` object and updates the corresponding properties of the BCF Topic.
   * It skips the `guid` property as it should not be modified.
   *
   * @param data - An object containing the properties to be updated.
   * @returns The topic
   *
   * @example
   * ```typescript
   * const topic = new Topic(components);
   * topic.set({
   *   title: "New BCF Topic Title",
   *   description: "This is a new description.",
   *   status: "Resolved",
   * });
   * ```
   */
  set(t) {
    const e = t, s = this;
    for (const n in t) {
      if (n === "guid")
        continue;
      const r = e[n];
      n in this && (s[n] = r);
    }
    return this._components.get(Bt).list.set(this.guid, this), this;
  }
  /**
   * Creates a new comment associated with the current topic.
   *
   * @param text - The text content of the comment.
   * @param viewpoint - (Optional) The viewpoint associated with the comment.
   *
   * @returns The newly created comment.
   *
   * @example
   * ```typescript
   * const viewpoint = viewpoints.create(world); // Created with an instance of Viewpoints
   * const topic = topics.create(); // Created with an instance of BCFTopics
   * topic.viewpoints.add(viewpoint);
   * const comment = topic.createComment("This is a new comment", viewpoint);
   * ```
   */
  createComment(t, e) {
    const s = new or(this._components, t);
    return s.viewpoint = e, s.topic = this, this.comments.set(s.guid, s), s;
  }
  createLabelTags() {
    const t = [...this.labels];
    if (this._components.get(Bt).config.exportCustomDataAsLabels)
      for (const s in this.customData) {
        const i = this.customData[s];
        typeof i == "string" && t.push(i);
      }
    return t;
  }
  createCommentTags() {
    return [...this.comments.values()].map((t) => {
      var e;
      return {
        $Guid: t.guid,
        Date: t.date.toISOString(),
        Author: t.author,
        Comment: t.comment,
        ModifiedAuthor: t.modifiedAuthor,
        ModifiedDate: (e = t.modifiedDate) == null ? void 0 : e.toISOString(),
        Viewpoint: t.viewpoint ? { $Guid: t.viewpoint } : void 0
      };
    });
  }
  createViewpointTags() {
    const t = this._components.get(Oe);
    return [...this.viewpoints].map((s) => t.list.get(s)).filter((s) => s).map((s) => {
      const i = {
        $Guid: s.guid,
        Viewpoint: `${s.title ?? s.guid}.bcfv`
      };
      if (t.snapshots.get(s.snapshot)) {
        const r = t.getSnapshotExtension(
          s.snapshot
        );
        i.Snapshot = `${s.snapshot}.${r}`;
      }
      return i;
    });
  }
  createRelatedTopicTags() {
    return [...this.relatedTopics].map((t) => ({ $Guid: t }));
  }
  createDocumentReferencesTag(t = this._managerVersion) {
    const e = [];
    if (!(t === "3" || t === "2.1"))
      return e;
    const s = this._components.get(Bt);
    for (const i of this.documentReferences) {
      const n = s.documents.get(i);
      if (!n)
        continue;
      let r = {
        $Guid: Xt.create(),
        Description: n.description
      };
      t === "2.1" && (r = {
        ...r,
        $isExternal: n.type === "external" ? true : void 0,
        ReferencedDocument: n.type === "external" ? n.url : `../${n.fileName}`
      }), t === "3" && (r = {
        ...r,
        DocumentGuid: n.type === "internal" ? i : void 0,
        Url: n.type === "external" ? n.url : void 0
      }), Object.keys(r).length > 0 && e.push(r);
    }
    return e;
  }
  toJSON() {
    var t, e;
    const s = {
      guid: this.guid,
      server_assigned_id: this.serverAssignedId,
      topic_type: this.type,
      topic_status: this.status,
      title: this.title,
      priority: this.priority,
      index: this.index,
      labels: [...this.labels],
      creation_date: this.creationDate.toISOString(),
      creation_author: this.creationAuthor,
      modified_date: (t = this.modifiedDate) == null ? void 0 : t.toISOString(),
      modified_author: this.modifiedAuthor,
      assigned_to: this.assignedTo,
      stage: this.stage,
      description: this.description,
      due_date: (e = this.dueDate) == null ? void 0 : e.toISOString(),
      comments: [...this.comments].map(([r, o]) => o.toJSON()),
      relatedTopics: [...this.relatedTopics].map((r) => ({ related_topic_guid: r }))
    }, i = this._components.get(Oe);
    for (const r of this.viewpoints) {
      const o = i.list.get(r);
      o && (s.viewpoints || (s.viewpoints = []), s.viewpoints.push(o.toJSON()));
    }
    const n = this._components.get(Bt);
    for (const r of this.documentReferences) {
      const o = n.documents.get(r);
      o && (s.document_references || (s.document_references = []), o.type === "external" ? s.document_references.push({
        guid: Xt.create(),
        // TODO: this is for sure incorrect!
        description: o.description,
        url: o.url
      }) : s.document_references.push({
        guid: Xt.create(),
        // TODO: this is for sure incorrect!
        description: o.description,
        document_guid: r
      }));
    }
    for (const [r, o] of Object.entries(s))
      (o === void 0 || Array.isArray(o) && o.length === 0) && delete s[r];
    return s;
  }
  /**
   * Serializes the BCF Topic instance into an XML string representation based on the official schema.
   *
   * @remarks
   * This method constructs an XML string based on the properties of the BCF Topic instance.
   * It includes the topic's guid, type, status, creation date, creation author, priority, index,
   * modified date, modified author, due date, assigned to, description, stage, labels, related topics,
   * comments, and viewpoints.
   *
   * @returns A string representing the XML serialization of the BCF Topic.
   *
   * @example
   * ```typescript
   * const topic = bcfTopics.create(); // Created with an instance of BCFTopics
   * const xml = topic.serialize();
   * console.log(xml);
   * ```
   */
  serialize() {
    var t, e;
    const s = this._managerVersion, i = {
      $Guid: this.guid,
      $TopicType: this.type,
      $TopicStatus: this.status,
      $ServerAssignedId: this.serverAssignedId,
      Title: this.title,
      CreationAuthor: this.creationAuthor,
      CreationDate: this.creationDate.toISOString(),
      Priority: this.priority,
      Index: s === "2.1" ? this.index : void 0,
      ModifiedDate: (t = this.modifiedDate) == null ? void 0 : t.toISOString(),
      ModifiedAuthor: this.modifiedAuthor,
      DueDate: (e = this.dueDate) == null ? void 0 : e.toISOString(),
      AssignedTo: this.assignedTo,
      Description: this.description,
      Stage: this.stage,
      DocumentReferences: s === "3" ? { DocumentReference: this.createDocumentReferencesTag(s) } : void 0,
      RelatedTopics: s === "3" ? { RelatedTopic: this.createRelatedTopicTags() } : void 0,
      RelatedTopic: s === "2.1" ? this.createRelatedTopicTags() : void 0,
      Labels: s === "3" ? { Label: this.createLabelTags() } : void 0,
      Viewpoints: s === "3" ? { ViewPoint: this.createViewpointTags() } : void 0,
      Comments: s === "3" ? { Comment: this.createCommentTags() } : void 0
    };
    s === "2.1" && (i.Labels = this.createLabelTags(), i.DocumentReference = this.createDocumentReferencesTag(s));
    const n = {
      Markup: { Topic: i }
    };
    return s === "2.1" && (n.Markup.Viewpoints = this.createViewpointTags(), n.Markup.Comment = this.createCommentTags()), `<?xml version="1.0" encoding="UTF-8"?>
    ${un.builder.build(n)}`;
  }
};
E(Da, "default", {
  title: "BCF Topic",
  type: "Issue",
  status: "Active"
});
var co = Da;
var md = (l, t) => {
  if (t.trim() === "")
    return;
  const e = Bt.xmlParser.parse(t).Extensions;
  if (!e)
    return;
  const { Priorities: s, TopicStatuses: i, TopicTypes: n, Users: r } = e;
  if (s && s.Priority) {
    const o = Array.isArray(s.Priority) ? s.Priority : [s.Priority];
    for (const a of o)
      l.config.priorities.add(a);
  }
  if (i && i.TopicStatus) {
    const o = Array.isArray(i.TopicStatus) ? i.TopicStatus : [i.TopicStatus];
    for (const a of o)
      l.config.statuses.add(a);
  }
  if (n && n.TopicType) {
    const o = Array.isArray(n.TopicType) ? n.TopicType : [n.TopicType];
    for (const a of o)
      l.config.types.add(a);
  }
  if (r && r.User) {
    const o = Array.isArray(r.User) ? r.User : [r.User];
    for (const a of o)
      l.config.users.add(a);
  }
};
var gd = class extends fn {
  constructor() {
    super(...arguments), E(this, "_config", {
      version: {
        type: "Select",
        options: /* @__PURE__ */ new Set(["2.1", "3"]),
        multiple: false,
        value: ""
      },
      author: {
        type: "Text",
        value: ""
      },
      types: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      statuses: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      priorities: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      labels: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      stages: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      users: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      includeSelectionTag: {
        type: "Boolean",
        value: false
      },
      updateExtensionsOnImport: {
        type: "Boolean",
        value: false
      },
      strict: {
        type: "Boolean",
        value: false
      },
      includeAllExtensionsOnExport: {
        type: "Boolean",
        value: false
      },
      fallbackVersionOnImport: {
        type: "Select",
        multiple: false,
        options: /* @__PURE__ */ new Set(["2.1", "3"]),
        value: ""
      },
      ignoreIncompleteTopicsOnImport: {
        type: "Boolean",
        value: false
      },
      exportCustomDataAsLabels: {
        type: "Boolean",
        value: false
      }
    });
  }
  get version() {
    return this._config.version.value;
  }
  set version(t) {
    this._config.version.value = t;
  }
  get author() {
    return this._config.author.value;
  }
  set author(t) {
    this._config.author.value = t;
  }
  get types() {
    return this._config.types.value;
  }
  set types(t) {
    this._config.types.value = t;
  }
  get statuses() {
    return this._config.statuses.value;
  }
  set statuses(t) {
    this._config.statuses.value = t;
  }
  get priorities() {
    return this._config.priorities.value;
  }
  set priorities(t) {
    this._config.priorities.value = t;
  }
  get labels() {
    return this._config.labels.value;
  }
  set labels(t) {
    this._config.labels.value = t;
  }
  get stages() {
    return this._config.stages.value;
  }
  set stages(t) {
    this._config.stages.value = t;
  }
  get users() {
    return this._config.users.value;
  }
  set users(t) {
    this._config.users.value = t;
  }
  get includeSelectionTag() {
    return this._config.includeSelectionTag.value;
  }
  set includeSelectionTag(t) {
    this._config.includeSelectionTag.value = t;
  }
  get updateExtensionsOnImport() {
    return this._config.updateExtensionsOnImport.value;
  }
  set updateExtensionsOnImport(t) {
    this._config.updateExtensionsOnImport.value = t;
  }
  get strict() {
    return this._config.strict.value;
  }
  set strict(t) {
    this._config.strict.value = t;
  }
  get includeAllExtensionsOnExport() {
    return this._config.includeAllExtensionsOnExport.value;
  }
  set includeAllExtensionsOnExport(t) {
    this._config.includeAllExtensionsOnExport.value = t;
  }
  get fallbackVersionOnImport() {
    return this._config.fallbackVersionOnImport.value;
  }
  set fallbackVersionOnImport(t) {
    this._config.fallbackVersionOnImport.value = t;
  }
  get ignoreIncompleteTopicsOnImport() {
    return this._config.ignoreIncompleteTopicsOnImport.value;
  }
  set ignoreIncompleteTopicsOnImport(t) {
    this._config.ignoreIncompleteTopicsOnImport.value = t;
  }
  get exportCustomDataAsLabels() {
    return this._config.exportCustomDataAsLabels.value;
  }
  set exportCustomDataAsLabels(t) {
    this._config.exportCustomDataAsLabels.value = t;
  }
};
var br = class Gs extends St {
  constructor() {
    super(...arguments), E(this, "enabled", false), E(this, "_defaultConfig", {
      author: "jhon.doe@example.com",
      version: "2.1",
      types: /* @__PURE__ */ new Set([
        "Clash",
        "Failure",
        "Fault",
        "Inquiry",
        "Issue",
        "Remark",
        "Request"
      ]),
      statuses: /* @__PURE__ */ new Set(["Active", "In Progress", "Done", "In Review", "Closed"]),
      priorities: /* @__PURE__ */ new Set(["On hold", "Minor", "Normal", "Major", "Critical"]),
      labels: /* @__PURE__ */ new Set(),
      stages: /* @__PURE__ */ new Set(),
      users: /* @__PURE__ */ new Set(),
      includeSelectionTag: false,
      updateExtensionsOnImport: true,
      strict: false,
      includeAllExtensionsOnExport: true,
      fallbackVersionOnImport: "2.1",
      ignoreIncompleteTopicsOnImport: false,
      exportCustomDataAsLabels: false
    }), E(this, "config", new gd(
      this,
      this.components,
      "BCF Topics",
      Gs.uuid
    )), E(this, "list", new Es()), E(this, "documents", new Es()), E(this, "onSetup", new tt()), E(this, "isSetup", false), E(this, "onBCFImported", new tt()), E(this, "onDisposed", new tt());
  }
  setup(t) {
    if (this.isSetup)
      return;
    const e = { ...this._defaultConfig, ...t };
    this.config.version = e.version, this.config.author = e.author, this.config.types = e.types, this.config.statuses = e.statuses, this.config.priorities = e.priorities, this.config.labels = e.labels, this.config.stages = e.stages, this.config.users = e.users, this.config.includeSelectionTag = e.includeSelectionTag, this.config.updateExtensionsOnImport = e.updateExtensionsOnImport, this.config.strict = e.strict, this.config.includeAllExtensionsOnExport = e.includeAllExtensionsOnExport, this.config.fallbackVersionOnImport = e.fallbackVersionOnImport || "", this.config.ignoreIncompleteTopicsOnImport = e.ignoreIncompleteTopicsOnImport, this.isSetup = true, this.enabled = true, this.onSetup.trigger();
  }
  /**
   * Creates a new BCFTopic instance and adds it to the list.
   *
   * @param data - Optional partial BCFTopic object to initialize the new topic with.
   * If not provided, default values will be used.
   * @returns The newly created BCFTopic instance.
   */
  create(t) {
    const e = new co(this.components);
    return t ? (e.guid = t.guid ?? e.guid, e.set(t)) : this.list.set(e.guid, e), e;
  }
  /**
   * Disposes of the BCFTopics component and triggers the onDisposed event.
   *
   * @remarks
   * This method clears the list of topics and triggers the onDisposed event.
   * It also resets the onDisposed event listener.
   */
  dispose() {
    this.list.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Retrieves the unique set of topic types used across all topics.
   *
   * @returns A Set containing the unique topic types.
   */
  get usedTypes() {
    const t = [...this.list].map(([e, s]) => s.type);
    return new Set(t);
  }
  /**
   * Retrieves the unique set of topic statuses used across all topics.
   *
   * @returns A Set containing the unique topic statuses.
   */
  get usedStatuses() {
    const t = [...this.list].map(([e, s]) => s.status);
    return new Set(t);
  }
  /**
   * Retrieves the unique set of topic priorities used across all topics.
   *
   * @returns A Set containing the unique topic priorities.
   * Note: This method filters out any null or undefined priorities.
   */
  get usedPriorities() {
    const t = [...this.list].map(([e, s]) => s.priority).filter((e) => e);
    return new Set(t);
  }
  /**
   * Retrieves the unique set of topic stages used across all topics.
   *
   * @returns A Set containing the unique topic stages.
   * Note: This method filters out any null or undefined stages.
   */
  get usedStages() {
    const t = [...this.list].map(([e, s]) => s.stage).filter((e) => e);
    return new Set(t);
  }
  /**
   * Retrieves the unique set of users associated with topics.
   *
   * @returns A Set containing the unique users.
   * Note: This method collects users from the creation author, assigned to, modified author, and comment authors.
   */
  get usedUsers() {
    const t = [];
    for (const [e, s] of this.list) {
      t.push(s.creationAuthor), s.assignedTo && t.push(s.assignedTo), s.modifiedAuthor && t.push(s.modifiedAuthor);
      for (const [i, n] of s.comments)
        t.push(n.author), n.modifiedAuthor && t.push(n.modifiedAuthor);
    }
    return new Set(t);
  }
  /**
   * Retrieves the unique set of labels used across all topics.
   *
   * @returns A Set containing the unique labels.
   */
  get usedLabels() {
    const t = [];
    for (const [e, s] of this.list)
      t.push(...s.labels);
    return new Set(t);
  }
  /**
   * Updates the set of extensions (types, statuses, priorities, labels, stages, users) based on the current topics.
   * This method iterates through each topic in the list and adds its properties to the corresponding sets in the config.
   */
  updateExtensions() {
    for (const [t, e] of this.list) {
      for (const s of e.labels)
        this.config.labels.add(s);
      this.config.types.add(e.type), e.priority && this.config.priorities.add(e.priority), e.stage && this.config.stages.add(e.stage), this.config.statuses.add(e.status), this.config.users.add(e.creationAuthor), e.assignedTo && this.config.users.add(e.assignedTo), e.modifiedAuthor && this.config.users.add(e.modifiedAuthor);
      for (const [s, i] of e.comments)
        this.config.users.add(i.author), i.modifiedAuthor && this.config.users.add(i.modifiedAuthor);
    }
  }
  /**
   * Updates the references to viewpoints in the topics.
   * This function iterates through each topic and checks if the viewpoints exist in the viewpoints list.
   * If a viewpoint does not exist, it is removed from the topic's viewpoints.
   */
  updateViewpointReferences() {
    const t = this.components.get(Oe);
    for (const [e, s] of this.list)
      for (const i of s.viewpoints)
        t.list.has(i) || s.viewpoints.delete(i);
  }
  /**
   * Exports the given topics to a BCF (Building Collaboration Format) zip file.
   *
   * @param topics - The topics to export. Defaults to all topics in the list.
   * @returns A promise that resolves to a Blob containing the exported BCF zip file.
   */
  async export(t = this.list.values()) {
    const e = new lo();
    e.file(
      "bcf.version",
      `<?xml version="1.0" encoding="UTF-8"?>
    <Version VersionId="${this.config.version}" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/buildingSMART/BCF-XML/release_3_0/Schemas/version.xsd"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    </Version>`
    );
    for (const [n, r] of this.documents.entries())
      r.type !== "external" && e.file(
        this.config.version === "2.1" ? r.fileName : `documents/${n}`,
        r.data
      );
    if (this.config.version === "3") {
      const n = [];
      for (const [r, o] of this.documents.entries()) {
        const { type: a, description: c } = o;
        a !== "external" && n.push(`<Document Guid="${r}">
        <Filename>${o.fileName}</Filename>
        ${c ? `<Description>${c}</Description>` : ""}
      </Document>`);
      }
      n.length > 0 && e.file(
        "documents.xml",
        `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
  <DocumentInfo xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="documents.xsd">
    <Documents>
      ${n.join(`
`)}
    </Documents>
  </DocumentInfo>`
      );
    }
    e.file("bcf.extensions", this.serializeExtensions());
    const s = this.components.get(Oe);
    for (const n of t) {
      const r = e.folder(n.guid);
      r.file("markup.bcf", n.serialize());
      for (const o of n.viewpoints) {
        const a = s.list.get(o);
        if (!a)
          continue;
        const c = a.title ?? a.guid;
        r.file(
          `${c}.bcfv`,
          await a.serialize()
        );
        const h = s.snapshots.get(a.snapshot);
        if (!h)
          continue;
        const d = h ? a.snapshot : a.guid, u = s.getSnapshotExtension(
          a.snapshot
        );
        r.file(
          `${d}.${u}`,
          h,
          {
            binary: true
          }
        );
      }
    }
    return await e.generateAsync({ type: "blob" });
  }
  serializeExtensions() {
    const t = [...this.config.types].map((o) => `<TopicType>${o}</TopicType>`).join(`
`), e = [...this.config.statuses].map((o) => `<TopicStatus>${o}</TopicStatus>`).join(`
`), s = [...this.config.priorities].map((o) => `<Priority>${o}</Priority>`).join(`
`), i = [...this.config.labels].map((o) => `<TopicLabel>${o}</TopicLabel>`).join(`
`), n = [...this.config.stages].map((o) => `<Stage>${o}</Stage>`).join(`
`), r = [...this.config.users].map((o) => `<User>${o}</User>`).join(`
`);
    return `
      <?xml version="1.0" encoding="UTF-8"?>
      <Extensions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="your-schema-location.xsd">
        ${t.length !== 0 ? `<TopicTypes>
${t}
</TopicTypes>` : ""}
        ${e.length !== 0 ? `<TopicStatuses>
${e}
</TopicStatuses>` : ""}
        ${s.length !== 0 ? `<Priorities>
${s}
</Priorities>` : ""}
        ${i.length !== 0 ? `<TopicLabels>
${i}
</TopicLabels>` : ""}
        ${n.length !== 0 ? `<Stages>
${n}
</Stages>` : ""}
        ${r.length !== 0 ? `<Users>
${r}
</Users>` : ""}
      </Extensions>
    `;
  }
  processMarkupComment(t) {
    const {
      Guid: e,
      Date: s,
      Author: i,
      Comment: n,
      Viewpoint: r
    } = t;
    if (!(e && s && i && (or || r)))
      return null;
    const o = new or(this.components, n ?? "");
    return o.guid = e, o.date = new Date(s), o.author = i, o.viewpoint = r == null ? void 0 : r.Guid, o.modifiedAuthor = t.ModifiedAuthor, o.modifiedDate = t.ModifiedDate ? new Date(t.ModifiedDate) : void 0, o;
  }
  getMarkupComments(t, e) {
    var s;
    let i;
    if (e === "2.1" && (i = t.Comment), e === "3" && (i = (s = t.Topic.Comments) == null ? void 0 : s.Comment), !i)
      return [];
    i = Array.isArray(i) ? i : [i];
    const n = i.map((o) => this.processMarkupComment(o)).filter((o) => o);
    return Array.isArray(n) ? n : [n];
  }
  getMarkupLabels(t, e) {
    var s;
    let i;
    return e === "2.1" && (i = t.Topic.Labels), e === "3" && (i = (s = t.Topic.Labels) == null ? void 0 : s.Label), i ? Array.isArray(i) ? i : [i] : [];
  }
  getMarkupViewpoints(t, e) {
    var s;
    let i;
    return e === "2.1" && (i = t.Viewpoints), e === "3" && (i = (s = t.Topic.Viewpoints) == null ? void 0 : s.ViewPoint), i ? (i = Array.isArray(i) ? i : [i], i) : [];
  }
  getMarkupRelatedTopics(t, e) {
    var s;
    let i;
    return e === "2.1" && (i = t.Topic.RelatedTopic), e === "3" && (i = (s = t.Topic.RelatedTopics) == null ? void 0 : s.RelatedTopic), i ? (Array.isArray(i) ? i : [i]).map((r) => r.Guid) : [];
  }
  getMarkupDocumentReferences(t, e) {
    var s;
    let i;
    return e === "2.1" && (i = t.Topic.DocumentReference), e === "3" && (i = (s = t.Topic.DocumentReferences) == null ? void 0 : s.DocumentReference), i ? Array.isArray(i) ? i : [i] : [];
  }
  /**
   * Loads BCF (Building Collaboration Format) data into the engine.
   *
   * @param world - The default world where the viewpoints are going to be created.
   * @param data - The BCF data to load.
   *
   * @returns A promise that resolves to an object containing the created viewpoints and topics.
   *
   * @throws An error if the BCF version is not supported.
   */
  async load(t) {
    var e, s, i;
    const {
      fallbackVersionOnImport: n,
      ignoreIncompleteTopicsOnImport: r,
      updateExtensionsOnImport: o
    } = this.config, a = new lo();
    await a.loadAsync(t);
    const c = Object.values(a.files);
    let h = n;
    const d = c.find((S) => S.name.endsWith(".version"));
    if (d) {
      const S = await d.async("string"), C = Gs.xmlParser.parse(S).Version.VersionId;
      h = String(C);
    }
    if (!(h && (h === "2.1" || h === "3")))
      throw new Error(`BCFTopics: ${h} is not supported.`);
    const u = c.find(
      (S) => S.name.endsWith(".extensions")
    );
    if (o && u) {
      const S = await u.async("string");
      md(this, S);
    }
    const f = [], g = this.components.get(Oe), m = c.filter((S) => S.name.endsWith(".bcfv"));
    for (const S of m) {
      const C = await S.async("string"), P = Gs.xmlParser.parse(C).VisualizationInfo;
      if (!P) {
        console.warn("Missing VisualizationInfo in Viewpoint");
        continue;
      }
      const O = {}, {
        Guid: z,
        ClippingPlanes: k,
        Components: H,
        OrthogonalCamera: T,
        PerspectiveCamera: L
      } = P;
      if (z && (O.guid = z), H) {
        const N = {
          selection: [],
          coloring: [],
          visibility: {
            default_visibility: false,
            exceptions: [],
            view_setup_hints: {
              spaces_visible: false,
              space_boundaries_visible: false,
              openings_visible: false
            }
          }
        };
        O.components = N;
        const { Selection: K, Visibility: W } = H;
        if (K && K.Component) {
          const it = Array.isArray(K.Component) ? K.Component : [K.Component];
          N.selection = it.map((U) => U.IfcGuid ? { ifc_guid: U.IfcGuid } : null).filter((U) => U !== null);
        }
        if (W && "DefaultVisibility" in W && (N.visibility.default_visibility = W.DefaultVisibility), W && W.Exceptions && "Component" in W.Exceptions) {
          const { Component: it } = W.Exceptions, U = Array.isArray(it) ? it : [it];
          N.visibility.exceptions = U.map((R) => R.IfcGuid ? { ifc_guid: R.IfcGuid } : null).filter((R) => R !== null);
        }
        let st;
        h === "2.1" && (st = H.ViewSetupHints), h === "3" && (st = (e = H.Visibility) == null ? void 0 : e.ViewSetupHints), st && ("OpeningsVisible" in st && (N.visibility.view_setup_hints.openings_visible = st.OpeningsVisible), "SpacesVisible" in st && (N.visibility.view_setup_hints.spaces_visible = st.SpacesVisible), "SpaceBoundariesVisible" in st && (N.visibility.view_setup_hints.space_boundaries_visible = st.SpaceBoundariesVisible));
        const { Coloring: j } = H;
        if (j && j.Color) {
          const it = Array.isArray(j.Color) ? j.Color : [j.Color];
          for (const U of it) {
            const { Color: R, Component: rt } = U;
            if (!(R.length === 6 || R.length === 8))
              continue;
            const Q = R.length === 6 ? R : R.slice(2), pt = (Array.isArray(rt) ? rt : [rt]).map((gt) => gt.IfcGuid ? { ifc_guid: gt.IfcGuid } : null).filter((gt) => gt !== null);
            N.coloring.push({
              color: Q,
              components: pt
            });
          }
        }
      }
      if (T || L) {
        const N = P.PerspectiveCamera ?? P.OrthogonalCamera, { CameraViewPoint: K, CameraDirection: W } = N, st = new Vector3(
          Number(K.X),
          Number(K.Z),
          Number(-K.Y)
        ), j = new Vector3(
          Number(W.X),
          Number(W.Z),
          Number(-W.Y)
        ), it = {
          camera_view_point: { x: st.x, y: st.y, z: st.z },
          camera_direction: { x: j.x, y: j.y, z: j.z },
          aspect_ratio: "AspectRatio" in N ? N.AspectRatio : 1,
          // TODO: Better define camera_up_vector
          camera_up_vector: {
            x: 0,
            y: 0,
            z: 0
          }
        };
        "ViewToWorldScale" in N && (O.orthogonal_camera = {
          ...it,
          view_to_world_scale: N.ViewToWorldScale
        }), "FieldOfView" in N && (O.perspective_camera = {
          ...it,
          field_of_view: N.FieldOfView
        });
      }
      if (k) {
        const K = (Array.isArray(k.ClippingPlane) ? k.ClippingPlane : [k.ClippingPlane]).map(
          ({ Location: W, Direction: st }) => ({
            location: { x: W.x, y: W.y, z: W.z },
            direction: { x: st.x, y: st.y, z: st.z }
          })
        );
        O.clipping_planes = K;
      }
      const w = new za(this.components, O);
      f.push(w);
    }
    const _ = (S) => {
      const C = S.split("/"), P = C[C.length - 1].split(".");
      return P.pop(), P.join(".");
    }, p = c.filter(
      (S) => S.name.endsWith(".png") || S.name.endsWith(".jpeg")
    );
    for (const S of p) {
      const C = _(S.name), P = await S.async("arraybuffer"), O = new Uint8Array(P);
      g.snapshots.set(C, O);
    }
    const y = {}, b = [], x = c.filter((S) => S.name.endsWith(".bcf"));
    for (const S of x) {
      const C = await S.async("string"), P = Gs.xmlParser.parse(C).Markup, O = P.Topic, {
        Guid: z,
        TopicType: k,
        TopicStatus: H,
        Title: T,
        CreationDate: L,
        CreationAuthor: w
      } = O;
      if (r && !(z && k && H && T && L && w))
        continue;
      const N = new co(this.components);
      N.guid = z ?? N.guid;
      const K = this.getMarkupRelatedTopics(P, h);
      y[N.guid] = new Set(K), N.type = k ?? N.type, N.status = H ?? N.status, N.title = T ?? N.title, N.creationDate = L ? new Date(L) : N.creationDate, N.creationAuthor = w ?? N.creationAuthor, N.serverAssignedId = O.ServerAssignedId, N.priority = O.Priority, N.index = O.Index, N.modifiedDate = O.ModifiedDate ? new Date(O.ModifiedDate) : void 0, N.modifiedAuthor = O.ModifiedAuthor, N.dueDate = O.DueDate ? new Date(O.DueDate) : void 0, N.assignedTo = O.AssignedTo, N.description = O.Description, N.stage = O.Stage;
      const W = this.getMarkupLabels(P, h);
      for (const Q of W)
        N.labels.add(Q);
      const st = this.getMarkupComments(P, h);
      for (const Q of st)
        N.comments.set(Q.guid, Q);
      const j = this.getMarkupViewpoints(P, h);
      for (const Q of j) {
        if (!(Q && Q.Guid))
          continue;
        const J = g.list.get(Q.Guid);
        if (J) {
          N.viewpoints.add(J.guid);
          const pt = _(
            Q.Snapshot
          );
          J.snapshot = pt ?? null;
        }
      }
      const it = this.getMarkupDocumentReferences(
        P,
        h
      ), U = c.find((Q) => Q.name === "documents.xml");
      let R = [];
      const rt = await (U == null ? void 0 : U.async("string"));
      if (rt) {
        const Q = (i = (s = un.parser.parse(rt).DocumentInfo) == null ? void 0 : s.Documents) == null ? void 0 : i.Document;
        R = Array.isArray(Q) ? Q : [Q];
      }
      for (const Q of it) {
        const {
          Description: J,
          // From 3.0
          DocumentGuid: pt,
          Url: gt,
          // From 2.1
          isExternal: ht,
          ReferencedDocument: dt
        } = Q;
        if (pt && R.length > 0) {
          const mt = R.find(
            ({ Guid: Y }) => Y === pt
          ), yt = c.find(
            (Y) => Y.name.endsWith(pt)
          ), It = await (yt == null ? void 0 : yt.async("uint8array"));
          if (!(mt && It))
            continue;
          const { Description: zt, Filename: v } = mt;
          this.documents.set(pt, {
            type: "internal",
            fileName: v,
            description: zt,
            data: It
          }), N.documentReferences.add(pt);
        }
        if (gt) {
          const mt = this.documents.add({
            type: "external",
            url: gt,
            description: J
          });
          N.documentReferences.add(mt);
        }
        if (dt) {
          let mt = null;
          if (ht)
            mt = this.documents.add({
              type: "external",
              url: dt,
              description: J
            });
          else {
            const yt = dt.split("/"), It = yt[yt.length - 1], zt = c.find((Y) => Y.name.endsWith(It)), v = await (zt == null ? void 0 : zt.async("uint8array"));
            if (!v)
              continue;
            mt = this.documents.add({
              type: "internal",
              fileName: It,
              data: v,
              description: J
            });
          }
          N.documentReferences.add(mt);
        }
      }
      this.list.set(N.guid, N), b.push(N);
    }
    for (const S in y) {
      const C = this.list.get(S);
      if (!C)
        continue;
      const P = y[S];
      for (const O of P)
        C.relatedTopics.add(O);
    }
    return this.onBCFImported.trigger(b), { viewpoints: f, topics: b };
  }
};
E(br, "uuid", "de977976-e4f6-4e4f-a01a-204727839802");
E(br, "xmlParser", new dn.XMLParser({
  allowBooleanAttributes: true,
  attributeNamePrefix: "",
  ignoreAttributes: false,
  ignoreDeclaration: true,
  ignorePiTags: true,
  numberParseOptions: { leadingZeros: true, hex: true },
  parseAttributeValue: true,
  preserveOrder: false,
  processEntities: false,
  removeNSPrefix: true,
  trimValues: true
}));
var Bt = br;
var ts = new Raycaster();
var jt = new Vector3();
var Be = new Vector3();
var Ct = new Quaternion();
var ho = {
  X: new Vector3(1, 0, 0),
  Y: new Vector3(0, 1, 0),
  Z: new Vector3(0, 0, 1)
};
var Bn = { type: "change" };
var uo = { type: "mouseDown", mode: null };
var fo = { type: "mouseUp", mode: null };
var po = { type: "objectChange" };
var _d = class extends Controls {
  /**
   * Constructs a new controls instance.
   *
   * @param {Camera} camera - The camera of the rendered scene.
   * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.
   */
  constructor(t, e = null) {
    super(void 0, e);
    const s = new Sd2(this);
    this._root = s;
    const i = new Ed();
    this._gizmo = i, s.add(i);
    const n = new Td();
    this._plane = n, s.add(n);
    const r = this;
    function o(b, x) {
      let S = x;
      Object.defineProperty(r, b, {
        get: function() {
          return S !== void 0 ? S : x;
        },
        set: function(C) {
          S !== C && (S = C, n[b] = C, i[b] = C, r.dispatchEvent({ type: b + "-changed", value: C }), r.dispatchEvent(Bn));
        }
      }), r[b] = x, n[b] = x, i[b] = x;
    }
    o("camera", t), o("object", void 0), o("enabled", true), o("axis", null), o("mode", "translate"), o("translationSnap", null), o("rotationSnap", null), o("scaleSnap", null), o("space", "world"), o("size", 1), o("dragging", false), o("showX", true), o("showY", true), o("showZ", true), o("minX", -1 / 0), o("maxX", 1 / 0), o("minY", -1 / 0), o("maxY", 1 / 0), o("minZ", -1 / 0), o("maxZ", 1 / 0);
    const a = new Vector3(), c = new Vector3(), h = new Quaternion(), d = new Quaternion(), u = new Vector3(), f = new Quaternion(), g = new Vector3(), m = new Vector3(), _ = new Vector3(), p = 0, y = new Vector3();
    o("worldPosition", a), o("worldPositionStart", c), o("worldQuaternion", h), o("worldQuaternionStart", d), o("cameraPosition", u), o("cameraQuaternion", f), o("pointStart", g), o("pointEnd", m), o("rotationAxis", _), o("rotationAngle", p), o("eye", y), this._offset = new Vector3(), this._startNorm = new Vector3(), this._endNorm = new Vector3(), this._cameraScale = new Vector3(), this._parentPosition = new Vector3(), this._parentQuaternion = new Quaternion(), this._parentQuaternionInv = new Quaternion(), this._parentScale = new Vector3(), this._worldScaleStart = new Vector3(), this._worldQuaternionInv = new Quaternion(), this._worldScale = new Vector3(), this._positionStart = new Vector3(), this._quaternionStart = new Quaternion(), this._scaleStart = new Vector3(), this._getPointer = yd.bind(this), this._onPointerDown = wd.bind(this), this._onPointerHover = vd.bind(this), this._onPointerMove = bd.bind(this), this._onPointerUp = xd.bind(this), e !== null && this.connect(e);
  }
  connect(t) {
    super.connect(t), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "auto";
  }
  /**
   * Returns the visual representation of the controls. Add the helper to your scene to
   * visually transform the attached  3D object.
   *
   * @return {TransformControlsRoot} The helper.
   */
  getHelper() {
    return this._root;
  }
  pointerHover(t) {
    if (this.object === void 0 || this.dragging === true)
      return;
    t !== null && ts.setFromCamera(t, this.camera);
    const e = Rn(this._gizmo.picker[this.mode], ts);
    e ? this.axis = e.object.name : this.axis = null;
  }
  pointerDown(t) {
    if (!(this.object === void 0 || this.dragging === true || t != null && t.button !== 0) && this.axis !== null) {
      t !== null && ts.setFromCamera(t, this.camera);
      const e = Rn(this._plane, ts, true);
      e && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(e.point).sub(this.worldPositionStart)), this.dragging = true, uo.mode = this.mode, this.dispatchEvent(uo);
    }
  }
  pointerMove(t) {
    const e = this.axis, s = this.mode, i = this.object;
    let n = this.space;
    if (s === "scale" ? n = "local" : (e === "E" || e === "XYZE" || e === "XYZ") && (n = "world"), i === void 0 || e === null || this.dragging === false || t !== null && t.button !== -1)
      return;
    t !== null && ts.setFromCamera(t, this.camera);
    const r = Rn(this._plane, ts, true);
    if (r) {
      if (this.pointEnd.copy(r.point).sub(this.worldPositionStart), s === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), n === "local" && e !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), e.indexOf("X") === -1 && (this._offset.x = 0), e.indexOf("Y") === -1 && (this._offset.y = 0), e.indexOf("Z") === -1 && (this._offset.z = 0), n === "local" && e !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), i.position.copy(this._offset).add(this._positionStart), this.translationSnap && (n === "local" && (i.position.applyQuaternion(Ct.copy(this._quaternionStart).invert()), e.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), e.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), e.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.position.applyQuaternion(this._quaternionStart)), n === "world" && (i.parent && i.position.add(jt.setFromMatrixPosition(i.parent.matrixWorld)), e.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), e.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), e.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.parent && i.position.sub(jt.setFromMatrixPosition(i.parent.matrixWorld)))), i.position.x = Math.max(this.minX, Math.min(this.maxX, i.position.x)), i.position.y = Math.max(this.minY, Math.min(this.maxY, i.position.y)), i.position.z = Math.max(this.minZ, Math.min(this.maxZ, i.position.z));
      else if (s === "scale") {
        if (e.search("XYZ") !== -1) {
          let o = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (o *= -1), Be.set(o, o, o);
        } else
          jt.copy(this.pointStart), Be.copy(this.pointEnd), jt.applyQuaternion(this._worldQuaternionInv), Be.applyQuaternion(this._worldQuaternionInv), Be.divide(jt), e.search("X") === -1 && (Be.x = 1), e.search("Y") === -1 && (Be.y = 1), e.search("Z") === -1 && (Be.z = 1);
        i.scale.copy(this._scaleStart).multiply(Be), this.scaleSnap && (e.search("X") !== -1 && (i.scale.x = Math.round(i.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), e.search("Y") !== -1 && (i.scale.y = Math.round(i.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), e.search("Z") !== -1 && (i.scale.z = Math.round(i.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (s === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const o = 20 / this.worldPosition.distanceTo(jt.setFromMatrixPosition(this.camera.matrixWorld));
        let a = false;
        e === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(jt.copy(this.rotationAxis).cross(this.eye)) * o) : (e === "X" || e === "Y" || e === "Z") && (this.rotationAxis.copy(ho[e]), jt.copy(ho[e]), n === "local" && jt.applyQuaternion(this.worldQuaternion), jt.cross(this.eye), jt.length() === 0 ? a = true : this.rotationAngle = this._offset.dot(jt.normalize()) * o), (e === "E" || a) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), n === "local" && e !== "E" && e !== "XYZE" ? (i.quaternion.copy(this._quaternionStart), i.quaternion.multiply(Ct.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), i.quaternion.copy(Ct.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), i.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(Bn), this.dispatchEvent(po);
    }
  }
  pointerUp(t) {
    t !== null && t.button !== 0 || (this.dragging && this.axis !== null && (fo.mode = this.mode, this.dispatchEvent(fo)), this.dragging = false, this.axis = null);
  }
  dispose() {
    this.disconnect(), this._root.dispose();
  }
  /**
   * Sets the 3D object that should be transformed and ensures the controls UI is visible.
   *
   * @param {Object3D} object -  The 3D object that should be transformed.
   * @return {TransformControls} A reference to this controls.
   */
  attach(t) {
    return this.object = t, this._root.visible = true, this;
  }
  /**
   * Removes the current 3D object from the controls and makes the helper UI invisible.
   *
   * @return {TransformControls} A reference to this controls.
   */
  detach() {
    return this.object = void 0, this.axis = null, this._root.visible = false, this;
  }
  /**
   * Resets the object's position, rotation and scale to when the current transform began.
   */
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(Bn), this.dispatchEvent(po), this.pointStart.copy(this.pointEnd));
  }
  /**
   * Returns the raycaster that is used for user interaction. This object is shared between all
   * instances of `TransformControls`.
   *
   * @returns {Raycaster} The internal raycaster.
   */
  getRaycaster() {
    return ts;
  }
  /**
   * Returns the transformation mode.
   *
   * @returns {'translate'|'rotate'|'scale'} The transformation mode.
   */
  getMode() {
    return this.mode;
  }
  /**
   * Sets the given transformation mode.
   *
   * @param {'translate'|'rotate'|'scale'} mode - The transformation mode to set.
   */
  setMode(t) {
    this.mode = t;
  }
  /**
   * Sets the translation snap.
   *
   * @param {?number} translationSnap - The translation snap to set.
   */
  setTranslationSnap(t) {
    this.translationSnap = t;
  }
  /**
   * Sets the rotation snap.
   *
   * @param {?number} rotationSnap - The rotation snap to set.
   */
  setRotationSnap(t) {
    this.rotationSnap = t;
  }
  /**
   * Sets the scale snap.
   *
   * @param {?number} scaleSnap - The scale snap to set.
   */
  setScaleSnap(t) {
    this.scaleSnap = t;
  }
  /**
   * Sets the size of the helper UI.
   *
   * @param {number} size - The size to set.
   */
  setSize(t) {
    this.size = t;
  }
  /**
   * Sets the coordinate space in which transformations are applied.
   *
   * @param {'world'|'local'} space - The space to set.
   */
  setSpace(t) {
    this.space = t;
  }
};
function yd(l) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: l.button
    };
  {
    const t = this.domElement.getBoundingClientRect();
    return {
      x: (l.clientX - t.left) / t.width * 2 - 1,
      y: -(l.clientY - t.top) / t.height * 2 + 1,
      button: l.button
    };
  }
}
function vd(l) {
  if (this.enabled)
    switch (l.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(l));
        break;
    }
}
function wd(l) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(l.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(l)), this.pointerDown(this._getPointer(l)));
}
function bd(l) {
  this.enabled && this.pointerMove(this._getPointer(l));
}
function xd(l) {
  this.enabled && (this.domElement.releasePointerCapture(l.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(l)));
}
function Rn(l, t, e) {
  const s = t.intersectObject(l, true);
  for (let i = 0; i < s.length; i++)
    if (s[i].object.visible || e)
      return s[i];
  return false;
}
var Di = new Euler();
var xt = new Vector3(0, 1, 0);
var mo = new Vector3(0, 0, 0);
var go = new Matrix4();
var Ii = new Quaternion();
var Gi = new Quaternion();
var ve2 = new Vector3();
var _o = new Matrix4();
var Zs = new Vector3(1, 0, 0);
var es = new Vector3(0, 1, 0);
var qs = new Vector3(0, 0, 1);
var zi = new Vector3();
var Ws = new Vector3();
var Xs = new Vector3();
var Sd2 = class extends Object3D {
  constructor(t) {
    super(), this.isTransformControlsRoot = true, this.controls = t, this.visible = false;
  }
  // updateMatrixWorld updates key transformation variables
  updateMatrixWorld(t) {
    const e = this.controls;
    e.object !== void 0 && (e.object.updateMatrixWorld(), e.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : e.object.parent.matrixWorld.decompose(e._parentPosition, e._parentQuaternion, e._parentScale), e.object.matrixWorld.decompose(e.worldPosition, e.worldQuaternion, e._worldScale), e._parentQuaternionInv.copy(e._parentQuaternion).invert(), e._worldQuaternionInv.copy(e.worldQuaternion).invert()), e.camera.updateMatrixWorld(), e.camera.matrixWorld.decompose(e.cameraPosition, e.cameraQuaternion, e._cameraScale), e.camera.isOrthographicCamera ? e.camera.getWorldDirection(e.eye).negate() : e.eye.copy(e.cameraPosition).sub(e.worldPosition).normalize(), super.updateMatrixWorld(t);
  }
  dispose() {
    this.traverse(function(t) {
      t.geometry && t.geometry.dispose(), t.material && t.material.dispose();
    });
  }
};
var Ed = class extends Object3D {
  constructor() {
    super(), this.isTransformControlsGizmo = true, this.type = "TransformControlsGizmo";
    const t = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    }), e = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    }), s = t.clone();
    s.opacity = 0.15;
    const i = e.clone();
    i.opacity = 0.5;
    const n = t.clone();
    n.color.setHex(16711680);
    const r = t.clone();
    r.color.setHex(65280);
    const o = t.clone();
    o.color.setHex(255);
    const a = t.clone();
    a.color.setHex(16711680), a.opacity = 0.5;
    const c = t.clone();
    c.color.setHex(65280), c.opacity = 0.5;
    const h = t.clone();
    h.color.setHex(255), h.opacity = 0.5;
    const d = t.clone();
    d.opacity = 0.25;
    const u = t.clone();
    u.color.setHex(16776960), u.opacity = 0.25, t.clone().color.setHex(16776960);
    const g = t.clone();
    g.color.setHex(7895160);
    const m = new CylinderGeometry(0, 0.04, 0.1, 12);
    m.translate(0, 0.05, 0);
    const _ = new BoxGeometry(0.08, 0.08, 0.08);
    _.translate(0, 0.04, 0);
    const p = new BufferGeometry();
    p.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const y = new CylinderGeometry(75e-4, 75e-4, 0.5, 3);
    y.translate(0, 0.25, 0);
    function b(N, K) {
      const W = new TorusGeometry(N, 75e-4, 3, 64, K * Math.PI * 2);
      return W.rotateY(Math.PI / 2), W.rotateX(Math.PI / 2), W;
    }
    function x() {
      const N = new BufferGeometry();
      return N.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3)), N;
    }
    const S = {
      X: [
        [new Mesh(m, n), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(m, n), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Mesh(y, n), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(m, r), [0, 0.5, 0]],
        [new Mesh(m, r), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Mesh(y, r)]
      ],
      Z: [
        [new Mesh(m, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(m, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Mesh(y, o), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.1, 0), d.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), h.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), a.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), c.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, C = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.2, 0), s)]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), s), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), s), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), s), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, P = {
      START: [
        [new Mesh(new OctahedronGeometry(0.01, 2), i), null, null, null, "helper"]
      ],
      END: [
        [new Mesh(new OctahedronGeometry(0.01, 2), i), null, null, null, "helper"]
      ],
      DELTA: [
        [new Line(x(), i), null, null, null, "helper"]
      ],
      X: [
        [new Line(p, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(p, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(p, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, O = {
      XYZE: [
        [new Mesh(b(0.5, 1), g), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Mesh(b(0.5, 0.5), n)]
      ],
      Y: [
        [new Mesh(b(0.5, 0.5), r), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Mesh(b(0.5, 0.5), o), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Mesh(b(0.75, 1), u), null, [0, Math.PI / 2, 0]]
      ]
    }, z = {
      AXIS: [
        [new Line(p, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, k = {
      XYZE: [
        [new Mesh(new SphereGeometry(0.25, 10, 8), s)]
      ],
      X: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), s), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), s), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), s), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), s)]
      ]
    }, H = {
      X: [
        [new Mesh(_, n), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(y, n), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(_, n), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(_, r), [0, 0.5, 0]],
        [new Mesh(y, r)],
        [new Mesh(_, r), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(_, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(y, o), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Mesh(_, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), h), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), a), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), c), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.1, 0.1, 0.1), d.clone())]
      ]
    }, T = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), s), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), s), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), s), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), s), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.2), s), [0, 0, 0]]
      ]
    }, L = {
      X: [
        [new Line(p, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(p, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(p, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function w(N) {
      const K = new Object3D();
      for (const W in N)
        for (let st = N[W].length; st--; ) {
          const j = N[W][st][0].clone(), it = N[W][st][1], U = N[W][st][2], R = N[W][st][3], rt = N[W][st][4];
          j.name = W, j.tag = rt, it && j.position.set(it[0], it[1], it[2]), U && j.rotation.set(U[0], U[1], U[2]), R && j.scale.set(R[0], R[1], R[2]), j.updateMatrix();
          const Q = j.geometry.clone();
          Q.applyMatrix4(j.matrix), j.geometry = Q, j.renderOrder = 1 / 0, j.position.set(0, 0, 0), j.rotation.set(0, 0, 0), j.scale.set(1, 1, 1), K.add(j);
        }
      return K;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = w(S)), this.add(this.gizmo.rotate = w(O)), this.add(this.gizmo.scale = w(H)), this.add(this.picker.translate = w(C)), this.add(this.picker.rotate = w(k)), this.add(this.picker.scale = w(T)), this.add(this.helper.translate = w(P)), this.add(this.helper.rotate = w(z)), this.add(this.helper.scale = w(L)), this.picker.translate.visible = false, this.picker.rotate.visible = false, this.picker.scale.visible = false;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(t) {
    const s = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : Gi;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let i = [];
    i = i.concat(this.picker[this.mode].children), i = i.concat(this.gizmo[this.mode].children), i = i.concat(this.helper[this.mode].children);
    for (let n = 0; n < i.length; n++) {
      const r = i[n];
      r.visible = true, r.rotation.set(0, 0, 0), r.position.copy(this.worldPosition);
      let o;
      if (this.camera.isOrthographicCamera ? o = (this.camera.top - this.camera.bottom) / this.camera.zoom : o = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), r.scale.set(1, 1, 1).multiplyScalar(o * this.size / 4), r.tag === "helper") {
        r.visible = false, r.name === "AXIS" ? (r.visible = !!this.axis, this.axis === "X" && (Ct.setFromEuler(Di.set(0, 0, 0)), r.quaternion.copy(s).multiply(Ct), Math.abs(xt.copy(Zs).applyQuaternion(s).dot(this.eye)) > 0.9 && (r.visible = false)), this.axis === "Y" && (Ct.setFromEuler(Di.set(0, 0, Math.PI / 2)), r.quaternion.copy(s).multiply(Ct), Math.abs(xt.copy(es).applyQuaternion(s).dot(this.eye)) > 0.9 && (r.visible = false)), this.axis === "Z" && (Ct.setFromEuler(Di.set(0, Math.PI / 2, 0)), r.quaternion.copy(s).multiply(Ct), Math.abs(xt.copy(qs).applyQuaternion(s).dot(this.eye)) > 0.9 && (r.visible = false)), this.axis === "XYZE" && (Ct.setFromEuler(Di.set(0, Math.PI / 2, 0)), xt.copy(this.rotationAxis), r.quaternion.setFromRotationMatrix(go.lookAt(mo, xt, es)), r.quaternion.multiply(Ct), r.visible = this.dragging), this.axis === "E" && (r.visible = false)) : r.name === "START" ? (r.position.copy(this.worldPositionStart), r.visible = this.dragging) : r.name === "END" ? (r.position.copy(this.worldPosition), r.visible = this.dragging) : r.name === "DELTA" ? (r.position.copy(this.worldPositionStart), r.quaternion.copy(this.worldQuaternionStart), jt.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), jt.applyQuaternion(this.worldQuaternionStart.clone().invert()), r.scale.copy(jt), r.visible = this.dragging) : (r.quaternion.copy(s), this.dragging ? r.position.copy(this.worldPositionStart) : r.position.copy(this.worldPosition), this.axis && (r.visible = this.axis.search(r.name) !== -1));
        continue;
      }
      r.quaternion.copy(s), this.mode === "translate" || this.mode === "scale" ? (r.name === "X" && Math.abs(xt.copy(Zs).applyQuaternion(s).dot(this.eye)) > 0.99 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = false), r.name === "Y" && Math.abs(xt.copy(es).applyQuaternion(s).dot(this.eye)) > 0.99 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = false), r.name === "Z" && Math.abs(xt.copy(qs).applyQuaternion(s).dot(this.eye)) > 0.99 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = false), r.name === "XY" && Math.abs(xt.copy(qs).applyQuaternion(s).dot(this.eye)) < 0.2 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = false), r.name === "YZ" && Math.abs(xt.copy(Zs).applyQuaternion(s).dot(this.eye)) < 0.2 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = false), r.name === "XZ" && Math.abs(xt.copy(es).applyQuaternion(s).dot(this.eye)) < 0.2 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = false)) : this.mode === "rotate" && (Ii.copy(s), xt.copy(this.eye).applyQuaternion(Ct.copy(s).invert()), r.name.search("E") !== -1 && r.quaternion.setFromRotationMatrix(go.lookAt(this.eye, mo, es)), r.name === "X" && (Ct.setFromAxisAngle(Zs, Math.atan2(-xt.y, xt.z)), Ct.multiplyQuaternions(Ii, Ct), r.quaternion.copy(Ct)), r.name === "Y" && (Ct.setFromAxisAngle(es, Math.atan2(xt.x, xt.z)), Ct.multiplyQuaternions(Ii, Ct), r.quaternion.copy(Ct)), r.name === "Z" && (Ct.setFromAxisAngle(qs, Math.atan2(xt.y, xt.x)), Ct.multiplyQuaternions(Ii, Ct), r.quaternion.copy(Ct))), r.visible = r.visible && (r.name.indexOf("X") === -1 || this.showX), r.visible = r.visible && (r.name.indexOf("Y") === -1 || this.showY), r.visible = r.visible && (r.name.indexOf("Z") === -1 || this.showZ), r.visible = r.visible && (r.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), r.material._color = r.material._color || r.material.color.clone(), r.material._opacity = r.material._opacity || r.material.opacity, r.material.color.copy(r.material._color), r.material.opacity = r.material._opacity, this.enabled && this.axis && (r.name === this.axis || this.axis.split("").some(function(a) {
        return r.name === a;
      })) && (r.material.color.setHex(16776960), r.material.opacity = 1);
    }
    super.updateMatrixWorld(t);
  }
};
var Td = class extends Mesh {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new MeshBasicMaterial({ visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false })
    ), this.isTransformControlsPlane = true, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(t) {
    let e = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (e = "local"), zi.copy(Zs).applyQuaternion(e === "local" ? this.worldQuaternion : Gi), Ws.copy(es).applyQuaternion(e === "local" ? this.worldQuaternion : Gi), Xs.copy(qs).applyQuaternion(e === "local" ? this.worldQuaternion : Gi), xt.copy(Ws), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            xt.copy(this.eye).cross(zi), ve2.copy(zi).cross(xt);
            break;
          case "Y":
            xt.copy(this.eye).cross(Ws), ve2.copy(Ws).cross(xt);
            break;
          case "Z":
            xt.copy(this.eye).cross(Xs), ve2.copy(Xs).cross(xt);
            break;
          case "XY":
            ve2.copy(Xs);
            break;
          case "YZ":
            ve2.copy(zi);
            break;
          case "XZ":
            xt.copy(Xs), ve2.copy(Ws);
            break;
          case "XYZ":
          case "E":
            ve2.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        ve2.set(0, 0, 0);
    }
    ve2.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (_o.lookAt(jt.set(0, 0, 0), ve2, xt), this.quaternion.setFromRotationMatrix(_o)), super.updateMatrixWorld(t);
  }
};
var xr = class _xr {
  constructor(t, e, s, i, n, r = 5, o = true) {
    if (E(this, "onDraggingStarted", new tt()), E(this, "onDraggingEnded", new tt()), E(this, "onDisposed", new tt()), E(this, "normal"), E(this, "origin"), E(this, "three", new Plane()), E(this, "components"), E(this, "world"), E(this, "type", "default"), E(this, "_title", "Clipping Plane"), E(this, "_helper"), E(this, "_visible", true), E(this, "_enabled", true), E(this, "_controlsActive", false), E(this, "_arrowBoundBox", new Mesh()), E(this, "_planeMesh"), E(this, "_controls"), E(this, "_hiddenMaterial", new MeshBasicMaterial({
      visible: false
    })), E(this, "_visibilityBeforeDisabled", true), E(this, "notifyManager", () => {
      const a = this.components.get(Ve), c = a.list.getKey(this);
      c && a.list.set(c, this);
    }), E(this, "update", () => {
      this._enabled && this.three.setFromNormalAndCoplanarPoint(
        this.normal,
        this._helper.position
      );
    }), E(this, "changeDrag", (a) => {
      this._visible = !a.value, this.preventCameraMovement(), this.notifyDraggingChanged(a);
    }), this.components = t, this.world = e, !e.renderer)
      throw new Error("The given world must have a renderer!");
    this.normal = i, this.origin = s, e.renderer.setPlane(true, this.three), this._planeMesh = _xr.newPlaneMesh(r, n), this._helper = this.newHelper(), this._controls = this.newTransformControls(), this.three.setFromNormalAndCoplanarPoint(i, s), o && this.toggleControls(true);
  }
  set title(t) {
    this._title = t, this.notifyManager();
  }
  get title() {
    return this._title;
  }
  /**
   * Getter for the enabled state of the clipping plane.
   * @returns {boolean} The current enabled state.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Setter for the enabled state of the clipping plane.
   * Updates the clipping plane state in the renderer and throws an error if no renderer is found.
   * @param {boolean} state - The new enabled state.
   */
  set enabled(t) {
    if (!this.world.isDisposing) {
      if (!this.world.renderer)
        throw new Error("No renderer found for clipping plane!");
      this._enabled = t, t ? this.visible = this._visibilityBeforeDisabled : (this._visibilityBeforeDisabled = this.visible, this.visible = false), this.world.renderer.setPlane(t, this.three), this.notifyManager();
    }
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(t) {
    this._visible = t, this._controls.getHelper().visible = t, this._helper.visible = t, this.toggleControls(t), this.notifyManager();
  }
  /** The meshes used for raycasting */
  get meshes() {
    return [this._planeMesh, this._arrowBoundBox];
  }
  /** The material of the clipping plane representation. */
  get planeMaterial() {
    return this._planeMesh.material;
  }
  /** The material of the clipping plane representation. */
  set planeMaterial(t) {
    this._planeMesh.material = t;
  }
  /** The size of the clipping plane representation. */
  get size() {
    return this._planeMesh.scale.x;
  }
  /** Sets the size of the clipping plane representation. */
  set size(t) {
    this._planeMesh.scale.set(t, t, t);
  }
  /**
   * Getter for the helper object of the clipping plane.
   * The helper object is a THREE.Object3D that contains the clipping plane mesh and other related objects.
   * It is used for positioning, rotating, and scaling the clipping plane in the 3D scene.
   *
   * @returns {THREE.Object3D} The helper object of the clipping plane.
   */
  get helper() {
    return this._helper;
  }
  /**
   * Sets the clipping plane's normal and origin from the given normal and point.
   * This method resets the clipping plane's state, updates the normal and origin,
   * and positions the helper object accordingly.
   *
   * @param normal - The new normal vector for the clipping plane.
   * @param point - The new origin point for the clipping plane.
   *
   * @returns {void}
   */
  setFromNormalAndCoplanarPoint(t, e) {
    this.reset(), this.normal.equals(t) || (this.normal.copy(t), this._helper.lookAt(t)), this.origin.copy(e), this._helper.position.copy(e), this._helper.updateMatrix(), this.update();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = false, this.onDraggingStarted.reset(), this.onDraggingEnded.reset(), this._helper.removeFromParent(), this.world.renderer && this.world.renderer.setPlane(false, this.three), this._arrowBoundBox.removeFromParent(), this._arrowBoundBox.geometry.dispose(), this._planeMesh.geometry.dispose(), this._controls.getHelper().removeFromParent(), this._controls.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  reset() {
    const t = new Vector3(1, 0, 0), e = new Vector3();
    this.normal.equals(t) || (this.normal.copy(t), this._helper.lookAt(t)), this.origin.copy(e), this._helper.position.copy(e), this._helper.updateMatrix();
  }
  toggleControls(t) {
    if (t) {
      if (this._controlsActive)
        return;
      this._controls.addEventListener("change", this.update), this._controls.addEventListener("dragging-changed", this.changeDrag);
    } else
      this._controls.removeEventListener("change", this.update), this._controls.removeEventListener("dragging-changed", this.changeDrag);
    this._controlsActive = t;
  }
  newTransformControls() {
    if (!this.world.renderer)
      throw new Error("No renderer found for clipping plane!");
    const t = this.world.camera.three, e = this.world.renderer.three.domElement, s = new _d(t, e);
    return this.initializeControls(s), this.world.scene.three.add(s.getHelper()), s;
  }
  initializeControls(t) {
    t.attach(this._helper), t.showX = false, t.showY = false, t.setSpace("local"), this.createArrowBoundingBox(), t.getHelper().children[0].children[0].add(this._arrowBoundBox);
  }
  createArrowBoundingBox() {
    this._arrowBoundBox.geometry = new CylinderGeometry(0.18, 0.18, 1.2), this._arrowBoundBox.material = this._hiddenMaterial, this._arrowBoundBox.rotateX(Math.PI / 2), this._arrowBoundBox.updateMatrix(), this._arrowBoundBox.geometry.applyMatrix4(this._arrowBoundBox.matrix);
  }
  notifyDraggingChanged(t) {
    t.value ? this.onDraggingStarted.trigger() : this.onDraggingEnded.trigger();
  }
  preventCameraMovement() {
    this.world.camera.enabled = this._visible;
  }
  newHelper() {
    const t = new Object3D();
    return t.lookAt(this.normal), t.position.copy(this.origin), this._planeMesh.position.z += 0.01, t.add(this._planeMesh), this.world.scene.three.add(t), t;
  }
  static newPlaneMesh(t, e) {
    const s = new PlaneGeometry(1), i = new Mesh(s, e);
    return i.scale.set(t, t, t), i;
  }
};
var Cd = class extends fn {
  constructor() {
    super(...arguments), E(this, "_config", {
      enabled: {
        value: true,
        type: "Boolean"
      },
      visible: {
        value: true,
        type: "Boolean"
      },
      color: {
        value: new Color(),
        type: "Color"
      },
      opacity: {
        type: "Number",
        interpolable: true,
        value: 1,
        min: 0,
        max: 1
      },
      size: {
        type: "Number",
        interpolable: true,
        value: 2,
        min: 0,
        max: 100
      }
    });
  }
  get enabled() {
    return this._config.enabled.value;
  }
  set enabled(t) {
    this._config.enabled.value = t, this._component.enabled = t;
  }
  get visible() {
    return this._config.visible.value;
  }
  set visible(t) {
    this._config.visible.value = t, this._component.visible = t;
  }
  get color() {
    return this._config.color.value;
  }
  set color(t) {
    this._config.color.value = t, this._component.material.color.copy(t);
  }
  get opacity() {
    return this._config.opacity.value;
  }
  set opacity(t) {
    this._config.opacity.value = t, this._component.material.opacity = t;
  }
  get size() {
    return this._config.size.value;
  }
  set size(t) {
    this._config.size.value = t, this._component.size = t;
  }
};
var Ia = class Zi extends St {
  constructor(t) {
    super(t), E(this, "onSetup", new tt()), E(this, "onBeforeDrag", new tt()), E(this, "onAfterDrag", new tt()), E(this, "onBeforeCreate", new tt()), E(this, "onBeforeCancel", new tt()), E(this, "onAfterCancel", new tt()), E(this, "onBeforeDelete", new tt()), E(this, "onAfterCreate", new tt()), E(this, "onAfterDelete", new tt()), E(this, "onDisposed", new tt()), E(this, "isSetup", false), E(this, "orthogonalY", false), E(this, "toleranceOrthogonalY", 0.7), E(this, "Type", xr), E(this, "list", new Yt()), E(this, "config", new Cd(
      this,
      this.components,
      "Clipper",
      Zi.uuid
    )), E(this, "_defaultConfig", {
      color: new Color(12255487),
      opacity: 0.2,
      size: 2
    }), E(this, "_material", new MeshBasicMaterial({
      color: 12255487,
      side: DoubleSide,
      transparent: true,
      opacity: 0.2
    })), E(this, "_size", 5), E(this, "_enabled", false), E(this, "_visible", true), E(this, "_onStartDragging", () => {
      this.onBeforeDrag.trigger();
    }), E(this, "_onEndDragging", () => {
      this.onAfterDrag.trigger();
    }), this.components.add(Zi.uuid, this), this.setEvents();
  }
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(t) {
    this._enabled = t;
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(t) {
    this._visible = t;
    for (const [e, s] of this.list)
      s.visible = t;
  }
  /** The material of the clipping plane representation. */
  get material() {
    return this._material;
  }
  /** The material of the clipping plane representation. */
  set material(t) {
    this._material = t;
    for (const [e, s] of this.list)
      s.planeMaterial = t;
  }
  /** The size of the geometric representation of the clippings planes. */
  get size() {
    return this._size;
  }
  /** The size of the geometric representation of the clippings planes. */
  set size(t) {
    this._size = t;
    for (const [e, s] of this.list)
      s.size = t;
  }
  setEvents() {
    this.list.onBeforeDelete.add(({ value: t }) => {
      if (!t.world.renderer)
        throw new Error("Renderer not found for this plane's world!");
      t.world.renderer.setPlane(false, t.three), t.dispose(), this.updateMaterialsAndPlanes();
    });
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = false, this.components.get(_r).list.delete(this.config.uuid), this.list.clear(), this._material.dispose(), this.onBeforeCreate.reset(), this.onBeforeCancel.reset(), this.onBeforeDelete.reset(), this.onBeforeDrag.reset(), this.onAfterCreate.reset(), this.onAfterCancel.reset(), this.onAfterDelete.reset(), this.onAfterDrag.reset(), this.onDisposed.trigger(Zi.uuid), this.onDisposed.reset();
  }
  /** {@link Createable.create} */
  async create(t) {
    const i = await this.components.get(me).get(t).castRay();
    return i ? this.createPlaneFromIntersection(t, i) : null;
  }
  /**
   * Creates a plane in a certain place and with a certain orientation,
   * without the need of the mouse.
   *
   * @param world - the world where this plane should be created.
   * @param normal - the orientation of the clipping plane.
   * @param point - the position of the clipping plane.
   * navigation.
   */
  createFromNormalAndCoplanarPoint(t, e, s) {
    const i = this.newPlane(t, s, e);
    return this.updateMaterialsAndPlanes(), i;
  }
  /**
   * {@link Createable.delete}
   *
   * @param world - the world where the plane to delete is.
   * @param planeId - the plane to delete. If undefined, the first plane
   * found under the cursor will be deleted.
   */
  async delete(t, e) {
    if (!e) {
      const s = await this.pickPlane(t);
      if (!s)
        return;
      e = this.list.getKey(s);
    }
    e && this.list.delete(e);
  }
  /**
   * Deletes all the existing clipping planes.
   *
   * @param types - the types of planes to be deleted. If not provided, all planes will be deleted.
   */
  deleteAll(t) {
    for (const [e, s] of this.list)
      (!t || t.has(s.type)) && this.list.delete(e);
  }
  /** {@link Configurable.setup} */
  setup(t) {
    const e = { ...this._defaultConfig, ...t };
    this.config.color = e.color, this.config.opacity = e.opacity, this.config.size = e.size, this.isSetup = true, this.onSetup.trigger();
  }
  // private deletePlane(plane: SimplePlane) {
  //   const index = this.list.indexOf(plane);
  //   if (index !== -1) {
  //     this.list.splice(index, 1);
  //     if (!plane.world.renderer) {
  //       throw new Error("Renderer not found for this plane's world!");
  //     }
  //     plane.world.renderer.setPlane(false, plane.three);
  //     plane.dispose();
  //     this.updateMaterialsAndPlanes();
  //     this.onAfterDelete.trigger(plane);
  //   }
  // }
  async pickPlane(t) {
    const s = this.components.get(me).get(t), i = this.getAllPlaneMeshes(), n = await s.castRay({ items: i });
    if (n) {
      const r = n.object;
      return [...this.list.values()].find((o) => o.meshes.includes(r));
    }
  }
  getAllPlaneMeshes() {
    const t = [];
    for (const [e, s] of this.list)
      t.push(...s.meshes);
    return t;
  }
  createPlaneFromIntersection(t, e) {
    var s;
    if (!t.renderer)
      throw new Error("The given world must have a renderer!");
    const i = e.point.distanceTo(new Vector3(0, 0, 0)), n = e.normal || ((s = e.face) == null ? void 0 : s.normal);
    if (!i || !n)
      return null;
    const r = this.getWorldNormal(e, n), o = this.newPlane(t, e.point, r.negate()), a = this.list.get(o);
    return a.visible = this._visible, a.size = this._size, t.renderer.setPlane(true, a.three), this.updateMaterialsAndPlanes(), a;
  }
  getWorldNormal(t, e) {
    const s = t.object;
    let i = t.object.matrixWorld.clone();
    if (s instanceof InstancedMesh && t.instanceId !== void 0) {
      const a = new Matrix4();
      s.getMatrixAt(t.instanceId, a), i = a.multiply(i);
    }
    const r = new Matrix3().getNormalMatrix(i), o = e.clone().applyMatrix3(r).normalize();
    return this.normalizePlaneDirectionY(o), o;
  }
  normalizePlaneDirectionY(t) {
    this.orthogonalY && (t.y > this.toleranceOrthogonalY && (t.x = 0, t.y = 1, t.z = 0), t.y < -this.toleranceOrthogonalY && (t.x = 0, t.y = -1, t.z = 0));
  }
  newPlane(t, e, s) {
    const i = new this.Type(
      this.components,
      t,
      e,
      s,
      this._material
    );
    i.onDraggingStarted.add(this._onStartDragging), i.onDraggingEnded.add(this._onEndDragging);
    const n = Xt.create();
    return this.list.set(n, i), this.onAfterCreate.trigger(i), n;
  }
  updateMaterialsAndPlanes() {
    const t = this.components.get(wa);
    for (const [e, s] of t.list) {
      if (!s.renderer)
        continue;
      s.renderer.updateClippingPlanes();
      const { clippingPlanes: i } = s.renderer;
      for (const n of s.meshes)
        if (n.material)
          if (Array.isArray(n.material))
            for (const r of n.material)
              r.clippingPlanes = i;
          else
            n.material.clippingPlanes = i;
    }
  }
};
E(Ia, "uuid", "66290bc5-18c4-4cd1-9379-2e17a0617611");
var Ve = Ia;
var za = class {
  constructor(t, e) {
    E(this, "title"), E(this, "guid", Xt.create()), E(this, "clippingPlanes", new Wt()), E(this, "camera", {
      aspect_ratio: 1,
      field_of_view: 60,
      camera_direction: { x: 0, y: 0, z: 0 },
      camera_view_point: { x: 0, y: 0, z: 0 },
      camera_up_vector: { x: 0, y: 1, z: 0 }
    }), E(this, "exceptionComponents", new Wt()), E(this, "selectionComponents", new Wt()), E(this, "componentColors", new Yt()), E(this, "spacesVisible", false), E(this, "spaceBoundariesVisible", false), E(this, "openingsVisible", false), E(this, "defaultVisibility", true), E(this, "snapshot", this.guid), E(this, "_components"), E(this, "_world", null), E(this, "notifyUpdate", () => {
      this._components.get(Oe).list.set(this.guid, this);
    }), this._components = t, e && (this.guid = e.guid ?? this.guid, this.set(e)), this.setEvents();
  }
  async getSelectionMap() {
    return await this._components.get(ct).guidsToModelIdMap([
      ...this.selectionComponents
    ]);
  }
  async getExceptionMap() {
    return await this._components.get(ct).guidsToModelIdMap([
      ...this.exceptionComponents
    ]);
  }
  /**
   * Retrieves the projection type of the viewpoint's camera.
   *
   * @returns A string representing the projection type of the viewpoint's camera.
   *          It can be either 'Perspective' or 'Orthographic'.
   */
  get projection() {
    return "field_of_view" in this.camera ? "Perspective" : "Orthographic";
  }
  /**
   * Retrieves the position vector of the viewpoint's camera.
   *
   * @returns A THREE.Vector3 representing the position of the viewpoint's camera.
   */
  get position() {
    const t = this._components.get(ct), { camera_view_point: e } = this.camera, { x: s, y: i, z: n } = e, r = new Vector3(s, i, n);
    return t.applyBaseCoordinateSystem(r, new Matrix4()), r;
  }
  /**
   * Sets the position of the viewpoint's camera.
   * @param value - The new position for the viewpoint's camera.
   */
  set position(t) {
    const e = t.clone(), s = this._components.get(ct);
    t.clone().applyMatrix4(s.baseCoordinationMatrix.clone().invert()), this.camera.camera_view_point = {
      x: e.x,
      y: e.y,
      z: e.z
    };
  }
  /**
   * Retrieves the direction vector of the viewpoint's camera.
   * @returns A THREE.Vector3 representing the direction of the viewpoint's camera.
   */
  get direction() {
    const { camera_direction: t } = this.camera, { x: e, y: s, z: i } = t;
    return new Vector3(e, s, i);
  }
  /**
   * Represents the world in which the viewpoint will take effect.
   */
  set world(t) {
    this._world = t;
  }
  get world() {
    return this._world;
  }
  get _managerVersion() {
    return this._components.get(Bt).config.version;
  }
  /**
   * Retrieves the list of BCF topics associated with the current viewpoint.
   *
   * @remarks
   * This function retrieves the BCFTopics manager from the components,
   * then filters the list of topics to find those associated with the current viewpoint.
   *
   * @returns An array of BCF topics associated with the current viewpoint.
   */
  get topics() {
    return [...this._components.get(Bt).list.values()].filter(
      (i) => i.viewpoints.has(this.guid)
    );
  }
  // TODO: Remove the notifyUpdate when needed
  setEvents() {
    this.selectionComponents.onUpdated.add(this.notifyUpdate), this.exceptionComponents.onUpdated.add(this.notifyUpdate), this.clippingPlanes.onUpdated.add(this.notifyUpdate), this.componentColors.onItemSet.add(this.notifyUpdate), this.componentColors.onItemDeleted.add(this.notifyUpdate), this.componentColors.onItemUpdated.add(this.notifyUpdate), this.componentColors.onCleared.add(this.notifyUpdate);
  }
  /**
   * Fully replace the properties of the viewpoint with the provided data.
   * The properties not included will remain unchanged.
   *
   * @remarks The guid will be ommited as it shouldn't change after it has been initially set.
   *
   * @param data - An object containing the properties to be set.
   */
  set(t) {
    this.title = t.title;
    const {
      components: e,
      perspective_camera: s,
      orthogonal_camera: i,
      clipping_planes: n
    } = t;
    if (e) {
      const { selection: r, visibility: o, coloring: a } = e;
      if (r) {
        this.selectionComponents.clear();
        for (const { ifc_guid: c } of r)
          c && this.selectionComponents.add(c);
      }
      if (o) {
        const { default_visibility: c, exceptions: h, view_setup_hints: d } = o;
        if (c !== void 0 && (this.defaultVisibility = c), h) {
          this.exceptionComponents.clear();
          for (const { ifc_guid: u } of h)
            u && this.exceptionComponents.add(u);
        }
        if (d) {
          const { spaces_visible: u, space_boundaries_visible: f, openings_visible: g } = d;
          u !== void 0 && (this.spacesVisible = u), f !== void 0 && (this.spaceBoundariesVisible = f), g !== void 0 && (this.openingsVisible = g);
        }
      }
      if (a) {
        this.componentColors.clear();
        for (const c of a) {
          const { color: h, components: d } = c, u = d.map((f) => f.ifc_guid).filter((f) => f !== null);
          this.componentColors.set(h, u);
        }
      }
    }
    if ((s || i) && (this.camera = s ?? i), n && this.world) {
      const r = this._components.get(Ve);
      for (const o of n) {
        const { location: a, direction: c } = o, h = new Vector3(
          a.x,
          a.z,
          -a.y
        ), d = new Vector3(
          c.x,
          c.z,
          -c.y
        ), u = r.createFromNormalAndCoplanarPoint(
          this.world,
          d,
          h
        );
        this.clippingPlanes.add(u), r.list.get(u).enabled = false, r.list.get(u).visible = false;
      }
    }
    this.notifyUpdate();
  }
  /**
   * Sets the viewpoint of the camera in the world.
   *
   * @remarks
   * This function calculates the target position based on the viewpoint information.
   * It sets the visibility of the viewpoint components and then applies the viewpoint using the camera's controls.
   *
   * @param transition - Indicates whether the camera movement should have a transition effect.
   *                      Default value is `true`.
   *
   * @throws An error if the world's camera does not have camera controls.
   *
   * @returns A Promise that resolves when the camera has been set.
   */
  async go(t) {
    if (!this.world)
      return;
    const { camera: e } = this.world;
    if (!(e instanceof Ma))
      throw new Error(
        "Viewpoint: the world's camera component must be of type OrthoPerspectiveCamera to switch between perspective and orthographic projections."
      );
    const { transition: s, applyClippings: i, applyVisibility: n, clippingsVisibility: r } = {
      transition: true,
      applyClippings: true,
      applyVisibility: true,
      clippingsVisibility: true,
      ...t
    };
    e.projection.set(this.projection);
    const o = new Vector3(
      this.camera.camera_view_point.x,
      this.camera.camera_view_point.y,
      this.camera.camera_view_point.z
    ), a = new Vector3(
      this.camera.camera_direction.x,
      this.camera.camera_direction.y,
      this.camera.camera_direction.z
    );
    if (o.equals(new Vector3()) && a.equals(new Vector3()))
      return;
    const c = this.position, h = this.direction, d = 80, u = {
      x: c.x + h.x * d,
      y: c.y + h.y * d,
      z: c.z + h.z * d
    }, f = [];
    i && this.setClippingState(true), n && f.push(this.applyVisibility()), this.setClippingVisibility(r), f.push(
      e.controls.setLookAt(
        c.x,
        c.y,
        c.z,
        u.x,
        u.y,
        u.z,
        s
      )
    ), await Promise.all(f);
  }
  /**
   * Updates the camera settings of the viewpoint based on the current world's camera and renderer.
   * @returns A boolean indicating if the camera data was updated or not.
   */
  async updateCamera(t = true) {
    return new Promise((e) => {
      if (!this.world) {
        e(false);
        return;
      }
      const { camera: s, renderer: i } = this.world;
      if (!i)
        throw new Error("Viewpoint: the world needs to have a renderer!");
      if (!s.hasCameraControls())
        throw new Error("Viewpoint: world's camera need camera controls!");
      const n = new Vector3();
      s.controls.getPosition(n);
      const r = s.three, o = new Vector3(0, 0, -1).applyEuler(
        r.rotation
      ), { width: a, height: c } = i.getSize();
      let h = a / c;
      Number.isNaN(h) && (h = 1);
      const d = this._components.get(ct);
      n.applyMatrix4(d.baseCoordinationMatrix.clone().invert());
      const u = {
        aspect_ratio: h,
        camera_view_point: { x: n.x, y: n.y, z: n.z },
        camera_direction: { x: o.x, y: o.y, z: o.z },
        camera_up_vector: { x: 0, y: 1, z: 0 }
      };
      if (r instanceof PerspectiveCamera ? this.camera = {
        ...u,
        field_of_view: r.fov
      } : r instanceof OrthographicCamera && (this.camera = {
        ...u,
        view_to_world_scale: r.top - r.bottom
      }), t) {
        const f = this._components.get(Oe), g = i.three.domElement;
        i.three.render(this.world.scene.three, s.three), g.toBlob(async (m) => {
          if (m) {
            const _ = await m.arrayBuffer(), p = new Uint8Array(_);
            f.snapshots.set(this.guid, p);
          }
          this.notifyUpdate(), e(true);
        });
      } else
        this.notifyUpdate(), e(true);
    });
  }
  /**
   * Captures a snapshot of the current viewpoint and stores it in the snapshots manager.
   */
  takeSnapshot() {
    return new Promise((t) => {
      if (!this.world) {
        t(false);
        return;
      }
      const { camera: e, renderer: s } = this.world;
      if (!s)
        throw new Error("Viewpoint: the world needs to have a renderer!");
      const i = this._components.get(Oe), n = s.three.domElement;
      s.three.render(this.world.scene.three, e.three), n.toBlob(async (r) => {
        if (r) {
          const o = await r.arrayBuffer(), a = new Uint8Array(o);
          i.snapshots.set(this.guid, a);
        }
        this.notifyUpdate(), t(true);
      });
    });
  }
  /**
   * Updates the collection of clipping planes by clearing the current set and adding enabled planes
   * from the associated `Clipper` component.
   */
  updateClippingPlanes() {
    this.clippingPlanes.clear();
    const t = this._components.get(Ve);
    for (const [e, s] of t.list)
      s.enabled && this.clippingPlanes.add(e);
  }
  /**
   * Applies visibility settings to components based on default visibility, exceptions, and selections.
   *
   * This method adjusts the visibility of components using the `Hider` instance. It ensures that:
   * - The default visibility is applied to all components.
   * - Exceptions are handled to override the default visibility.
   * - Selected components are always visible.
   */
  async applyVisibility() {
    const t = this._components.get(Gc);
    t.set(this.defaultVisibility);
    const e = await this.getExceptionMap();
    t.set(!this.defaultVisibility, e);
    const s = await this.getSelectionMap();
    t.set(true, s);
  }
  // TODO: Analyze how this works along with the Highlighter
  /**
   * Asynchronously sets the colorization state for the viewpoint's components.
   * When the state is true, it applies the defined component colors to the corresponding fragments.
   * When the state is false, it resets the highlight for the corresponding fragments.
   *
   * @param state - A boolean indicating whether to apply or reset the colorization.
   *                If true, the components will be colorized. If false, the colorization will be reset.
   * @returns A Promise that resolves when all colorization or reset operations are complete.
   * @remarks Be careful when using this method along with the Highlighter as it can cause unwanted results
   */
  async setColorizationState(t) {
    const e = this._components.get(ct), s = [];
    if (t)
      for (const [i, n] of this.componentColors) {
        const r = `#${i}`, o = await e.guidsToModelIdMap(n);
        for (const [a, c] of Object.entries(o)) {
          const h = e.list.get(a);
          h && s.push(
            h.highlight([...c], {
              customId: r,
              color: new Color(r),
              renderedFaces: ve.ONE,
              opacity: 1,
              transparent: false
            })
          );
        }
      }
    else
      for (const [i, n] of this.componentColors) {
        const r = await e.guidsToModelIdMap(n);
        for (const [o, a] of Object.entries(r)) {
          const c = e.list.get(o);
          c && s.push(c.resetHighlight([...a]));
        }
      }
    s.push(e.core.update(true)), await Promise.all(s);
  }
  /**
   * Sets the enabled state of all clipping planes associated with this viewpoint.
   * @param state A boolean indicating whether the clipping planes should be enabled or disabled.
   */
  setClippingState(t) {
    const e = this._components.get(Ve);
    for (const [s, i] of e.list)
      i.enabled = t && this.clippingPlanes.has(s);
  }
  /**
   * Sets the visibility of all clipping planes associated with this viewpoint.
   *
   * @param visibility - A boolean indicating whether the clipping planes should be visible (`true`) or hidden (`false`).
   */
  setClippingVisibility(t) {
    const e = this._components.get(Ve);
    for (const s of this.clippingPlanes) {
      const i = e.list.get(s);
      i && (i.visible = t);
    }
  }
  async createComponentTags(t) {
    var e;
    const s = this._components.get(ct), i = this._components.get(Bt);
    let n = "";
    if (i.config.includeSelectionTag) {
      const r = t === "selection" ? await this.getSelectionMap() : await this.getExceptionMap();
      for (const o in r) {
        const a = s.list.get(o);
        if (!a)
          continue;
        const c = r[o];
        for (const h of c) {
          const d = a.getItem(h), u = await d.getGuid();
          if (!u)
            continue;
          const f = (e = await d.getAttributes()) == null ? void 0 : e.getValue("Tag");
          let g = null;
          f && (g = `AuthoringToolId="${f}"`), n += `
<Component IfcGuid="${u}" ${g ?? ""} />`;
        }
      }
    } else
      n = [...this.selectionComponents].map((r) => `<Component IfcGuid="${r}" />`).join(`
`);
    return n;
  }
  createColorTags() {
    let t = "";
    for (const [e, s] of this.componentColors.entries()) {
      const i = s.map((n) => `
<Component IfcGuid="${n}" />`).join(`
`);
      t += `<Color Color="${e}">
${i}
</Color>`;
    }
    return t.length !== 0 ? `<Coloring>
${t}
</Coloring>` : "<Coloring />";
  }
  /**
   * Converts the current viewpoint instance into a JSON representation compliant with the BCFViewpoint format.
   *
   * @returns A BCF API JSON complaint object representing the viewpoint, including its GUID, components,
   * visibility settings, clipping planes, camera configuration, and snapshot data.
   */
  toJSON() {
    const t = this._components.get(Ve), e = {
      guid: this.guid,
      components: {
        selection: [...this.selectionComponents].map((n) => ({ ifc_guid: n, authoring_tool_id: null })),
        coloring: [...this.componentColors].map(([n, r]) => ({
          color: n,
          components: r.map((o) => ({ ifc_guid: o, authoring_tool_id: null }))
        })),
        visibility: {
          default_visibility: this.defaultVisibility,
          exceptions: [...this.exceptionComponents].map((n) => ({ ifc_guid: n, authoring_tool_id: null })),
          view_setup_hints: {
            spaces_visible: this.spacesVisible,
            space_boundaries_visible: this.spaceBoundariesVisible,
            openings_visible: this.openingsVisible
          }
        }
      },
      clipping_planes: [...this.clippingPlanes].map((n) => {
        const r = t.list.get(n);
        if (!r)
          return null;
        const o = r._controls.worldPosition ?? r.origin, { normal: a } = r;
        return {
          location: { x: o.x, y: -o.z, z: o.y },
          direction: { x: a.x, y: -a.z, z: a.y }
        };
      }).filter((n) => n !== null)
    };
    "field_of_view" in this.camera ? e.perspective_camera = this.camera : e.orthogonal_camera = this.camera;
    const s = this._components.get(Oe), i = s.snapshots.get(this.snapshot);
    if (i) {
      const n = i.toString(), r = btoa(n), o = s.getSnapshotExtension(this.snapshot);
      e.snapshot = { snapshot_type: o, snapshot_data: r };
    }
    return e;
  }
  /**
   * Serializes the viewpoint into a buildingSMART compliant XML string for export.
   *
   * @param version - The version of the BCF Manager to use for serialization.
   *                   If not provided, the current version of the manager will be used.
   *
   * @returns A Promise that resolves to an XML string representing the viewpoint.
   *          The XML string follows the BCF VisualizationInfo schema.
   *
   * @throws An error if the world's camera does not have camera controls.
   * @throws An error if the world's renderer is not available.
   */
  async serialize(t = this._managerVersion) {
    const e = this._components.get(ct), s = this.position;
    s.applyMatrix4(e.baseCoordinationMatrix.clone().invert());
    const i = this.direction;
    i.normalize();
    const n = new Matrix4().makeRotationX(Math.PI / 2), r = i.clone().applyMatrix4(n);
    r.normalize();
    const o = `<CameraViewPoint>
      <X>${s.x}</X>
      <Y>${-s.z}</Y>
      <Z>${s.y}</Z>
    </CameraViewPoint>`, a = `<CameraDirection>
      <X>${i.x}</X>
      <Y>${-i.z}</Y>
      <Z>${i.y}</Z>
    </CameraDirection>`, c = `<CameraUpVector>
      <X>${r.x}</X>
      <Y>${-r.z}</Y>
      <Z>${r.y}</Z>
    </CameraUpVector>`, h = `<AspectRatio>${this.camera.aspect_ratio}</AspectRatio>`;
    let d = "";
    "viewToWorld" in this.camera ? d = `<OrthogonalCamera>
        ${o}
        ${a}
        ${c}
        ${h}
        <ViewToWorldScale>${this.camera.viewToWorld}</ViewToWorldScale>
      </OrthogonalCamera>` : "fov" in this.camera && (d = `<PerspectiveCamera>
        ${o}
        ${a}
        ${c}
        ${h}
        <FieldOfView>${this.camera.fov}</FieldOfView>
      </PerspectiveCamera>`);
    const u = `<ViewSetupHints SpacesVisible="${this.spacesVisible ?? false}" SpaceBoundariesVisible="${this.spaceBoundariesVisible ?? false}" OpeningsVisible="${this.openingsVisible ?? false}" />`, f = (await this.createComponentTags("selection")).trim(), g = (await this.createComponentTags("exception")).trim(), m = this.createColorTags();
    return `<?xml version="1.0" encoding="UTF-8"?>
    <VisualizationInfo Guid="${this.guid}">
      <Components>
        ${t === "2.1" ? u : ""}
        ${f.length !== 0 ? `<Selection>${f}</Selection>` : ""}
        <Visibility DefaultVisibility="${this.defaultVisibility}">
          ${t === "3" ? u : ""}
          ${g.length !== 0 ? `<Exceptions>${g}</Exceptions>` : ""}
        </Visibility>
        ${m}
      </Components>
      ${d}
    </VisualizationInfo>`;
  }
};
var Ad = class extends fn {
  constructor() {
    super(...arguments), E(this, "_config", {
      overwriteColors: {
        value: false,
        type: "Boolean"
      }
    });
  }
  get overwriteColors() {
    return this._config.overwriteColors.value;
  }
  set overwriteColors(t) {
    this._config.overwriteColors.value = t;
  }
};
var La = class ar extends St {
  constructor(t) {
    super(t), E(this, "enabled", true), E(this, "world", null), E(this, "list", new Yt()), E(this, "snapshots", new Yt()), E(this, "isSetup", false), E(this, "onSetup", new tt()), E(this, "config", new Ad(
      this,
      this.components,
      "Viewpoints",
      ar.uuid
    )), E(this, "onDisposed", new tt()), t.add(ar.uuid, this);
  }
  /**
   * Creates a new Viewpoint instance and adds it to the list.
   *
   * @param data - Optional partial data for the Viewpoint. If not provided, default data will be used.
   *
   * @returns The newly created Viewpoint instance.
   */
  create(t) {
    const e = new za(this.components, t);
    return e.world = this.world, t || this.list.set(e.guid, e), e;
  }
  /**
   * Determines the file extension of a snapshot based on its header bytes.
   *
   * @param name - The name of the snapshot from the list to retrieve its extension.
   * @returns The file extension as a string. Defaults to "jpeg" if the snapshot
   *          does not exist or the header bytes do not match known formats.
   */
  getSnapshotExtension(t) {
    let e = "jpeg";
    const s = this.snapshots.get(t);
    if (!s)
      return e;
    const i = s.subarray(0, 4);
    let n = "";
    for (let r = 0; r < i.length; r++)
      n += i[r].toString(16);
    return n.startsWith("89504e47") && (e = "png"), n.startsWith("ffd8ffe") && (e = "jpeg"), e;
  }
  setup() {
  }
  /**
   * Disposes of the Viewpoints component and its associated resources.
   *
   * This method is responsible for cleaning up any resources held by the Viewpoints component,
   * such as disposing of the DataMap of Viewpoint instances and triggering and resetting the
   * onDisposed event.
   */
  dispose() {
    this.list.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
E(La, "uuid", "ee867824-a796-408d-8aa0-4e5962a83c66");
var Oe = La;
var yo = class {
  constructor(t, e) {
    E(this, "_components"), E(this, "_cameraOffset", 10), E(this, "_planeHelper"), E(this, "_farPlaneHelper"), E(this, "_cameraHelper"), E(this, "onStateChanged", new tt()), E(this, "onUpdated", new tt()), E(this, "onDisposed", new tt()), E(this, "camera"), E(this, "plane", new Plane()), E(this, "farPlane", new Plane()), E(this, "id", Xt.create()), E(this, "_open", false), E(this, "_range", Pd.defaultRange), E(this, "_world", null), E(this, "_helpersVisible", false), E(this, "_planesEnabled", false), this._components = t, this.camera = new Ma(this._components);
    const { threeOrtho: s } = this.camera;
    if (e != null && e.id && (this.id = e.id), e != null && e.normal && (e != null && e.point)) {
      const { normal: i, point: n } = e;
      this.plane.setFromNormalAndCoplanarPoint(i, n);
    }
    this._cameraHelper = new CameraHelper(s), this._planeHelper = new PlaneHelper(this.plane, 50), this._farPlaneHelper = new PlaneHelper(this.farPlane, 50), this.farPlaneHelperColor = new Color("blue"), this.update();
  }
  get _planeNormalOpposite() {
    return this.plane.normal.clone().negate();
  }
  get _planePosition() {
    return this.plane.normal.clone().multiplyScalar(-this.plane.constant);
  }
  get _cameraPosition() {
    return this._planePosition.addScaledVector(
      this._planeNormalOpposite,
      this._cameraOffset
    );
  }
  set open(t) {
    this._open = t, this.onStateChanged.trigger(["open"]);
  }
  get open() {
    return this._open;
  }
  set planeHelperColor(t) {
    !Array.isArray(this._planeHelper.material) && "color" in this._planeHelper.material && this._planeHelper.material.color instanceof Color && (this._planeHelper.material.color = t);
  }
  set farPlaneHelperColor(t) {
    !Array.isArray(this._farPlaneHelper.material) && "color" in this._farPlaneHelper.material && this._farPlaneHelper.material.color instanceof Color && (this._farPlaneHelper.material.color = t);
  }
  set range(t) {
    this._range = t, this.update();
  }
  get range() {
    return this._range;
  }
  set distance(t) {
    this.plane.constant = t, this.update();
  }
  get distance() {
    return this.plane.constant;
  }
  set world(t) {
    this._world = t, this.camera.currentWorld = t, t && (this.camera.projection.set("Orthographic"), this.camera.set("Plan"), this.camera.controls.dollySpeed = 6, this.camera.controls.restThreshold = 5e-3, this.update());
  }
  get world() {
    return this._world;
  }
  set helpersVisible(t) {
    if (!t) {
      this._helpersVisible = t, this._planeHelper.removeFromParent(), this._farPlaneHelper.removeFromParent(), this._cameraHelper.removeFromParent();
      return;
    }
    this.world && (this._helpersVisible = t, this.world.scene.three.add(
      this._planeHelper,
      this._farPlaneHelper
      // this._cameraHelper,
    ));
  }
  get helpersVisible() {
    return this._helpersVisible;
  }
  // for debugging purposes
  // Section the model based on the planes
  // without using the camera
  set planesEnabled(t) {
    const { world: e } = this;
    if (!e)
      return;
    const { renderer: s } = e;
    s && (s.setPlane(t, this.plane), s.setPlane(t, this.farPlane), this._planesEnabled = t);
  }
  get planesEnabled() {
    return this._planesEnabled;
  }
  dispose() {
    this.helpersVisible = false;
    const t = this._components.get(De);
    t.destroy(this._planeHelper), t.destroy(this._farPlaneHelper), t.destroy(this._cameraHelper), this.camera.dispose(), this.onDisposed.trigger();
  }
  // update based on changes made to this.plane
  update() {
    if (this.world) {
      const t = this._cameraPosition, e = this._planePosition;
      this.camera.controls.setLookAt(
        t.x,
        t.y,
        t.z,
        e.x,
        e.y,
        e.z,
        false
      );
    }
    this.farPlane.normal.copy(this._planeNormalOpposite), this.farPlane.constant = this.range - this.plane.constant, this.onUpdated.trigger();
  }
  flip() {
    this.plane.normal.negate(), this.update();
  }
};
var Sr = class Na extends St {
  constructor(t) {
    super(t), E(this, "list", new Yt()), E(this, "enabled", true), E(this, "world", null), E(this, "_fragmentsUpdateEvent", () => {
      this.components.get(ct).core.update(true);
    }), t.add(Na.uuid, this), this.setupEvents();
  }
  /**
   * Determines whether there are any open views in this component's list.
   */
  get hasOpenViews() {
    return [...this.list.values()].some((t) => t.open);
  }
  setupEvents() {
    this.list.onBeforeDelete.add(({ key: t, value: e }) => {
      e.open && this.close(t), e.dispose();
    });
  }
  /**
   * Creates a new view with the specified normal vector, point, and optional configuration.
   *
   * @param normal - The normal vector defining the orientation of the view.
   * @param point - The point in space where the view is centered.
   * @param config - Optional configuration for the view creation.
   * @returns The newly created `View` instance.
   * @remarks The created view will be added to the component's list data map.
   */
  create(t, e, s) {
    const i = new yo(this.components, { id: s == null ? void 0 : s.id, normal: t, point: e });
    return i.world = (s == null ? void 0 : s.world) ?? this.world, this.list.set(i.id, i), i;
  }
  /**
   * Creates a new view from the specified plane and optional configuration.
   *
   * @param plane - The `THREE.Plane` object representing the plane to create the view from.
   * @param config - Optional configuration for creating the view.
   * @returns The newly created `View` instance.
   * @remarks The created view will be added to the component's list data map.
   */
  createFromPlane(t, e) {
    const s = new yo(this.components, { id: e == null ? void 0 : e.id });
    return s.plane.copy(t), s.update(), s.world = (e == null ? void 0 : e.world) ?? this.world, this.list.set(s.id, s), s;
  }
  /**
   * Creates views from IFC storeys based on the provided configuration.
   * This method iterates through the fragments of the model, filters storeys
   * based on the configuration, and generates views for each storey.
   *
   * @param config - Optional configuration for creating views from IFC storeys.
   * @returns A promise that resolves to an array of `View` objects created from the IFC storeys.
   *
   * @remarks Each IfcBuilsingStorey is represented as a plane in 3D space, with its elevation adjusted by the `offset`. The created views will be added to the component's list data map.
   */
  async createFromIfcStoreys(t) {
    const e = [], s = this.components.get(ct), i = (t == null ? void 0 : t.offset) === void 0 ? 0.25 : t.offset;
    for (const [n, r] of s.list) {
      if (t && t.modelIds && !t.modelIds.some((d) => d.test(n)))
        continue;
      const o = Object.values(
        await r.getItemsOfCategories([/BUILDINGSTOREY/])
      ).flat();
      if (o.length === 0)
        continue;
      const a = await r.getItemsData(o), [, c] = await r.getCoordinates(), h = new Vector3(0, -1, 0);
      for (const d of a) {
        if (!("value" in d.Name && "value" in d.Elevation))
          continue;
        const { value: u } = d.Name;
        if (t != null && t.storeyNames && !t.storeyNames.some((_) => _.test(u)))
          continue;
        const f = d.Elevation.value + c + i, g = new Plane(h, f), m = this.createFromPlane(g, {
          id: u,
          world: t == null ? void 0 : t.world
        });
        e.push(m);
      }
    }
    return e;
  }
  /**
   * Creates views representing the front, back, left, and right sides of bounding boxes for specified models or a combined bounding box of all models.
   *
   * @param config - Optional configuration object for creating bounding views.
   * @returns A promise that resolves to an array of `View` objects created from the boundings.
   * @remarks The method calculates bounding boxes for the specified models, optionally combines them into a single bounding box, and creates views for the planes representing the bounding box sides.
   */
  createElevations(t) {
    const e = [], s = this.components.get(ct), i = (t == null ? void 0 : t.combine) === void 0 ? false : t.combine, n = (t == null ? void 0 : t.namingCallback) ?? ((o) => ({
      front: `${i ? "Front" : `${o}: Front`}`,
      back: `${i ? "Back" : `${o}: Back`}`,
      left: `${i ? "Left" : `${o}: Left`}`,
      right: `${i ? "Right" : `${o}: Right`}`
    }));
    let r = [];
    for (const [o, a] of s.list)
      t && t.modelIds && !t.modelIds.some((c) => c.test(o)) || r.push({ id: o, box: a.box });
    if (i) {
      const o = this.components.get(ha);
      o.list.clear(), o.list.add(...r.map((c) => c.box)), r = [{ id: "combined", box: o.get() }];
    }
    for (const { id: o, box: a } of r) {
      const { min: c, max: h } = a, d = Math.abs(h.x - c.x), u = Math.abs(h.z - c.z), f = new Vector3();
      a.getCenter(f);
      const g = new Plane(new Vector3(0, 0, -1), h.z), m = new Plane(new Vector3(0, 0, 1), -c.z), _ = new Plane(new Vector3(-1, 0, 0), h.x), p = new Plane(new Vector3(1, 0, 0), -c.x), {
        front: y,
        back: b,
        left: x,
        right: S
      } = n(o), C = this.createFromPlane(g, {
        id: y,
        world: t == null ? void 0 : t.world
      });
      C.range = u;
      const P = this.createFromPlane(m, {
        id: b,
        world: t == null ? void 0 : t.world
      });
      P.range = u;
      const O = this.createFromPlane(_, {
        id: x,
        world: t == null ? void 0 : t.world
      });
      O.range = d;
      const z = this.createFromPlane(p, {
        id: S,
        world: t == null ? void 0 : t.world
      });
      z.range = d, e.push(C, P, O, z);
    }
    return e;
  }
  /**
   * Opens a view by its unique identifier. Ensures that no more than one view
   * is opened in the same world at a time. If the view is already open, the method
   * returns without performing any action.
   *
   * @param id - The unique identifier of the view to open.
   * @remarks This method changes world camera to use the view's.
   */
  open(t) {
    const e = this.list.get(t);
    if (!e)
      throw new Error(`Views: the view with id ${t} doesn't exist.`);
    if (e.open)
      return;
    const { world: s } = e;
    if (!s)
      throw new Error(`Views: no world found for view with id ${t}.`);
    const { renderer: i } = s;
    if (!i)
      throw new Error(
        `Views: no renderer found for world with id ${s.uuid}.`
      );
    for (const [, n] of this.list)
      n.world === s && this.close(n.id);
    i.setPlane(true, e.plane), i.setPlane(true, e.farPlane), e.camera.controls.addEventListener("rest", this._fragmentsUpdateEvent), s.camera = e.camera, e.open = true;
  }
  /**
   * Closes a view by its unique identifier and performs necessary cleanup operations.
   *
   * @param id - The unique identifier of the view to be closed. If not provided, all opened views across worlds will be closed.
   * @remarks This method resets the world to use its default camera.
   */
  close(t) {
    let e;
    if (t ? e = this.list.get(t) : e = [...this.list.values()].find((n) => n.open), t && !e)
      throw new Error(`Views: the view with id ${t} doesn't exist.`);
    if (!e || !e.open)
      return;
    const { world: s } = e;
    if (!s)
      throw new Error(`Views: no world found for view with id ${t}.`);
    const { renderer: i } = s;
    if (!i)
      throw new Error(
        `Views: no renderer found for world with id ${s.uuid}.`
      );
    i.setPlane(false, e.plane), i.setPlane(false, e.farPlane), e.camera.controls.removeEventListener(
      "rest",
      this._fragmentsUpdateEvent
    ), s.useDefaultCamera(), e.open = false;
  }
};
E(Sr, "uuid", "fb22f1f5-6598-4664-a11d-de8963ae420f");
E(Sr, "defaultRange", 15);
var Pd = Sr;
var As = class {
  constructor(t) {
    E(this, "cardinality", "required"), E(this, "instructions"), E(this, "evalRequirement", (e, s, i, n) => {
      const r = {
        parameter: i,
        currentValue: e,
        requiredValue: s,
        pass: false
      };
      n && this.addCheckResult(r, n);
      let o = false;
      if (s.type === "simple" && (o = e === s.parameter), s.type === "enumeration" && (o = s.parameter.includes(e)), s.type === "pattern" && (o = new RegExp(s.parameter).test(String(e))), s.type === "length") {
        const { min: a, length: c, max: h } = s.parameter;
        c !== void 0 && (o = String(e).length === c), a !== void 0 && (o = String(e).length >= a), h !== void 0 && (o = String(e).length <= h);
      }
      if (s.type === "bounds" && typeof e == "number") {
        const { min: a, minInclusive: c, max: h, maxInclusive: d } = s.parameter;
        let u = true, f = true;
        a !== void 0 && (u = c ? e >= a : e > a), h !== void 0 && (f = d ? e <= h : e < h), o = u && f;
      }
      return this.cardinality === "prohibited" && (o = !o), this.cardinality === "optional" && (o = true), r.pass = o, r.pass;
    }), this._components = t;
  }
  addCheckResult(t, e) {
    const s = e.findIndex(
      ({ parameter: i }) => i === t.parameter
    );
    s !== -1 ? e[s] = t : e.push(t);
  }
  getItemChecks(t, e, s) {
    if (!("value" in s._localId && typeof s._localId.value == "number"))
      return null;
    let i = t.get(e);
    i || (i = new Yt(), t.set(e, i));
    let n = i.get(s._localId.value);
    if (n) {
      if (!n.pass)
        return null;
    } else {
      const a = [];
      n = {
        guid: Array.isArray(s._guid) ? void 0 : s._guid.value,
        pass: false,
        checks: a
      }, Object.defineProperty(n, "pass", {
        get: () => a.every(({ pass: c }) => c)
      }), i.set(s._localId.value, n);
    }
    const r = [], o = {
      facetType: this.facetType,
      cardinality: this.cardinality,
      checks: r,
      pass: false
    };
    return Object.defineProperty(o, "pass", {
      get: () => r.every(({ pass: a }) => a)
    }), n.checks.push(o), o.checks;
  }
};
var Ce = (l, t) => {
  let e = "";
  if (!t)
    return e;
  if (t.type === "simple" && (e = `<simpleValue>${t.parameter}</simpleValue>`), t.type === "enumeration" && (e = `<xs:restriction base="xs:string">
    ${t.parameter.map((n) => `<xs:enumeration value="${n}" />`).join(`
`)}
    </xs:restriction>`), t.type === "pattern" && (e = `<xs:restriction base="xs:string">
      <xs:pattern value="${t.parameter}" />
    </xs:restriction>`), t.type === "bounds") {
    const { min: i, minInclusive: n, max: r, maxInclusive: o } = t.parameter;
    let a = "";
    i !== void 0 && (a = `<xs:min${n ? "Inclusive" : "Exclusive"} value="${i}">`);
    let c = "";
    r !== void 0 && (c = `<xs:max${o ? "Inclusive" : "Exclusive"} value="${r}">`), e = `<xs:restriction base="xs:double">
      ${a}
      ${c}
    </xs:restriction>`;
  }
  if (t.type === "length") {
    const { length: i, min: n, max: r } = t.parameter;
    let o = "";
    i !== void 0 && n === void 0 && r === void 0 && (o = `<xs:length value="${i}" />`);
    let a = "";
    n !== void 0 && i === void 0 && (a = `<xs:minLength value="${n}" />`);
    let c = "";
    r !== void 0 && i === void 0 && (c = `<xs:maxLength value="${r}" />`), e = `<xs:restriction base="xs:string">
      ${o}
      ${a}
      ${c}
    </xs:restriction>`;
  }
  return `<${l[0].toLowerCase() + l.slice(1)}>
    ${e}
  </${l[0].toLowerCase() + l.slice(1)}>`;
};
var Md = class extends As {
  constructor(t, e) {
    super(t), E(this, "facetType", "Attribute"), E(this, "name"), E(this, "value"), this.name = e;
  }
  serialize(t) {
    const e = Ce("Name", this.name), s = Ce("Value", this.value);
    let i = "";
    return t === "requirement" && (i += `cardinality="${this.cardinality}"`, i += this.instructions ? `instructions="${this.instructions}"` : ""), `<attribute ${i}>
  ${e}
  ${s}
</attribute>`;
  }
  // This can be very ineficcient as we do not have an easy way to get an entity based on an attribute
  // Right now, all entities must be iterated.
  // When the new IfcEntitiesFinder comes, this can become easier.
  // This may be greatly increase in performance if the applicability has any of the other facets and this is applied the latest
  async getEntities() {
  }
  // async getEntities(
  //   model: FRAGS.FragmentsGroup,
  //   collector: FRAGS.IfcProperties = {},
  // ) {
  //   return [];
  //   // for (const expressID in model) {
  //   //   if (collector[expressID]) continue;
  //   //   const entity = model[expressID];
  //   //   // Check if the attribute exists
  //   //   const attribute = entity[this.name];
  //   //   const attributeExists = !!attribute;
  //   //   // Check if the attribute value matches
  //   //   let valueMatches = true;
  //   //   if (attributeExists && this.value && this.value.value) {
  //   //     if (this.value.type === "simpleValue") {
  //   //       valueMatches = attribute.value === this.value.value;
  //   //     }
  //   //     if (this.value.type === "restriction") {
  //   //       const regex = new RegExp(this.value.value);
  //   //       valueMatches = regex.test(attribute.value);
  //   //     }
  //   //   }
  //   //   if (attributeExists && valueMatches) {
  //   //     collector[entity.expressID] = entity;
  //   //   }
  //   // }
  // }
  // https://github.com/buildingSMART/IDS/tree/development/Documentation/ImplementersDocumentation/TestCases/attribute
  // Test cases from buildingSMART repo have been tested and they all match with the expected result
  // All invalid cases have been treated as failures
  // FragmentsGroup do not hold some of the entities used in the tests
  async test(t, e) {
    const s = this._components.get(ct);
    for (const [i, n] of Object.entries(t)) {
      const r = s.list.get(i);
      if (!r)
        continue;
      const o = await r.getItemsData([...n]);
      for (const a of o) {
        const c = this.getItemChecks(e, i, a);
        if (!c)
          continue;
        const d = Object.keys(a).filter((f) => {
          const g = this.evalRequirement(f, this.name, "Name");
          if (!g)
            return false;
          const m = a[f];
          return Array.isArray(m) ? true : m === null || m.value === null ? this.cardinality === "optional" || this.cardinality === "prohibited" : Array.isArray(m.value) && m.value.length === 0 || typeof m.value == "string" && m.value.trim() === "" ? false : g;
        }), u = d.length > 0;
        if (c.push({
          parameter: "Name",
          currentValue: u ? d[0] : null,
          requiredValue: this.name,
          pass: this.cardinality === "prohibited" ? !u : u
        }), this.value)
          if (d[0]) {
            const f = a[d[0]];
            Array.isArray(f) ? c.push({
              parameter: "Value",
              currentValue: null,
              requiredValue: this.value,
              pass: this.cardinality === "prohibited"
            }) : Array.isArray(f.value) ? c.push({
              parameter: "Value",
              currentValue: null,
              requiredValue: this.value,
              pass: this.cardinality === "prohibited"
            }) : this.evalRequirement(
              f.value,
              this.value,
              "Value",
              c
            );
          } else
            c.push({
              parameter: "Value",
              currentValue: null,
              requiredValue: this.value,
              pass: this.cardinality === "prohibited"
            });
      }
    }
  }
};
var Od = class extends As {
  constructor(t, e) {
    super(t), E(this, "facetType", "Classification"), E(this, "system"), E(this, "value"), E(this, "uri"), this.system = e;
  }
  serialize(t) {
    const e = Ce("System", this.system), s = Ce("Value", this.value);
    let i = "";
    return t === "requirement" && (i += `cardinality="${this.cardinality}"`, i += this.uri ? `uri=${this.uri}` : "", i += this.instructions ? `instructions="${this.instructions}"` : ""), `<classification ${i}>
  ${e}
  ${s}
</classification>`;
  }
  async getEntities(t, e) {
  }
  async test(t, e) {
  }
  // private async processReferencedSource(
  //   model: FRAGS.FragmentsGroup,
  //   attrs: Record<string, any>,
  // ) {
  //   const sourceID = attrs.ReferencedSource?.value;
  //   if (!sourceID) return null;
  //   const sourceAttrs = await model.getProperties(sourceID);
  //   if (!sourceAttrs) return null;
  //   if (sourceAttrs.type === WEBIFC.IFCCLASSIFICATIONREFERENCE) {
  //     sourceAttrs.ReferencedSource = await this.processReferencedSource(
  //       model,
  //       sourceAttrs,
  //     );
  //   }
  //   return sourceAttrs;
  // }
  // private async getSystems(model: FRAGS.FragmentsGroup, expressID: number) {
  //   const result: Record<string, any>[] = [];
  //   const indexer = this._components.get(IfcRelationsIndexer);
  //   const ocurrenceAssociations = indexer.getEntityRelations(
  //     model,
  //     expressID,
  //     "HasAssociations",
  //   );
  //   if (ocurrenceAssociations) {
  //     for (const id of ocurrenceAssociations) {
  //       const attrs = await model.getProperties(id);
  //       if (!attrs) continue;
  //       if (attrs.type === WEBIFC.IFCCLASSIFICATION) {
  //         result.push(attrs);
  //       }
  //       if (attrs.type === WEBIFC.IFCCLASSIFICATIONREFERENCE) {
  //         attrs.ReferencedSource = await this.processReferencedSource(
  //           model,
  //           attrs,
  //         );
  //         if (attrs.ReferencedSource) result.push(attrs);
  //       }
  //     }
  //   }
  //   // As occurence classifications prevail over type clasifications
  //   // the classification systems used by the occurrence are get
  //   // so type classifications are not included
  //   const occurrenceSystems = result
  //     .map((attrs) => {
  //       if (attrs.type === WEBIFC.IFCCLASSIFICATION) {
  //         return attrs.Name?.value;
  //       }
  //       if (attrs.type === WEBIFC.IFCCLASSIFICATIONREFERENCE) {
  //         return attrs.ReferencedSource?.Name?.value;
  //       }
  //       return null;
  //     })
  //     .filter((name) => name);
  //   const types = indexer.getEntityRelations(model, expressID, "IsTypedBy");
  //   if (!(types && types[0])) return result;
  //   const type = types[0];
  //   const typeAssociations = indexer.getEntityRelations(
  //     model,
  //     type,
  //     "HasAssociations",
  //   );
  //   if (typeAssociations) {
  //     for (const id of typeAssociations) {
  //       const attrs = await model.getProperties(id);
  //       if (!attrs) continue;
  //       if (attrs.type === WEBIFC.IFCCLASSIFICATION) {
  //         if (occurrenceSystems.includes(attrs.Name?.value)) continue;
  //         result.push(attrs);
  //       }
  //       if (attrs.type === WEBIFC.IFCCLASSIFICATIONREFERENCE) {
  //         attrs.ReferencedSource = await this.processReferencedSource(
  //           model,
  //           attrs,
  //         );
  //         if (attrs.ReferencedSource) result.push(attrs);
  //       }
  //     }
  //   }
  //   return result;
  // }
  // private getSystemName(attrs: Record<string, any>): string | null {
  //   if (attrs.type === WEBIFC.IFCCLASSIFICATION) {
  //     return attrs.Name?.value;
  //   }
  //   if (attrs.type === WEBIFC.IFCCLASSIFICATIONREFERENCE) {
  //     if (attrs.ReferencedSource?.type === WEBIFC.IFCCLASSIFICATIONREFERENCE) {
  //       return this.getSystemName(attrs.ReferencedSource);
  //     }
  //     if (attrs.ReferencedSource?.type === WEBIFC.IFCCLASSIFICATION) {
  //       return attrs.ReferencedSource.Name?.value;
  //     }
  //   }
  //   return null;
  // }
  // private getAllReferenceIdentifications(attrs: Record<string, any>) {
  //   if (attrs.type !== WEBIFC.IFCCLASSIFICATIONREFERENCE) return null;
  //   const identifications: string[] = [];
  //   if (attrs.Identification) identifications.push(attrs.Identification.value);
  //   if (attrs.ReferencedSource) {
  //     const identification = this.getAllReferenceIdentifications(
  //       attrs.ReferencedSource,
  //     );
  //     if (identification) identifications.push(...identification);
  //   }
  //   return identifications;
  // }
  // private evalSystem(attrs: Record<string, any>, checks?: IDSCheck[]) {
  //   const name = this.getSystemName(attrs);
  //   return this.evalRequirement(name, this.system, "System", checks);
  // }
  // private evalValue(attrs: any, checks?: IDSCheck[]) {
  //   if (!this.value) return true;
  //   const identifications = this.getAllReferenceIdentifications(attrs);
  //   if (!identifications) return false;
  //   const identifier = identifications.find((id) => {
  //     if (!this.value) return false;
  //     return this.evalRequirement(id, this.value, "Value");
  //   });
  //   if (checks) {
  //     this.addCheckResult(
  //       {
  //         parameter: "Value",
  //         currentValue: identifier ?? null,
  //         requiredValue: this.value,
  //         pass: !!identifier,
  //       },
  //       checks,
  //     );
  //   }
  //   return !!identifier;
  // }
  // private evalURI(attrs: any, checks?: IDSCheck[]) {
  //   if (!this.uri) return true;
  //   const result = this.evalRequirement(
  //     attrs.Location?.value,
  //     {
  //       type: "simple",
  //       parameter: this.uri,
  //     },
  //     "URI",
  //     checks,
  //   );
  //   return result;
  // }
};
var lr = class extends As {
  constructor(t, e) {
    super(t), E(this, "facetType", "Entity"), E(this, "name"), E(this, "predefinedType"), this.name = e;
  }
  serialize(t) {
    const e = Ce("Name", this.name), s = Ce("Name", this.predefinedType);
    let i = "";
    return t === "requirement" && (i += `cardinality="${this.cardinality}"`, i += this.instructions ? `instructions="${this.instructions}"` : ""), `<entity ${i}>
  ${e}
  ${s}
</entity>`;
  }
  async getEntities(t, e) {
    const s = this._components.get(ct), i = /* @__PURE__ */ new Map();
    for (const [r, o] of s.list) {
      if (!t.find((h) => h.test(r)))
        continue;
      const c = await o.getCategories();
      for (const h of c) {
        if (!await this.evalName(h))
          continue;
        let u = i.get(r);
        u || (u = [], i.set(r, u)), u.push(h);
      }
    }
    const n = {};
    if (await Promise.all(
      Array.from(i.entries()).map(
        async ([r, o]) => {
          const a = s.list.get(r);
          if (!a)
            return;
          const c = o.map(
            (u) => new RegExp(`^${u}$`)
          ), h = await a.getItemsOfCategories(c), d = Object.values(h).flat();
          n[r] = new Set(d);
        }
      )
    ), !this.predefinedType) {
      Dt.add(e, n);
      return;
    }
    for (const [r, o] of Object.entries(n)) {
      const a = s.list.get(r);
      if (!a)
        continue;
      const c = await a.getItemsData([...o]);
      for (const h of c) {
        if (!("value" in h._localId))
          continue;
        await this.evalPredefinedType(
          r,
          h
        ) && Dt.append(e, r, h._localId.value);
      }
    }
  }
  async test(t, e) {
    const s = this._components.get(ct);
    for (const [i, n] of Object.entries(t)) {
      const r = s.list.get(i);
      if (!r)
        continue;
      const o = await r.getItemsData([...n]);
      for (const a of o) {
        if (!("value" in a._category))
          continue;
        const c = this.getItemChecks(e, i, a);
        c && (await this.evalName(a._category.value, c), await this.evalPredefinedType(i, a, c));
      }
    }
  }
  async evalName(t, e) {
    return this.evalRequirement(t, this.name, "Name", e);
  }
  async evalPredefinedType(t, e, s) {
    if (!this.predefinedType || !("value" in e.PredefinedType))
      return null;
    const i = typeof this.predefinedType.parameter == "string" && this.predefinedType.parameter === "USERDEFINED";
    let n = e.PredefinedType.value;
    if (n === "USERDEFINED" && !i) {
      const a = Object.keys(e).find((c) => /^((?!Predefined).)*Type$/.test(c));
      if (a) {
        const c = e[a];
        "value" in c && (n = c.value);
      } else
        n = "USERDEFINED";
    }
    if (!n) {
      const a = this._components.get(ct).list.get(t);
      if (a && "value" in e._localId) {
        const [c] = await a.getItemsData([e._localId.value], {
          relations: { IsTypedBy: { attributes: true, relations: false } }
        });
        if (Array.isArray(c.IsTypedBy)) {
          const h = c.IsTypedBy[0];
          if (h && "value" in h.PredefinedType && (n = h.PredefinedType.value, n === "USERDEFINED" && !i)) {
            const u = Object.keys(h).find(
              (f) => /^((?!Predefined).)*Type$/.test(f)
            );
            if (u) {
              const f = h[u];
              "value" in f && (n = f.value);
            } else
              n = "USERDEFINED";
          }
        }
      }
    }
    return this.evalRequirement(
      n,
      this.predefinedType,
      "PredefinedType",
      s
    );
  }
};
var Dd = class extends As {
  constructor(t, e, s) {
    super(t), E(this, "facetType", "Property"), E(this, "propertySet"), E(this, "baseName"), E(this, "value"), E(this, "dataType"), E(this, "uri"), E(this, "_unsupportedTypes", [
      "IFCCOMPLEXPROPERTY",
      "IFCPHYSICALCOMPLEXQUANTITY"
    ]), this.propertySet = e, this.baseName = s;
  }
  serialize(t) {
    const e = Ce("PropertySet", this.propertySet), s = Ce("BaseName", this.baseName), i = Ce("Value", this.value), n = this.dataType ? `dataType=${this.dataType}` : "";
    let r = "";
    return t === "requirement" && (r += `cardinality="${this.cardinality}"`, r += this.uri ? `uri=${this.uri}` : "", r += this.instructions ? `instructions="${this.instructions}"` : ""), `<property ${n} ${r}>
  ${e}
  ${s}
  ${i}
</property>`;
  }
  async getEntities(t, e) {
    const s = this._components.get(ct);
    for (const [i, n] of s.list) {
      if (!t.find((h) => h.test(i)))
        continue;
      const o = await n.getItemsOfCategories([
        /PROPERTYSET/,
        /ELEMENTQUANTITY/
      ]), a = Object.values(o).flat();
      if (a.length === 0)
        continue;
      const c = await n.getItemsData(a, {
        relations: {
          HasProperties: { attributes: true, relations: false },
          DefinesOcurrence: { attributes: true, relations: false }
        }
      });
      for (const h of c) {
        if (!("value" in h._localId && "value" in h._category && "value" in h.Name && Array.isArray(h.DefinesOcurrence)) || !this.evalRequirement(
          h.Name.value,
          this.propertySet,
          "PropertySet"
        ))
          continue;
        let u;
        if (h._category.value === "IFCPROPERTYSET" && (u = "HasProperties"), h._category.value === "IFCELEMENTQUANTITY" && (u = "Quantities"), !u)
          continue;
        const f = h[u];
        if (Array.isArray(f))
          for (const g of f) {
            const m = Object.keys(g), _ = m.find((x) => /Name/.test(x));
            if (!(_ && "value" in g[_]))
              continue;
            const p = g[_];
            if (!("value" in p) || !this.evalRequirement(
              p.value,
              this.baseName,
              "BaseName"
            ))
              continue;
            if (this.value) {
              const x = m.find((P) => /Value/.test(P));
              if (!x)
                continue;
              const S = g[x];
              if (!("value" in S) || !this.evalRequirement(
                S.value,
                this.value,
                "Value"
              ))
                continue;
            }
            const b = h.DefinesOcurrence.map((x) => "value" in x._localId && typeof x._localId.value == "number" ? x._localId.value : null).filter((x) => x !== null);
            Dt.append(e, i, ...b);
          }
      }
    }
  }
  async test(t, e) {
    const s = this._components.get(ct);
    for (const [i, n] of Object.entries(t)) {
      const r = s.list.get(i);
      if (!r)
        continue;
      const o = await r.getItemsData([...n], {
        relations: {
          IsDefinedBy: { attributes: true, relations: true },
          IsTypedBy: { attributes: true, relations: false },
          HasPropertySets: { attributes: true, relations: true },
          DefinesOcurrence: { attributes: false, relations: false }
        }
      });
      for (const a of o) {
        const c = this.getItemChecks(e, i, a);
        if (!c)
          continue;
        const d = (await this.getPsets(a)).filter((u) => !("value" in u.Name) || !this.evalRequirement(
          u.Name.value,
          this.propertySet,
          "PropertySet"
        ) ? false : (c.push({
          currentValue: u.Name.value,
          parameter: "PropertySet",
          pass: true,
          requiredValue: this.propertySet
        }), true));
        if (d.length === 0) {
          c.push({
            currentValue: null,
            parameter: "PropertySet",
            pass: false,
            requiredValue: this.propertySet
          });
          continue;
        }
        for (const u of d) {
          const f = this.getPropertyListName(u);
          if (!f)
            continue;
          const g = u[f];
          if (!Array.isArray(g)) {
            c.push({
              currentValue: null,
              parameter: "BaseName",
              pass: false,
              requiredValue: this.baseName
            });
            continue;
          }
          const m = g.filter((_) => !("value" in _._category && "value" in _.Name) || this._unsupportedTypes.includes(_._category.value) || !this.evalRequirement(
            _.Name.value,
            this.baseName,
            "BaseName"
          ) ? false : (c.push({
            currentValue: _.Name.value,
            parameter: "BaseName",
            pass: true,
            requiredValue: this.baseName
          }), true));
          if (m.length === 0) {
            c.push({
              currentValue: null,
              parameter: "BaseName",
              pass: false,
              requiredValue: this.baseName
            });
            continue;
          }
          for (const _ of m)
            this.evalValue(_, c), this.evalDataType(_, c), this.evalURI();
        }
      }
    }
  }
  getPropertyListName(t) {
    let e;
    return "value" in t._category && (t._category.value === "IFCPROPERTYSET" && (e = "HasProperties"), t._category.value === "IFCELEMENTQUANTITY" && (e = "Quantities")), e;
  }
  getValueKey(t) {
    return Object.keys(t).find(
      (e) => /Value/.test(e) || /Values/.test(e)
    );
  }
  getTypePsets(t) {
    if (!Array.isArray(t.IsTypedBy))
      return [];
    const [e] = t.IsTypedBy;
    return e && Array.isArray(e.HasPropertySets) ? e.HasPropertySets : [];
  }
  async getPsets(t) {
    const e = this.getTypePsets(t);
    if (!Array.isArray(t.IsDefinedBy))
      return e;
    const s = [];
    for (const i of t.IsDefinedBy) {
      if (!("value" in i.Name))
        continue;
      const n = i.Name.value, r = this.getPropertyListName(i);
      if (!(n && r))
        continue;
      const o = e.find((a) => "value" in a.Name ? a.Name.value === n : false);
      if (o && Array.isArray(o.HasProperties) && Array.isArray(i.HasProperties))
        for (const a of o.HasProperties) {
          if (!("value" in a.Name))
            continue;
          const c = a.Name.value;
          i.HasProperties.find((d) => "value" in d.Name ? d.Name.value === c : false) || i.HasProperties.push(a);
        }
      s.push(i);
    }
    return s;
  }
  // IFCPROPERTYBOUNDEDVALUE are not supported yet
  // IFCPROPERTYTABLEVALUE are not supported yet
  // TODO: Work must to be done to convert numerical value units to IDS-nominated standard units https://github.com/buildingSMART/IDS/blob/development/Documentation/UserManual/units.md
  evalValue(t, e) {
    const s = this.getValueKey(t), i = t[s];
    if (!("value" in i))
      return false;
    if (this.value) {
      if (!s)
        return e == null || e.push({
          parameter: "Value",
          currentValue: null,
          pass: false,
          requiredValue: this.value
        }), false;
      const n = structuredClone(this.value);
      return i.type === "IFCLABEL" && n.type === "simple" && (n.parameter = String(n.parameter)), this.evalRequirement(
        i.value,
        n,
        "Value",
        e
      );
    }
    return s && typeof i.value == "string" && i.value.trim() === "" ? (e == null || e.push({
      parameter: "Value",
      currentValue: "",
      pass: false,
      requiredValue: this.value
    }), false) : true;
  }
  evalDataType(t, e) {
    if (!this.dataType)
      return true;
    const s = this.getValueKey(t);
    if (!(s && "value" in t[s]))
      return e == null || e.push({
        parameter: "DataType",
        currentValue: null,
        pass: false,
        requiredValue: this.dataType
      }), false;
    const i = t[s];
    return this.evalRequirement(
      i.type ?? null,
      {
        type: "simple",
        parameter: this.dataType
      },
      "DataType",
      e
    );
  }
  evalURI() {
    return true;
  }
};
var Id = class extends As {
  constructor() {
    super(...arguments), E(this, "_ifcMaterialEntities", [
      /^IFCMATERIALLAYERSETUSAGE$/,
      /^IFCMATERIALCONSTITUENTSET$/,
      /^IFCMATERIAL$/,
      /^IFCMATERIALLIST$/
    ]), E(this, "facetType", "Material"), E(this, "value"), E(this, "uri");
  }
  serialize(t) {
    if (!(this.value && this.uri))
      return "<material />";
    const e = Ce("Value", this.value);
    let s = "";
    return t === "requirement" && (s += `cardinality="${this.cardinality}"`, s += this.uri ? `uri=${this.uri}` : "", s += this.instructions ? `instructions="${this.instructions}"` : ""), `<material ${s}>
  ${e}
</material>`;
  }
  async getEntities(t, e) {
    const s = this._components.get(ct);
    for (const [i, n] of s.list) {
      if (!t.find((h) => h.test(i)))
        continue;
      const o = await n.getItemsOfCategories(this._ifcMaterialEntities), a = Object.values(o).flat();
      if (a.length === 0)
        continue;
      const c = await n.getItemsData(a, {
        relations: {
          AssociatedTo: { attributes: true, relations: false },
          MaterialConstituents: { attributes: true, relations: true },
          ForLayerSet: { attributes: true, relations: true },
          MaterialLayers: { attributes: true, relations: true },
          Materials: { attributes: true, relations: false }
        }
      });
      for (const h of c) {
        if (!("value" in h._localId && "value" in h._category && Array.isArray(h.AssociatedTo)) || !this.hasValidMaterial(h))
          continue;
        const u = h.AssociatedTo.map((f) => "value" in f._localId && f._localId.value ? f._localId.value : null).filter((f) => f !== null);
        Dt.append(e, i, ...u);
      }
    }
  }
  async test(t, e) {
    const s = this._components.get(ct);
    for (const [i, n] of Object.entries(t)) {
      const r = s.list.get(i);
      if (!r)
        continue;
      const o = await r.getItemsData([[...n][0]], {
        relations: {
          AssociatedTo: { attributes: false, relations: false },
          HasAssociations: { attributes: true, relations: true },
          MaterialConstituents: { attributes: true, relations: true },
          ForLayerSet: { attributes: true, relations: true },
          MaterialLayers: { attributes: true, relations: true },
          Materials: { attributes: true, relations: false }
        }
      });
      for (const a of o) {
        const c = this.getItemChecks(e, i, a);
        if (c) {
          if (!Array.isArray(a.HasAssociations)) {
            c.push({
              parameter: null,
              currentValue: null,
              requiredValue: this.value,
              pass: false
            });
            continue;
          }
          for (const h of a.HasAssociations) {
            if (!this._ifcMaterialEntities.some((u) => "value" in h._category ? u.test(h._category.value) : false))
              continue;
            if (this.hasValidMaterial(h, c))
              break;
          }
        }
      }
    }
  }
  hasValidMaterial(t, e) {
    let s = false;
    if ("value" in t._category && t._category.value === "IFCMATERIAL")
      this.evalValue(t, e) && (s = true);
    else
      for (const [i, n] of Object.entries(t))
        if ([
          "ForLayerSet",
          "MaterialLayers",
          "Material",
          "MaterialConstituents",
          "Materials"
        ].includes(i) && Array.isArray(n)) {
          for (const r of n)
            if ("value" in r._category && r._category.value === "IFCMATERIAL") {
              if (this.evalValue(r, e)) {
                s = true;
                break;
              }
            } else if (this.hasValidMaterial(r)) {
              s = true;
              break;
            }
        }
    return s;
  }
  evalValue(t, e) {
    if (!this.value)
      return e == null || e.push({
        parameter: null,
        currentValue: t.Name && "value" in t.Name ? t.Name.value : null,
        pass: true
      }), true;
    if (!("value" in t._category && t._category.value === "IFCMATERIAL"))
      return null;
    let s = false;
    return t.Name && "value" in t.Name && (s = this.evalRequirement(
      t.Name.value,
      this.value,
      "Value",
      e
    )), s || (t.Category && "value" in t.Category && (s = this.evalRequirement(
      t.Category.value,
      this.value,
      "Value",
      e
    )), s);
  }
};
var zd = class extends As {
  constructor(t, e) {
    super(t), E(this, "facetType", "PartOf"), E(this, "_entityFacet"), E(this, "_entity"), E(this, "relation"), E(this, "cardinality", "required"), this._entity = e, this._entityFacet = new lr(t, e.name), this._entityFacet.predefinedType = e.predefinedType;
  }
  set entity(t) {
    this._entity = t;
    const { name: e, predefinedType: s } = t;
    this._entityFacet = new lr(this._components, e), this._entityFacet.predefinedType = s;
  }
  get entity() {
    return this._entity;
  }
  serialize() {
    return "";
  }
  async getEntities(t, e) {
  }
  async test(t) {
  }
};
var Ld = class {
  constructor(t, e, s) {
    E(this, "name"), E(this, "ifcVersion", /* @__PURE__ */ new Set()), E(this, "identifier", Xt.create()), E(this, "description"), E(this, "instructions"), E(this, "requirementsDescription"), E(this, "applicability", new Wt()), E(this, "requirements", new Wt()), E(this, "components"), this.components = t, this.name = e;
    for (const i of s)
      this.ifcVersion.add(i);
  }
  set(t) {
    const e = t, s = this;
    for (const n in t) {
      if (n === "identifier")
        continue;
      const r = e[n];
      n in this && (s[n] = r);
    }
    return this.components.get(Nd).list.set(this.identifier, this), this;
  }
  /**
   * Tests the model to test against the specification's requirements.
   *
   * @param modelId - The modelId of the model to be tested.
   * @returns An array representing the test results.
   * If no requirements are defined for the specification, an empty array is returned.
   */
  async test(t) {
    const e = new Yt();
    if (this.requirements.size === 0)
      return e;
    const s = {}, i = [];
    for (const r of this.applicability)
      i.push(r.getEntities(t, s));
    await Promise.all(i);
    const n = [];
    for (const r of this.requirements)
      n.push(r.test(s, e));
    return await Promise.all(n), e;
  }
  /**
   * Serializes the IDSSpecification instance into XML format.
   *
   * @remarks This method is not meant to be used directly. It is used by the IDSSpecifications component.
   *
   * @returns The XML representation of the IDSSpecification.
   */
  serialize() {
    const t = `name="${this.name}"`, e = this.identifier ? `identifier="${this.identifier}"` : "", s = this.description ? `description="${this.description}"` : "", i = this.instructions ? `instructions="${this.instructions}"` : "";
    return `<specification ifcVersion="${[...this.ifcVersion].join(" ")}" ${t} ${e} ${s} ${i}>
      <applicability minOccurs="1" maxOccurs="unbounded">
        ${[...this.applicability].map((r) => r.serialize("applicability")).join(`
`)}
      </applicability>
      <requirements>
        ${[...this.requirements].map((r) => r.serialize("requirement")).join(`
`)}
      </requirements>
    </specification>`;
  }
};
var le = (l) => {
  if (!l)
    return;
  const t = {};
  if ("simpleValue" in l && (t.type = "simple", t.parameter = l.simpleValue), "restriction" in l) {
    const e = l.restriction, s = Object.keys(e);
    if ("pattern" in e && (t.type = "pattern", t.parameter = e.pattern.value), "enumeration" in e) {
      t.type = "enumeration";
      const i = e.enumeration.map(
        ({ value: n }) => n
      );
      t.parameter = i;
    }
    if (s.some(
      (i) => [
        "minInclusive",
        "minExclusive",
        "maxInclusive",
        "maxExclusive"
      ].includes(i)
    )) {
      t.type = "bounds";
      const i = {}, n = s.find((o) => o.includes("min")), r = s.find((o) => o.includes("max"));
      n && (i.minInclusive = n === "minInclusive", i.min = e[n].value), r && (i.maxInclusive = r === "maxInclusive", i.max = e[r].value), t.parameter = i;
    }
    if (s.some((i) => ["minLength", "length", "maxLength"].includes(i))) {
      t.type = "length";
      const i = {};
      e.length !== void 0 && (i.length = e.length.value), e.minLength !== void 0 && (i.min = e.minLength.value), e.maxLength !== void 0 && (i.max = e.maxLength.value), t.parameter = i;
    }
  }
  if (t.parameter !== void 0)
    return t;
};
var vo = (l, t) => {
  const e = [];
  for (const s of t) {
    const i = s.name, n = le(i);
    if (!n)
      continue;
    const r = new lr(l, n);
    s.cardinality && (r.cardinality = s.cardinality), r.predefinedType = le(s.predefinedType), r.instructions = s.instructions, e.push(r);
  }
  return e;
};
var wo = (l, t) => {
  const e = [];
  for (const s of t) {
    const i = s.name, n = le(i);
    if (!n)
      continue;
    const r = new Md(l, n);
    s.cardinality && (r.cardinality = s.cardinality), r.value = le(s.value), r.instructions = s.instructions, e.push(r);
  }
  return e;
};
var bo = (l, t) => {
  const e = [];
  for (const s of t) {
    const i = new Id(l);
    s.cardinality && (i.cardinality = s.cardinality);
    const n = le(s.value);
    (n == null ? void 0 : n.type) === "enumeration" && Array.isArray(n.parameter) && (n.parameter = n.parameter.map(String)), i.value = n, i.uri = s.uri, i.instructions = s.instructions, e.push(i);
  }
  return e;
};
var xo = (l, t) => {
  const e = [];
  for (const s of t) {
    const i = s.propertySet, n = s.baseName, r = le(i), o = le(n);
    if (!(o && r))
      continue;
    const a = new Dd(l, r, o);
    s.cardinality && (a.cardinality = s.cardinality);
    const c = le(s.value);
    a.value = c, a.dataType = s.dataType, a.uri = s.uri, a.instructions = s.instructions, e.push(a);
  }
  return e;
};
var So = (l, t) => {
  const e = [];
  for (const s of t) {
    const i = s.system, n = le(i);
    if (!n)
      continue;
    const r = new Od(l, n);
    s.cardinality && (r.cardinality = s.cardinality);
    const o = le(s.value);
    (o == null ? void 0 : o.type) === "simple" && (o.parameter = String(o.parameter)), (o == null ? void 0 : o.type) === "enumeration" && Array.isArray(o.parameter) && (o.parameter = o.parameter.map(String)), r.value = o, r.uri = s.uri, r.instructions = s.instructions, e.push(r);
  }
  return e;
};
var Eo = (l, t) => {
  const e = [];
  for (const s of t) {
    const i = le(s.entity.name);
    if (!i)
      continue;
    const n = le(
      s.entity.predefinedType
    ), r = new zd(l, {
      name: i,
      predefinedType: n
    });
    r.relation = s.relation, s.cardinality && (r.cardinality = s.cardinality), r.instructions = s.instructions, e.push(r);
  }
  return e;
};
var Er = class cr extends St {
  constructor(t) {
    super(t), E(this, "enabled", true), E(this, "list", new Es()), t.add(cr.uuid, this);
  }
  /**
   * Processes the results of an IDS check and categorizes the items into passing and failing.
   *
   * @param result - An `IDSCheckResult` object containing the check results for various model IDs.
   * @returns An object containing two `ModelIdMap` objects:
   *          - `pass`: A ModelIdMap representing items that passed the check.
   *          - `fail`: A ModelIdMap representing items that failed the check.
   */
  getModelIdMap(t) {
    const e = {}, s = {};
    for (const [i, n] of t) {
      const o = [...n].filter(([, h]) => h.pass).map(([h]) => h);
      Dt.append(e, i, ...o);
      const c = [...n].filter(([, h]) => !h.pass).map(([h]) => h);
      Dt.append(s, i, ...c);
    }
    return { pass: e, fail: s };
  }
  /**
   * Creates a new IDSSpecification instance and adds it to the list.
   *
   * @param name - The name of the IDSSpecification.
   * @param ifcVersion - An array of IfcVersion values that the specification supports.
   *
   * @returns The newly created IDSSpecification instance.
   */
  create(t, e, s) {
    const i = new Ld(
      this.components,
      t,
      e
    );
    return s && (i.identifier = s), this.list.set(i.identifier, i), i;
  }
  /**
   * Parses and processes an XML string containing Information Delivery Specification (IDS) data.
   * It creates IDSSpecification instances based on the parsed data and returns them in an array.
   * Also, the instances are added to the list array.
   *
   * @param data - The XML string to parse.
   *
   * @returns An array of IDSSpecification instances created from the parsed data.
   */
  load(t) {
    const e = [], s = cr.xmlParser.parse(t).ids, { specifications: i } = s;
    if (i && i.specification) {
      const n = Array.isArray(i.specification) ? i.specification : [i.specification];
      for (const r of n) {
        const { name: o, ifcVersion: a, description: c, instructions: h, identifier: d } = r;
        if (!(o && a))
          continue;
        const u = [], f = [], { applicability: g, requirements: m } = r;
        if (g) {
          const { maxOccurs: y, ...b } = g, x = Array.isArray(b) ? b : [b];
          for (const S of x)
            for (const C in S) {
              const P = Array.isArray(S[C]) ? S[C] : [S[C]];
              if (C === "entity") {
                const O = vo(this.components, P);
                u.push(...O);
              }
              if (C === "attribute") {
                const O = wo(this.components, P);
                u.push(...O);
              }
              if (C === "material") {
                const O = bo(this.components, P);
                u.push(...O);
              }
              if (C === "classification") {
                const O = So(
                  this.components,
                  P
                );
                u.push(...O);
              }
              if (C === "property") {
                const O = xo(this.components, P);
                u.push(...O);
              }
              if (C === "partOf") {
                const O = Eo(this.components, P);
                u.push(...O);
              }
            }
        }
        let _;
        if (m) {
          const { maxOccurs: y, ...b } = m;
          _ = m.description;
          const x = Array.isArray(b) ? b : [b];
          for (const S of x)
            for (const C in S) {
              const P = Array.isArray(S[C]) ? S[C] : [S[C]];
              if (C === "entity") {
                const O = vo(this.components, P);
                f.push(...O);
              }
              if (C === "attribute") {
                const O = wo(this.components, P);
                f.push(...O);
              }
              if (C === "material") {
                const O = bo(this.components, P);
                f.push(...O);
              }
              if (C === "classification") {
                const O = So(
                  this.components,
                  P
                );
                f.push(...O);
              }
              if (C === "property") {
                const O = xo(this.components, P);
                f.push(...O);
              }
              if (C === "partOf") {
                const O = Eo(this.components, P);
                f.push(...O);
              }
            }
        }
        const p = this.create(
          o,
          a.split(/\s+/),
          d
        );
        p.description = c, p.instructions = h, p.requirementsDescription = _, p.applicability.add(...u), p.requirements.add(...f), e.push(p);
      }
    }
    return e;
  }
  /**
   * Exports the IDSSpecifications data into an XML string.
   *
   * @param info - The metadata information for the exported XML.
   * @param specifications - An optional iterable of IDSSpecification instances to export.
   * If not provided, all specifications in the list will be exported.
   *
   * @returns A string containing the exported IDSSpecifications data in XML format.
   */
  export(t, e = this.list.values()) {
    const s = e ?? this.list;
    return `<ids xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://standards.buildingsmart.org/IDS http://standards.buildingsmart.org/IDS/1.0/ids.xsd" xmlns:ids="http://standards.buildingsmart.org/IDS">
  <!-- Made with That Open Engine ${Pa.release} (https://github.com/thatopen/engine_components) -->
  <info>
    <title>${t.title}</title>
    ${t.copyright ? `<copyright>${t.copyright}</copyright>` : ""}
    ${t.version ? `<version>${t.version}</version>` : ""}
    ${t.description ? `<description>${t.description}</description>` : ""}
    ${t.author ? `<author>${t.author}</author>` : ""}
    ${t.date ? `<date>${t.date.toISOString().split("T")[0]}</date>` : ""}
    ${t.purpose ? `<purpose>${t.purpose}</purpose>` : ""}
    ${t.milestone ? `<milestone>${t.milestone}</milestone>` : ""}
  </info>
  <specifications>
    ${[...s].map((n) => n.serialize()).join(`
`)}
  </specifications>
</ids>`;
  }
};
E(Er, "uuid", "9f0b9f78-9b2e-481a-b766-2fbfd01f342c");
E(Er, "xmlParser", new dn.XMLParser({
  allowBooleanAttributes: true,
  attributeNamePrefix: "",
  ignoreAttributes: false,
  ignoreDeclaration: true,
  ignorePiTags: true,
  numberParseOptions: { leadingZeros: true, hex: true },
  parseAttributeValue: true,
  preserveOrder: false,
  processEntities: false,
  removeNSPrefix: true,
  trimValues: true
}));
var Nd = Er;
var ka = class Ba extends St {
  constructor(t) {
    super(t), E(this, "enabled", true), t.add(Ba.uuid, this);
  }
  /**
   * Utility method to calculate the distance from a point to a line segment.
   *
   * @param point - The point from which to calculate the distance.
   * @param lineStart - The start point of the line segment.
   * @param lineEnd - The end point of the line segment.
   * @param clamp - If true, the distance will be clamped to the line segment's length.
   * @returns The distance from the point to the line segment.
   */
  static distanceFromPointToLine(t, e, s, i = false) {
    const n = new Line3(), r = new Vector3();
    return n.set(e, s), n.closestPointToPoint(t, i, r), r.distanceTo(t);
  }
  // /**
  //  * Method to get the face of a mesh that contains a given triangle index.
  //  * It also returns the edges of the found face and their indices.
  //  *
  //  * @param mesh - The mesh to get the face from. It must be indexed.
  //  * @param triangleIndex - The index of the triangle within the mesh.
  //  * @param instance - The instance of the mesh (optional).
  //  * @returns An object containing the edges of the found face and their indices, or null if no face was found.
  //  */
  // getFace(
  //   mesh: THREE.InstancedMesh | THREE.Mesh,
  //   triangleIndex: number,
  //   instance?: number,
  // ) {
  //   if (!mesh.geometry.index) {
  //     throw new Error("Geometry must be indexed!");
  //   }
  //   const allEdges = new Map<string, MeasureEdge>();
  //   const indices = mesh.geometry.index.array;
  //   // Find out the raycasted face plane
  //   const { plane: targetPlane } = this.getFaceData(
  //     triangleIndex,
  //     instance,
  //     mesh,
  //   );
  //   // Get the face where the given triangle belongs
  //   const coplanarFacesIndices: {
  //     index: number;
  //     edges: { id: string; distance: number; points: THREE.Vector3[] }[];
  //   }[] = [];
  //   for (let faceIndex = 0; faceIndex < indices.length / 3; faceIndex++) {
  //     const { plane, edges } = this.getFaceData(faceIndex, instance, mesh);
  //     if (plane.equals(targetPlane)) {
  //       coplanarFacesIndices.push({ index: faceIndex, edges });
  //       for (const { id, points, distance } of edges) {
  //         allEdges.set(id, { points, distance });
  //       }
  //     }
  //   }
  //   // Now, let's get all faces (groups of adjacent triangles)
  //   // To visualize this, draw all possible cases on paper, it's easy
  //   let nextFaceID = 0;
  //   const edgeFaceMap = new Map<string, number>();
  //   const faceEdgesMap = new Map<
  //     number,
  //     { edges: Set<string>; indices: Set<number> }
  //   >();
  //   for (const { index, edges } of coplanarFacesIndices) {
  //     const commonEdgesFaces = new Map<string, number>();
  //     for (const { id: edge } of edges) {
  //       if (edgeFaceMap.has(edge)) {
  //         const commonFace = edgeFaceMap.get(edge) as number;
  //         commonEdgesFaces.set(edge, commonFace);
  //       }
  //     }
  //     const edgesIDs = edges.map((edge) => edge.id);
  //     // Triangle is isolated, just create a new face
  //     if (!commonEdgesFaces.size) {
  //       const faceID = nextFaceID++;
  //       for (const { id: edge } of edges) {
  //         edgeFaceMap.set(edge, faceID);
  //       }
  //       faceEdgesMap.set(faceID, {
  //         edges: new Set(edgesIDs),
  //         indices: new Set([index]),
  //       });
  //       continue;
  //     }
  //     // Triangle has common edges with existing faces
  //     let firstFaceID: number | null = null;
  //     const otherFaces = new Set<number>();
  //     const edgesToAdd = new Set(edgesIDs);
  //     // First, remove all common edges
  //     for (const [edge, faceID] of commonEdgesFaces) {
  //       if (firstFaceID === null) {
  //         firstFaceID = faceID;
  //       } else if (faceID !== firstFaceID) {
  //         otherFaces.add(faceID);
  //       }
  //       edgeFaceMap.delete(edge);
  //       const { edges: foundFaceEdges } = faceEdgesMap.get(faceID)!;
  //       foundFaceEdges.delete(edge);
  //       edgesToAdd.delete(edge);
  //     }
  //     // If we hadn't found a face, we wouldn't be here
  //     if (firstFaceID === null) {
  //       throw new Error("Error computing face!");
  //     }
  //     // Now, let's merge this triangle with the first face
  //     const firstFace = faceEdgesMap.get(firstFaceID)!;
  //     const { indices: firstFaceIndices } = firstFace;
  //     firstFaceIndices.add(index);
  //     for (const edge of edgesToAdd) {
  //       edgeFaceMap.set(edge, firstFaceID);
  //       const { edges: firstFaceEdges } = firstFace;
  //       firstFaceEdges.add(edge);
  //     }
  //     // Finally, if there were other faces in common
  //     // merge them with the first one
  //     for (const faceID of otherFaces) {
  //       const otherFace = faceEdgesMap.get(faceID)!;
  //       const { edges: otherEdges, indices: otherIndices } = otherFace;
  //       const firstFace = faceEdgesMap.get(firstFaceID)!;
  //       const { edges: firstEdges, indices: firstIndices } = firstFace;
  //       for (const edge of otherEdges) {
  //         firstEdges.add(edge);
  //         edgeFaceMap.set(edge, firstFaceID);
  //       }
  //       for (const index of otherIndices) {
  //         firstIndices.add(index);
  //       }
  //       faceEdgesMap.delete(faceID);
  //     }
  //   }
  //   for (const [_faceID, { indices, edges }] of faceEdgesMap) {
  //     if (indices.has(triangleIndex)) {
  //       const foundEdges: MeasureEdge[] = [];
  //       for (const edgeID of edges) {
  //         const foundEdge = allEdges.get(edgeID)!;
  //         foundEdges.push(foundEdge);
  //       }
  //       return { edges: foundEdges, indices };
  //     }
  //   }
  //   return null;
  // }
  // /**
  //  * Method to get the vertices and normal of a mesh face at a given index.
  //  * It also applies instance transformation if provided.
  //  *
  //  * @param mesh - The mesh to get the face from. It must be indexed.
  //  * @param faceIndex - The index of the face within the mesh.
  //  * @param instance - The instance of the mesh (optional).
  //  * @returns An object containing the vertices and normal of the face.
  //  * @throws Will throw an error if the geometry is not indexed.
  //  */
  // getVerticesAndNormal(
  //   mesh: THREE.Mesh | THREE.InstancedMesh,
  //   faceIndex: number,
  //   instance: number | undefined,
  // ) {
  //   if (!mesh.geometry.index) {
  //     throw new Error("Geometry must be indexed!");
  //   }
  //   const indices = mesh.geometry.index.array;
  //   const pos = mesh.geometry.attributes.position.array;
  //   const nor = mesh.geometry.attributes.normal.array;
  //   const i1 = indices[faceIndex * 3] * 3;
  //   const i2 = indices[faceIndex * 3 + 1] * 3;
  //   const i3 = indices[faceIndex * 3 + 2] * 3;
  //   const p1 = new THREE.Vector3(pos[i1], pos[i1 + 1], pos[i1 + 2]);
  //   const p2 = new THREE.Vector3(pos[i2], pos[i2 + 1], pos[i2 + 2]);
  //   const p3 = new THREE.Vector3(pos[i3], pos[i3 + 1], pos[i3 + 2]);
  //   const n1 = new THREE.Vector3(nor[i1], nor[i1 + 1], nor[i1 + 2]);
  //   const n2 = new THREE.Vector3(nor[i2], nor[i2 + 1], nor[i2 + 2]);
  //   const n3 = new THREE.Vector3(nor[i3], nor[i3 + 1], nor[i3 + 2]);
  //   const averageNx = (n1.x + n2.x + n3.x) / 3;
  //   const averageNy = (n1.y + n2.y + n3.y) / 3;
  //   const averageNz = (n1.z + n2.z + n3.z) / 3;
  //   const faceNormal = new THREE.Vector3(averageNx, averageNy, averageNz);
  //   // Apply instance transformation to vertex and normal
  //   if (instance !== undefined && mesh instanceof THREE.InstancedMesh) {
  //     const transform = new THREE.Matrix4();
  //     mesh.getMatrixAt(instance, transform);
  //     const rotation = new THREE.Matrix4();
  //     rotation.extractRotation(transform);
  //     faceNormal.applyMatrix4(rotation);
  //     p1.applyMatrix4(transform);
  //     p2.applyMatrix4(transform);
  //     p3.applyMatrix4(transform);
  //   }
  //   return { p1, p2, p3, faceNormal };
  // }
  /**
   * Method to round the vector's components to a specified number of decimal places.
   * This is used to ensure numerical precision in edge detection.
   *
   * @param vector - The vector to round.
   * @returns The vector with rounded components.
   */
  round(t) {
    t.x = Math.trunc(t.x * 1e3) / 1e3, t.y = Math.trunc(t.y * 1e3) / 1e3, t.z = Math.trunc(t.z * 1e3) / 1e3;
  }
  /**
   * @deprecated Use {@link getItemsVolume} instead.
   *
   * Calculates the volume of a set of items.
   */
  async getVolumeFromFragments(t) {
    return console.warn(
      "getVolumeFromFragments is deprecated. Use getItemsVolume instead."
    ), this.getItemsVolume(t);
  }
  /**
   * Calculates the total volume of items for a given map of model IDs to local IDs.
   * @param modelIdMap A map where the key is the model ID and the value is an array of local IDs.
   * @returns A promise that resolves to the total volume of the specified items.
   */
  async getItemsVolume(t) {
    let e = 0;
    const s = this.components.get(ct);
    for (const [i, n] of Object.entries(t)) {
      const r = s.list.get(i);
      r && (e += await r.getItemsVolume([...n]));
    }
    return e;
  }
  // private getFaceData(
  //   faceIndex: number,
  //   instance: number | undefined,
  //   mesh: THREE.Mesh | THREE.InstancedMesh,
  // ) {
  //   const found = this.getVerticesAndNormal(mesh, faceIndex, instance);
  //   const { p1, p2, p3, faceNormal } = found;
  //   // Round numbers to make sure numerical precision
  //   // doesn't affect edge detection
  //   this.round(p1);
  //   this.round(p2);
  //   this.round(p3);
  //   this.round(faceNormal);
  //   // To make sure the edge AB === the edge BA
  //   const vertices = [
  //     { id: `${p1.x}|${p1.y}|${p1.z}`, value: p1 },
  //     { id: `${p2.x}|${p2.y}|${p2.z}`, value: p2 },
  //     { id: `${p3.x}|${p3.y}|${p3.z}`, value: p3 },
  //   ];
  //   vertices.sort((a, b) => {
  //     if (a.id < b.id) {
  //       return -1;
  //     }
  //     if (a.id > b.id) {
  //       return 1;
  //     }
  //     return 0;
  //   });
  //   const [
  //     { id: id1, value: v1 },
  //     { id: id2, value: v2 },
  //     { id: id3, value: v3 },
  //   ] = vertices;
  //   // Create IDs to identify the edges
  //   const edges = [
  //     {
  //       id: `${id1}|${id2}`,
  //       distance: v1.distanceTo(v2),
  //       points: [v1, v2],
  //     },
  //     {
  //       id: `${id2}|${id3}`,
  //       distance: v2.distanceTo(v3),
  //       points: [v2, v3],
  //     },
  //     {
  //       id: `${id1}|${id3}`,
  //       distance: v1.distanceTo(v3),
  //       points: [v1, v3],
  //     },
  //   ];
  //   const plane = new THREE.Plane();
  //   plane.setFromNormalAndCoplanarPoint(faceNormal, p1);
  //   plane.constant = Math.round(plane.constant * 10) / 10;
  //   return { plane, edges };
  // }
  /**
   * Converts a value from one unit to another for length, area, or volume without using external libraries.
   *
   * @param value - The value to convert.
   * @param fromUnit - The unit of the input value (e.g., "m", "cm", "mm" for lengths; "m2", "cm2" for areas; "m3", "cm3" for volumes).
   * @param toUnit - The unit to convert to (e.g., "cm", "mm", "m" for lengths; "cm2", "m2" for areas; "cm3", "m3" for volumes).
   * @param precision - The number of decimal places to round the result to, as number between 0 and 5. (default is 2).
   * @throws {Error} If the rounding value is not a valid integer or is out of range (0-5).
   * @returns The converted value rounded to the specified precision.
   */
  static convertUnits(t, e, s, i = 2) {
    const n = {
      // Length
      m: 1,
      cm: 0.01,
      mm: 1e-3,
      km: 1e3,
      // Area
      m2: 1,
      cm2: 1e-4,
      mm2: 1e-6,
      km2: 1e6,
      // Volume
      m3: 1,
      cm3: 1e-6,
      mm3: 1e-9,
      km3: 1e9
    };
    if (!n[e] || !n[s])
      throw new Error("Invalid units provided for conversion.");
    if (!Number.isInteger(i) || i < 0 || i > 5)
      throw new Error("Precision must be an integer between 0 and 5.");
    let r = n[e] / n[s];
    e.endsWith("2") && s.endsWith("2") ? r **= 2 : e.endsWith("3") && s.endsWith("3") && (r **= 3);
    const o = t * r, a = 10 ** i;
    return Math.round(o * a) / a;
  }
};
E(ka, "uuid", "267ca032-672f-4cb0-afa9-d24e904f39d6");
var gn = ka;
var en = class en2 extends St {
  constructor(e) {
    super(e);
    A(this, "enabled", true);
    A(this, "inputs", ["OBC", "BUI"]);
    A(this, "_requestEventID", "thatOpenCompanyComponentRequested");
    A(this, "_createEventID", "thatOpenCompanyComponentCreated");
    e.add(en2.uuid, this);
  }
  async import(e) {
    return new Promise((s) => {
      const i = document.createElement("script"), n = `
        function main() {
          const { ${this.inputs} } = window.ThatOpenCompany;
        
          ${e}
        
          const onComponentRequested = () => {
            window.removeEventListener("${this._requestEventID}", onComponentRequested);
            const event = new CustomEvent("${this._createEventID}", { detail: main });
            window.dispatchEvent(event);
          };
          
          window.addEventListener("${this._requestEventID}", onComponentRequested);
        }
        
        main();
      `, r = (o) => {
        window.removeEventListener(this._createEventID, r);
        const a = o.detail, c = this.components.get(a);
        i.remove(), s(c);
      };
      i.addEventListener("load", () => {
        window.addEventListener(this._createEventID, r), window.dispatchEvent(new Event(this._requestEventID));
      }), i.src = URL.createObjectURL(new File([n], "temp.js")), document.head.appendChild(i);
    });
  }
};
A(en, "uuid", "74c0c370-1af8-4ca9-900a-4a4196c0f2f5");
var To = en;
var Ra = class extends Object3D {
  /**
   * Constructs a new CSS2D object.
   *
   * @param {DOMElement} [element] - The DOM element.
   */
  constructor(t = document.createElement("div")) {
    super(), this.isCSS2DObject = true, this.element = t, this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", false), this.center = new Vector2(0.5, 0.5), this.addEventListener("removed", function() {
      this.traverse(function(e) {
        e.element instanceof e.element.ownerDocument.defaultView.Element && e.element.parentNode !== null && e.element.remove();
      });
    });
  }
  copy(t, e) {
    return super.copy(t, e), this.element = t.element.cloneNode(true), this.center = t.center, this;
  }
};
var ws = new Vector3();
var Co = new Matrix4();
var Ao = new Matrix4();
var Po = new Vector3();
var Mo = new Vector3();
var kd = class {
  /**
   * Constructs a new CSS2D renderer.
   *
   * @param {CSS2DRenderer~Parameters} [parameters] - The parameters.
   */
  constructor(t = {}) {
    const e = this;
    let s, i, n, r;
    const o = {
      objects: /* @__PURE__ */ new WeakMap()
    }, a = t.element !== void 0 ? t.element : document.createElement("div");
    a.style.overflow = "hidden", this.domElement = a, this.getSize = function() {
      return {
        width: s,
        height: i
      };
    }, this.render = function(g, m) {
      g.matrixWorldAutoUpdate === true && g.updateMatrixWorld(), m.parent === null && m.matrixWorldAutoUpdate === true && m.updateMatrixWorld(), Co.copy(m.matrixWorldInverse), Ao.multiplyMatrices(m.projectionMatrix, Co), h(g, g, m), f(g);
    }, this.setSize = function(g, m) {
      s = g, i = m, n = s / 2, r = i / 2, a.style.width = g + "px", a.style.height = m + "px";
    };
    function c(g) {
      g.isCSS2DObject && (g.element.style.display = "none");
      for (let m = 0, _ = g.children.length; m < _; m++)
        c(g.children[m]);
    }
    function h(g, m, _) {
      if (g.visible === false) {
        c(g);
        return;
      }
      if (g.isCSS2DObject) {
        ws.setFromMatrixPosition(g.matrixWorld), ws.applyMatrix4(Ao);
        const p = ws.z >= -1 && ws.z <= 1 && g.layers.test(_.layers) === true, y = g.element;
        y.style.display = p === true ? "" : "none", p === true && (g.onBeforeRender(e, m, _), y.style.transform = "translate(" + -100 * g.center.x + "%," + -100 * g.center.y + "%)translate(" + (ws.x * n + n) + "px," + (-ws.y * r + r) + "px)", y.parentNode !== a && a.appendChild(y), g.onAfterRender(e, m, _));
        const b = {
          distanceToCameraSquared: d(_, g)
        };
        o.objects.set(g, b);
      }
      for (let p = 0, y = g.children.length; p < y; p++)
        h(g.children[p], m, _);
    }
    function d(g, m) {
      return Po.setFromMatrixPosition(g.matrixWorld), Mo.setFromMatrixPosition(m.matrixWorld), Po.distanceToSquared(Mo);
    }
    function u(g) {
      const m = [];
      return g.traverseVisible(function(_) {
        _.isCSS2DObject && m.push(_);
      }), m;
    }
    function f(g) {
      const m = u(g).sort(function(p, y) {
        if (p.renderOrder !== y.renderOrder)
          return y.renderOrder - p.renderOrder;
        const b = o.objects.get(p).distanceToCameraSquared, x = o.objects.get(y).distanceToCameraSquared;
        return b - x;
      }), _ = m.length;
      for (let p = 0, y = m.length; p < y; p++)
        m[p].element.style.zIndex = _ - p;
    }
  }
};
var is = class {
  // Define marker as setup configuration?
  constructor(t, e, s) {
    A(this, "three");
    A(this, "world");
    A(this, "onDisposed", new tt());
    this.world = t;
    let i;
    if (e)
      i = e;
    else {
      i = document.createElement("div");
      const r = "6px";
      i.style.color = "white", i.style.height = r, i.style.width = r, i.style.borderRadius = "50%", i.style.border = "2px solid rgb(122, 75, 209)", i.style.zIndex = "-20";
    }
    this.three = new Ra(i), (s || t.scene.three).add(this.three), this.visible = true;
  }
  /** {@link OBC.Hideable.visible} */
  set visible(t) {
    this.three.visible = t;
  }
  /** {@link OBC.Hideable.visible} */
  get visible() {
    return this.three.visible;
  }
  /**
   * Toggles the visibility of the marker.
   *
   * This method changes the `visible` property of the marker to its opposite value.
   * If the marker is currently visible, it will be hidden, and vice versa.
   */
  toggleVisibility() {
    this.visible = !this.visible;
  }
  /**
   * Never Display marker.
   *
   * This method changes the `visible` property of the marker to its false value.
   * Marker will never displayed.
   */
  notDisplay() {
    this.visible = false;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    this.three.removeFromParent(), this.three.element.remove(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
var Bd = class extends Jc {
  constructor(e, s, i) {
    super(e, s, i);
    A(this, "three2D", new kd());
    this.onAfterUpdate.add(() => {
      if (this.onBeforeUpdate.trigger(this), !this.enabled || !this.currentWorld)
        return;
      const n = this.currentWorld.scene.three, r = this.currentWorld.camera.three;
      n instanceof Scene && this.three2D.render(n, r);
    }), this.onDisposed.add(() => {
      this.three2D.domElement.remove();
    }), this.onResize.add(({ x: n, y: r }) => {
      this.three2D.setSize(n, r);
    }), this.setupHtmlRenderer(), this.resize();
  }
  setupHtmlRenderer() {
    this.three2D.domElement.style.position = "absolute", this.three2D.domElement.style.top = "0px", this.three2D.domElement.style.pointerEvents = "none", this.container && (this.container.appendChild(this.three2D.domElement), this.container.style.position = "relative");
  }
};
var sn = class sn2 extends St {
  constructor(e) {
    super(e);
    A(this, "onDisposed", new tt());
    A(this, "enabled", true);
    A(this, "threshold", 50);
    A(this, "autoCluster", true);
    A(this, "list", /* @__PURE__ */ new Map());
    A(this, "clusterLabels", /* @__PURE__ */ new Set());
    A(this, "currentKeys", /* @__PURE__ */ new Set());
    A(this, "_color", "white");
    A(this, "_markerKey", 0);
    A(this, "_clusterKey", 0);
    A(this, "_worldEvents", /* @__PURE__ */ new Map());
    A(this, "_setupWorlds", /* @__PURE__ */ new Set());
    e.add(sn2.uuid, this);
  }
  /**
   * Getter for the color property.
   * Returns the current color of the markers.
   *
   * @returns {string} The current color of the markers.
   */
  get color() {
    return this._color;
  }
  /**
   * Setter for the color property.
   * Updates the color of all the markers to the new value.
   *
   * @param {string} value - The new color value for the markers.
   */
  set color(e) {
    this._color = e;
    for (const [s, i] of this.list)
      for (const [n, r] of i)
        r.label.three.element.style.color = e;
  }
  /**
   * Creates a new marker at the specified point in the world.
   *
   * @param world - The world where the marker will be created.
   * @param text - The text content of the marker.
   * @param point - The 3D position where the marker will be placed.
   * @param isStatic - Indicates whether the marker should be static and not clustered.
   * @returns The unique key of the created marker.
   */
  create(e, s, i, n = false) {
    this.setupEvents(e, true);
    const r = this._markerKey.toString(), o = this.getWorldMarkerList(e);
    if (o.has(r))
      return null;
    const a = document.createElement("span");
    a.append(s);
    const c = new is(e, a);
    return c.three.position.copy(i), o.set(r, {
      key: r,
      label: c,
      merged: false,
      static: n
    }), this._markerKey++, r;
  }
  /**
   * Deletes a marker with the specified ID from all worlds.
   *
   * @param id - The unique identifier of the marker to be deleted.
   *
   * @remarks
   * This method iterates through all the worlds and their respective markers.
   * If a marker with the specified ID is found, it disposes of the marker's label
   * and removes the marker from the world's marker list.
   *
   */
  delete(e) {
    for (const [s, i] of this.list) {
      const n = i.get(e);
      n && n.label.dispose(), i.delete(e);
    }
  }
  /**
   * Retrieves the list of markers associated with a specific world.
   * If the list does not exist for the given world, it creates a new one.
   *
   * @param world - The world for which the marker list is to be retrieved.
   * @returns A Map containing the markers associated with the given world.
   *
   * @remarks
   * This method is used to manage markers per world. It ensures that each world has its own set of markers.
   * If a marker list for the given world does not exist, it creates a new one and associates it with the world.
   */
  getWorldMarkerList(e) {
    return this.list.has(e.uuid) || this.list.set(e.uuid, /* @__PURE__ */ new Map()), this.list.get(e.uuid);
  }
  /** {@link OBC.Disposable.dispose} */
  dispose(e) {
    for (const [s, i] of this.list) {
      const n = [...i.keys()];
      for (const r of n) {
        const o = i.get(r);
        e && o.type !== e || (o.label.dispose(), i.delete(r));
      }
    }
    if (!e) {
      this.list.clear(), this._markerKey = 0;
      for (const s of this.clusterLabels)
        s.label.dispose();
      this.clusterLabels.clear(), this._clusterKey = 0, this.currentKeys.clear();
    }
    this.onDisposed.trigger();
  }
  /**
   * Sets up event listeners for clustering markers in the given world.
   *
   * @param world - The world where the event listeners will be set up.
   * @param enabled - Indicates whether the event listeners should be enabled or disabled.
   *
   * @remarks
   * This method checks if the event listeners are already set up for the given world.
   * If the event listeners are already set up and the `enabled` parameter is true, the method returns without doing anything.
   * If the world does not have camera controls, the method returns without doing anything.
   *
   * The method then retrieves the event listener for the given world using the `getWorldEvent` method.
   * It removes the existing event listeners for the "sleep" and "rest" events from the world's camera controls.
   *
   * If the `enabled` parameter is true, the method adds the event listener for the "sleep" and "rest" events to the world's camera controls.
   */
  setupEvents(e, s) {
    if (s && this._setupWorlds.has(e.uuid) || !e.camera.hasCameraControls())
      return;
    const i = this.getWorldEvent(e);
    e.camera.controls.removeEventListener("sleep", i), e.camera.controls.removeEventListener("rest", i), s && (e.camera.controls.addEventListener("sleep", i), e.camera.controls.addEventListener("rest", i));
  }
  /**
   * Performs clustering of markers in the given world.
   *
   * @param world - The world where clustering will be performed.
   *
   */
  cluster(e) {
    if (!this.autoCluster)
      return;
    this.resetMarkers();
    const s = this.list.get(e.uuid);
    if (s) {
      for (const [i, n] of s)
        if (!n.merged && !n.static) {
          this.currentKeys.clear();
          for (const [r, o] of s)
            o.static || n.key !== o.key && !o.merged && this.distance(n.label, o.label) < this.threshold && (this.currentKeys.add(o.key), o.merged = true);
          if (this.currentKeys.size > 0) {
            this.currentKeys.add(n.key), n.merged = true;
            const r = Array.from(this.currentKeys), o = this.getAveragePositionFromLabels(r), a = new is(
              n.label.world,
              this.createClusterElement(this._clusterKey.toString())
            ), { element: c } = a.three;
            c.textContent = r.length.toString(), a.three.position.copy(o), this.clusterLabels.add({
              key: this._clusterKey.toString(),
              markerKeys: r,
              label: a
            }), this._clusterKey++;
          }
        }
      this.removeMergeMarkers(e);
    }
  }
  getWorldEvent(e) {
    if (!this._worldEvents.has(e.uuid)) {
      const s = () => {
        this.cluster(e);
      };
      this._worldEvents.set(e.uuid, s);
    }
    return this._worldEvents.get(e.uuid);
  }
  resetMarkers() {
    for (const [e, s] of this.list)
      for (const [i, n] of s)
        n.merged = false;
    for (const e of this.clusterLabels)
      e.label.dispose();
    this.clusterLabels.clear(), this._clusterKey = 0;
  }
  removeMergeMarkers(e) {
    const s = this.list.get(e.uuid);
    if (s) {
      for (const [i, n] of s)
        n.merged ? n.label.dispose() : n.label.world.scene.three.add(n.label.three);
      for (const i of this.clusterLabels)
        if (i.markerKeys.length === 1) {
          for (const [n, r] of this.list) {
            const o = r.get(i.markerKeys[0]);
            if (!o)
              continue;
            o.label.world.scene.three.add(o.label.three), o.merged = false;
          }
          i.label.dispose(), this.clusterLabels.delete(i);
        }
    }
  }
  getAveragePositionFromLabels(e) {
    const s = e.map((i) => {
      for (const [n, r] of this.list) {
        const o = r.get(i);
        if (o)
          return o.label.three.position;
      }
      return new Vector3();
    });
    return s.reduce((i, n) => i.add(n), new Vector3()).divideScalar(s.length);
  }
  createClusterElement(e) {
    const s = document.createElement("div");
    return s.textContent = e, s.style.color = "#000000", s.style.background = "#FFFFFF", s.style.fontSize = "1.2rem", s.style.fontWeight = "500", s.style.pointerEvents = "auto", s.style.borderRadius = "50%", s.style.padding = "5px 11px", s.style.textAlign = "center", s.style.cursor = "pointer", s.addEventListener("pointerdown", () => {
      this.navigateToCluster(e);
    }), s.addEventListener("pointerover", () => {
      s.style.background = "#BCF124";
    }), s.addEventListener("pointerout", () => {
      s.style.background = "#FFFFFF";
    }), s;
  }
  getScreenPosition(e) {
    const s = new Vector3();
    if (!e.world.renderer)
      throw new Error("Renderer not found!");
    const i = e.three.position.clone();
    i.project(e.world.camera.three);
    const n = e.world.renderer.getSize();
    return s.x = i.x * n.x / 2 + n.x / 2, s.y = -(i.y * n.y / 2) + n.y / 2, s;
  }
  distance(e, s) {
    const i = this.getScreenPosition(e), n = this.getScreenPosition(s), r = i.x - n.x, o = i.y - n.y, a = Math.sqrt(r * r + o * o) * 0.5;
    return a === 0 ? this.threshold + 1 : a;
  }
  navigateToCluster(e) {
    const s = [], i = Array.from(this.clusterLabels).find(
      (d) => d.key === e
    );
    if (!i)
      return;
    const n = i.label.world.camera;
    if (!n.hasCameraControls()) {
      console.warn("Zoom to clusters only supported with Camera Controls!");
      return;
    }
    for (const d of i.markerKeys)
      for (const [u, f] of this.list) {
        const g = f.get(d);
        if (g) {
          const { x: m, y: _, z: p } = g.label.three.position;
          s.push(m, _, p);
        }
      }
    i.label.dispose(), this.clusterLabels.delete(i);
    const r = new BufferGeometry(), o = new Float32Array(s), a = new BufferAttribute(o, 3);
    r.setAttribute("position", a);
    const c = new Mesh(r);
    c.geometry.computeBoundingSphere(), c.geometry.boundingSphere && n.controls.fitToSphere(c, true), r.dispose(), c.clear(), s.length = 0;
  }
};
A(sn, "uuid", "4079eb91-79b0-4ede-bcf2-15b837129236");
var Oo = sn;
var qi = {
  name: "CopyShader",
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
  )
};
var Ae = class {
  /**
   * Constructs a new pass.
   */
  constructor() {
    this.isPass = true, this.enabled = true, this.needsSwap = true, this.clear = false, this.renderToScreen = false;
  }
  /**
   * Sets the size of the pass.
   *
   * @abstract
   * @param {number} width - The width to set.
   * @param {number} height - The width to set.
   */
  setSize() {
  }
  /**
   * This method holds the render logic of a pass. It must be implemented in all derived classes.
   *
   * @abstract
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the pass is no longer used in your app.
   *
   * @abstract
   */
  dispose() {
  }
};
var Rd = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var Ud = class extends BufferGeometry {
  constructor() {
    super(), this.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
  }
};
var Fd = new Ud();
var Ye = class {
  /**
   * Constructs a new full screen quad.
   *
   * @param {?Material} material - The material to render te full screen quad with.
   */
  constructor(t) {
    this._mesh = new Mesh(Fd, t);
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the instance is no longer used in your app.
   */
  dispose() {
    this._mesh.geometry.dispose();
  }
  /**
   * Renders the full screen quad.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   */
  render(t) {
    t.render(this._mesh, Rd);
  }
  /**
   * The quad's material.
   *
   * @type {?Material}
   */
  get material() {
    return this._mesh.material;
  }
  set material(t) {
    this._mesh.material = t;
  }
};
var Vd = class extends Ae {
  /**
   * Constructs a new shader pass.
   *
   * @param {Object|ShaderMaterial} [shader] - A shader object holding vertex and fragment shader as well as
   * defines and uniforms. It's also valid to pass a custom shader material.
   * @param {string} [textureID='tDiffuse'] - The name of the texture uniform that should sample
   * the read buffer.
   */
  constructor(t, e = "tDiffuse") {
    super(), this.textureID = e, this.uniforms = null, this.material = null, t instanceof ShaderMaterial ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = UniformsUtils.clone(t.uniforms), this.material = new ShaderMaterial({
      name: t.name !== void 0 ? t.name : "unspecified",
      defines: Object.assign({}, t.defines),
      uniforms: this.uniforms,
      vertexShader: t.vertexShader,
      fragmentShader: t.fragmentShader
    })), this._fsQuad = new Ye(this.material);
  }
  /**
   * Performs the shader pass.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(t, e, s) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = s.texture), this._fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this._fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this._fsQuad.render(t));
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the pass is no longer used in your app.
   */
  dispose() {
    this.material.dispose(), this._fsQuad.dispose();
  }
};
var Do = class extends Ae {
  /**
   * Constructs a new mask pass.
   *
   * @param {Scene} scene - The 3D objects in this scene will define the mask.
   * @param {Camera} camera - The camera.
   */
  constructor(t, e) {
    super(), this.scene = t, this.camera = e, this.clear = true, this.needsSwap = false, this.inverse = false;
  }
  /**
   * Performs a mask pass with the configured scene and camera.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(t, e, s) {
    const i = t.getContext(), n = t.state;
    n.buffers.color.setMask(false), n.buffers.depth.setMask(false), n.buffers.color.setLocked(true), n.buffers.depth.setLocked(true);
    let r, o;
    this.inverse ? (r = 0, o = 1) : (r = 1, o = 0), n.buffers.stencil.setTest(true), n.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE), n.buffers.stencil.setFunc(i.ALWAYS, r, 4294967295), n.buffers.stencil.setClear(o), n.buffers.stencil.setLocked(true), t.setRenderTarget(s), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(e), this.clear && t.clear(), t.render(this.scene, this.camera), n.buffers.color.setLocked(false), n.buffers.depth.setLocked(false), n.buffers.color.setMask(true), n.buffers.depth.setMask(true), n.buffers.stencil.setLocked(false), n.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295), n.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP), n.buffers.stencil.setLocked(true);
  }
};
var Hd = class extends Ae {
  /**
   * Constructs a new clear mask pass.
   */
  constructor() {
    super(), this.needsSwap = false;
  }
  /**
   * Performs the clear of the currently defined mask.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(t) {
    t.state.buffers.stencil.setLocked(false), t.state.buffers.stencil.setTest(false);
  }
};
var jd = class {
  /**
   * Constructs a new effect composer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} [renderTarget] - This render target and a clone will
   * be used as the internal read and write buffers. If not given, the composer creates
   * the buffers automatically.
   */
  constructor(t, e) {
    if (this.renderer = t, this._pixelRatio = t.getPixelRatio(), e === void 0) {
      const s = t.getSize(new Vector2());
      this._width = s.width, this._height = s.height, e = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType }), e.texture.name = "EffectComposer.rt1";
    } else
      this._width = e.width, this._height = e.height;
    this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = true, this.passes = [], this.copyPass = new Vd(qi), this.copyPass.material.blending = NoBlending, this.clock = new Clock();
  }
  /**
   * Swaps the internal read/write buffers.
   */
  swapBuffers() {
    const t = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = t;
  }
  /**
   * Adds the given pass to the pass chain.
   *
   * @param {Pass} pass - The pass to add.
   */
  addPass(t) {
    this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  /**
   * Inserts the given pass at a given index.
   *
   * @param {Pass} pass - The pass to insert.
   * @param {number} index - The index into the pass chain.
   */
  insertPass(t, e) {
    this.passes.splice(e, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  /**
   * Removes the given pass from the pass chain.
   *
   * @param {Pass} pass - The pass to remove.
   */
  removePass(t) {
    const e = this.passes.indexOf(t);
    e !== -1 && this.passes.splice(e, 1);
  }
  /**
   * Returns `true` if the pass for the given index is the last enabled pass in the pass chain.
   *
   * @param {number} passIndex - The pass index.
   * @return {boolean} Whether the the pass for the given index is the last pass in the pass chain.
   */
  isLastEnabledPass(t) {
    for (let e = t + 1; e < this.passes.length; e++)
      if (this.passes[e].enabled)
        return false;
    return true;
  }
  /**
   * Executes all enabled post-processing passes in order to produce the final frame.
   *
   * @param {number} deltaTime - The delta time in seconds. If not given, the composer computes
   * its own time delta value.
   */
  render(t) {
    t === void 0 && (t = this.clock.getDelta());
    const e = this.renderer.getRenderTarget();
    let s = false;
    for (let i = 0, n = this.passes.length; i < n; i++) {
      const r = this.passes[i];
      if (r.enabled !== false) {
        if (r.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i), r.render(this.renderer, this.writeBuffer, this.readBuffer, t, s), r.needsSwap) {
          if (s) {
            const o = this.renderer.getContext(), a = this.renderer.state.buffers.stencil;
            a.setFunc(o.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), a.setFunc(o.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        Do !== void 0 && (r instanceof Do ? s = true : r instanceof Hd && (s = false));
      }
    }
    this.renderer.setRenderTarget(e);
  }
  /**
   * Resets the internal state of the EffectComposer.
   *
   * @param {WebGLRenderTarget} [renderTarget] - This render target has the same purpose like
   * the one from the constructor. If set, it is used to setup the read and write buffers.
   */
  reset(t) {
    if (t === void 0) {
      const e = this.renderer.getSize(new Vector2());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = e.width, this._height = e.height, t = this.renderTarget1.clone(), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  /**
   * Resizes the internal read and write buffers as well as all passes. Similar to {@link WebGLRenderer#setSize},
   * this method honors the current pixel ration.
   *
   * @param {number} width - The width in logical pixels.
   * @param {number} height - The height in logical pixels.
   */
  setSize(t, e) {
    this._width = t, this._height = e;
    const s = this._width * this._pixelRatio, i = this._height * this._pixelRatio;
    this.renderTarget1.setSize(s, i), this.renderTarget2.setSize(s, i);
    for (let n = 0; n < this.passes.length; n++)
      this.passes[n].setSize(s, i);
  }
  /**
   * Sets device pixel ratio. This is usually used for HiDPI device to prevent blurring output.
   * Setting the pixel ratio will automatically resize the composer.
   *
   * @param {number} pixelRatio - The pixel ratio to set.
   */
  setPixelRatio(t) {
    this._pixelRatio = t, this.setSize(this._width, this._height);
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the composer is no longer used in your app.
   */
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
};
var Li = {
  defines: {
    PERSPECTIVE_CAMERA: 1,
    SAMPLES: 16,
    NORMAL_VECTOR_TYPE: 1,
    DEPTH_SWIZZLING: "x",
    SCREEN_SPACE_RADIUS: 0,
    SCREEN_SPACE_RADIUS_SCALE: 100,
    SCENE_CLIP_BOX: 0
  },
  uniforms: {
    tNormal: { value: null },
    tDepth: { value: null },
    tNoise: { value: null },
    resolution: { value: new Vector2() },
    cameraNear: { value: null },
    cameraFar: { value: null },
    cameraProjectionMatrix: { value: new Matrix4() },
    cameraProjectionMatrixInverse: { value: new Matrix4() },
    cameraWorldMatrix: { value: new Matrix4() },
    radius: { value: 0.25 },
    distanceExponent: { value: 1 },
    thickness: { value: 1 },
    distanceFallOff: { value: 1 },
    scale: { value: 1 },
    sceneBoxMin: { value: new Vector3(-1, -1, -1) },
    sceneBoxMax: { value: new Vector3(1, 1, 1) }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		varying vec2 vUv;
		uniform highp sampler2D tNormal;
		uniform highp sampler2D tDepth;
		uniform sampler2D tNoise;
		uniform vec2 resolution;
		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraProjectionMatrixInverse;
		uniform mat4 cameraWorldMatrix;
		uniform float radius;
		uniform float distanceExponent;
		uniform float thickness;
		uniform float distanceFallOff;
		uniform float scale;
		#if SCENE_CLIP_BOX == 1
			uniform vec3 sceneBoxMin;
			uniform vec3 sceneBoxMax;
		#endif

		#include <common>
		#include <packing>

		#ifndef FRAGMENT_OUTPUT
		#define FRAGMENT_OUTPUT vec4(vec3(ao), 1.)
		#endif

		vec3 getViewPosition(const in vec2 screenPosition, const in float depth) {
			vec4 clipSpacePosition = vec4(vec3(screenPosition, depth) * 2.0 - 1.0, 1.0);
			vec4 viewSpacePosition = cameraProjectionMatrixInverse * clipSpacePosition;
			return viewSpacePosition.xyz / viewSpacePosition.w;
		}

		float getDepth(const vec2 uv) {
			return textureLod(tDepth, uv.xy, 0.0).DEPTH_SWIZZLING;
		}

		float fetchDepth(const ivec2 uv) {
			return texelFetch(tDepth, uv.xy, 0).DEPTH_SWIZZLING;
		}

		float getViewZ(const in float depth) {
			#if PERSPECTIVE_CAMERA == 1
				return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
			#else
				return orthographicDepthToViewZ(depth, cameraNear, cameraFar);
			#endif
		}

		vec3 computeNormalFromDepth(const vec2 uv) {
			vec2 size = vec2(textureSize(tDepth, 0));
			ivec2 p = ivec2(uv * size);
			float c0 = fetchDepth(p);
			float l2 = fetchDepth(p - ivec2(2, 0));
			float l1 = fetchDepth(p - ivec2(1, 0));
			float r1 = fetchDepth(p + ivec2(1, 0));
			float r2 = fetchDepth(p + ivec2(2, 0));
			float b2 = fetchDepth(p - ivec2(0, 2));
			float b1 = fetchDepth(p - ivec2(0, 1));
			float t1 = fetchDepth(p + ivec2(0, 1));
			float t2 = fetchDepth(p + ivec2(0, 2));
			float dl = abs((2.0 * l1 - l2) - c0);
			float dr = abs((2.0 * r1 - r2) - c0);
			float db = abs((2.0 * b1 - b2) - c0);
			float dt = abs((2.0 * t1 - t2) - c0);
			vec3 ce = getViewPosition(uv, c0).xyz;
			vec3 dpdx = (dl < dr) ? ce - getViewPosition((uv - vec2(1.0 / size.x, 0.0)), l1).xyz : -ce + getViewPosition((uv + vec2(1.0 / size.x, 0.0)), r1).xyz;
			vec3 dpdy = (db < dt) ? ce - getViewPosition((uv - vec2(0.0, 1.0 / size.y)), b1).xyz : -ce + getViewPosition((uv + vec2(0.0, 1.0 / size.y)), t1).xyz;
			return normalize(cross(dpdx, dpdy));
		}

		vec3 getViewNormal(const vec2 uv) {
			#if NORMAL_VECTOR_TYPE == 2
				return normalize(textureLod(tNormal, uv, 0.).rgb);
			#elif NORMAL_VECTOR_TYPE == 1
				return unpackRGBToNormal(textureLod(tNormal, uv, 0.).rgb);
			#else
				return computeNormalFromDepth(uv);
			#endif
		}

		vec3 getSceneUvAndDepth(vec3 sampleViewPos) {
			vec4 sampleClipPos = cameraProjectionMatrix * vec4(sampleViewPos, 1.);
			vec2 sampleUv = sampleClipPos.xy / sampleClipPos.w * 0.5 + 0.5;
			float sampleSceneDepth = getDepth(sampleUv);
			return vec3(sampleUv, sampleSceneDepth);
		}

		void main() {
			float depth = getDepth(vUv.xy);
			if (depth >= 1.0) {
				discard;
				return;
			}
			vec3 viewPos = getViewPosition(vUv, depth);
			vec3 viewNormal = getViewNormal(vUv);

			float radiusToUse = radius;
			float distanceFalloffToUse = thickness;
			#if SCREEN_SPACE_RADIUS == 1
				float radiusScale = getViewPosition(vec2(0.5 + float(SCREEN_SPACE_RADIUS_SCALE) / resolution.x, 0.0), depth).x;
				radiusToUse *= radiusScale;
				distanceFalloffToUse *= radiusScale;
			#endif

			#if SCENE_CLIP_BOX == 1
				vec3 worldPos = (cameraWorldMatrix * vec4(viewPos, 1.0)).xyz;
				float boxDistance = length(max(vec3(0.0), max(sceneBoxMin - worldPos, worldPos - sceneBoxMax)));
				if (boxDistance > radiusToUse) {
					discard;
					return;
				}
			#endif

			vec2 noiseResolution = vec2(textureSize(tNoise, 0));
			vec2 noiseUv = vUv * resolution / noiseResolution;
			vec4 noiseTexel = textureLod(tNoise, noiseUv, 0.0);
			vec3 randomVec = noiseTexel.xyz * 2.0 - 1.0;
			vec3 tangent = normalize(vec3(randomVec.xy, 0.));
			vec3 bitangent = vec3(-tangent.y, tangent.x, 0.);
			mat3 kernelMatrix = mat3(tangent, bitangent, vec3(0., 0., 1.));

			const int DIRECTIONS = SAMPLES < 30 ? 3 : 5;
			const int STEPS = (SAMPLES + DIRECTIONS - 1) / DIRECTIONS;
			float ao = 0.0;
			for (int i = 0; i < DIRECTIONS; ++i) {

				float angle = float(i) / float(DIRECTIONS) * PI;
				vec4 sampleDir = vec4(cos(angle), sin(angle), 0., 0.5 + 0.5 * noiseTexel.w);
				sampleDir.xyz = normalize(kernelMatrix * sampleDir.xyz);

				vec3 viewDir = normalize(-viewPos.xyz);
				vec3 sliceBitangent = normalize(cross(sampleDir.xyz, viewDir));
				vec3 sliceTangent = cross(sliceBitangent, viewDir);
				vec3 normalInSlice = normalize(viewNormal - sliceBitangent * dot(viewNormal, sliceBitangent));

				vec3 tangentToNormalInSlice = cross(normalInSlice, sliceBitangent);
				vec2 cosHorizons = vec2(dot(viewDir, tangentToNormalInSlice), dot(viewDir, -tangentToNormalInSlice));

				for (int j = 0; j < STEPS; ++j) {
					vec3 sampleViewOffset = sampleDir.xyz * radiusToUse * sampleDir.w * pow(float(j + 1) / float(STEPS), distanceExponent);

					vec3 sampleSceneUvDepth = getSceneUvAndDepth(viewPos + sampleViewOffset);
					vec3 sampleSceneViewPos = getViewPosition(sampleSceneUvDepth.xy, sampleSceneUvDepth.z);
					vec3 viewDelta = sampleSceneViewPos - viewPos;
					if (abs(viewDelta.z) < thickness) {
						float sampleCosHorizon = dot(viewDir, normalize(viewDelta));
						cosHorizons.x += max(0., (sampleCosHorizon - cosHorizons.x) * mix(1., 2. / float(j + 2), distanceFallOff));
					}

					sampleSceneUvDepth = getSceneUvAndDepth(viewPos - sampleViewOffset);
					sampleSceneViewPos = getViewPosition(sampleSceneUvDepth.xy, sampleSceneUvDepth.z);
					viewDelta = sampleSceneViewPos - viewPos;
					if (abs(viewDelta.z) < thickness) {
						float sampleCosHorizon = dot(viewDir, normalize(viewDelta));
						cosHorizons.y += max(0., (sampleCosHorizon - cosHorizons.y) * mix(1., 2. / float(j + 2), distanceFallOff));
					}
				}

				vec2 sinHorizons = sqrt(1. - cosHorizons * cosHorizons);
				float nx = dot(normalInSlice, sliceTangent);
				float ny = dot(normalInSlice, viewDir);
				float nxb = 1. / 2. * (acos(cosHorizons.y) - acos(cosHorizons.x) + sinHorizons.x * cosHorizons.x - sinHorizons.y * cosHorizons.y);
				float nyb = 1. / 2. * (2. - cosHorizons.x * cosHorizons.x - cosHorizons.y * cosHorizons.y);
				float occlusion = nx * nxb + ny * nyb;
				ao += occlusion;
			}

			ao = clamp(ao / float(DIRECTIONS), 0., 1.);
		#if SCENE_CLIP_BOX == 1
			ao = mix(ao, 1., smoothstep(0., radiusToUse, boxDistance));
		#endif
			ao = pow(ao, scale);

			gl_FragColor = FRAGMENT_OUTPUT;
		}`
  )
};
var Ni = {
  defines: {
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDepth: { value: null },
    cameraNear: { value: null },
    cameraFar: { value: null }
  },
  vertexShader: (
    /* glsl */
    `
		varying vec2 vUv;

		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform sampler2D tDepth;
		uniform float cameraNear;
		uniform float cameraFar;
		varying vec2 vUv;

		#include <packing>

		float getLinearDepth( const in vec2 screenPosition ) {
			#if PERSPECTIVE_CAMERA == 1
				float fragCoordZ = texture2D( tDepth, screenPosition ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );
			#else
				return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		void main() {
			float depth = getLinearDepth( vUv );
			gl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );

		}`
  )
};
var Un = {
  uniforms: {
    tDiffuse: { value: null },
    intensity: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `
		varying vec2 vUv;

		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform float intensity;
		uniform sampler2D tDiffuse;
		varying vec2 vUv;

		void main() {
			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = vec4(mix(vec3(1.), texel.rgb, intensity), texel.a);
		}`
  )
};
function Wd(l = 5) {
  const t = Math.floor(l) % 2 === 0 ? Math.floor(l) + 1 : Math.floor(l), e = Xd(t), s = e.length, i = new Uint8Array(s * 4);
  for (let r = 0; r < s; ++r) {
    const o = e[r], a = 2 * Math.PI * o / s, c = new Vector3(
      Math.cos(a),
      Math.sin(a),
      0
    ).normalize();
    i[r * 4] = (c.x * 0.5 + 0.5) * 255, i[r * 4 + 1] = (c.y * 0.5 + 0.5) * 255, i[r * 4 + 2] = 127, i[r * 4 + 3] = 255;
  }
  const n = new DataTexture(i, t, t);
  return n.wrapS = RepeatWrapping, n.wrapT = RepeatWrapping, n.needsUpdate = true, n;
}
function Xd(l) {
  const t = Math.floor(l) % 2 === 0 ? Math.floor(l) + 1 : Math.floor(l), e = t * t, s = Array(e).fill(0);
  let i = Math.floor(t / 2), n = t - 1;
  for (let r = 1; r <= e; ) {
    if (i === -1 && n === t ? (n = t - 2, i = 0) : (n === t && (n = 0), i < 0 && (i = t - 1)), s[i * t + n] !== 0) {
      n -= 2, i++;
      continue;
    } else
      s[i * t + n] = r++;
    n++, i--;
  }
  return s;
}
var ki = {
  defines: {
    SAMPLES: 16,
    SAMPLE_VECTORS: Ua(16, 2, 1),
    NORMAL_VECTOR_TYPE: 1,
    DEPTH_VALUE_SOURCE: 0
  },
  uniforms: {
    tDiffuse: { value: null },
    tNormal: { value: null },
    tDepth: { value: null },
    tNoise: { value: null },
    resolution: { value: new Vector2() },
    cameraProjectionMatrixInverse: { value: new Matrix4() },
    lumaPhi: { value: 5 },
    depthPhi: { value: 5 },
    normalPhi: { value: 5 },
    radius: { value: 4 },
    index: { value: 0 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		varying vec2 vUv;

		uniform sampler2D tDiffuse;
		uniform sampler2D tNormal;
		uniform sampler2D tDepth;
		uniform sampler2D tNoise;
		uniform vec2 resolution;
		uniform mat4 cameraProjectionMatrixInverse;
		uniform float lumaPhi;
		uniform float depthPhi;
		uniform float normalPhi;
		uniform float radius;
		uniform int index;

		#include <common>
		#include <packing>

		#ifndef SAMPLE_LUMINANCE
		#define SAMPLE_LUMINANCE dot(vec3(0.2125, 0.7154, 0.0721), a)
		#endif

		#ifndef FRAGMENT_OUTPUT
		#define FRAGMENT_OUTPUT vec4(denoised, 1.)
		#endif

		float getLuminance(const in vec3 a) {
			return SAMPLE_LUMINANCE;
		}

		const vec3 poissonDisk[SAMPLES] = SAMPLE_VECTORS;

		vec3 getViewPosition(const in vec2 screenPosition, const in float depth) {
			vec4 clipSpacePosition = vec4(vec3(screenPosition, depth) * 2.0 - 1.0, 1.0);
			vec4 viewSpacePosition = cameraProjectionMatrixInverse * clipSpacePosition;
			return viewSpacePosition.xyz / viewSpacePosition.w;
		}

		float getDepth(const vec2 uv) {
		#if DEPTH_VALUE_SOURCE == 1
			return textureLod(tDepth, uv.xy, 0.0).a;
		#else
			return textureLod(tDepth, uv.xy, 0.0).r;
		#endif
		}

		float fetchDepth(const ivec2 uv) {
			#if DEPTH_VALUE_SOURCE == 1
				return texelFetch(tDepth, uv.xy, 0).a;
			#else
				return texelFetch(tDepth, uv.xy, 0).r;
			#endif
		}

		vec3 computeNormalFromDepth(const vec2 uv) {
			vec2 size = vec2(textureSize(tDepth, 0));
			ivec2 p = ivec2(uv * size);
			float c0 = fetchDepth(p);
			float l2 = fetchDepth(p - ivec2(2, 0));
			float l1 = fetchDepth(p - ivec2(1, 0));
			float r1 = fetchDepth(p + ivec2(1, 0));
			float r2 = fetchDepth(p + ivec2(2, 0));
			float b2 = fetchDepth(p - ivec2(0, 2));
			float b1 = fetchDepth(p - ivec2(0, 1));
			float t1 = fetchDepth(p + ivec2(0, 1));
			float t2 = fetchDepth(p + ivec2(0, 2));
			float dl = abs((2.0 * l1 - l2) - c0);
			float dr = abs((2.0 * r1 - r2) - c0);
			float db = abs((2.0 * b1 - b2) - c0);
			float dt = abs((2.0 * t1 - t2) - c0);
			vec3 ce = getViewPosition(uv, c0).xyz;
			vec3 dpdx = (dl < dr) ?  ce - getViewPosition((uv - vec2(1.0 / size.x, 0.0)), l1).xyz
									: -ce + getViewPosition((uv + vec2(1.0 / size.x, 0.0)), r1).xyz;
			vec3 dpdy = (db < dt) ?  ce - getViewPosition((uv - vec2(0.0, 1.0 / size.y)), b1).xyz
									: -ce + getViewPosition((uv + vec2(0.0, 1.0 / size.y)), t1).xyz;
			return normalize(cross(dpdx, dpdy));
		}

		vec3 getViewNormal(const vec2 uv) {
		#if NORMAL_VECTOR_TYPE == 2
			return normalize(textureLod(tNormal, uv, 0.).rgb);
		#elif NORMAL_VECTOR_TYPE == 1
			return unpackRGBToNormal(textureLod(tNormal, uv, 0.).rgb);
		#else
			return computeNormalFromDepth(uv);
		#endif
		}

		void denoiseSample(in vec3 center, in vec3 viewNormal, in vec3 viewPos, in vec2 sampleUv, inout vec3 denoised, inout float totalWeight) {
			vec4 sampleTexel = textureLod(tDiffuse, sampleUv, 0.0);
			float sampleDepth = getDepth(sampleUv);
			vec3 sampleNormal = getViewNormal(sampleUv);
			vec3 neighborColor = sampleTexel.rgb;
			vec3 viewPosSample = getViewPosition(sampleUv, sampleDepth);

			float normalDiff = dot(viewNormal, sampleNormal);
			float normalSimilarity = pow(max(normalDiff, 0.), normalPhi);
			float lumaDiff = abs(getLuminance(neighborColor) - getLuminance(center));
			float lumaSimilarity = max(1.0 - lumaDiff / lumaPhi, 0.0);
			float depthDiff = abs(dot(viewPos - viewPosSample, viewNormal));
			float depthSimilarity = max(1. - depthDiff / depthPhi, 0.);
			float w = lumaSimilarity * depthSimilarity * normalSimilarity;

			denoised += w * neighborColor;
			totalWeight += w;
		}

		void main() {
			float depth = getDepth(vUv.xy);
			vec3 viewNormal = getViewNormal(vUv);
			if (depth == 1. || dot(viewNormal, viewNormal) == 0.) {
				discard;
				return;
			}
			vec4 texel = textureLod(tDiffuse, vUv, 0.0);
			vec3 center = texel.rgb;
			vec3 viewPos = getViewPosition(vUv, depth);

			vec2 noiseResolution = vec2(textureSize(tNoise, 0));
			vec2 noiseUv = vUv * resolution / noiseResolution;
			vec4 noiseTexel = textureLod(tNoise, noiseUv, 0.0);
      		vec2 noiseVec = vec2(sin(noiseTexel[index % 4] * 2. * PI), cos(noiseTexel[index % 4] * 2. * PI));
    		mat2 rotationMatrix = mat2(noiseVec.x, -noiseVec.y, noiseVec.x, noiseVec.y);

			float totalWeight = 1.0;
			vec3 denoised = texel.rgb;
			for (int i = 0; i < SAMPLES; i++) {
				vec3 sampleDir = poissonDisk[i];
				vec2 offset = rotationMatrix * (sampleDir.xy * (1. + sampleDir.z * (radius - 1.)) / resolution);
				vec2 sampleUv = vUv + offset;
				denoiseSample(center, viewNormal, viewPos, sampleUv, denoised, totalWeight);
			}

			if (totalWeight > 0.) {
				denoised /= totalWeight;
			}
			gl_FragColor = FRAGMENT_OUTPUT;
		}`
  )
};
function Ua(l, t, e) {
  const s = Yd(
    l,
    t,
    e
  );
  let i = "vec3[SAMPLES](";
  for (let n = 0; n < l; n++) {
    const r = s[n];
    i += `vec3(${r.x}, ${r.y}, ${r.z})${n < l - 1 ? "," : ")"}`;
  }
  return i;
}
function Yd(l, t, e) {
  const s = [];
  for (let i = 0; i < l; i++) {
    const n = 2 * Math.PI * t * i / l, r = Math.pow(i / (l - 1), e);
    s.push(new Vector3(Math.cos(n), Math.sin(n), r));
  }
  return s;
}
var Gd = class {
  /**
   * Constructs a new simplex noise object.
   *
   * @param {Object} [r=Math] - A math utility class that holds a `random()` method. This makes it
   * possible to pass in custom random number generator.
   */
  constructor(t = Math) {
    this.grad3 = [
      [1, 1, 0],
      [-1, 1, 0],
      [1, -1, 0],
      [-1, -1, 0],
      [1, 0, 1],
      [-1, 0, 1],
      [1, 0, -1],
      [-1, 0, -1],
      [0, 1, 1],
      [0, -1, 1],
      [0, 1, -1],
      [0, -1, -1]
    ], this.grad4 = [
      [0, 1, 1, 1],
      [0, 1, 1, -1],
      [0, 1, -1, 1],
      [0, 1, -1, -1],
      [0, -1, 1, 1],
      [0, -1, 1, -1],
      [0, -1, -1, 1],
      [0, -1, -1, -1],
      [1, 0, 1, 1],
      [1, 0, 1, -1],
      [1, 0, -1, 1],
      [1, 0, -1, -1],
      [-1, 0, 1, 1],
      [-1, 0, 1, -1],
      [-1, 0, -1, 1],
      [-1, 0, -1, -1],
      [1, 1, 0, 1],
      [1, 1, 0, -1],
      [1, -1, 0, 1],
      [1, -1, 0, -1],
      [-1, 1, 0, 1],
      [-1, 1, 0, -1],
      [-1, -1, 0, 1],
      [-1, -1, 0, -1],
      [1, 1, 1, 0],
      [1, 1, -1, 0],
      [1, -1, 1, 0],
      [1, -1, -1, 0],
      [-1, 1, 1, 0],
      [-1, 1, -1, 0],
      [-1, -1, 1, 0],
      [-1, -1, -1, 0]
    ], this.p = [];
    for (let e = 0; e < 256; e++)
      this.p[e] = Math.floor(t.random() * 256);
    this.perm = [];
    for (let e = 0; e < 512; e++)
      this.perm[e] = this.p[e & 255];
    this.simplex = [
      [0, 1, 2, 3],
      [0, 1, 3, 2],
      [0, 0, 0, 0],
      [0, 2, 3, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 2, 3, 0],
      [0, 2, 1, 3],
      [0, 0, 0, 0],
      [0, 3, 1, 2],
      [0, 3, 2, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 3, 2, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 2, 0, 3],
      [0, 0, 0, 0],
      [1, 3, 0, 2],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 3, 0, 1],
      [2, 3, 1, 0],
      [1, 0, 2, 3],
      [1, 0, 3, 2],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 0, 3, 1],
      [0, 0, 0, 0],
      [2, 1, 3, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 0, 1, 3],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [3, 0, 1, 2],
      [3, 0, 2, 1],
      [0, 0, 0, 0],
      [3, 1, 2, 0],
      [2, 1, 0, 3],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [3, 1, 0, 2],
      [0, 0, 0, 0],
      [3, 2, 0, 1],
      [3, 2, 1, 0]
    ];
  }
  /**
   * A 2D simplex noise method.
   *
   * @param {number} xin - The x coordinate.
   * @param {number} yin - The y coordinate.
   * @return {number} The noise value.
   */
  noise(t, e) {
    let s, i, n;
    const r = 0.5 * (Math.sqrt(3) - 1), o = (t + e) * r, a = Math.floor(t + o), c = Math.floor(e + o), h = (3 - Math.sqrt(3)) / 6, d = (a + c) * h, u = a - d, f = c - d, g = t - u, m = e - f;
    let _, p;
    g > m ? (_ = 1, p = 0) : (_ = 0, p = 1);
    const y = g - _ + h, b = m - p + h, x = g - 1 + 2 * h, S = m - 1 + 2 * h, C = a & 255, P = c & 255, O = this.perm[C + this.perm[P]] % 12, z = this.perm[C + _ + this.perm[P + p]] % 12, k = this.perm[C + 1 + this.perm[P + 1]] % 12;
    let H = 0.5 - g * g - m * m;
    H < 0 ? s = 0 : (H *= H, s = H * H * this._dot(this.grad3[O], g, m));
    let T = 0.5 - y * y - b * b;
    T < 0 ? i = 0 : (T *= T, i = T * T * this._dot(this.grad3[z], y, b));
    let L = 0.5 - x * x - S * S;
    return L < 0 ? n = 0 : (L *= L, n = L * L * this._dot(this.grad3[k], x, S)), 70 * (s + i + n);
  }
  /**
   * A 3D simplex noise method.
   *
   * @param {number} xin - The x coordinate.
   * @param {number} yin - The y coordinate.
   * @param {number} zin - The z coordinate.
   * @return {number} The noise value.
   */
  noise3d(t, e, s) {
    let i, n, r, o;
    const c = (t + e + s) * 0.3333333333333333, h = Math.floor(t + c), d = Math.floor(e + c), u = Math.floor(s + c), f = 1 / 6, g = (h + d + u) * f, m = h - g, _ = d - g, p = u - g, y = t - m, b = e - _, x = s - p;
    let S, C, P, O, z, k;
    y >= b ? b >= x ? (S = 1, C = 0, P = 0, O = 1, z = 1, k = 0) : y >= x ? (S = 1, C = 0, P = 0, O = 1, z = 0, k = 1) : (S = 0, C = 0, P = 1, O = 1, z = 0, k = 1) : b < x ? (S = 0, C = 0, P = 1, O = 0, z = 1, k = 1) : y < x ? (S = 0, C = 1, P = 0, O = 0, z = 1, k = 1) : (S = 0, C = 1, P = 0, O = 1, z = 1, k = 0);
    const H = y - S + f, T = b - C + f, L = x - P + f, w = y - O + 2 * f, N = b - z + 2 * f, K = x - k + 2 * f, W = y - 1 + 3 * f, st = b - 1 + 3 * f, j = x - 1 + 3 * f, it = h & 255, U = d & 255, R = u & 255, rt = this.perm[it + this.perm[U + this.perm[R]]] % 12, Q = this.perm[it + S + this.perm[U + C + this.perm[R + P]]] % 12, J = this.perm[it + O + this.perm[U + z + this.perm[R + k]]] % 12, pt = this.perm[it + 1 + this.perm[U + 1 + this.perm[R + 1]]] % 12;
    let gt = 0.6 - y * y - b * b - x * x;
    gt < 0 ? i = 0 : (gt *= gt, i = gt * gt * this._dot3(this.grad3[rt], y, b, x));
    let ht = 0.6 - H * H - T * T - L * L;
    ht < 0 ? n = 0 : (ht *= ht, n = ht * ht * this._dot3(this.grad3[Q], H, T, L));
    let dt = 0.6 - w * w - N * N - K * K;
    dt < 0 ? r = 0 : (dt *= dt, r = dt * dt * this._dot3(this.grad3[J], w, N, K));
    let mt = 0.6 - W * W - st * st - j * j;
    return mt < 0 ? o = 0 : (mt *= mt, o = mt * mt * this._dot3(this.grad3[pt], W, st, j)), 32 * (i + n + r + o);
  }
  /**
   * A 4D simplex noise method.
   *
   * @param {number} x - The x coordinate.
   * @param {number} y - The y coordinate.
   * @param {number} z - The z coordinate.
   * @param {number} w - The w coordinate.
   * @return {number} The noise value.
   */
  noise4d(t, e, s, i) {
    const n = this.grad4, r = this.simplex, o = this.perm, a = (Math.sqrt(5) - 1) / 4, c = (5 - Math.sqrt(5)) / 20;
    let h, d, u, f, g;
    const m = (t + e + s + i) * a, _ = Math.floor(t + m), p = Math.floor(e + m), y = Math.floor(s + m), b = Math.floor(i + m), x = (_ + p + y + b) * c, S = _ - x, C = p - x, P = y - x, O = b - x, z = t - S, k = e - C, H = s - P, T = i - O, L = z > k ? 32 : 0, w = z > H ? 16 : 0, N = k > H ? 8 : 0, K = z > T ? 4 : 0, W = k > T ? 2 : 0, st = H > T ? 1 : 0, j = L + w + N + K + W + st, it = r[j][0] >= 3 ? 1 : 0, U = r[j][1] >= 3 ? 1 : 0, R = r[j][2] >= 3 ? 1 : 0, rt = r[j][3] >= 3 ? 1 : 0, Q = r[j][0] >= 2 ? 1 : 0, J = r[j][1] >= 2 ? 1 : 0, pt = r[j][2] >= 2 ? 1 : 0, gt = r[j][3] >= 2 ? 1 : 0, ht = r[j][0] >= 1 ? 1 : 0, dt = r[j][1] >= 1 ? 1 : 0, mt = r[j][2] >= 1 ? 1 : 0, yt = r[j][3] >= 1 ? 1 : 0, It = z - it + c, zt = k - U + c, v = H - R + c, Y = T - rt + c, X = z - Q + 2 * c, I = k - J + 2 * c, M = H - pt + 2 * c, B = T - gt + 2 * c, G = z - ht + 3 * c, Z = k - dt + 3 * c, F = H - mt + 3 * c, $ = T - yt + 3 * c, nt = z - 1 + 4 * c, et = k - 1 + 4 * c, at = H - 1 + 4 * c, vt = T - 1 + 4 * c, ft = _ & 255, Nt = p & 255, ce = y & 255, Ht = b & 255, Ze = o[ft + o[Nt + o[ce + o[Ht]]]] % 32, At = o[ft + it + o[Nt + U + o[ce + R + o[Ht + rt]]]] % 32, rs = o[ft + Q + o[Nt + J + o[ce + pt + o[Ht + gt]]]] % 32, Ps = o[ft + ht + o[Nt + dt + o[ce + mt + o[Ht + yt]]]] % 32, he = o[ft + 1 + o[Nt + 1 + o[ce + 1 + o[Ht + 1]]]] % 32;
    let ze2 = 0.6 - z * z - k * k - H * H - T * T;
    ze2 < 0 ? h = 0 : (ze2 *= ze2, h = ze2 * ze2 * this._dot4(n[Ze], z, k, H, T));
    let qe = 0.6 - It * It - zt * zt - v * v - Y * Y;
    qe < 0 ? d = 0 : (qe *= qe, d = qe * qe * this._dot4(n[At], It, zt, v, Y));
    let Qe = 0.6 - X * X - I * I - M * M - B * B;
    Qe < 0 ? u = 0 : (Qe *= Qe, u = Qe * Qe * this._dot4(n[rs], X, I, M, B));
    let Ke = 0.6 - G * G - Z * Z - F * F - $ * $;
    Ke < 0 ? f = 0 : (Ke *= Ke, f = Ke * Ke * this._dot4(n[Ps], G, Z, F, $));
    let Le = 0.6 - nt * nt - et * et - at * at - vt * vt;
    return Le < 0 ? g = 0 : (Le *= Le, g = Le * Le * this._dot4(n[he], nt, et, at, vt)), 27 * (h + d + u + f + g);
  }
  // private
  _dot(t, e, s) {
    return t[0] * e + t[1] * s;
  }
  _dot3(t, e, s, i) {
    return t[0] * e + t[1] * s + t[2] * i;
  }
  _dot4(t, e, s, i, n) {
    return t[0] * e + t[1] * s + t[2] * i + t[3] * n;
  }
};
var Jt = class _Jt extends Ae {
  /**
   * Constructs a new GTAO pass.
   *
   * @param {Scene} scene - The scene to compute the AO for.
   * @param {Camera} camera - The camera.
   * @param {number} [width=512] - The width of the effect.
   * @param {number} [height=512] - The height of the effect.
   * @param {Object} [parameters] - The pass parameters.
   * @param {Object} [aoParameters] - The AO parameters.
   * @param {Object} [pdParameters] - The denoise parameters.
   */
  constructor(t, e, s = 512, i = 512, n, r, o) {
    super(), this.width = s, this.height = i, this.clear = true, this.camera = e, this.scene = t, this.output = 0, this._renderGBuffer = true, this._visibilityCache = /* @__PURE__ */ new Map(), this.blendIntensity = 1, this.pdRings = 2, this.pdRadiusExponent = 2, this.pdSamples = 16, this.gtaoNoiseTexture = Wd(), this.pdNoiseTexture = this._generateNoise(), this.gtaoRenderTarget = new WebGLRenderTarget(this.width, this.height, { type: HalfFloatType }), this.pdRenderTarget = this.gtaoRenderTarget.clone(), this.gtaoMaterial = new ShaderMaterial({
      defines: Object.assign({}, Li.defines),
      uniforms: UniformsUtils.clone(Li.uniforms),
      vertexShader: Li.vertexShader,
      fragmentShader: Li.fragmentShader,
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    }), this.gtaoMaterial.defines.PERSPECTIVE_CAMERA = this.camera.isPerspectiveCamera ? 1 : 0, this.gtaoMaterial.uniforms.tNoise.value = this.gtaoNoiseTexture, this.gtaoMaterial.uniforms.resolution.value.set(this.width, this.height), this.gtaoMaterial.uniforms.cameraNear.value = this.camera.near, this.gtaoMaterial.uniforms.cameraFar.value = this.camera.far, this.normalMaterial = new MeshNormalMaterial(), this.normalMaterial.blending = NoBlending, this.pdMaterial = new ShaderMaterial({
      defines: Object.assign({}, ki.defines),
      uniforms: UniformsUtils.clone(ki.uniforms),
      vertexShader: ki.vertexShader,
      fragmentShader: ki.fragmentShader,
      depthTest: false,
      depthWrite: false
    }), this.pdMaterial.uniforms.tDiffuse.value = this.gtaoRenderTarget.texture, this.pdMaterial.uniforms.tNoise.value = this.pdNoiseTexture, this.pdMaterial.uniforms.resolution.value.set(this.width, this.height), this.pdMaterial.uniforms.lumaPhi.value = 10, this.pdMaterial.uniforms.depthPhi.value = 2, this.pdMaterial.uniforms.normalPhi.value = 3, this.pdMaterial.uniforms.radius.value = 8, this.depthRenderMaterial = new ShaderMaterial({
      defines: Object.assign({}, Ni.defines),
      uniforms: UniformsUtils.clone(Ni.uniforms),
      vertexShader: Ni.vertexShader,
      fragmentShader: Ni.fragmentShader,
      blending: NoBlending
    }), this.depthRenderMaterial.uniforms.cameraNear.value = this.camera.near, this.depthRenderMaterial.uniforms.cameraFar.value = this.camera.far, this.copyMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(qi.uniforms),
      vertexShader: qi.vertexShader,
      fragmentShader: qi.fragmentShader,
      transparent: true,
      depthTest: false,
      depthWrite: false,
      blendSrc: DstColorFactor,
      blendDst: ZeroFactor,
      blendEquation: AddEquation,
      blendSrcAlpha: DstAlphaFactor,
      blendDstAlpha: ZeroFactor,
      blendEquationAlpha: AddEquation
    }), this.blendMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(Un.uniforms),
      vertexShader: Un.vertexShader,
      fragmentShader: Un.fragmentShader,
      transparent: true,
      depthTest: false,
      depthWrite: false,
      blending: CustomBlending,
      blendSrc: DstColorFactor,
      blendDst: ZeroFactor,
      blendEquation: AddEquation,
      blendSrcAlpha: DstAlphaFactor,
      blendDstAlpha: ZeroFactor,
      blendEquationAlpha: AddEquation
    }), this._fsQuad = new Ye(null), this._originalClearColor = new Color(), this.setGBuffer(n ? n.depthTexture : void 0, n ? n.normalTexture : void 0), r !== void 0 && this.updateGtaoMaterial(r), o !== void 0 && this.updatePdMaterial(o);
  }
  /**
   * Sets the size of the pass.
   *
   * @param {number} width - The width to set.
   * @param {number} height - The width to set.
   */
  setSize(t, e) {
    this.width = t, this.height = e, this.gtaoRenderTarget.setSize(t, e), this.normalRenderTarget.setSize(t, e), this.pdRenderTarget.setSize(t, e), this.gtaoMaterial.uniforms.resolution.value.set(t, e), this.gtaoMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix), this.gtaoMaterial.uniforms.cameraProjectionMatrixInverse.value.copy(this.camera.projectionMatrixInverse), this.pdMaterial.uniforms.resolution.value.set(t, e), this.pdMaterial.uniforms.cameraProjectionMatrixInverse.value.copy(this.camera.projectionMatrixInverse);
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the pass is no longer used in your app.
   */
  dispose() {
    this.gtaoNoiseTexture.dispose(), this.pdNoiseTexture.dispose(), this.normalRenderTarget.dispose(), this.gtaoRenderTarget.dispose(), this.pdRenderTarget.dispose(), this.normalMaterial.dispose(), this.pdMaterial.dispose(), this.copyMaterial.dispose(), this.depthRenderMaterial.dispose(), this._fsQuad.dispose();
  }
  /**
   * A texture holding the computed AO.
   *
   * @type {Texture}
   * @readonly
   */
  get gtaoMap() {
    return this.pdRenderTarget.texture;
  }
  /**
   * Configures the GBuffer of this pass. If no arguments are passed,
   * the pass creates an internal render target for holding depth
   * and normal data.
   *
   * @param {DepthTexture} [depthTexture] - The depth texture.
   * @param {DepthTexture} [normalTexture] - The normal texture.
   */
  setGBuffer(t, e) {
    t !== void 0 ? (this.depthTexture = t, this.normalTexture = e, this._renderGBuffer = false) : (this.depthTexture = new DepthTexture(), this.depthTexture.format = DepthStencilFormat, this.depthTexture.type = UnsignedInt248Type, this.normalRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      type: HalfFloatType,
      depthTexture: this.depthTexture
    }), this.normalTexture = this.normalRenderTarget.texture, this._renderGBuffer = true);
    const s = this.normalTexture ? 1 : 0, i = this.depthTexture === this.normalTexture ? "w" : "x";
    this.gtaoMaterial.defines.NORMAL_VECTOR_TYPE = s, this.gtaoMaterial.defines.DEPTH_SWIZZLING = i, this.gtaoMaterial.uniforms.tNormal.value = this.normalTexture, this.gtaoMaterial.uniforms.tDepth.value = this.depthTexture, this.pdMaterial.defines.NORMAL_VECTOR_TYPE = s, this.pdMaterial.defines.DEPTH_SWIZZLING = i, this.pdMaterial.uniforms.tNormal.value = this.normalTexture, this.pdMaterial.uniforms.tDepth.value = this.depthTexture, this.depthRenderMaterial.uniforms.tDepth.value = this.normalRenderTarget.depthTexture;
  }
  /**
   * Configures the clip box of the GTAO shader with the given AABB.
   *
   * @param {?Box3} box - The AABB enclosing the scene that should receive AO. When passing
   * `null`, to clip box is used.
   */
  setSceneClipBox(t) {
    t ? (this.gtaoMaterial.needsUpdate = this.gtaoMaterial.defines.SCENE_CLIP_BOX !== 1, this.gtaoMaterial.defines.SCENE_CLIP_BOX = 1, this.gtaoMaterial.uniforms.sceneBoxMin.value.copy(t.min), this.gtaoMaterial.uniforms.sceneBoxMax.value.copy(t.max)) : (this.gtaoMaterial.needsUpdate = this.gtaoMaterial.defines.SCENE_CLIP_BOX === 0, this.gtaoMaterial.defines.SCENE_CLIP_BOX = 0);
  }
  /**
   * Updates the GTAO material from the given paramter object.
   *
   * @param {Object} parameters - The GTAO material parameters.
   */
  updateGtaoMaterial(t) {
    t.radius !== void 0 && (this.gtaoMaterial.uniforms.radius.value = t.radius), t.distanceExponent !== void 0 && (this.gtaoMaterial.uniforms.distanceExponent.value = t.distanceExponent), t.thickness !== void 0 && (this.gtaoMaterial.uniforms.thickness.value = t.thickness), t.distanceFallOff !== void 0 && (this.gtaoMaterial.uniforms.distanceFallOff.value = t.distanceFallOff, this.gtaoMaterial.needsUpdate = true), t.scale !== void 0 && (this.gtaoMaterial.uniforms.scale.value = t.scale), t.samples !== void 0 && t.samples !== this.gtaoMaterial.defines.SAMPLES && (this.gtaoMaterial.defines.SAMPLES = t.samples, this.gtaoMaterial.needsUpdate = true), t.screenSpaceRadius !== void 0 && (t.screenSpaceRadius ? 1 : 0) !== this.gtaoMaterial.defines.SCREEN_SPACE_RADIUS && (this.gtaoMaterial.defines.SCREEN_SPACE_RADIUS = t.screenSpaceRadius ? 1 : 0, this.gtaoMaterial.needsUpdate = true);
  }
  /**
   * Updates the Denoise material from the given paramter object.
   *
   * @param {Object} parameters - The denoise parameters.
   */
  updatePdMaterial(t) {
    let e = false;
    t.lumaPhi !== void 0 && (this.pdMaterial.uniforms.lumaPhi.value = t.lumaPhi), t.depthPhi !== void 0 && (this.pdMaterial.uniforms.depthPhi.value = t.depthPhi), t.normalPhi !== void 0 && (this.pdMaterial.uniforms.normalPhi.value = t.normalPhi), t.radius !== void 0 && t.radius !== this.radius && (this.pdMaterial.uniforms.radius.value = t.radius), t.radiusExponent !== void 0 && t.radiusExponent !== this.pdRadiusExponent && (this.pdRadiusExponent = t.radiusExponent, e = true), t.rings !== void 0 && t.rings !== this.pdRings && (this.pdRings = t.rings, e = true), t.samples !== void 0 && t.samples !== this.pdSamples && (this.pdSamples = t.samples, e = true), e && (this.pdMaterial.defines.SAMPLES = this.pdSamples, this.pdMaterial.defines.SAMPLE_VECTORS = Ua(this.pdSamples, this.pdRings, this.pdRadiusExponent), this.pdMaterial.needsUpdate = true);
  }
  /**
   * Performs the GTAO pass.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(t, e, s) {
    switch (this._renderGBuffer && (this._overrideVisibility(), this._renderOverride(t, this.normalMaterial, this.normalRenderTarget, 7829503, 1), this._restoreVisibility()), this.gtaoMaterial.uniforms.cameraNear.value = this.camera.near, this.gtaoMaterial.uniforms.cameraFar.value = this.camera.far, this.gtaoMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix), this.gtaoMaterial.uniforms.cameraProjectionMatrixInverse.value.copy(this.camera.projectionMatrixInverse), this.gtaoMaterial.uniforms.cameraWorldMatrix.value.copy(this.camera.matrixWorld), this._renderPass(t, this.gtaoMaterial, this.gtaoRenderTarget, 16777215, 1), this.pdMaterial.uniforms.cameraProjectionMatrixInverse.value.copy(this.camera.projectionMatrixInverse), this._renderPass(t, this.pdMaterial, this.pdRenderTarget, 16777215, 1), this.output) {
      case _Jt.OUTPUT.Off:
        break;
      case _Jt.OUTPUT.Diffuse:
        this.copyMaterial.uniforms.tDiffuse.value = s.texture, this.copyMaterial.blending = NoBlending, this._renderPass(t, this.copyMaterial, this.renderToScreen ? null : e);
        break;
      case _Jt.OUTPUT.AO:
        this.copyMaterial.uniforms.tDiffuse.value = this.gtaoRenderTarget.texture, this.copyMaterial.blending = NoBlending, this._renderPass(t, this.copyMaterial, this.renderToScreen ? null : e);
        break;
      case _Jt.OUTPUT.Denoise:
        this.copyMaterial.uniforms.tDiffuse.value = this.pdRenderTarget.texture, this.copyMaterial.blending = NoBlending, this._renderPass(t, this.copyMaterial, this.renderToScreen ? null : e);
        break;
      case _Jt.OUTPUT.Depth:
        this.depthRenderMaterial.uniforms.cameraNear.value = this.camera.near, this.depthRenderMaterial.uniforms.cameraFar.value = this.camera.far, this._renderPass(t, this.depthRenderMaterial, this.renderToScreen ? null : e);
        break;
      case _Jt.OUTPUT.Normal:
        this.copyMaterial.uniforms.tDiffuse.value = this.normalRenderTarget.texture, this.copyMaterial.blending = NoBlending, this._renderPass(t, this.copyMaterial, this.renderToScreen ? null : e);
        break;
      case _Jt.OUTPUT.Default:
        this.copyMaterial.uniforms.tDiffuse.value = s.texture, this.copyMaterial.blending = NoBlending, this._renderPass(t, this.copyMaterial, this.renderToScreen ? null : e), this.blendMaterial.uniforms.intensity.value = this.blendIntensity, this.blendMaterial.uniforms.tDiffuse.value = this.pdRenderTarget.texture, this._renderPass(t, this.blendMaterial, this.renderToScreen ? null : e);
        break;
      default:
        console.warn("THREE.GTAOPass: Unknown output type.");
    }
  }
  // internals
  _renderPass(t, e, s, i, n) {
    t.getClearColor(this._originalClearColor);
    const r = t.getClearAlpha(), o = t.autoClear;
    t.setRenderTarget(s), t.autoClear = false, i != null && (t.setClearColor(i), t.setClearAlpha(n || 0), t.clear()), this._fsQuad.material = e, this._fsQuad.render(t), t.autoClear = o, t.setClearColor(this._originalClearColor), t.setClearAlpha(r);
  }
  _renderOverride(t, e, s, i, n) {
    t.getClearColor(this._originalClearColor);
    const r = t.getClearAlpha(), o = t.autoClear;
    t.setRenderTarget(s), t.autoClear = false, i = e.clearColor || i, n = e.clearAlpha || n, i != null && (t.setClearColor(i), t.setClearAlpha(n || 0), t.clear()), this.scene.overrideMaterial = e, t.render(this.scene, this.camera), this.scene.overrideMaterial = null, t.autoClear = o, t.setClearColor(this._originalClearColor), t.setClearAlpha(r);
  }
  _overrideVisibility() {
    const t = this.scene, e = this._visibilityCache;
    t.traverse(function(s) {
      e.set(s, s.visible), (s.isPoints || s.isLine) && (s.visible = false);
    });
  }
  _restoreVisibility() {
    const t = this.scene, e = this._visibilityCache;
    t.traverse(function(s) {
      const i = e.get(s);
      s.visible = i;
    }), e.clear();
  }
  _generateNoise(t = 64) {
    const e = new Gd(), s = t * t * 4, i = new Uint8Array(s);
    for (let r = 0; r < t; r++)
      for (let o = 0; o < t; o++) {
        const a = r, c = o;
        i[(r * t + o) * 4] = (e.noise(a, c) * 0.5 + 0.5) * 255, i[(r * t + o) * 4 + 1] = (e.noise(a + t, c) * 0.5 + 0.5) * 255, i[(r * t + o) * 4 + 2] = (e.noise(a, c + t) * 0.5 + 0.5) * 255, i[(r * t + o) * 4 + 3] = (e.noise(a + t, c + t) * 0.5 + 0.5) * 255;
      }
    const n = new DataTexture(i, t, t, RGBAFormat, UnsignedByteType);
    return n.wrapS = RepeatWrapping, n.wrapT = RepeatWrapping, n.needsUpdate = true, n;
  }
};
Jt.OUTPUT = {
  Off: -1,
  Default: 0,
  Diffuse: 1,
  Depth: 2,
  Normal: 3,
  AO: 4,
  Denoise: 5
};
var Bi = {
  name: "OutputShader",
  uniforms: {
    tDiffuse: { value: null },
    toneMappingExposure: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `
		precision highp float;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		precision highp float;

		uniform sampler2D tDiffuse;

		#include <tonemapping_pars_fragment>
		#include <colorspace_pars_fragment>

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );

			// tone mapping

			#ifdef LINEAR_TONE_MAPPING

				gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );

			#elif defined( REINHARD_TONE_MAPPING )

				gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );

			#elif defined( CINEON_TONE_MAPPING )

				gl_FragColor.rgb = CineonToneMapping( gl_FragColor.rgb );

			#elif defined( ACES_FILMIC_TONE_MAPPING )

				gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );

			#elif defined( AGX_TONE_MAPPING )

				gl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );

			#elif defined( NEUTRAL_TONE_MAPPING )

				gl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );

			#elif defined( CUSTOM_TONE_MAPPING )

				gl_FragColor.rgb = CustomToneMapping( gl_FragColor.rgb );

			#endif

			// color space

			#ifdef SRGB_TRANSFER

				gl_FragColor = sRGBTransferOETF( gl_FragColor );

			#endif

		}`
  )
};
var Zd = class extends Ae {
  /**
   * Constructs a new output pass.
   */
  constructor() {
    super(), this.uniforms = UniformsUtils.clone(Bi.uniforms), this.material = new RawShaderMaterial({
      name: Bi.name,
      uniforms: this.uniforms,
      vertexShader: Bi.vertexShader,
      fragmentShader: Bi.fragmentShader
    }), this._fsQuad = new Ye(this.material), this._outputColorSpace = null, this._toneMapping = null;
  }
  /**
   * Performs the output pass.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(t, e, s) {
    this.uniforms.tDiffuse.value = s.texture, this.uniforms.toneMappingExposure.value = t.toneMappingExposure, (this._outputColorSpace !== t.outputColorSpace || this._toneMapping !== t.toneMapping) && (this._outputColorSpace = t.outputColorSpace, this._toneMapping = t.toneMapping, this.material.defines = {}, ColorManagement.getTransfer(this._outputColorSpace) === SRGBTransfer && (this.material.defines.SRGB_TRANSFER = ""), this._toneMapping === LinearToneMapping ? this.material.defines.LINEAR_TONE_MAPPING = "" : this._toneMapping === ReinhardToneMapping ? this.material.defines.REINHARD_TONE_MAPPING = "" : this._toneMapping === CineonToneMapping ? this.material.defines.CINEON_TONE_MAPPING = "" : this._toneMapping === ACESFilmicToneMapping ? this.material.defines.ACES_FILMIC_TONE_MAPPING = "" : this._toneMapping === AgXToneMapping ? this.material.defines.AGX_TONE_MAPPING = "" : this._toneMapping === NeutralToneMapping ? this.material.defines.NEUTRAL_TONE_MAPPING = "" : this._toneMapping === CustomToneMapping && (this.material.defines.CUSTOM_TONE_MAPPING = ""), this.material.needsUpdate = true), this.renderToScreen === true ? (t.setRenderTarget(null), this._fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this._fsQuad.render(t));
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the pass is no longer used in your app.
   */
  dispose() {
    this.material.dispose(), this._fsQuad.dispose();
  }
};
var Ri = {
  defines: {
    SMAA_THRESHOLD: "0.1"
  },
  uniforms: {
    tDiffuse: { value: null },
    resolution: { value: new Vector2(1 / 1024, 1 / 512) }
  },
  vertexShader: (
    /* glsl */
    `

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];

		void SMAAEdgeDetectionVS( vec2 texcoord ) {
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 ); // WebGL port note: Changed sign in W component
		}

		void main() {

			vUv = uv;

			SMAAEdgeDetectionVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];

		vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {
			vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );

			// Calculate color deltas:
			vec4 delta;
			vec3 C = texture2D( colorTex, texcoord ).rgb;

			vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;
			vec3 t = abs( C - Cleft );
			delta.x = max( max( t.r, t.g ), t.b );

			vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;
			t = abs( C - Ctop );
			delta.y = max( max( t.r, t.g ), t.b );

			// We do the usual threshold:
			vec2 edges = step( threshold, delta.xy );

			// Then discard if there is no edge:
			if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )
				discard;

			// Calculate right and bottom deltas:
			vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;
			t = abs( C - Cright );
			delta.z = max( max( t.r, t.g ), t.b );

			vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;
			t = abs( C - Cbottom );
			delta.w = max( max( t.r, t.g ), t.b );

			// Calculate the maximum delta in the direct neighborhood:
			float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );

			// Calculate left-left and top-top deltas:
			vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;
			t = abs( C - Cleftleft );
			delta.z = max( max( t.r, t.g ), t.b );

			vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;
			t = abs( C - Ctoptop );
			delta.w = max( max( t.r, t.g ), t.b );

			// Calculate the final maximum delta:
			maxDelta = max( max( maxDelta, delta.z ), delta.w );

			// Local contrast adaptation in action:
			edges.xy *= step( 0.5 * maxDelta, delta.xy );

			return vec4( edges, 0.0, 0.0 );
		}

		void main() {

			gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );

		}`
  )
};
var Ui = {
  defines: {
    SMAA_MAX_SEARCH_STEPS: "8",
    SMAA_AREATEX_MAX_DISTANCE: "16",
    SMAA_AREATEX_PIXEL_SIZE: "( 1.0 / vec2( 160.0, 560.0 ) )",
    SMAA_AREATEX_SUBTEX_SIZE: "( 1.0 / 7.0 )"
  },
  uniforms: {
    tDiffuse: { value: null },
    tArea: { value: null },
    tSearch: { value: null },
    resolution: { value: new Vector2(1 / 1024, 1 / 512) }
  },
  vertexShader: (
    /* glsl */
    `

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];
		varying vec2 vPixcoord;

		void SMAABlendingWeightCalculationVS( vec2 texcoord ) {
			vPixcoord = texcoord / resolution;

			// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 ); // WebGL port note: Changed sign in Y and W components
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 ); // WebGL port note: Changed sign in Y and W components

			// And these for the searches, they indicate the ends of the loops:
			vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );

		}

		void main() {

			vUv = uv;

			SMAABlendingWeightCalculationVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )

		uniform sampler2D tDiffuse;
		uniform sampler2D tArea;
		uniform sampler2D tSearch;
		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[3];
		varying vec2 vPixcoord;

		#if __VERSION__ == 100
		vec2 round( vec2 x ) {
			return sign( x ) * floor( abs( x ) + 0.5 );
		}
		#endif

		float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {
			// Not required if searchTex accesses are set to point:
			// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);
			// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +
			//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;
			e.r = bias + e.r * scale;
			return 255.0 * texture2D( searchTex, e, 0.0 ).r;
		}

		float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			/**
				* @PSEUDO_GATHER4
				* This texcoord has been offset by (-0.25, -0.125) in the vertex shader to
				* sample between edge, thus fetching four edges in a row.
				* Sampling with different offsets in each direction allows to disambiguate
				* which edges are active from the four fetched ones.
				*/
			vec2 e = vec2( 0.0, 1.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord -= vec2( 2.0, 0.0 ) * resolution;
				if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;
			}

			// We correct the previous (-0.25, -0.125) offset we applied:
			texcoord.x += 0.25 * resolution.x;

			// The searches are bias by 1, so adjust the coords accordingly:
			texcoord.x += resolution.x;

			// Disambiguate the length added by the last step:
			texcoord.x += 2.0 * resolution.x; // Undo last step
			texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);

			return texcoord.x;
		}

		float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 0.0, 1.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord += vec2( 2.0, 0.0 ) * resolution;
				if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;
			}

			texcoord.x -= 0.25 * resolution.x;
			texcoord.x -= resolution.x;
			texcoord.x -= 2.0 * resolution.x;
			texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );

			return texcoord.x;
		}

		float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 1.0, 0.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord += vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign
				if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;
			}

			texcoord.y -= 0.25 * resolution.y; // WebGL port note: Changed sign
			texcoord.y -= resolution.y; // WebGL port note: Changed sign
			texcoord.y -= 2.0 * resolution.y; // WebGL port note: Changed sign
			texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 ); // WebGL port note: Changed sign

			return texcoord.y;
		}

		float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 1.0, 0.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord -= vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign
				if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;
			}

			texcoord.y += 0.25 * resolution.y; // WebGL port note: Changed sign
			texcoord.y += resolution.y; // WebGL port note: Changed sign
			texcoord.y += 2.0 * resolution.y; // WebGL port note: Changed sign
			texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 ); // WebGL port note: Changed sign

			return texcoord.y;
		}

		vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {
			// Rounding prevents precision errors of bilinear filtering:
			vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;

			// We do a scale and bias for mapping to texel space:
			texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );

			// Move to proper place, according to the subpixel offset:
			texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;

			return texture2D( areaTex, texcoord, 0.0 ).rg;
		}

		vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {
			vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );

			vec2 e = texture2D( edgesTex, texcoord ).rg;

			if ( e.g > 0.0 ) { // Edge at north
				vec2 d;

				// Find the distance to the left:
				vec2 coords;
				coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );
				coords.y = offset[ 1 ].y; // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)
				d.x = coords.x;

				// Now fetch the left crossing edges, two at a time using bilinear
				// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to
				// discern what value each edge has:
				float e1 = texture2D( edgesTex, coords, 0.0 ).r;

				// Find the distance to the right:
				coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );
				d.y = coords.x;

				// We want the distances to be in pixel units (doing this here allow to
				// better interleave arithmetic and memory accesses):
				d = d / resolution.x - pixcoord.x;

				// SMAAArea below needs a sqrt, as the areas texture is compressed
				// quadratically:
				vec2 sqrt_d = sqrt( abs( d ) );

				// Fetch the right crossing edges:
				coords.y -= 1.0 * resolution.y; // WebGL port note: Added
				float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;

				// Ok, we know how this pattern looks like, now it is time for getting
				// the actual area:
				weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );
			}

			if ( e.r > 0.0 ) { // Edge at west
				vec2 d;

				// Find the distance to the top:
				vec2 coords;

				coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );
				coords.x = offset[ 0 ].x; // offset[1].x = texcoord.x - 0.25 * resolution.x;
				d.x = coords.y;

				// Fetch the top crossing edges:
				float e1 = texture2D( edgesTex, coords, 0.0 ).g;

				// Find the distance to the bottom:
				coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );
				d.y = coords.y;

				// We want the distances to be in pixel units:
				d = d / resolution.y - pixcoord.y;

				// SMAAArea below needs a sqrt, as the areas texture is compressed
				// quadratically:
				vec2 sqrt_d = sqrt( abs( d ) );

				// Fetch the bottom crossing edges:
				coords.y -= 1.0 * resolution.y; // WebGL port note: Added
				float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;

				// Get the area for this direction:
				weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );
			}

			return weights;
		}

		void main() {

			gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );

		}`
  )
};
var Fn = {
  uniforms: {
    tDiffuse: { value: null },
    tColor: { value: null },
    resolution: { value: new Vector2(1 / 1024, 1 / 512) }
  },
  vertexShader: (
    /* glsl */
    `

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 2 ];

		void SMAANeighborhoodBlendingVS( vec2 texcoord ) {
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component
		}

		void main() {

			vUv = uv;

			SMAANeighborhoodBlendingVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform sampler2D tColor;
		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 2 ];

		vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {
			// Fetch the blending weights for current pixel:
			vec4 a;
			a.xz = texture2D( blendTex, texcoord ).xz;
			a.y = texture2D( blendTex, offset[ 1 ].zw ).g;
			a.w = texture2D( blendTex, offset[ 1 ].xy ).a;

			// Is there any blending weight with a value greater than 0.0?
			if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {
				return texture2D( colorTex, texcoord, 0.0 );
			} else {
				// Up to 4 lines can be crossing a pixel (one through each edge). We
				// favor blending by choosing the line with the maximum weight for each
				// direction:
				vec2 offset;
				offset.x = a.a > a.b ? a.a : -a.b; // left vs. right
				offset.y = a.g > a.r ? -a.g : a.r; // top vs. bottom // WebGL port note: Changed signs

				// Then we go in the direction that has the maximum weight:
				if ( abs( offset.x ) > abs( offset.y )) { // horizontal vs. vertical
					offset.y = 0.0;
				} else {
					offset.x = 0.0;
				}

				// Fetch the opposite color and lerp by hand:
				vec4 C = texture2D( colorTex, texcoord, 0.0 );
				texcoord += sign( offset ) * resolution;
				vec4 Cop = texture2D( colorTex, texcoord, 0.0 );
				float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );

				// WebGL port note: Added gamma correction
				C.xyz = pow(C.xyz, vec3(2.2));
				Cop.xyz = pow(Cop.xyz, vec3(2.2));
				vec4 mixed = mix(C, Cop, s);
				mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));

				return mixed;
			}
		}

		void main() {

			gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );

		}`
  )
};
var qd = class extends Ae {
  /**
   * Constructs a new SMAA pass.
   */
  constructor() {
    super(), this._edgesRT = new WebGLRenderTarget(1, 1, {
      depthBuffer: false,
      type: HalfFloatType
    }), this._edgesRT.texture.name = "SMAAPass.edges", this._weightsRT = new WebGLRenderTarget(1, 1, {
      depthBuffer: false,
      type: HalfFloatType
    }), this._weightsRT.texture.name = "SMAAPass.weights";
    const t = this, e = new Image();
    e.src = this._getAreaTexture(), e.onload = function() {
      t._areaTexture.needsUpdate = true;
    }, this._areaTexture = new Texture(), this._areaTexture.name = "SMAAPass.area", this._areaTexture.image = e, this._areaTexture.minFilter = LinearFilter, this._areaTexture.generateMipmaps = false, this._areaTexture.flipY = false;
    const s = new Image();
    s.src = this._getSearchTexture(), s.onload = function() {
      t._searchTexture.needsUpdate = true;
    }, this._searchTexture = new Texture(), this._searchTexture.name = "SMAAPass.search", this._searchTexture.image = s, this._searchTexture.magFilter = NearestFilter, this._searchTexture.minFilter = NearestFilter, this._searchTexture.generateMipmaps = false, this._searchTexture.flipY = false, this._uniformsEdges = UniformsUtils.clone(Ri.uniforms), this._materialEdges = new ShaderMaterial({
      defines: Object.assign({}, Ri.defines),
      uniforms: this._uniformsEdges,
      vertexShader: Ri.vertexShader,
      fragmentShader: Ri.fragmentShader
    }), this._uniformsWeights = UniformsUtils.clone(Ui.uniforms), this._uniformsWeights.tDiffuse.value = this._edgesRT.texture, this._uniformsWeights.tArea.value = this._areaTexture, this._uniformsWeights.tSearch.value = this._searchTexture, this._materialWeights = new ShaderMaterial({
      defines: Object.assign({}, Ui.defines),
      uniforms: this._uniformsWeights,
      vertexShader: Ui.vertexShader,
      fragmentShader: Ui.fragmentShader
    }), this._uniformsBlend = UniformsUtils.clone(Fn.uniforms), this._uniformsBlend.tDiffuse.value = this._weightsRT.texture, this._materialBlend = new ShaderMaterial({
      uniforms: this._uniformsBlend,
      vertexShader: Fn.vertexShader,
      fragmentShader: Fn.fragmentShader
    }), this._fsQuad = new Ye(null);
  }
  /**
   * Performs the SMAA pass.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(t, e, s) {
    this._uniformsEdges.tDiffuse.value = s.texture, this._fsQuad.material = this._materialEdges, t.setRenderTarget(this._edgesRT), this.clear && t.clear(), this._fsQuad.render(t), this._fsQuad.material = this._materialWeights, t.setRenderTarget(this._weightsRT), this.clear && t.clear(), this._fsQuad.render(t), this._uniformsBlend.tColor.value = s.texture, this._fsQuad.material = this._materialBlend, this.renderToScreen ? (t.setRenderTarget(null), this._fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(), this._fsQuad.render(t));
  }
  /**
   * Sets the size of the pass.
   *
   * @param {number} width - The width to set.
   * @param {number} height - The width to set.
   */
  setSize(t, e) {
    this._edgesRT.setSize(t, e), this._weightsRT.setSize(t, e), this._materialEdges.uniforms.resolution.value.set(1 / t, 1 / e), this._materialWeights.uniforms.resolution.value.set(1 / t, 1 / e), this._materialBlend.uniforms.resolution.value.set(1 / t, 1 / e);
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the pass is no longer used in your app.
   */
  dispose() {
    this._edgesRT.dispose(), this._weightsRT.dispose(), this._areaTexture.dispose(), this._searchTexture.dispose(), this._materialEdges.dispose(), this._materialWeights.dispose(), this._materialBlend.dispose(), this._fsQuad.dispose();
  }
  // internals
  _getAreaTexture() {
    return "data:image/png;base64,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";
  }
  _getSearchTexture() {
    return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=";
  }
};
var Qd = class extends Ae {
  constructor(e, s, i = 1) {
    super();
    A(this, "_edgeMaterial");
    A(this, "_combineMaterial");
    A(this, "_fsQuad");
    A(this, "_edgeRenderTarget");
    A(this, "_vertexColorRenderTarget");
    A(this, "_fragments");
    A(this, "_renderer");
    A(this, "_overrideMaterial", new MeshBasicMaterial({
      vertexColors: true
    }));
    this._renderer = e, this._fragments = s, this._edgeMaterial = new ShaderMaterial({
      uniforms: {
        tDiffuse: { value: null },
        width: { value: i }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float width;
        varying vec2 vUv;

        void main() {
          vec2 texel = vec2(1.0 / float(textureSize(tDiffuse, 0).x), 1.0 / float(textureSize(tDiffuse, 0).y));
          vec2 offset = texel * width;
          
          vec4 center = texture2D(tDiffuse, vUv);
          vec4 right = texture2D(tDiffuse, vUv + vec2(offset.x, 0.0));
          vec4 left = texture2D(tDiffuse, vUv - vec2(offset.x, 0.0));
          vec4 up = texture2D(tDiffuse, vUv + vec2(0.0, offset.y));
          vec4 down = texture2D(tDiffuse, vUv - vec2(0.0, offset.y));
          
          float diff = 0.0;
          diff += distance(center.rgb, right.rgb);
          diff += distance(center.rgb, left.rgb);
          diff += distance(center.rgb, up.rgb);
          diff += distance(center.rgb, down.rgb);
          
          gl_FragColor = vec4(vec3(step(0.0001, diff)), 1.0);
        }
      `
    }), this._combineMaterial = new ShaderMaterial({
      uniforms: {
        tDiffuse: { value: null },
        tEdges: { value: null },
        edgeColor: { value: new Color(8947848) }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform sampler2D tEdges;
        uniform vec3 edgeColor;
        varying vec2 vUv;

        void main() {
          vec4 color = texture2D(tDiffuse, vUv);
          vec4 edges = texture2D(tEdges, vUv);
          
          // Combine color with edges (edges are black, so we multiply)
          gl_FragColor = mix(color, vec4(edgeColor, 1.0), edges.r);
        }
      `
    }), this._fsQuad = new Ye(this._edgeMaterial), this._edgeRenderTarget = new WebGLRenderTarget(1, 1, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBAFormat
    }), this._vertexColorRenderTarget = new WebGLRenderTarget(1, 1, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBAFormat
    });
  }
  get width() {
    return this._edgeMaterial.uniforms.width.value;
  }
  set width(e) {
    this._edgeMaterial.uniforms.width.value = e;
  }
  get color() {
    return this._combineMaterial.uniforms.edgeColor.value;
  }
  set color(e) {
    this._combineMaterial.uniforms.edgeColor.value = e;
  }
  setSize(e, s) {
    this._edgeRenderTarget.setSize(e, s), this._vertexColorRenderTarget.setSize(e, s);
  }
  setWidth(e) {
    this._edgeMaterial.uniforms.width.value = e;
  }
  render(e, s, i) {
    const n = this._renderer.currentWorld, r = n.scene.three, o = r.overrideMaterial;
    r.overrideMaterial = this._overrideMaterial, e.setRenderTarget(this._vertexColorRenderTarget), e.render(r, n.camera.three), r.overrideMaterial = o, this._edgeMaterial.uniforms.tDiffuse.value = this._vertexColorRenderTarget.texture, this._fsQuad.material = this._edgeMaterial, e.setRenderTarget(this._edgeRenderTarget), this._fsQuad.render(e), this._combineMaterial.uniforms.tDiffuse.value = i.texture, this._combineMaterial.uniforms.tEdges.value = this._edgeRenderTarget.texture, this._fsQuad.material = this._combineMaterial, this.renderToScreen ? e.setRenderTarget(null) : e.setRenderTarget(s), this._fsQuad.render(e);
  }
  dispose() {
    this._edgeMaterial.dispose(), this._combineMaterial.dispose(), this._fsQuad.dispose(), this._edgeRenderTarget.dispose(), this._vertexColorRenderTarget.dispose();
  }
};
var Kd = class extends Ae {
  constructor(e, s, i) {
    super();
    A(this, "outlineColor", new Color(16762880));
    A(this, "thickness", 2);
    A(this, "fillColor", new Color(16776960));
    A(this, "fillOpacity", 0.3);
    A(this, "debugShowMask", false);
    A(this, "scene", new Scene());
    A(this, "_maskTarget");
    A(this, "_fsQuad");
    A(this, "_world");
    A(this, "_debugQuad", null);
    this._world = i, this.scene.background = new Color(0), this._maskTarget = new WebGLRenderTarget(e, s, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBAFormat,
      type: UnsignedByteType
    }), this._fsQuad = new Ye(
      new ShaderMaterial({
        uniforms: {
          tDiffuse: { value: null },
          tMask: { value: null },
          outlineColor: { value: new Color(65280) },
          thickness: { value: 2 },
          resolution: { value: new Vector2(e, s) },
          fillColor: { value: new Color(16776960) },
          fillOpacity: { value: 0.3 }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D tDiffuse;
          uniform sampler2D tMask;
          uniform vec3 outlineColor;
          uniform float thickness;
          uniform vec2 resolution;
          uniform vec3 fillColor;
          uniform float fillOpacity;
          varying vec2 vUv;

          void main() {
            float mask = texture2D(tMask, vUv).r;
            float outline = 0.0;
            float t = thickness;
            vec2 texel = 1.0 / resolution;
            for (float x = -t; x <= t; x++) {
              for (float y = -t; y <= t; y++) {
                vec2 offset = vec2(x, y) * texel;
                float neighbor = texture2D(tMask, vUv + offset).r;
                if (neighbor > 0.5) outline = 1.0;
              }
            }
            vec4 sceneColor = texture2D(tDiffuse, vUv);
            // Fill inside
            if (mask > 0.5) {
              sceneColor.rgb = mix(sceneColor.rgb, fillColor, fillOpacity);
            }
            // Only draw outline where mask is not set but neighbor is
            if (outline > 0.5 && mask < 0.5) {
              gl_FragColor = vec4(outlineColor, 1.0);
            } else {
              gl_FragColor = sceneColor;
            }
          }
        `
      })
    ), this._debugQuad = new Ye(
      new ShaderMaterial({
        uniforms: {
          tMask: { value: null }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D tMask;
          varying vec2 vUv;
          void main() {
            float mask = texture2D(tMask, vUv).r;
            gl_FragColor = vec4(vec3(mask), 1.0);
          }
        `
      })
    );
  }
  setSize(e, s) {
    this._maskTarget.setSize(e, s), this._fsQuad.material.uniforms.resolution.value.set(e, s);
  }
  render(e, s, i) {
    const n = this._world.camera.three, r = e.getClearColor(new Color()), o = e.getClearAlpha();
    if (e.setClearColor(0, 0), e.setRenderTarget(this._maskTarget), e.clear(), e.render(this.scene, n), e.setClearColor(r, o), this.debugShowMask) {
      const c = this._debugQuad.material;
      c.uniforms.tMask.value = this._maskTarget.texture, this.renderToScreen ? e.setRenderTarget(null) : e.setRenderTarget(s), this._debugQuad.render(e);
      return;
    }
    const a = this._fsQuad.material;
    a.uniforms.tDiffuse.value = i.texture, a.uniforms.tMask.value = this._maskTarget.texture, a.uniforms.outlineColor.value.copy(this.outlineColor), a.uniforms.thickness.value = this.thickness, a.uniforms.fillColor.value.copy(this.fillColor), a.uniforms.fillOpacity.value = this.fillOpacity, this.renderToScreen ? e.setRenderTarget(null) : e.setRenderTarget(s), this._fsQuad.render(e);
  }
  dispose() {
    this._maskTarget.dispose(), this._fsQuad.dispose();
    const e = [...this.scene.children];
    for (const s of e)
      s.removeFromParent();
  }
};
var Jd = class extends Ae {
  constructor(e, s) {
    super();
    A(this, "_excludedMaterials", /* @__PURE__ */ new Set());
    A(this, "_blackMaterial", new MeshBasicMaterial({ color: 0 }));
    A(this, "_originalMaterials", /* @__PURE__ */ new Map());
    A(this, "_renderer");
    A(this, "_world");
    A(this, "_fsQuad");
    A(this, "_combineMaterial");
    A(this, "_excludedRenderTarget");
    this._renderer = e, this._world = s, this._excludedRenderTarget = new WebGLRenderTarget(1, 1, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBAFormat
    }), this._combineMaterial = new ShaderMaterial({
      uniforms: {
        tDiffuse: { value: null },
        // Input pass texture
        tExcluded: { value: null }
        // Excluded objects texture
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform sampler2D tExcluded;
        varying vec2 vUv;

        void main() {
          vec4 inputColor = texture2D(tDiffuse, vUv);
          vec4 excludedColor = texture2D(tExcluded, vUv);
          
          // If excluded pixel is black (or very dark), use input color
          // Otherwise, use excluded color
          float excludedLuminance = (excludedColor.r + excludedColor.g + excludedColor.b) / 3.0;
          float threshold = 0.01; // Adjust this threshold as needed
          
          if (excludedLuminance < threshold) {
            gl_FragColor = inputColor;
          } else {
            gl_FragColor = excludedColor;
          }
        }
      `
    }), this._fsQuad = new Ye(this._combineMaterial);
  }
  /**
   * Add materials to be excluded from postproduction
   */
  addExcludedMaterial(e) {
    this._excludedMaterials.add(e);
  }
  /**
   * Remove materials from the excluded list
   */
  removeExcludedMaterial(e) {
    this._excludedMaterials.delete(e);
  }
  /**
   * Clear all excluded materials
   */
  clearExcludedMaterials() {
    this._excludedMaterials.clear();
  }
  /**
   * Get the list of excluded materials
   */
  get excludedMaterials() {
    return Array.from(this._excludedMaterials);
  }
  setSize(e, s) {
    this._excludedRenderTarget.setSize(e, s);
  }
  render(e, s, i) {
    const n = this._world.scene.three, r = this._world.camera.three, o = e.getClearColor(new Color()), a = e.getClearAlpha();
    e.setClearColor(0, 0), this._substituteMaterials(n), e.setRenderTarget(this._excludedRenderTarget), e.render(n, r), this._restoreMaterials(), this._combineMaterial.uniforms.tDiffuse.value = i.texture, this._combineMaterial.uniforms.tExcluded.value = this._excludedRenderTarget.texture, this.renderToScreen ? e.setRenderTarget(null) : e.setRenderTarget(s), this._fsQuad.render(e), e.setClearColor(o, a);
  }
  _substituteMaterials(e) {
    if (e instanceof Mesh) {
      const s = e.material;
      if (Array.isArray(s)) {
        for (const i of s)
          if ("isLodMaterial" in i)
            return;
      } else if ("isLodMaterial" in s)
        return;
      this._excludedMaterials.has(s) || (this._originalMaterials.set(e, s), e.material = this._blackMaterial);
    }
    for (const s of e.children)
      this._substituteMaterials(s);
  }
  _restoreMaterials() {
    for (const [e, s] of this._originalMaterials)
      e.material = s;
    this._originalMaterials.clear();
  }
  dispose() {
    this._blackMaterial.dispose(), this._combineMaterial.dispose(), this._fsQuad.dispose(), this._excludedRenderTarget.dispose(), this._excludedMaterials.clear(), this._originalMaterials.clear();
  }
};
var $d = class extends Ae {
  constructor(e, s, i = null, n = null, r = null) {
    super();
    A(this, "scene");
    A(this, "camera");
    A(this, "overrideMaterial");
    A(this, "clearColor");
    A(this, "clearAlpha");
    A(this, "clearDepth");
    A(this, "needsSwap");
    A(this, "isolatedMaterials", []);
    A(this, "_oldClearColor");
    this.scene = e, this.camera = s, this.overrideMaterial = i, this.clearColor = n, this.clearAlpha = r, this.clear = true, this.clearDepth = false, this.needsSwap = false, this._oldClearColor = new Color();
  }
  render(e, s, i) {
    for (const a of this.isolatedMaterials)
      a.userData.wasVisibleBasePass !== void 0 && (a.visible = a.userData.wasVisibleBasePass);
    const n = e.autoClear;
    e.autoClear = false;
    let r, o;
    this.overrideMaterial !== null && (o = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (e.getClearColor(this._oldClearColor), e.setClearColor(this.clearColor, e.getClearAlpha())), this.clearAlpha !== null && (r = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), this.clearDepth === true && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : i), this.clear === true && e.clear(
      e.autoClearColor,
      e.autoClearDepth,
      e.autoClearStencil
    ), e.render(this.scene, this.camera), this.clearColor !== null && e.setClearColor(this._oldClearColor), this.clearAlpha !== null && e.setClearAlpha(r), this.overrideMaterial !== null && (this.scene.overrideMaterial = o), e.autoClear = n;
    for (const a of this.isolatedMaterials)
      a.userData.wasVisibleBasePass = a.visible, a.visible = false;
  }
};
var tu = ((l) => (l[l.COLOR = 0] = "COLOR", l[l.PEN = 1] = "PEN", l[l.PEN_SHADOWS = 2] = "PEN_SHADOWS", l[l.COLOR_PEN = 3] = "COLOR_PEN", l[l.COLOR_SHADOWS = 4] = "COLOR_SHADOWS", l[l.COLOR_PEN_SHADOWS = 5] = "COLOR_PEN_SHADOWS", l))(tu || {});
var eu = class {
  constructor(t, e) {
    A(this, "invisibleMaterials", /* @__PURE__ */ new Set());
    A(this, "_enabled", false);
    A(this, "_initialized", false);
    A(this, "_composer");
    A(this, "_basePass");
    A(this, "_aoPass");
    A(this, "_outputPass");
    A(this, "_edgeDetectionPass");
    A(this, "_smaaPass");
    A(this, "_simpleOutlinePass");
    A(this, "_excludedObjectsPass");
    A(this, "_style", 0);
    A(this, "_outlinesEnabled", false);
    A(this, "_excludedObjectsEnabled", false);
    A(this, "_components");
    A(this, "_renderer");
    this._components = t, this._renderer = e;
  }
  get basePass() {
    if (!this._basePass)
      throw new Error("Base pass not initialized");
    return this._basePass;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    this._enabled = t, t && !this._initialized && this.initialize();
  }
  get aoPass() {
    if (!this._aoPass)
      throw new Error("AO pass not initialized");
    return this._aoPass;
  }
  get outlinePass() {
    if (!this._simpleOutlinePass)
      throw new Error("Outline pass not initialized");
    return this._simpleOutlinePass;
  }
  get edgesPass() {
    if (!this._edgeDetectionPass)
      throw new Error("Edge detection pass not initialized");
    return this._edgeDetectionPass;
  }
  get excludedObjectsPass() {
    if (!this._excludedObjectsPass)
      throw new Error("Excluded objects pass not initialized");
    return this._excludedObjectsPass;
  }
  get outlinesEnabled() {
    return this._outlinesEnabled;
  }
  set outlinesEnabled(t) {
    this._outlinesEnabled = t, this.style = this._style;
  }
  get excludedObjectsEnabled() {
    return this._excludedObjectsEnabled;
  }
  set excludedObjectsEnabled(t) {
    this._excludedObjectsEnabled = t, this.style = this._style;
  }
  get style() {
    return this._style;
  }
  set style(t) {
    this._composer && (!this._composer || !this._basePass || !this._smaaPass || !this._outputPass || !this._aoPass || !this._edgeDetectionPass || !this._simpleOutlinePass || !this._excludedObjectsPass || (this._style = t, this.clearPasses(), this.clearComposer(), t === 0 && (this._composer.addPass(this._basePass), this._outlinesEnabled && this._composer.addPass(this._simpleOutlinePass), this._excludedObjectsEnabled && this._composer.addPass(this._excludedObjectsPass), this._composer.addPass(this._outputPass)), t === 1 && (this._composer.addPass(this._edgeDetectionPass), this._outlinesEnabled && this._composer.addPass(this._simpleOutlinePass), this._excludedObjectsEnabled && this._composer.addPass(this._excludedObjectsPass)), t === 2 && (this._composer.addPass(this._basePass), this._composer.addPass(this._aoPass), this._aoPass.output = Jt.OUTPUT.AO, this._composer.addPass(this._edgeDetectionPass), this._outlinesEnabled && this._composer.addPass(this._simpleOutlinePass), this._excludedObjectsEnabled && this._composer.addPass(this._excludedObjectsPass), this._composer.addPass(this._outputPass)), t === 3 && (this._composer.addPass(this._basePass), this._composer.addPass(this._edgeDetectionPass), this._outlinesEnabled && this._composer.addPass(this._simpleOutlinePass), this._excludedObjectsEnabled && this._composer.addPass(this._excludedObjectsPass), this._composer.addPass(this._outputPass)), t === 4 && (this._composer.addPass(this._basePass), this._composer.addPass(this._aoPass), this._aoPass.output = Jt.OUTPUT.Default, this._outlinesEnabled && this._composer.addPass(this._simpleOutlinePass), this._excludedObjectsEnabled && this._composer.addPass(this._excludedObjectsPass), this._composer.addPass(this._outputPass)), t === 5 && (this._composer.addPass(this._basePass), this._composer.addPass(this._aoPass), this._aoPass.output = Jt.OUTPUT.Default, this._composer.addPass(this._edgeDetectionPass), this._outlinesEnabled && this._composer.addPass(this._simpleOutlinePass), this._excludedObjectsEnabled && this._composer.addPass(this._excludedObjectsPass), this._composer.addPass(this._outputPass))));
  }
  update() {
    if (this._composer) {
      for (const t of this.invisibleMaterials)
        t.userData.wasVisibleForPostproduction = t.visible, t.visible = false;
      this._composer.render();
      for (const t of this.invisibleMaterials)
        t.visible = t.userData.wasVisibleForPostproduction;
    }
  }
  dispose() {
    var t, e, s, i, n, r, o;
    (t = this._composer) == null || t.dispose(), (e = this._aoPass) == null || e.dispose(), (s = this._outputPass) == null || s.dispose(), (i = this._edgeDetectionPass) == null || i.dispose(), (n = this._smaaPass) == null || n.dispose(), (r = this._simpleOutlinePass) == null || r.dispose(), (o = this._excludedObjectsPass) == null || o.dispose();
  }
  setSize(t, e) {
    t === 0 || e === 0 || (this._composer && this._composer.setSize(t, e), this._simpleOutlinePass && this._simpleOutlinePass.setSize(t, e), this._excludedObjectsPass && this._excludedObjectsPass.setSize(t, e));
  }
  updateCamera() {
    const t = this._renderer.currentWorld.camera.three;
    this._basePass && (this._basePass.camera = t), this._aoPass && (this._aoPass.camera = t);
  }
  clearPasses() {
    if (!this._composer)
      return;
    const t = [...this._composer.passes];
    for (const e of t)
      this._composer.removePass(e);
  }
  clearComposer() {
    this._composer && (this._renderer.three.setClearColor(0, 0), this._renderer.three.setRenderTarget(this._composer.renderTarget1), this._renderer.three.clear(), this._renderer.three.setRenderTarget(this._composer.renderTarget2), this._renderer.three.clear(), this._renderer.three.setRenderTarget(null));
  }
  initialize() {
    this._initialized = true;
    const t = this._renderer.currentWorld.scene.three, e = this._renderer.currentWorld.camera.three;
    this._renderer.three.setClearColor(0, 0), this._composer = new jd(this._renderer.three);
    const s = new $d(t, e);
    this._basePass = s, this._smaaPass = new qd(), this._aoPass = new Jt(
      t,
      e,
      this._renderer.three.domElement.width,
      this._renderer.three.domElement.height
    ), this._aoPass.output = Jt.OUTPUT.Default;
    const i = this._components.get(ct);
    this._edgeDetectionPass = new Qd(
      this._renderer,
      i
    ), this._outputPass = new Zd(), this._simpleOutlinePass = new Kd(
      this._renderer.three.domElement.width,
      this._renderer.three.domElement.height,
      this._renderer.currentWorld
    ), this._excludedObjectsPass = new Jd(
      this._renderer,
      this._renderer.currentWorld
    ), this.style = 0;
  }
};
var yu = class extends Bd {
  constructor(e, s, i) {
    super(e, s, i);
    A(this, "_postproduction");
    this.onResize.add((n) => {
      this.setPostproductionSize(n);
    }), this.onWorldChanged.add(() => {
      this.currentWorld && (this._postproduction && this._postproduction.dispose(), this._postproduction = new eu(e, this), this.setPostproductionSize());
    });
  }
  /**
   * Getter for the postproduction instance.
   * Throws an error if the postproduction instance is not yet initialized.
   *
   * @returns The initialized Postproduction instance.
   */
  get postproduction() {
    if (!this._postproduction)
      throw new Error("Renderer not initialized yet with a world!");
    return this._postproduction;
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled || !this.currentWorld)
      return;
    this.onBeforeUpdate.trigger();
    const e = this.currentWorld.scene.three, s = this.currentWorld.camera.three;
    this.postproduction.enabled ? this.postproduction.update() : this.three.render(e, s), e instanceof Scene && this.three2D.render(e, s), this.onAfterUpdate.trigger();
  }
  /** {@link OBC.Disposable.dispose}. */
  dispose() {
    super.dispose(), this.postproduction.dispose();
  }
  setPostproductionSize(e) {
    if (e && (e.x === 0 || e.y === 0) || !this.container || !this._postproduction)
      return;
    const s = Math.min(window.devicePixelRatio, 2), i = (e == null ? void 0 : e.x) ?? this.container.clientWidth * s, n = (e == null ? void 0 : e.y) ?? this.container.clientHeight * s;
    i === 0 || n === 0 || this.postproduction.setSize(i, n);
  }
};
var Io = new Box3();
var Fi = new Vector3();
var Tr = class extends InstancedBufferGeometry {
  /**
   * Constructs a new line segments geometry.
   */
  constructor() {
    super(), this.isLineSegmentsGeometry = true, this.type = "LineSegmentsGeometry";
    const t = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], e = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], s = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(s), this.setAttribute("position", new Float32BufferAttribute(t, 3)), this.setAttribute("uv", new Float32BufferAttribute(e, 2));
  }
  /**
   * Applies the given 4x4 transformation matrix to the geometry.
   *
   * @param {Matrix4} matrix - The matrix to apply.
   * @return {LineSegmentsGeometry} A reference to this instance.
   */
  applyMatrix4(t) {
    const e = this.attributes.instanceStart, s = this.attributes.instanceEnd;
    return e !== void 0 && (e.applyMatrix4(t), s.applyMatrix4(t), e.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  /**
   * Sets the given line positions for this geometry. The length must be a multiple of six since
   * each line segment is defined by a start end vertex in the pattern `(xyz xyz)`.
   *
   * @param {Float32Array|Array<number>} array - The position data to set.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  setPositions(t) {
    let e;
    t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t));
    const s = new InstancedInterleavedBuffer(e, 6, 1);
    return this.setAttribute("instanceStart", new InterleavedBufferAttribute(s, 3, 0)), this.setAttribute("instanceEnd", new InterleavedBufferAttribute(s, 3, 3)), this.instanceCount = this.attributes.instanceStart.count, this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  /**
   * Sets the given line colors for this geometry. The length must be a multiple of six since
   * each line segment is defined by a start end color in the pattern `(rgb rgb)`.
   *
   * @param {Float32Array|Array<number>} array - The position data to set.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  setColors(t) {
    let e;
    t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t));
    const s = new InstancedInterleavedBuffer(e, 6, 1);
    return this.setAttribute("instanceColorStart", new InterleavedBufferAttribute(s, 3, 0)), this.setAttribute("instanceColorEnd", new InterleavedBufferAttribute(s, 3, 3)), this;
  }
  /**
   * Setups this line segments geometry from the given wireframe geometry.
   *
   * @param {WireframeGeometry} geometry - The geometry that should be used as a data source for this geometry.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  fromWireframeGeometry(t) {
    return this.setPositions(t.attributes.position.array), this;
  }
  /**
   * Setups this line segments geometry from the given edges geometry.
   *
   * @param {EdgesGeometry} geometry - The geometry that should be used as a data source for this geometry.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  fromEdgesGeometry(t) {
    return this.setPositions(t.attributes.position.array), this;
  }
  /**
   * Setups this line segments geometry from the given mesh.
   *
   * @param {Mesh} mesh - The mesh geometry that should be used as a data source for this geometry.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  fromMesh(t) {
    return this.fromWireframeGeometry(new WireframeGeometry(t.geometry)), this;
  }
  /**
   * Setups this line segments geometry from the given line segments.
   *
   * @param {LineSegments} lineSegments - The line segments that should be used as a data source for this geometry.
   * Assumes the source geometry is not using indices.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  fromLineSegments(t) {
    const e = t.geometry;
    return this.setPositions(e.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Box3());
    const t = this.attributes.instanceStart, e = this.attributes.instanceEnd;
    t !== void 0 && e !== void 0 && (this.boundingBox.setFromBufferAttribute(t), Io.setFromBufferAttribute(e), this.boundingBox.union(Io));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere()), this.boundingBox === null && this.computeBoundingBox();
    const t = this.attributes.instanceStart, e = this.attributes.instanceEnd;
    if (t !== void 0 && e !== void 0) {
      const s = this.boundingSphere.center;
      this.boundingBox.getCenter(s);
      let i = 0;
      for (let n = 0, r = t.count; n < r; n++)
        Fi.fromBufferAttribute(t, n), i = Math.max(i, s.distanceToSquared(Fi)), Fi.fromBufferAttribute(e, n), i = Math.max(i, s.distanceToSquared(Fi));
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
};
UniformsLib.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new Vector2(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
ShaderLib.line = {
  uniforms: UniformsUtils.merge([
    UniformsLib.common,
    UniformsLib.fog,
    UniformsLib.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
var Cr = class extends ShaderMaterial {
  /**
   * Constructs a new line segments geometry.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(t) {
    super({
      type: "LineMaterial",
      uniforms: UniformsUtils.clone(ShaderLib.line.uniforms),
      vertexShader: ShaderLib.line.vertexShader,
      fragmentShader: ShaderLib.line.fragmentShader,
      clipping: true
      // required for clipping support
    }), this.isLineMaterial = true, this.setValues(t);
  }
  /**
   * The material's color.
   *
   * @type {Color}
   * @default (1,1,1)
   */
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(t) {
    this.uniforms.diffuse.value = t;
  }
  /**
   * Whether the material's sizes (width, dash gaps) are in world units.
   *
   * @type {boolean}
   * @default false
   */
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(t) {
    t === true ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  /**
   * Controls line thickness in CSS pixel units when `worldUnits` is `false` (default),
   * or in world units when `worldUnits` is `true`.
   *
   * @type {number}
   * @default 1
   */
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(t) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = t);
  }
  /**
   * Whether the line is dashed, or solid.
   *
   * @type {boolean}
   * @default false
   */
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(t) {
    t === true !== this.dashed && (this.needsUpdate = true), t === true ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  /**
   * The scale of the dashes and gaps.
   *
   * @type {number}
   * @default 1
   */
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(t) {
    this.uniforms.dashScale.value = t;
  }
  /**
   * The size of the dash.
   *
   * @type {number}
   * @default 1
   */
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(t) {
    this.uniforms.dashSize.value = t;
  }
  /**
   * Where in the dash cycle the dash starts.
   *
   * @type {number}
   * @default 0
   */
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(t) {
    this.uniforms.dashOffset.value = t;
  }
  /**
   * The size of the gap.
   *
   * @type {number}
   * @default 0
   */
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(t) {
    this.uniforms.gapSize.value = t;
  }
  /**
   * The opacity.
   *
   * @type {number}
   * @default 1
   */
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(t) {
    this.uniforms && (this.uniforms.opacity.value = t);
  }
  /**
   * The size of the viewport, in screen pixels. This must be kept updated to make
   * screen-space rendering accurate.The `LineSegments2.onBeforeRender` callback
   * performs the update for visible objects.
   *
   * @type {Vector2}
   */
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(t) {
    this.uniforms.resolution.value.copy(t);
  }
  /**
   * Whether to use alphaToCoverage or not. When enabled, this can improve the
   * anti-aliasing of line edges when using MSAA.
   *
   * @type {boolean}
   */
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(t) {
    this.defines && (t === true !== this.alphaToCoverage && (this.needsUpdate = true), t === true ? this.defines.USE_ALPHA_TO_COVERAGE = "" : delete this.defines.USE_ALPHA_TO_COVERAGE);
  }
};
var Vn = new Vector4();
var zo = new Vector3();
var Lo = new Vector3();
var Rt = new Vector4();
var Ut = new Vector4();
var we = new Vector4();
var Hn = new Vector3();
var jn = new Matrix4();
var Ft = new Line3();
var No = new Vector3();
var Vi = new Box3();
var Hi = new Sphere();
var be = new Vector4();
var Ee;
var ns;
function ko(l, t, e) {
  return be.set(0, 0, -t, 1).applyMatrix4(l.projectionMatrix), be.multiplyScalar(1 / be.w), be.x = ns / e.width, be.y = ns / e.height, be.applyMatrix4(l.projectionMatrixInverse), be.multiplyScalar(1 / be.w), Math.abs(Math.max(be.x, be.y));
}
function su(l, t) {
  const e = l.matrixWorld, s = l.geometry, i = s.attributes.instanceStart, n = s.attributes.instanceEnd, r = Math.min(s.instanceCount, i.count);
  for (let o = 0, a = r; o < a; o++) {
    Ft.start.fromBufferAttribute(i, o), Ft.end.fromBufferAttribute(n, o), Ft.applyMatrix4(e);
    const c = new Vector3(), h = new Vector3();
    Ee.distanceSqToSegment(Ft.start, Ft.end, h, c), h.distanceTo(c) < ns * 0.5 && t.push({
      point: h,
      pointOnLine: c,
      distance: Ee.origin.distanceTo(h),
      object: l,
      face: null,
      faceIndex: o,
      uv: null,
      uv1: null
    });
  }
}
function iu(l, t, e) {
  const s = t.projectionMatrix, n = l.material.resolution, r = l.matrixWorld, o = l.geometry, a = o.attributes.instanceStart, c = o.attributes.instanceEnd, h = Math.min(o.instanceCount, a.count), d = -t.near;
  Ee.at(1, we), we.w = 1, we.applyMatrix4(t.matrixWorldInverse), we.applyMatrix4(s), we.multiplyScalar(1 / we.w), we.x *= n.x / 2, we.y *= n.y / 2, we.z = 0, Hn.copy(we), jn.multiplyMatrices(t.matrixWorldInverse, r);
  for (let u = 0, f = h; u < f; u++) {
    if (Rt.fromBufferAttribute(a, u), Ut.fromBufferAttribute(c, u), Rt.w = 1, Ut.w = 1, Rt.applyMatrix4(jn), Ut.applyMatrix4(jn), Rt.z > d && Ut.z > d)
      continue;
    if (Rt.z > d) {
      const b = Rt.z - Ut.z, x = (Rt.z - d) / b;
      Rt.lerp(Ut, x);
    } else if (Ut.z > d) {
      const b = Ut.z - Rt.z, x = (Ut.z - d) / b;
      Ut.lerp(Rt, x);
    }
    Rt.applyMatrix4(s), Ut.applyMatrix4(s), Rt.multiplyScalar(1 / Rt.w), Ut.multiplyScalar(1 / Ut.w), Rt.x *= n.x / 2, Rt.y *= n.y / 2, Ut.x *= n.x / 2, Ut.y *= n.y / 2, Ft.start.copy(Rt), Ft.start.z = 0, Ft.end.copy(Ut), Ft.end.z = 0;
    const m = Ft.closestPointToPointParameter(Hn, true);
    Ft.at(m, No);
    const _ = MathUtils.lerp(Rt.z, Ut.z, m), p = _ >= -1 && _ <= 1, y = Hn.distanceTo(No) < ns * 0.5;
    if (p && y) {
      Ft.start.fromBufferAttribute(a, u), Ft.end.fromBufferAttribute(c, u), Ft.start.applyMatrix4(r), Ft.end.applyMatrix4(r);
      const b = new Vector3(), x = new Vector3();
      Ee.distanceSqToSegment(Ft.start, Ft.end, x, b), e.push({
        point: x,
        pointOnLine: b,
        distance: Ee.origin.distanceTo(x),
        object: l,
        face: null,
        faceIndex: u,
        uv: null,
        uv1: null
      });
    }
  }
}
var Fa = class extends Mesh {
  /**
   * Constructs a new wide line.
   *
   * @param {LineSegmentsGeometry} [geometry] - The line geometry.
   * @param {LineMaterial} [material] - The line material.
   */
  constructor(t = new Tr(), e = new Cr({ color: Math.random() * 16777215 })) {
    super(t, e), this.isLineSegments2 = true, this.type = "LineSegments2";
  }
  /**
   * Computes an array of distance values which are necessary for rendering dashed lines.
   * For each vertex in the geometry, the method calculates the cumulative length from the
   * current point to the very beginning of the line.
   *
   * @return {LineSegments2} A reference to this instance.
   */
  computeLineDistances() {
    const t = this.geometry, e = t.attributes.instanceStart, s = t.attributes.instanceEnd, i = new Float32Array(2 * e.count);
    for (let r = 0, o = 0, a = e.count; r < a; r++, o += 2)
      zo.fromBufferAttribute(e, r), Lo.fromBufferAttribute(s, r), i[o] = o === 0 ? 0 : i[o - 1], i[o + 1] = i[o] + zo.distanceTo(Lo);
    const n = new InstancedInterleavedBuffer(i, 2, 1);
    return t.setAttribute("instanceDistanceStart", new InterleavedBufferAttribute(n, 1, 0)), t.setAttribute("instanceDistanceEnd", new InterleavedBufferAttribute(n, 1, 1)), this;
  }
  /**
   * Computes intersection points between a casted ray and this instance.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(t, e) {
    const s = this.material.worldUnits, i = t.camera;
    i === null && !s && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const n = t.params.Line2 !== void 0 && t.params.Line2.threshold || 0;
    Ee = t.ray;
    const r = this.matrixWorld, o = this.geometry, a = this.material;
    ns = a.linewidth + n, o.boundingSphere === null && o.computeBoundingSphere(), Hi.copy(o.boundingSphere).applyMatrix4(r);
    let c;
    if (s)
      c = ns * 0.5;
    else {
      const d = Math.max(i.near, Hi.distanceToPoint(Ee.origin));
      c = ko(i, d, a.resolution);
    }
    if (Hi.radius += c, Ee.intersectsSphere(Hi) === false)
      return;
    o.boundingBox === null && o.computeBoundingBox(), Vi.copy(o.boundingBox).applyMatrix4(r);
    let h;
    if (s)
      h = ns * 0.5;
    else {
      const d = Math.max(i.near, Vi.distanceToPoint(Ee.origin));
      h = ko(i, d, a.resolution);
    }
    Vi.expandByScalar(h), Ee.intersectsBox(Vi) !== false && (s ? su(this, e) : iu(this, i, e));
  }
  onBeforeRender(t) {
    const e = this.material.uniforms;
    e && e.resolution && (t.getViewport(Vn), this.material.uniforms.resolution.value.set(Vn.z, Vn.w));
  }
};
var nu = class {
  constructor(t, e) {
    A(this, "_components");
    A(this, "_modelStyleGeometries", new Yt());
    A(this, "onDisposed", new tt());
    A(this, "three", new Group());
    A(this, "plane");
    A(this, "items", new Yt());
    A(this, "world", null);
    A(this, "_visible", false);
    this._components = t, this.plane = e, this.setupEvents();
  }
  /**
   * Sets the visibility of the object in the scene.
   * When set to `true`, the object is added to the scene if the `world` property is defined.
   * When set to `false`, the object is removed from its parent.
   */
  set visible(t) {
    t ? this.world && (this.world.scene.three.add(this.three), this._visible = true) : (this.three.removeFromParent(), this._visible = false);
  }
  get visible() {
    return this._visible;
  }
  setupEvents() {
    const t = this._components.get(Ks);
    this.items.guard = (e, { style: s }) => !!t.styles.get(s), this.items.onItemSet.add(({ value: e }) => {
      const { style: s, data: i } = e;
      this.create(s, i);
    });
  }
  getStyleMeshes(t, e) {
    const i = this._components.get(Ks).styles.get(e);
    if (!i)
      throw new Error(`ClipStyler: "${e}" style not found.`);
    const r = this._components.get(ct).list.get(t);
    if (!r)
      throw new Error(`ClipEdges: model with id "${t}" not found.`);
    const { linesMaterial: o, fillsMaterial: a } = i;
    let c = this._modelStyleGeometries.get(t);
    c || (c = new Yt(), this._modelStyleGeometries.set(t, c));
    let h = c.get(e);
    if (!h) {
      let d;
      o && (d = new Fa(new Tr(), o), d.frustumCulled = false, r && d.applyMatrix4(r.object.matrixWorld), this.three.add(d));
      let u;
      a && (u = new Mesh(new BufferGeometry(), a), r && u.applyMatrix4(r.object.matrixWorld), this.three.add(u)), h = { edges: d, fills: u }, c.set(e, h);
    }
    return h;
  }
  async updateMeshes(t, e, s) {
    const n = this._components.get(ct).list.get(t);
    if (!n)
      return;
    const r = this._components.get(De), o = this.plane.clone();
    o.constant -= 0.01;
    const a = await n.getSection(o, s), { buffer: c, index: h, fillsIndices: d } = a, u = this.getStyleMeshes(t, e), { edges: f, fills: g } = u, m = new BufferAttribute(c, 3, false);
    if (f) {
      m.setUsage(DynamicDrawUsage);
      const _ = new BufferGeometry();
      _.setAttribute("position", m), _.setDrawRange(0, h);
      const p = new LineSegments(_);
      f.geometry.fromLineSegments(p), r.destroy(p);
    }
    g && (g.geometry.attributes.position = m, g.geometry.setIndex(d));
  }
  async create(t, e) {
    if (!this._components.get(Ks).styles.get(t))
      throw new Error(`ClipEdges: "${t}" style not found.`);
    const n = this._components.get(qc);
    let r = null;
    e && (r = await n.find(e));
    const o = this._components.get(ct);
    if (r)
      for (const [a, c] of Object.entries(r))
        o.list.get(a) && this.updateMeshes(a, t, [...c]);
    else
      for (const [a] of o.list)
        this.updateMeshes(a, t);
  }
  /**
   * Updates the clip edges based on the provided groups and their associated styles and data.
   * If no groups are specified, all items will be updated.
   *
   * @param groups - An optional array of group names to filter which items should be updated.
   * @returns A promise that resolves when the update process is complete.
   */
  async update(t) {
    for (const [e, { data: s, style: i }] of this.items)
      t && !t.includes(e) || this.create(i, s);
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    this._components.get(De).destroy(this.three, true, true), this._modelStyleGeometries.clear();
  }
};
var $s = class $s2 extends St {
  constructor(e) {
    super(e);
    A(this, "onDisposed", new tt());
    A(this, "enabled", true);
    A(this, "world", null);
    A(this, "styles", new Yt());
    A(this, "list", new Yt());
    A(this, "_visible", true);
    this.components.list.set($s2.uuid, this), this.setEvents();
  }
  /**
   * Gets the visibility state of the edges.
   */
  get visible() {
    return this._visible;
  }
  /**
   * Sets the visibility state of the edges.
   * @param {boolean} active - The new visibility state.
   */
  set visible(e) {
    this._visible = e;
    for (const [, s] of this.list)
      s.visible = e;
  }
  setEvents() {
    this.list.onBeforeDelete.add(({ value: e }) => e.dispose());
  }
  setEdgesConfig(e, s) {
    if (e.world = (s == null ? void 0 : s.world) ?? this.world, s != null && s.items)
      for (const [n, r] of Object.entries(s.items))
        e.items.set(n, r);
    const i = (s == null ? void 0 : s.id) ?? Xt.create();
    this.list.set(i, e);
  }
  /**
   * Creates a new instance of `ClipEdges` using the specified plane and optional configuration.
   *
   * @param plane - The `THREE.Plane` object used to define the clipping plane.
   * @param config - Optional configuration for the edges creation.
   * @returns A new instance of `ClipEdges` initialized with the specified plane and configuration.
   * @remarks The given plane won't be copied during the ClipEdges creation.
   */
  create(e, s) {
    const i = new nu(this.components, e);
    return s && this.setEdgesConfig(i, s), i;
  }
  /**
   * Creates and configures clip edges from a given view.
   *
   * This method generates clip edges based on the provided view's plane and optional configuration.
   * If the `link` option in the configuration is enabled (default is `true`), the clip edges are
   * dynamically linked to the view's lifecycle events, ensuring proper disposal, updates, and visibility
   * synchronization with the view's state.
   *
   * @param view - The view object from which the clip edges are created.
   * @param config - Optional configuration for clip edge creation.
   * @returns The created clip edges object, configured and optionally linked to the view's lifecycle.
   */
  createFromView(e, s) {
    const i = this.create(e.plane, s);
    return ((s == null ? void 0 : s.link) !== void 0 ? s.link : true) && (e.onDisposed.add(() => i.dispose()), e.onUpdated.add(() => i.update()), e.onStateChanged.add(() => i.visible = e.open)), i;
  }
  /**
   * Creates and returns styled edges from a clipping plane identified by its ID.
   * Optionally, a configuration object can be provided to customize the creation process.
   *
   * @param id - The unique identifier of the clipping plane to create edges from.
   * @param config - Optional configuration for edge creation, including visibility and linking behavior.
   *
   * @returns The created edges styled from the clipping plane.
   *
   * @remarks
   * - If `config.link` is `true` (default), the edges will automatically update when the clipping plane's dragging ends
   *   and will be disposed of when the clipping plane is disposed.
   */
  createFromClipping(e, s) {
    const n = this.components.get(Ve).list.get(e);
    if (!n)
      throw new Error(`ClipStyler: Clipping plane with ID ${e} not found.`);
    const r = this.create(n.three, s);
    return r.visible = true, ((s == null ? void 0 : s.link) !== void 0 ? s.link : true) && (n.onDraggingEnded.add(() => r.update()), n.onDisposed.add(() => r.dispose())), r;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    this.styles.clear(), this.list.clear(), this.onDisposed.trigger($s2.uuid);
  }
};
A($s, "uuid", "24dfc306-a3c4-410f-8071-babc4afa5e4d");
var Ks = $s;
var ti = class ti2 extends St {
  constructor(e) {
    super(e);
    A(this, "onDisposed", new tt());
    A(this, "onBeforeUpdate", new tt());
    A(this, "onAfterUpdate", new tt());
    A(this, "onSetup", new tt());
    A(this, "isSetup", false);
    A(this, "enabled", true);
    A(this, "events", {});
    A(this, "multiple", "ctrlKey");
    A(this, "zoomFactor", 1.5);
    A(this, "zoomToSelection", false);
    A(this, "backupColor", null);
    A(this, "selection", {});
    A(this, "config", {
      selectName: "select",
      selectionColor: null,
      autoHighlightOnClick: true,
      world: null,
      selectEnabled: true,
      selectMaterialDefinition: {
        color: new Color("#BCF124"),
        renderedFaces: ve.ONE,
        opacity: 1,
        transparent: false
      }
    });
    A(this, "styles", new Yt());
    A(this, "autoToggle", /* @__PURE__ */ new Set());
    A(this, "mouseDownPosition", { x: 0, y: 0 });
    A(this, "mouseMoveThreshold", 5);
    A(this, "selectable", {});
    A(this, "eventManager", new jc());
    A(this, "_mouseState", {
      down: false,
      moved: false
    });
    A(this, "_fromHighlight", false);
    A(this, "restorePreviousColors", (e2 = this.selection.select) => {
      for (const [s, i] of Object.entries(this.selection))
        if (!(s === this.config.selectName || !this.styles.get(s)))
          for (const [r, o] of Object.entries(e2)) {
            const a = i[r];
            if (!a)
              continue;
            const c = [...o].filter(
              (h) => a.has(h)
            );
            c.length !== 0 && new Set(c);
          }
    });
    A(this, "onMouseDown", (e2) => {
      this.enabled && (this.debounceTimeout && clearTimeout(this.debounceTimeout), this.mouseDownPosition = { x: e2.clientX, y: e2.clientY }, this._mouseState.down = true);
    });
    A(this, "debounceTimeout", null);
    A(this, "onMouseUp", async (e2) => {
      if (!this.enabled)
        return;
      const { world: s, autoHighlightOnClick: i, selectEnabled: n } = this.config;
      if (!s)
        throw new Error("No world found!");
      if (!s.renderer)
        throw new Error("This world doesn't have a renderer!");
      if (e2.target === s.renderer.three.domElement) {
        if (this._mouseState.down = false, this._mouseState.moved || e2.button !== 0) {
          this._mouseState.moved = false;
          return;
        }
        if (this._mouseState.moved = false, i && n) {
          const r = this.multiple === "none" ? true : !e2[this.multiple];
          await this.highlight(this.config.selectName, r, this.zoomToSelection);
        }
      }
    });
    A(this, "onMouseMove", async (e2) => {
      if (!this.enabled)
        return;
      const s = e2.clientX - this.mouseDownPosition.x, i = e2.clientY - this.mouseDownPosition.y, n = Math.sqrt(s * s + i * i);
      this._mouseState.moved || n > this.mouseMoveThreshold && (this._mouseState.moved = this._mouseState.down);
    });
    this.components.add(ti2.uuid, this), this.eventManager.list.add(this.onSetup), this.eventManager.list.add(this.onDisposed), this.setStyleEvents();
  }
  setStyleEvents() {
    this.styles.onBeforeDelete.add(async ({ key: e }) => {
      if (await this.clear(e), delete this.selection[e], !(e in this.events))
        return;
      const { onClear: s, onHighlight: i, onBeforeHighlight: n } = this.events[e];
      this.eventManager.list.delete(s), this.eventManager.list.delete(i), this.eventManager.list.delete(n), delete this.events[e];
    }), this.styles.onItemSet.add(({ key: e }) => {
      this.selection[e] = {};
      const s = new tt(), i = new tt(), n = new tt();
      this.events[e] = {
        onHighlight: s,
        onClear: n,
        onBeforeHighlight: i
      }, this.eventManager.add([n, s, i]);
    });
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.setupEvents(false), this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.selection = {}, this.styles.clear(), this.onDisposed.trigger(ti2.uuid), this.eventManager.reset(), this.isSetup = false;
  }
  add(e) {
    if (console.warn(
      "highlighter.add() is deprecated, use highlighter.styles.set() instead"
    ), typeof e == "string")
      this.styles.set(e, null);
    else {
      const { customId: s } = e;
      this.styles.set(s, e);
    }
  }
  /**
   * Removes the specified selection.
   *
   * @param name - The name of the new selection.
   * @deprecated use highlighter.styles.delete
   */
  async remove(e) {
    console.warn(
      "highlighter.remove() is deprecated, use highlighter.styles.delete() instead"
    ), this.styles.delete(e);
  }
  /**
   * Highlights a fragment based on a raycast from the mouse position.
   *
   * @param name - The name of the selection.
   * @param removePrevious - Whether to remove previous highlights.
   * @param zoomToSelection - Whether to zoom to the highlighted selection.
   * @param exclude - Fragments to exclude from the highlight.
   *
   * @returns The highlighted fragment and its ID, or null if no fragment was highlighted.
   *
   * @throws Will throw an error if the world or a required component is not found.
   * @throws Will throw an error if the selection does not exist.
   * @throws Will throw an error if the fragment or its geometry is not found.
   * @throws Will throw an error if the item ID is not found.
   * @throws Will throw an error if the fragment does not belong to a FragmentsGroup.
   */
  async highlight(e, s = true, i = this.zoomToSelection, n = null) {
    if (!this.enabled)
      return;
    if (!this.config.world)
      throw new Error("No world found in config!");
    const r = this.config.world;
    if (!this.selection[e])
      throw new Error(`Selection ${e} does not exist.`);
    const c = await this.components.get(me).get(r).castRay();
    if (!c || c.localId === void 0 || c.localId === null) {
      s && this.clear(e);
      return;
    }
    const {
      localId: h,
      fragments: { modelId: d }
    } = c, u = { [d]: /* @__PURE__ */ new Set([h]) };
    await this.highlightByID(
      e,
      u,
      s,
      i,
      n,
      true
    );
  }
  // TODO: Make parameters an object?
  /**
   * Highlights a fragment based on a given fragment ID map.
   *
   * @param name - The name of the selection.
   * @param modelIdMap - The fragment ID map to highlight.
   * @param removePrevious - Whether to remove previous highlights.
   * @param zoomToSelection - Whether to zoom to the highlighted selection.
   * @param exclude - Fragments to exclude from the highlight.
   * @param fillMesh - The fill mesh to also highlight, if any.
   * @param isPicking - Whether this function is called when picking with the mouse.
   *
   * @returns Promise that resolves when the highlighting is complete.
   *
   * @throws Will throw an error if the selection does not exist.
   * @throws Will throw an error if the fragment or its geometry is not found.
   * @throws Will throw an error if the item ID is not found.
   * @throws Will throw an error if the fragment does not belong to a FragmentsGroup.
   */
  async highlightByID(e, s, i = true, n = this.zoomToSelection, r = null, o = false) {
    var c;
    if (!this.enabled)
      return;
    this._fromHighlight = true, this.events[e].onBeforeHighlight.trigger(this.selection[e]), i && await this.clear(e);
    let a = {};
    if (Object.keys(this.selectable).length !== 0 || r !== null)
      for (const h in s) {
        const d = new Set(s[h]), u = (c = this.selectable) == null ? void 0 : c[e], f = u ? u[h] : void 0, g = f ? new Set(f) : void 0, m = r == null ? void 0 : r[h], _ = m ? new Set(m) : void 0;
        if (_ || g)
          for (const p of d) {
            if (_ && _.has(p) || g && !g.has(p))
              continue;
            let y = a[h];
            y || (y = /* @__PURE__ */ new Set(), a[h] = y), y.add(p);
          }
      }
    else
      a = s;
    if (o && this.autoToggle.has(e)) {
      const h = {};
      let d = false;
      for (const u in a) {
        const f = this.selection[e][u];
        if (!f)
          continue;
        const g = a[u];
        for (const m of g)
          if (f.has(m)) {
            f.delete(m);
            let _ = h[u];
            _ || (_ = /* @__PURE__ */ new Set(), h[u] = _), _.add(m), d = true;
          } else
            f.add(m);
        a[u] = f;
      }
      d && (this.events[e].onClear.trigger(h), e === this.config.selectName && this.restorePreviousColors(h));
    }
    this.updateStyleMap(e, a), this.events[e].onHighlight.trigger(this.selection[e]), this._fromHighlight = false, await this.updateColors(), n && await this.zoomSelection(a);
  }
  /**
   * Updates the colors of highlighted fragments based on the current selection and styles.
   * @returns Resolves when all highlight updates and core state updates are completed.
   */
  async updateColors() {
    const e = this.components.get(ct), s = [e.resetHighlight()];
    for (const [i, n] of Object.entries(this.selection)) {
      const r = this.styles.get(i);
      if (!r)
        continue;
      const o = i === "select" || !this.styles.get(this.config.selectName) ? n : this.getMapWithoutSelection(i);
      o && s.push(
        e.highlight({ ...r, customId: i }, o)
      );
    }
    s.push(e.core.update(true)), await Promise.allSettled(s);
  }
  updateStyleMap(e, s) {
    const i = this.selection[e];
    for (const n in s) {
      let r = i[n];
      r || (r = /* @__PURE__ */ new Set(), i[n] = r);
      const o = s[n];
      for (const a of o)
        r.add(a);
    }
    if (e !== this.config.selectName)
      for (const [n, r] of Object.entries(this.selection)) {
        if (n === this.config.selectName || n === e)
          continue;
        const o = r;
        for (const [a, c] of Object.entries(i)) {
          const h = o[a];
          if (h)
            for (const d of c)
              h.delete(d);
        }
      }
  }
  /**
   * Retrieves a map of model IDs to element IDs, excluding elements that are also present in the selection map
   * specified by `this.config.selectName`. Optionally filters the results based on a provided filter map.
   *
   * @param style - The style name to retrieve the selection from.
   * @param filter - An optional map of model IDs to element IDs used to further filter the results. If provided,
   *                 only elements present in this filter will be included in the result.
   * @returns A map of model IDs to element IDs, excluding selected elements and optionally filtered elements.
   *          Returns `null` if the resulting map is empty.
   * @throws Error - If the specified style does not exist in the selection.
   */
  getMapWithoutSelection(e, s) {
    const i = this.selection[e];
    if (!i)
      throw new Error(`Style ${e} does not exist.`);
    const n = this.selection[this.config.selectName] ?? {}, r = {};
    for (const o in i) {
      const a = i[o], c = e === this.config.selectName ? /* @__PURE__ */ new Set() : n[o] ?? /* @__PURE__ */ new Set(), h = Array.from(a).filter(
        (d) => {
          var u;
          return !c.has(d) && (!s || ((u = s[o]) == null ? void 0 : u.has(d)));
        }
      );
      h.length > 0 && (r[o] = new Set(h));
    }
    return Object.keys(r).length > 0 ? r : null;
  }
  /**
   * Clears the selection for the given name or all selections if no name is provided.
   *
   * @param name - The name of the selection to clear. If not provided, clears all selections.
   * @param filter - The only items to unselect. If not provided, all items will be unselected.
   *
   */
  async clear(e, s) {
    const i = e ? [e] : Object.keys(this.selection), n = s ?? void 0;
    for (const r of i) {
      const o = this.selection[r] ?? {}, a = n ?? o;
      r === this.config.selectName && this.restorePreviousColors();
      const c = {};
      for (const [h, d] of Object.entries(a)) {
        const u = o[h];
        if (u)
          for (const f of d) {
            if (!u.delete(f))
              continue;
            let m = c[h];
            m || (m = /* @__PURE__ */ new Set(), c[h] = m), m.add(f);
          }
      }
      Object.keys(c).length > 0 && this.events[r].onClear.trigger(c);
    }
    this._fromHighlight || await this.updateColors();
  }
  /**
   * Sets up the Highlighter with the provided configuration.
   *
   * @param config - Optional configuration for the Highlighter.
   * If not provided, the Highlighter will use the default configuration.
   *
   * @throws Will throw an error if the world or a required component is not found.
   * @throws Will throw an error if the selection already exists.
   * @throws Will throw an error if the fragment or its geometry is not found.
   * @throws Will throw an error if the item ID is not found.
   * @throws Will throw an error if the fragment does not belong to a FragmentsGroup.
   */
  setup(e) {
    if (this.isSetup)
      return;
    this.config = { ...this.config, ...e };
    const { selectName: s, selectionColor: i, selectMaterialDefinition: n } = this.config;
    n ? (i && (console.warn(
      "highlighter.config.selectionColor is deprecated, use selectMaterialDefinition instead"
    ), n.color = i), this.styles.set(s, n)) : this.styles.set(s, null), this.autoToggle.add(this.config.selectName), this.setupEvents(true), this.enabled = true, this.isSetup = true, this.onSetup.trigger(this);
  }
  async zoomSelection(e) {
    if (!this.config.world)
      throw new Error("No world found in config!");
    const s = this.config.world;
    let i = false;
    for (const y in e)
      if (e[y].size > 0) {
        i = true;
        break;
      }
    if (!i || !s.camera.hasCameraControls())
      return;
    const r = await this.components.get(ct).getBBoxes(e), o = new Sphere(), a = new Box3();
    for (const y of r)
      a.union(y);
    a.getBoundingSphere(o);
    const c = 1 / 0, h = -1 / 0, { x: d, y: u, z: f } = o.center, g = o.radius === c || d === c || u === c || f === c, m = o.radius === h || d === h || u === h || f === h, _ = o.radius === 0;
    if (g || m || _)
      return;
    o.radius *= this.zoomFactor, await s.camera.controls.fitToSphere(o, true);
  }
  setupEvents(e) {
    if (!this.config.world) {
      console.log("No world found while setting up events!");
      return;
    }
    if (this.config.world.isDisposing)
      return;
    if (!this.config.world.renderer)
      throw new Error("The given world doesn't have a renderer!");
    const s = this.config.world.renderer.three.domElement;
    s.removeEventListener("mousedown", this.onMouseDown), s.removeEventListener("mouseup", this.onMouseUp), s.removeEventListener("pointermove", this.onMouseMove), e && (s.addEventListener("mousedown", this.onMouseDown), s.addEventListener("mouseup", this.onMouseUp), s.addEventListener("pointermove", this.onMouseMove));
  }
};
A(ti, "uuid", "cb8a76f2-654a-4b50-80c6-66fd83cafd77");
var Js = ti;
var nn = class nn2 extends St {
  constructor() {
    super(...arguments);
    A(this, "enabled", true);
    A(this, "geometries", new Yt());
    A(this, "onDisposed", new tt());
  }
  /**
   * Retrieves meshes for specified model items, optionally applying a material and coordinate system transformation.
   *
   * @param modelIdMap - A map of model IDs to an array of local IDs, specifying which items to retrieve meshes for.
   * @param _config - Optional configuration object.
   * @param _config.material - Optional material to apply to the meshes. If not provided, the default material is used.
   * @param _config.coordinate - Whether to apply coordinate system transformation. Defaults to `true`.
   * @param _config.applyTransformation - Whether to bring the mesh to its original position or leave it at 0,0,0. Defaults to `true`.
   * @returns A map of model IDs to a map of local IDs to an array of THREE.Mesh objects.
   */
  async get(e, s) {
    const { material: i, coordinate: n, applyTransformation: r } = {
      coordinate: true,
      applyTransformation: true,
      ...s
    }, o = this.components.get(ct), a = new Yt();
    for (const [c, h] of Object.entries(e)) {
      const d = o.list.get(c);
      if (!d)
        continue;
      const u = this.getModelMeshes(c);
      for (const f of h) {
        let g = a.get(c);
        g || (g = new Yt(), a.set(c, g));
        let m = u.get(f);
        if (m && m.length > 0) {
          const y = [];
          for (const [b, { geometry: x, transform: S }] of m.entries()) {
            const C = await this.createMesh(d, x, S, {
              material: i,
              applyTransformation: r,
              coordinate: n
            });
            y.push(C);
          }
          g.set(f, y);
          continue;
        } else
          m = [], u.set(f, m);
        const [_] = await d.getItemsGeometry([f]);
        if (!_)
          continue;
        const p = [];
        for (const y of _) {
          const b = this.createGeometry(y);
          if (!b)
            continue;
          const { geometry: x, transform: S } = b;
          m.push(b);
          const C = await this.createMesh(d, x, S, {
            material: i,
            applyTransformation: r,
            coordinate: n
          });
          p.push(C);
        }
        g.set(f, p);
      }
    }
    return a;
  }
  getModelMeshes(e) {
    let s = this.geometries.get(e);
    return s || (s = new Yt(), this.geometries.set(e, s)), s;
  }
  /**
   * Removes the cached geometries by disposing the resources.
   * This makes the meshes created by the component unusable as the geometry will no longer be present.
   *
   * @param modelIds - An optional array of model IDs to remove. If not provided, all meshes will be removed.
   */
  remove(e = [...this.geometries.keys()]) {
    for (const s of e) {
      const i = this.geometries.get(s);
      if (i) {
        for (const [n, r] of i)
          for (const { geometry: o } of r)
            o.dispose();
        this.geometries.delete(s);
      }
    }
  }
  dispose(e = true) {
    this.remove(), e && this.geometries.dispose(), this.onDisposed.trigger(nn2.uuid);
  }
  getMeshesFromResult(e) {
    const s = [];
    for (const i of e.values())
      for (const n of i.values())
        s.push(...n);
    return s;
  }
  createGeometry(e) {
    const { positions: s, indices: i, normals: n, transform: r } = e;
    if (!(s && i && n))
      return null;
    const o = new BufferGeometry();
    return o.setAttribute("position", new BufferAttribute(s, 3)), o.setAttribute(
      "normal",
      new BufferAttribute(n, 3, true)
    ), o.setIndex(new BufferAttribute(i, 1)), { geometry: o, transform: r };
  }
  async createMesh(e, s, i, n) {
    const { material: r, applyTransformation: o, coordinate: a } = {
      applyTransformation: true,
      coordinate: true,
      ...n
    }, c = this.components.get(ct), h = new Mesh(s, r);
    if (h.applyMatrix4(i), o || h.position.set(0, 0, 0), a && c.baseCoordinationModel !== e.modelId) {
      const d = await e.getCoordinationMatrix();
      c.applyBaseCoordinateSystem(h, d);
    }
    return h;
  }
};
A(nn, "uuid", "ab45d0a7-feea-4afc-927c-80832dae76dd");
var hr = nn;
var ei = class ei2 extends St {
  constructor(e) {
    super(e);
    A(this, "_world");
    A(this, "styles", new Wt());
    A(this, "outlinePositions", false);
    A(this, "_mesh", null);
    A(this, "onDisposed", new tt());
    A(this, "_meshes", []);
    A(this, "_map", {});
    A(this, "_activeStyles", /* @__PURE__ */ new Set());
    A(this, "_styleCallbacks", {});
    e.add(ei2.uuid, this), this.setupEvents();
  }
  /**
   * The world where the outliner operates.
   */
  set world(e) {
    if (this._world = e, !e)
      return;
    this.getRenderer().postproduction.excludedObjectsPass.addExcludedMaterial(
      this._points.material
    );
  }
  get world() {
    return this._world;
  }
  get _points() {
    return this._mesh || (this._mesh = new Points(
      new BufferGeometry(),
      new PointsMaterial({
        size: 10,
        sizeAttenuation: false,
        depthTest: false
      })
    )), this._mesh;
  }
  /** {@link OBC.Component.enabled} */
  get enabled() {
    return !this.world || this.world.isDisposing ? false : this.getRenderer().postproduction.outlinesEnabled;
  }
  /** {@link OBC.Component.enabled} */
  set enabled(e) {
    if (!this.world || this.world.isDisposing)
      return;
    const s = this.getRenderer();
    s.postproduction.outlinesEnabled = e, this.outlinePositions && (this._points.material.color = this.color, this.world.scene.three.add(this._points));
  }
  get color() {
    return this.getRenderer().postproduction.outlinePass.outlineColor;
  }
  /**
   * Sets the color for the outline.
   */
  set color(e) {
    this.getRenderer().postproduction.outlinePass.outlineColor.copy(e), this._points.material.color.copy(e);
  }
  get thickness() {
    return this.getRenderer().postproduction.outlinePass.thickness;
  }
  /**
   * Sets the thickness of the outline effect in the post-production renderer.
   */
  set thickness(e) {
    this.getRenderer().postproduction.outlinePass.thickness = e;
  }
  get fillColor() {
    return this.getRenderer().postproduction.outlinePass.fillColor;
  }
  /**
   * Sets the fill color for the outline effect in the postproduction pipeline.
   */
  set fillColor(e) {
    this.getRenderer().postproduction.outlinePass.fillColor.copy(e);
  }
  get fillOpacity() {
    return this.getRenderer().postproduction.outlinePass.fillOpacity;
  }
  /**
   * Sets the fill opacity for the outline pass in the postproduction renderer.
   */
  set fillOpacity(e) {
    const s = this.getRenderer().postproduction;
    s.outlinePass.fillOpacity = e;
  }
  setupEvents() {
    const e = this.components.get(Js);
    this.styles.guard = (s) => e.styles.has(s), this.styles.onItemAdded.add((s) => {
      const i = this.components.get(Js), n = () => {
        this._activeStyles.add(s), this.updateFromStyles();
      }, r = () => {
        this._activeStyles.delete(s), this.updateFromStyles();
      };
      this._styleCallbacks[s] = { onHighlight: n, onClear: r }, i.events[s].onHighlight.add(n), i.events[s].onClear.add(r);
    }), this.styles.onBeforeDelete.add((s) => {
      const { onHighlight: i, onClear: n } = this._styleCallbacks[s];
      e.events[s].onHighlight.remove(i), e.events[s].onClear.remove(n), this._activeStyles.delete(s), delete this._styleCallbacks[s];
    }), e.styles.onItemDeleted.add((s) => this.styles.delete(s));
  }
  async updateFromStyles() {
    const e = this.components.get(Js), s = [];
    for (const n of this._activeStyles) {
      const r = e.selection[n];
      r && s.push(r);
    }
    const i = Dt.join(s);
    this._map = i, await this.update();
  }
  /**
   * Updates the outline effect with the current meshes from the mesher component.
   */
  async update(e = this._map) {
    if (e === this._map && this.cleanMeshes(), this.outlinePositions && this.updatePoints(), Object.keys(e).length === 0)
      return;
    const i = this.getRenderer().postproduction.outlinePass, r = await this.components.get(hr).get(e);
    for (const [o, a] of r.entries()) {
      const c = [...a.values()].flat();
      for (const h of c)
        this._meshes.push(h), i.scene.add(h);
    }
  }
  /**
   * Adds items to be outlined.
   *
   * @param modelIdMap - An object representing the model ID map to be added.
   * @returns A promise that resolves once the outliner has been updated with the new model ID map.
   */
  async addItems(e) {
    Dt.add(this._map, e), await this.update(e);
  }
  /**
   * Removes items from the current outlines.
   *
   * @param modelIdMap - An object representing the mapping of model IDs to be removed.
   * @returns A promise that resolves once the update operation is complete.
   */
  async removeItems(e) {
    Dt.remove(this._map, e), await this.update();
  }
  /**
   * Cleans up the outlines.
   */
  clean() {
    this._map = {}, this._activeStyles.clear(), this.cleanMeshes(), this._mesh && this.components.get(De).destroy(this._mesh, true, true), this._mesh = null;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.styles.clear(), this.clean(), this.onDisposed.trigger(ei2.uuid);
  }
  cleanMeshes() {
    for (const e of this._meshes)
      e.removeFromParent();
    this._meshes = [];
  }
  async updatePoints() {
    let e = 0;
    for (const [n, r] of Object.entries(this._map))
      e += r.size;
    this._points.geometry.setAttribute(
      "position",
      new Float32BufferAttribute(new Float32Array(e * 3), 3)
    );
    const i = await this.components.get(ct).getPositions(this._map);
    for (let n = 0; n < i.length; n++) {
      const { x: r, y: o, z: a } = i[n];
      this._points.geometry.attributes.position.array[n * 3] = r, this._points.geometry.attributes.position.array[n * 3 + 1] = o, this._points.geometry.attributes.position.array[n * 3 + 2] = a;
    }
    this._points.geometry.attributes.position.needsUpdate = true;
  }
  getRenderer() {
    if (!this.world)
      throw new Error("You must set a world to use the outliner!");
    const e = this.world.renderer;
    if (!e.postproduction)
      throw new Error(
        "The world given to the outliner must use the postproduction renderer."
      );
    return e;
  }
};
A(ei, "uuid", "2fd3bcc5-b3b6-4ded-9f64-f47a02854a10");
var Bo = ei;
var rn = class rn2 extends St {
  constructor(e) {
    super(e);
    A(this, "HOVERER_OPACITY_KEY", "_maxHoverOpacity");
    A(this, "_hoverTimeout", null);
    A(this, "_meshes", new Wt());
    A(this, "_localId", null);
    A(this, "_fadeAnimation", null);
    A(this, "_world", null);
    A(this, "_enabled", false);
    A(this, "_material", new MeshBasicMaterial({
      color: 16777215,
      transparent: true,
      opacity: 0.5,
      depthTest: false,
      userData: { [this.HOVERER_OPACITY_KEY]: 0.5 }
    }));
    A(this, "onDisposed", new tt());
    A(this, "duration", 200);
    A(this, "animation", true);
    A(this, "mouseStopTimeout", null);
    A(this, "onMouseMove", () => {
      this.mouseStopTimeout !== null && clearTimeout(this.mouseStopTimeout), this.mouseStopTimeout = window.setTimeout(() => this.hover(), 50);
    });
    A(this, "onMouseLeave", () => {
      this._meshes.clear();
    });
    A(this, "animate", () => {
      if (!(this._fadeAnimation && this.animation && this.material.transparent))
        return;
      const { startTime: e2, duration: s, fadeIn: i } = this._fadeAnimation, n = Date.now() - e2, r = Math.min(n / s, 1), o = i ? r : 1 - r, a = this.material.userData[this.HOVERER_OPACITY_KEY], c = o * (a !== void 0 ? a : 1);
      this.material.opacity = c, r < 1 ? requestAnimationFrame(this.animate) : (i || this._meshes.clear(), this._fadeAnimation = null);
    });
    e.add(rn2.uuid, this), this._meshes.onBeforeDelete.add((s) => {
      s.removeFromParent(), s.geometry.dispose();
    }), this._meshes.onItemAdded.add((s) => {
      this.world && this.world.scene.three.add(s);
    }), this._meshes.onCleared.add(() => {
      this._localId = null, this._hoverTimeout && (clearTimeout(this._hoverTimeout), this._hoverTimeout = null);
    });
  }
  set world(e) {
    if (e) {
      this.components.get(me).get(e), this._world = e, this.setupEvents(true);
      for (const s of this._meshes)
        e.scene.three.add(s);
    } else {
      this.setupEvents(false), this._world = null;
      for (const s of this._meshes)
        s.removeFromParent();
    }
  }
  get world() {
    return this._world;
  }
  set enabled(e) {
    this.setupEvents(e), this._enabled = e;
  }
  get enabled() {
    return this._enabled;
  }
  set material(e) {
    e.userData[this.HOVERER_OPACITY_KEY] = e.opacity;
    for (const s of this._meshes)
      s.material = e;
    this._material.dispose(), this._material = e;
  }
  get material() {
    return this._material;
  }
  setupEvents(e) {
    if (!this.world || this.world.isDisposing)
      return;
    if (!this.world.renderer)
      throw new Error("The given world doesn't have a renderer!");
    const s = this.world.renderer.three.domElement;
    s.removeEventListener("mousemove", this.onMouseMove), s.removeEventListener("mouseleave", this.onMouseMove), e && (s.addEventListener("mousemove", this.onMouseMove), s.addEventListener("mouseleave", this.onMouseLeave));
  }
  async hover() {
    if (!this.enabled || !this.world)
      return;
    const i = await this.components.get(me).get(this.world).castRay();
    if (!i) {
      this._meshes.clear();
      return;
    }
    const { fragments: n, localId: r } = i;
    this._localId !== r && (this._meshes.clear(), this._localId = r, this._hoverTimeout = window.setTimeout(async () => {
      const a = await n.getItem(r).getGeometry();
      if (!a)
        return;
      const c = await a.get();
      for (const h of c) {
        const { positions: d, normals: u, indices: f, transform: g } = h;
        if (!(d && u && f && g))
          continue;
        const m = new BufferGeometry();
        m.setAttribute(
          "position",
          new Float32BufferAttribute(d, 3)
        ), m.setAttribute(
          "normal",
          new Float32BufferAttribute(u, 3)
        ), m.setIndex(new Uint16BufferAttribute(f, 1)), h.transform && m.applyMatrix4(h.transform), m.computeVertexNormals();
        const _ = new Mesh(m, this.material);
        this._meshes.add(_);
      }
      this._fadeAnimation = {
        startTime: Date.now(),
        duration: this.duration,
        // in milliseconds
        fadeIn: true
      }, this.animate();
    }, 100));
  }
  clear() {
    this._meshes.clear();
  }
  dispose() {
    this._enabled = false, this._meshes.clear(), this._fadeAnimation = null, this._hoverTimeout = null, this.onDisposed.trigger();
  }
};
A(rn, "uuid", "26fbd870-b1b2-4b71-b747-4063d484de1b");
var Ro = rn;
var ru = class {
  constructor(t) {
    A(this, "alignments", []);
    A(this, "enabled", true);
    A(this, "world", null);
    A(this, "_raycastable", []);
    A(this, "_components");
    this._components = t;
  }
  update() {
    this.dispose();
    for (const t of this.alignments)
      for (const e of t.children) {
        const s = e;
        s.updateWorldMatrix(true, true);
        for (const i of s.children) {
          const n = i;
          if (n.isLine2 && n.userData.points) {
            const r = new BufferGeometry(), o = new Line();
            o.geometry.setIndex(n.geometry.index);
            const a = new Float32Array(n.userData.points), c = new BufferAttribute(a, 3);
            r.setAttribute("position", c), o.geometry = r, o.userData.curve = n, o.applyMatrix4(n.matrixWorld), o.updateMatrixWorld(), this._raycastable.push(o);
          }
        }
      }
  }
  dispose() {
    for (const t of this._raycastable)
      t.geometry.dispose(), t.geometry = void 0;
    this._raycastable = [];
  }
  castRay() {
    if (!this.enabled || !this.world)
      return null;
    const s = this._components.get(me).get(this.world).castRayToObjects(this._raycastable);
    if (!s)
      return null;
    const i = s.object, n = i.geometry, r = s.index, o = n.attributes.position.array[r * 3], a = n.attributes.position.array[r * 3 + 1], c = n.attributes.position.array[r * 3 + 2], h = n.attributes.position.array[r * 3 + 3], d = n.attributes.position.array[r * 3 + 4], u = n.attributes.position.array[r * 3 + 5], f = new Vector3(h - o, d - a, u - c).normalize();
    return {
      point: s.point,
      normal: f,
      curve: i.userData.curve,
      alignment: i.userData.curve.parent
    };
  }
};
var Wn = class {
  static alignmentPercentageToPoint(t, e) {
    const s = new Vector3(), i = new Vector3(), n = this.alignmentLength(t), r = e * n;
    let o = 0;
    if (t.updateWorldMatrix(true, true), e === 1)
      for (let a = t.children.length - 1; a >= 0; a--) {
        const c = t.children[a], h = c.userData.points;
        if (!h)
          continue;
        const d = new Vector3(
          h[h.length - 3],
          h[h.length - 2],
          h[h.length - 1]
        );
        return d.applyMatrix4(c.matrixWorld), {
          normal: new Vector3(),
          point: d,
          curve: c,
          alignment: t
        };
      }
    for (const a of t.children) {
      const c = a.userData.points;
      if (c)
        for (let h = 0; h < c.length - 3; h += 3) {
          const d = s.set(c[h], c[h + 1], c[h + 2]), u = i.set(c[h + 3], c[h + 4], c[h + 5]), f = d.distanceTo(u);
          if (o + f >= r) {
            const g = r - o, m = u.clone().sub(d).normalize(), _ = m.clone().multiplyScalar(g);
            return d.add(_), d.applyMatrix4(a.matrixWorld), {
              normal: m,
              point: d,
              curve: a,
              alignment: t
            };
          }
          o += f;
        }
    }
    return null;
  }
  static curvePercentageToPoint(t, e, s) {
    const i = new Vector3(), n = new Vector3(), r = this.curveLength(e), o = s * r;
    let a = 0;
    const c = e.userData.points;
    if (!c)
      throw new Error("No points found in curve");
    for (let h = 0; h < c.length - 3; h += 3) {
      const d = i.set(c[h], c[h + 1], c[h + 2]), u = n.set(c[h + 3], c[h + 4], c[h + 5]), f = d.distanceTo(u);
      if (a + f >= o) {
        const g = o - a, m = u.clone().sub(d).normalize(), _ = m.clone().multiplyScalar(g);
        return d.add(_), {
          normal: m,
          point: d,
          curve: e,
          alignment: t
        };
      }
      a += f;
    }
    return null;
  }
  static alignmentLength(t) {
    let e = 0;
    if (t.userData.length !== void 0)
      return t.userData.length;
    for (const s of t.children)
      "isLine2" in s && (e += this.curveLength(s));
    return t.userData.length = e, e;
  }
  static curveLength(t) {
    let e = 0;
    if (t.userData.length !== void 0)
      return t.userData.length;
    const s = new Vector3(), i = new Vector3(), n = t.userData.points;
    if (!n)
      throw new Error("No points found in curve");
    for (let r = 0; r < n.length - 2 - 3; r += 3) {
      const o = s.set(n[r], n[r + 1], n[r + 2]), a = i.set(n[r + 3], n[r + 4], n[r + 5]);
      e += o.distanceTo(a);
    }
    return t.userData.length = e, e;
  }
  static curvePointToAlignmentPercentage(t, e, s) {
    const i = new Vector3(), n = new Vector3(), r = this.alignmentLength(t);
    let o = 0;
    t.updateWorldMatrix(true, true);
    for (const a of t.children) {
      const c = a.userData.points;
      if (c)
        for (let h = 0; h < c.length - 3; h += 3) {
          const d = i.set(c[h], c[h + 1], c[h + 2]), u = n.set(c[h + 3], c[h + 4], c[h + 5]);
          d.applyMatrix4(a.matrixWorld), u.applyMatrix4(a.matrixWorld);
          const f = d.distanceTo(u), g = d.distanceTo(e) < 1e-3, m = u.distanceTo(e) < 1e-3, _ = this.isPointbetweenTwoOthers(d, u, e);
          if (a === s && (g || m || _)) {
            const p = d.distanceTo(e);
            return (o + p) / r;
          }
          o += f;
        }
    }
    return null;
  }
  // Src: https://discourse.threejs.org/t/how-to-determine-wether-a-point-is-between-two-other-points/10047
  static isPointbetweenTwoOthers(t, e, s) {
    const i = new Vector3();
    i.subVectors(e, t).normalize();
    const n = new Vector3();
    n.subVectors(s, t).normalize();
    const r = new Vector3();
    r.subVectors(s, e).normalize();
    const a = 1 - 16e-4;
    return i.dot(n) > a && i.dot(r) < -a;
  }
};
var ou = class {
  constructor(t, e) {
    A(this, "onDisposed", new tt());
    A(this, "alignments", []);
    A(this, "components");
    A(this, "onMarkerChange", new tt());
    A(this, "enabled", true);
    A(this, "highlightMaterial");
    A(this, "increments", 20);
    A(this, "screenDistanceLimit", 0.1);
    A(this, "fadeInTime", 500);
    A(this, "_mouseMarkers");
    A(this, "_highlighted", /* @__PURE__ */ new Set());
    A(this, "_stationPoints", /* @__PURE__ */ new Map());
    A(this, "_originalHighlightMaterialId", "originalHighlightMaterial");
    A(this, "_world", null);
    A(this, "_raycaster");
    A(this, "_stationLabelColor", new Color(16777215));
    A(this, "_stationLabelBackgroundColor", new Color(8014801));
    A(this, "_stationPointerColor", new Color(16777215));
    A(this, "_stationPointerBackgroundColor", new Color(4803766));
    A(this, "_pointerDown", performance.now());
    A(this, "_pointerDownTime", 150);
    A(this, "onPointerDown", () => {
      this._pointerDown = performance.now();
    });
    A(this, "onPointerUp", () => {
      if (performance.now() - this._pointerDown > this._pointerDownTime)
        return;
      const t2 = this.setMarkerToMouse("select");
      t2 && this.onMarkerChange.trigger(t2);
    });
    A(this, "onMouseMove", () => {
      this.setMarkerToMouse("hover");
    });
    this.components = t, this.highlightMaterial = e, this._raycaster = new ru(t), this._raycaster.alignments = this.alignments;
  }
  /**
   * Getter for the world property.
   * Returns the current world instance.
   * @returns {OBC.World | null} The current world instance or null if not set.
   */
  get world() {
    return this._world;
  }
  /**
   * Setter for the world property.
   * Sets the world instance and initializes the component.
   * @param {OBC.World | null} world - The new world instance or null to clear the current world.
   */
  set world(t) {
    var i, n, r, o;
    if (t === this._world || (this._world && this.setupEvents(false), this._world = t, (i = this._mouseMarkers) == null || i.hover.removeFromParent(), (n = this._mouseMarkers) == null || n.select.removeFromParent(), (r = this._mouseMarkers) == null || r.hover.element.remove(), (o = this._mouseMarkers) == null || o.select.element.remove(), !t))
      return;
    this._raycaster.world = t;
    const e = this.newCivilLabel(0, "stationPointer");
    t.scene.three.add(e), e.visible = false, e.element.style.transition = "";
    const s = this.newCivilLabel(0, "stationPointer");
    s.element.style.transition = "", s.element.style.opacity = "0.5", t.scene.three.add(s), s.visible = false, this._mouseMarkers = {
      select: e,
      hover: s
    }, this.setupEvents(true);
  }
  get stationLabelColor() {
    return this._stationLabelColor;
  }
  set stationLabelColor(t) {
    this._stationLabelColor = t;
    const e = `#${t.getHexString()}`;
    for (const [, { labels: s }] of this._stationPoints) {
      const i = [...s.children];
      for (const n of i) {
        const r = this.getLabel(n);
        r.style.color = e;
        const o = this.getPoint(n);
        o.style.backgroundColor = e;
      }
    }
  }
  get stationLabelBackgroundColor() {
    return this._stationLabelBackgroundColor;
  }
  set stationLabelBackgroundColor(t) {
    this._stationLabelBackgroundColor = t;
    const e = `#${t.getHexString()}`;
    for (const [, { labels: s }] of this._stationPoints) {
      const i = [...s.children];
      for (const n of i) {
        const r = this.getLabel(n);
        r.style.backgroundColor = e;
        const o = this.getPoint(n);
        o.style.border = `2px solid ${e}`;
      }
    }
  }
  get stationPointerColor() {
    return this._stationPointerColor;
  }
  set stationPointerColor(t) {
    this._stationPointerColor = t;
    const e = `#${t.getHexString()}`;
    if (this._mouseMarkers) {
      const s = this._mouseMarkers.select, i = this.getLabel(s);
      i.style.color = e;
      const n = this.getPoint(s);
      n.style.backgroundColor = e;
    }
  }
  get stationPointerBackgroundColor() {
    return this._stationPointerBackgroundColor;
  }
  set stationPointerBackgroundColor(t) {
    this._stationPointerBackgroundColor = t;
    const e = `#${t.getHexString()}`;
    if (this._mouseMarkers) {
      const s = this._mouseMarkers.select, i = this.getLabel(s);
      i.style.backgroundColor = e;
      const n = this.getPoint(s);
      n.style.border = `2px solid ${e}`;
    }
  }
  dispose() {
    var t, e, s, i;
    this.clearHighlight(), this.clearStations(), this.alignments = [], (t = this._mouseMarkers) == null || t.hover.removeFromParent(), (e = this._mouseMarkers) == null || e.select.removeFromParent(), (s = this._mouseMarkers) == null || s.hover.element.remove(), (i = this._mouseMarkers) == null || i.select.element.remove(), this._raycaster.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  updateAlignments() {
    this._raycaster.update();
  }
  setMarkerAtPoint(t, e) {
    if (!this._mouseMarkers)
      throw new Error(
        "No mouse markers found! Initialize the world before using this."
      );
    this.updateMarkerValue(t, e), this._mouseMarkers[e].visible = true, this._mouseMarkers[e].position.copy(t.point);
  }
  highlight(t, e = true) {
    e && this.clearHighlight(this._highlighted);
    for (const s of t.children)
      "isLineSegments2" in s && "material" in s && (s.userData[this._originalHighlightMaterialId] = s.material, s.material = this.highlightMaterial);
    this._highlighted.add(t);
  }
  clearHighlight(t = this._highlighted) {
    for (const e of t)
      for (const s of e.children)
        "isLineSegments2" in s && "material" in s && (s.material = s.userData[this._originalHighlightMaterialId], delete s.userData[this._originalHighlightMaterialId]);
    this._highlighted.clear();
  }
  createStations(t) {
    if (!this.world || this._stationPoints.has(t.uuid))
      return;
    const e = new Group();
    this.world.scene.three.add(e), this._stationPoints.set(t.uuid, { alignment: t, labels: e });
  }
  clearStations(t = this._stationPoints.keys()) {
    for (const e of t) {
      const s = this._stationPoints.get(e);
      s && (this.clearLabels(s.labels), this._stationPoints.delete(e));
    }
  }
  updateStations() {
    if (!this.world)
      throw new Error("No world found!");
    if (!this.world.renderer)
      throw new Error("No renderer found!");
    const t = this.world.camera.three, e = this.world.renderer.three, s = new Frustum(), i = e.clippingPlanes, n = new Vector3(), r = new Vector3();
    let o = true;
    const a = new Vector3();
    for (const [, { alignment: c, labels: h }] of this._stationPoints) {
      this.clearLabels(h), c.updateWorldMatrix(true, true);
      const d = c.userData.initialStation;
      let u = d || 0;
      const f = u % this.increments;
      let g = d + this.increments - f;
      for (const m of c.children) {
        if (!("isLine2" in m))
          continue;
        const _ = m;
        if (_.geometry.boundingBox || _.geometry.computeBoundingBox(), s.setFromProjectionMatrix(
          new Matrix4().multiplyMatrices(
            t.projectionMatrix,
            t.matrixWorldInverse
          )
        ), !s.intersectsBox(_.geometry.boundingBox)) {
          const L = Wn.curveLength(m);
          u += L;
          const w = u % this.increments;
          g = u + this.increments - w;
          continue;
        }
        const p = m.userData.points, y = p[0], b = p[1], x = p[2];
        if (a.set(y, b, x), a.applyMatrix4(m.matrixWorld), !this.isLabelClipped(i, a)) {
          if (o) {
            o = false, n.set(a.x, a.y, a.z), n.project(t), n.z = 0;
            const L = this.newCivilLabel(
              u,
              "stationLabel"
            );
            L.position.set(a.x, a.y, a.z), h.children.push(L);
          } else if (r.set(a.x, a.y, a.z), r.project(t), r.z = 0, n.distanceTo(r) > this.screenDistanceLimit) {
            const w = this.newCivilLabel(
              u,
              "stationLabel"
            );
            w.position.set(a.x, a.y, a.z), h.children.push(w), n.copy(r);
          }
        }
        const C = new Vector3(), P = new Vector3();
        for (let L = 0; L < p.length - 3; L += 3) {
          C.set(p[L], p[L + 1], p[L + 2]), P.set(p[L + 3], p[L + 4], p[L + 5]);
          const w = C.distanceTo(P), N = u + w, K = P.clone().sub(C).normalize();
          for (; N > g; ) {
            const W = g - u, st = K.clone();
            st.multiplyScalar(W);
            const { x: j, y: it, z: U } = C.clone().add(st);
            if (a.set(j, it, U), a.applyMatrix4(m.matrixWorld), !this.isLabelClipped(i, a) && s.containsPoint(a) && (r.set(a.x, a.y, a.z), r.project(t), r.z = 0, n.distanceTo(r) > this.screenDistanceLimit)) {
              const Q = this.newCivilLabel(
                g,
                "stationLabel"
              );
              Q.position.set(a.x, a.y, a.z), h.children.push(Q), n.copy(r);
            }
            g += this.increments;
          }
          u += w;
        }
        const O = p[p.length - 3], z = p[p.length - 2], k = p[p.length - 1];
        if (a.set(O, z, k), a.applyMatrix4(m.matrixWorld), this.isLabelClipped(i, a) || !s.containsPoint(a))
          continue;
        if (r.set(a.x, a.y, a.z), r.project(t), r.z = 0, n.distanceTo(r) > this.screenDistanceLimit) {
          const L = this.newCivilLabel(
            u,
            "stationLabel"
          );
          L.position.set(a.x, a.y, a.z), h.children.push(L), n.copy(r);
        }
      }
    }
  }
  getCursorValue() {
    if (!this._mouseMarkers)
      throw new Error(
        "No mouse markers found! Initialize the world before using this."
      );
    return this._mouseMarkers.select.element.children[0].children[0].innerText;
  }
  setCursorValue(t, e) {
    if (!this._mouseMarkers)
      throw new Error(
        "No mouse markers found! Initialize the world before using this."
      );
    const i = this._mouseMarkers[e].element.children[0].children[0];
    i.innerText = t;
  }
  isLabelClipped(t, e) {
    for (const s of t)
      if (!(s.distanceToPoint(e) > 0))
        return true;
    return false;
  }
  clearLabels(t) {
    const e = [...t.children];
    for (const s of e)
      s.element.style.opacity = "0";
    setTimeout(() => {
      for (const s of e)
        s.removeFromParent(), s.element.remove(), s.visible = false;
    }, this.fadeInTime);
  }
  newCivilLabel(t, e) {
    const s = document.createElement("div"), i = e === "stationLabel" ? this.stationLabelColor : this.stationPointerColor, n = e === "stationLabel" ? this.stationLabelBackgroundColor : this.stationPointerBackgroundColor, r = document.createElement("div");
    r.style.width = "4px", r.style.height = "4px", r.style.borderRadius = "50%", r.style.backgroundColor = `#${i.getHexString()}`, r.style.border = `2px solid #${n.getHexString()}`, r.style.display = "flex", r.style.justifyContent = "center";
    const o = this.getFormattedStation(t), a = document.createElement("div");
    a.innerText = o, a.style.backgroundColor = `#${n.getHexString()}`, a.style.color = `#${i.getHexString()}`, a.style.padding = "0.3rem", a.style.position = "absolute", a.style.bottom = "1rem", a.style.borderRadius = "6px", a.style.boxShadow = "rgba(0, 0, 0, 0.6) 0px 4px 6px", r.appendChild(a);
    const c = new Ra(s);
    return s.appendChild(r), e === "stationLabel" && (s.style.transition = `opacity ${this.fadeInTime}ms ease-in-out`, s.style.opacity = "0", setTimeout(() => {
      s.style.opacity = "1";
    })), c;
  }
  setupEvents(t) {
    if (!this.world)
      throw new Error("No world found!");
    if (this.world.isDisposing || !this.world.renderer)
      return;
    const e = this.world.renderer.three.domElement, i = this.components.get(me).get(this.world);
    i.three.params.Line || (i.three.params.Line = {
      threshold: 10
    }), e.removeEventListener("pointerdown", this.onPointerDown), e.removeEventListener("pointerup", this.onPointerUp), e.removeEventListener("pointermove", this.onMouseMove), t && (e.addEventListener("pointerdown", this.onPointerDown), e.addEventListener("pointerup", this.onPointerUp), e.addEventListener("pointermove", this.onMouseMove));
  }
  setMarkerToMouse(t) {
    if (!this.enabled || !this._mouseMarkers)
      return null;
    if (!this.world)
      throw new Error("No world found!");
    const e = this._raycaster.castRay();
    if (!e)
      return this._mouseMarkers[t].visible = false, null;
    this._mouseMarkers[t].visible = true;
    const s = e.point;
    return this._mouseMarkers[t].position.copy(s), this.updateMarkerValue(e, t), e;
  }
  updateMarkerValue(t, e) {
    if (!this._mouseMarkers)
      return;
    const { alignment: s, curve: i, point: n } = t, r = Wn.curvePointToAlignmentPercentage(
      s,
      n,
      i
    );
    if (r === null)
      throw new Error("Point is not on the curve");
    const a = r * Wn.alignmentLength(s) + s.userData.initialStation, c = this.getFormattedStation(a);
    this.setCursorValue(c, e);
  }
  getFormattedStation(t) {
    const e = Math.floor(t / 1e3), s = Math.round(t - e * 1e3);
    return `${e}+${s}`;
  }
  getLabel(t) {
    return t.element.children[0].children[0];
  }
  getPoint(t) {
    return t.element.children[0];
  }
};
var on = class on2 extends St {
  constructor(e) {
    super(e);
    A(this, "onDisposed", new tt());
    A(this, "list", /* @__PURE__ */ new Map());
    A(this, "enabled", true);
    A(this, "highlightMaterial", new Cr({
      color: 8014801,
      linewidth: 5,
      depthTest: false
    }));
    A(this, "_increments", 20);
    A(this, "_screenDistanceLimit", 0.1);
    A(this, "_fadeInTime", 500);
    A(this, "_stationLabelColor", new Color(16777215));
    A(this, "_stationLabelBackgroundColor", new Color(8014801));
    A(this, "_stationPointerColor", new Color(16777215));
    A(this, "_stationPointerBackgroundColor", new Color(4803766));
    this.components.add(on2.uuid, this);
  }
  get increments() {
    return this._increments;
  }
  set increments(e) {
    this._increments = e;
    for (const [, s] of this.list)
      s.increments = e;
  }
  get screenDistanceLimit() {
    return this._screenDistanceLimit;
  }
  set screenDistanceLimit(e) {
    this._screenDistanceLimit = e;
    for (const [, s] of this.list)
      s.screenDistanceLimit = e;
  }
  get fadeInTime() {
    return this._fadeInTime;
  }
  set fadeInTime(e) {
    this._fadeInTime = e;
    for (const [, s] of this.list)
      s.fadeInTime = e;
  }
  get stationLabelColor() {
    return this._stationLabelColor;
  }
  set stationLabelColor(e) {
    this._stationLabelColor = e;
    for (const [, s] of this.list)
      s.stationLabelColor = e;
  }
  get stationLabelBackgroundColor() {
    return this._stationLabelBackgroundColor;
  }
  set stationLabelBackgroundColor(e) {
    this._stationLabelBackgroundColor = e;
    for (const [, s] of this.list)
      s.stationLabelBackgroundColor = e;
  }
  get stationPointerColor() {
    return this._stationPointerColor;
  }
  set stationPointerColor(e) {
    this._stationPointerColor = e;
    for (const [, s] of this.list)
      s.stationPointerColor = e;
  }
  get stationPointerBackgroundColor() {
    return this._stationPointerBackgroundColor;
  }
  set stationPointerBackgroundColor(e) {
    this._stationPointerBackgroundColor = e;
    for (const [, s] of this.list)
      s.stationPointerBackgroundColor = e;
  }
  create(e) {
    const s = new ou(
      this.components,
      this.highlightMaterial
    );
    return this.list.set(e, s), s;
  }
  delete(e) {
    const s = this.list.get(e);
    s && (s.dispose(), this.list.delete(e));
  }
  dispose() {
    for (const [, e] of this.list)
      e.dispose();
    this.onDisposed.trigger(), this.onDisposed.reset();
  }
  updateAlignments() {
    for (const [, e] of this.list)
      e.updateAlignments();
  }
};
A(on, "uuid", "0a59c09e-2b49-474a-9320-99f51f40f182");
var Uo = on;
var au = ((l) => (l.SELECT = "select", l.HOVER = "hover", l))(au || {});
var an = class an2 extends St {
  constructor(e) {
    super(e);
    A(this, "enabled", true);
    A(this, "onDisposed", new tt());
    A(this, "_world", null);
    A(this, "_flip", false);
    A(this, "_plane");
    A(this, "_point", new Vector3());
    A(this, "_edgeMeshes", []);
    A(this, "_sectionVisible", false);
    A(this, "_sectionOffset", 0.1);
    A(this, "edgeMaterial", new Cr({
      color: 0,
      linewidth: 5,
      depthTest: false
    }));
    this.components.add(an2.uuid, this);
  }
  /**
   * A property representing the plane used for cross section visualization.
   */
  get plane() {
    if (!this._plane)
      throw new Error("Plane is not set. You must give a world.");
    return this._plane;
  }
  /**
   * A property representing the plane used for cross section visualization.
   */
  set plane(e) {
    this._plane = e;
  }
  get sectionVisible() {
    return this._sectionVisible;
  }
  set sectionVisible(e) {
    this._sectionVisible = e;
    for (const s of this._edgeMeshes)
      s.visible = e;
  }
  /**
   * A getter for the 3D world.
   * @returns The 3D world.
   */
  get world() {
    return this._world;
  }
  /**
   * A setter for the 3D world.
   * @param world - The new 3D world.
   */
  set world(e) {
    var n;
    if (this._world = e, (n = this._plane) == null || n.dispose(), !e)
      return;
    const s = this.components.get(Ve), i = s.createFromNormalAndCoplanarPoint(
      e,
      new Vector3(1, 0, 0),
      new Vector3()
    );
    this.plane = s.list.get(i), this.plane.visible = false, this.plane.enabled = false;
  }
  get flip() {
    return this._flip;
  }
  set flip(e) {
    var i;
    if (e === this._flip)
      return;
    this._flip = e;
    const s = (i = this.plane) == null ? void 0 : i.normal.clone().multiplyScalar(-1);
    for (const n of this._edgeMeshes)
      n.position.add(s.clone().multiplyScalar(this._sectionOffset));
    this.plane.setFromNormalAndCoplanarPoint(s, this._point), this.plane.update();
  }
  dispose() {
    var e;
    this.clearMeshes(), (e = this.plane) == null || e.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Sets the cross section plane based on the given curve mesh and point.
   *
   * @param point - The point on the curve mesh where the cross section should be created.
   * @param normal - The normal of the plane.
   *
   * @throws Will throw an error if the world or plane is not set before calling this method.
   * @throws Will throw an error if the geometry is not indexed.
   *
   * @returns {Promise<void>}
   */
  async set(e, s) {
    this.flip && s.multiplyScalar(-1), this.plane.setFromNormalAndCoplanarPoint(s, e), this._point.copy(e);
  }
  async update() {
    this.clearMeshes();
    const e = this.components.get(ct);
    this.plane.update();
    const s = [];
    for (const [, i] of e.list)
      s.push(this.generateModelSection(i));
    await Promise.all(s);
  }
  async generateModelSection(e) {
    if (!this.world)
      return;
    const s = this.plane.three.clone();
    s.constant -= 0.01;
    const { buffer: i } = await e.getSection(s), n = new BufferGeometry(), r = new BufferAttribute(i, 3, false);
    n.setAttribute("position", r);
    const o = new LineSegments(n), a = new Tr();
    a.fromLineSegments(o);
    const c = new Fa(a, this.edgeMaterial);
    c.frustumCulled = false, this.world.scene.three.add(c), this._edgeMeshes.push(c), c.renderOrder = 3, o.geometry.dispose();
  }
  clearMeshes() {
    for (const e of this._edgeMeshes)
      e.removeFromParent(), e.geometry.dispose(), e.material = void 0;
    this._edgeMeshes = [];
  }
};
A(an, "uuid", "96b2c87e-d90b-4639-8257-8f01136fe324");
var Fo = an;
var xe = class xe2 {
  constructor(t) {
    A(this, "onDisposed", new tt());
    A(this, "marker", null);
    A(this, "world", null);
    A(this, "_enabled", false);
    A(this, "_components");
    this._components = t;
  }
  set enabled(t) {
    this._enabled = t, this.marker && (this.marker.visible = t), t && this.get();
  }
  get enabled() {
    return this._enabled;
  }
  /** {@link OBC.Disposable.onDisposed} */
  dispose() {
    this.marker && this.marker.dispose();
  }
  /**
   * Retrieves the picked vertex from the world and updates the marker's position.
   * If no vertex is picked, the marker is hidden.
   *
   * @param world - The world in which to pick the vertex.
   * @returns The picked vertex, or null if no vertex was picked.
   */
  async get(t) {
    const e = (t == null ? void 0 : t.world) ?? this.world;
    if (!e)
      throw new Error(
        "GraphicVertexPicker: a world is need to get a casting result."
      );
    const n = await this._components.get(me).get(e).castRay({
      snappingClasses: t == null ? void 0 : t.snappingClasses
    });
    if (n) {
      const { point: r } = n;
      if (!this.marker) {
        const o = document.createElement("div");
        this.marker = new is(e, o);
      }
      if (this.marker.world !== e && (this.marker.world = e, this.marker.three.removeFromParent(), e.scene.three.add(this.marker.three)), this.marker.visible = true, this.marker.three.position.copy(r), "snappingClass" in n && typeof n.snappingClass == "number" && (n.snappingClass === 0 || n.snappingClass === 1 || n.snappingClass === 2)) {
        const o = xe2.snappingStyles[n.snappingClass] ?? xe2.baseSnappingStyle;
        Object.assign(this.marker.three.element.style, o);
      } else
        Object.assign(
          this.marker.three.element.style,
          xe2.baseSnappingStyle
        );
    } else
      this.marker && (this.marker.visible = false);
    return n;
  }
};
A(xe, "baseSnappingStyle", {
  height: "6px",
  width: "6px",
  borderRadius: "100%",
  borderWidth: "2px",
  borderColor: "rgb(122, 75, 209)",
  borderStyle: "solid",
  zIndex: "-20"
}), A(xe, "snappingStyles", {
  [ze.FACE]: { ...xe.baseSnappingStyle },
  [ze.POINT]: {
    ...xe.baseSnappingStyle,
    borderColor: "#e25959",
    borderRadius: "0"
  },
  [ze.LINE]: {
    ...xe.baseSnappingStyle,
    borderColor: "#2d2d2d",
    borderRadius: "0"
  }
});
var dr = xe;
function Va() {
  const l = document.createElement("div");
  return l.style.backgroundColor = "blue", l.style.color = "white", l.style.padding = "6px", l.style.borderRadius = "6px", l.style.boxShadow = "0px 4px 6px rgba(0, 0, 0, 0.6)", l.style.zIndex = "-10", l;
}
function lu(l = {}) {
  const {
    color: t = "white",
    size: e = "4px",
    border: s = "2px solid blue",
    background: i = "white"
  } = l, n = document.createElement("div");
  return n.style.backgroundColor = i, n.style.color = t, n.style.height = e, n.style.width = e, n.style.borderRadius = "50%", n.style.border = s, n.style.zIndex = "-20", n;
}
var We = class extends Line3 {
  constructor() {
    super(...arguments);
    A(this, "id", Xt.create());
    A(this, "_units", "m");
    A(this, "_rounding", 2);
  }
  set units(e) {
    this._units = e;
  }
  get units() {
    return this._units;
  }
  set rounding(e) {
    this._rounding = e;
  }
  get rounding() {
    return this._rounding;
  }
  get value() {
    const e = this.distance();
    return gn.convertUnits(
      e,
      "m",
      this.units,
      this.rounding
    );
  }
};
var tn = class _tn {
  constructor(t, e, s, i = 2, n = "m") {
    A(this, "label");
    A(this, "boundingBox", new Mesh());
    A(this, "world");
    A(this, "_components");
    A(this, "_units", "m");
    A(this, "_rounding", 2);
    A(this, "startNormal", null);
    A(this, "line");
    A(this, "rectangleComponentLines", []);
    A(this, "projectionComponentLines", []);
    A(this, "_visible", true);
    A(this, "_root", new Group());
    A(this, "_endpoints", new Wt());
    A(this, "lineElement");
    A(this, "rectangleDimensions", new Wt());
    A(this, "projectionDimensions", new Wt());
    A(this, "isSelected", false);
    A(this, "_latestRectangularInversion", false);
    A(this, "_endpointElement", lu());
    A(this, "_material");
    A(this, "_componentsMaterial", new LineDashedMaterial({
      depthTest: false,
      gapSize: 0.2,
      dashSize: 0.2,
      transparent: true,
      opacity: 0.5,
      color: 3026478
    }));
    this._components = t, this.world = e, this._material = s.lineMaterial, this._rounding = i, this._units = n, this.line = s.line, this.startNormal = s.startNormal ?? null, this.rectangleComponentLines = [new We(), new We()], this.updateRectangleComponents(), this.updateProjectionComponents(), this.lineElement = this.createLine(s), this._endpoints.onItemAdded.add((r) => {
      this._root.add(r.three);
      const o = this._endpoints.size === 1 ? this.line.start : this.line.end;
      r.three.position.copy(o);
    }), this._endpoints.onBeforeDelete.add((r) => r.dispose()), this.createEndpoints();
    for (const r of this._endpoints)
      r.three.element.style.borderColor = `#${s.lineMaterial.color.getHexString()}`;
    this.label = this.newText(), this.label.three.element.style.backgroundColor = `#${s.lineMaterial.color.getHexString()}`, this.label.three.renderOrder = 1, this._root.renderOrder = 2, this.world.scene.three.add(this._root), this.setupEvents();
  }
  /**
   * The units used for the dimension line.
   */
  set units(t) {
    for (const e of this.rectangleDimensions)
      e.units = t;
    for (const e of this.projectionDimensions)
      e.units = t;
    this._units = t, this.updateLabel();
  }
  get units() {
    return this._units;
  }
  set rounding(t) {
    for (const e of this.rectangleDimensions)
      e.rounding = t;
    for (const e of this.projectionDimensions)
      e.rounding = t;
    this._rounding = t, this.updateLabel();
  }
  get rounding() {
    return this._rounding;
  }
  /**
   * Getter for the visibility of the dimension line.
   */
  get visible() {
    return this._visible;
  }
  /**
   * Setter for the visibility of the dimension line.
   * @param {boolean} value - The new visibility state.
   */
  set visible(t) {
    for (const o of this.rectangleDimensions)
      o.visible = t;
    for (const o of this.projectionDimensions)
      o.visible = t;
    this._visible = t, this.label.visible = t;
    for (const o of this._endpoints)
      o.visible = t;
    const [e, s] = this._endpoints, i = e.three, n = s.three, r = this.label.three;
    t ? (this.world.scene.three.add(this._root), this._root.add(r, i, n)) : (r.removeFromParent(), i.removeFromParent(), n.removeFromParent(), this._root.removeFromParent());
  }
  /**
   * Setter for the end point of the dimension line.
   * Updates the line geometry and position of the end point marker.
   * @param {THREE.Vector3} point - The new end point.
   */
  set end(t) {
    this.line.end = t;
    const e = this.lineElement.geometry.attributes.position;
    e.setXYZ(1, t.x, t.y, t.z), e.needsUpdate = true, this.update();
  }
  /**
   * Setter for the start point of the dimension line.
   * Updates the line geometry and position of the start point marker.
   * @param {THREE.Vector3} point - The new start point.
   */
  set start(t) {
    this.line.start = t;
    const e = this.lineElement.geometry.attributes.position;
    e.setXYZ(0, t.x, t.y, t.z), e.needsUpdate = true, this.update();
  }
  setupEvents() {
    this.rectangleDimensions.onBeforeDelete.add(
      (t) => t.dispose()
    ), this.projectionDimensions.onBeforeDelete.add(
      (t) => t.dispose()
    );
  }
  /**
   * Disposes of the dimension line and its associated resources.
   * This method should be called when the dimension line is no longer needed.
   * It removes the dimension line from the world, destroys its components, and frees up memory.
   */
  dispose() {
    this.visible = false;
    const t = this._components.get(De);
    t.destroy(this._root), t.destroy(this.lineElement), this._endpoints.clear(), this.label.dispose(), this.boundingBox && t.destroy(this.boundingBox), this.rectangleDimensions.clear(), this.projectionDimensions.clear(), this._components = null;
  }
  /**
   * Creates a bounding box for the dimension line.
   * The bounding box is a 3D box that encloses the dimension line.
   * It is used for collision detection and visibility culling.
   * The bounding box is initially invisible and can be toggled using the `toggleBoundingBox` method.
   */
  createBoundingBox() {
    const t = new Vector3();
    this.line.getCenter(t);
    const e = this.line.distance();
    this.boundingBox.geometry = new BoxGeometry(1, 1, e), this.boundingBox.position.copy(t), this.boundingBox.lookAt(this.line.end), this.boundingBox.visible = false, this._root.add(this.boundingBox);
  }
  invertRectangularDimensions() {
    this.rectangleDimensions.size !== 0 && (this.rectangleDimensions.clear(), this._latestRectangularInversion = !this._latestRectangularInversion, this.updateRectangleComponents(this._latestRectangularInversion), this.displayRectangularDimensions());
  }
  displayRectangularDimensions() {
    this.rectangleDimensions.clear();
    for (const t of this.rectangleComponentLines) {
      const e = new _tn(this._components, this.world, {
        line: t,
        lineMaterial: this._componentsMaterial,
        endpointElement: this.endpointElement
      });
      e.lineElement.computeLineDistances(), this.rectangleDimensions.add(e);
    }
  }
  displayProjectionDimensions() {
    this.projectionDimensions.clear();
    for (const t of this.projectionComponentLines) {
      const e = new _tn(this._components, this.world, {
        line: t,
        lineMaterial: this._componentsMaterial,
        endpointElement: this.endpointElement
      });
      e.lineElement.computeLineDistances(), this.projectionDimensions.add(e);
    }
  }
  set endpointElement(t) {
    for (const e of this.rectangleDimensions)
      e.endpointElement = t;
    for (const e of this.projectionDimensions)
      e.endpointElement = t;
    this._endpointElement = t, this.createEndpoints();
  }
  get endpointElement() {
    return this._endpointElement;
  }
  createEndpoints() {
    this._endpoints.clear();
    const t = new is(this.world, this._endpointElement), e = new is(
      this.world,
      this._endpointElement.cloneNode(true)
    );
    this._endpoints.add(t, e);
  }
  updateProjectionComponents() {
    if (!this.startNormal)
      return;
    const t = new Plane().setFromNormalAndCoplanarPoint(
      this.startNormal,
      this.line.start
    ), e = new Vector3();
    t.projectPoint(this.line.end, e);
    let [s] = this.projectionComponentLines;
    s || (s = new We(), this.projectionComponentLines.push(s)), s.set(this.line.end, e), s.distance() < 0.01 && this.projectionComponentLines.shift();
    for (const i of this.projectionDimensions)
      i && i.update();
  }
  updateRectangleComponents(t = false) {
    const e = t ? this.line.end : this.line.start, s = t ? this.line.start : this.line.end, i = new Vector3();
    i.subVectors(s, e), Math.abs(s.y - e.y) >= 0.1 ? i.y = 0 : i.x = 0;
    const r = e.clone().add(i), [o, a] = this.rectangleComponentLines;
    o.set(r, e), a.set(r, s);
    for (const c of this.rectangleDimensions)
      c.update();
  }
  updateLabel() {
    this.label.three.element.textContent = this.getTextContent();
    const t = new Vector3();
    this.line.getCenter(t), this.label.three.position.copy(t);
  }
  updateGeometry() {
    this.updateRectangleComponents(), this.updateProjectionComponents(), [...this._endpoints][0].three.position.copy(this.line.start), [...this._endpoints][1].three.position.copy(this.line.end), this.lineElement.geometry.computeBoundingSphere();
  }
  update() {
    this.updateGeometry(), this.updateLabel();
  }
  set material(t) {
    this._material.dispose(), this._material = t, this.lineElement.material = t;
  }
  get material() {
    return this._material;
  }
  createLine(t) {
    const e = new BufferGeometry();
    e.setFromPoints([t.line.start, t.line.end]);
    const s = new Line(e, t.lineMaterial);
    return this._root.add(s), s;
  }
  newText() {
    const t = Va();
    t.textContent = this.getTextContent();
    const e = new is(this.world, t), s = new Vector3();
    return this.line.getCenter(s), e.three.position.copy(s), this._root.add(e.three), e;
  }
  getTextContent(t = this.line.distance()) {
    return `${gn.convertUnits(
      t,
      "m",
      this._units,
      this.rounding
    )} ${this._units}`;
  }
  set color(t) {
    const e = `#${t.getHexString()}`;
    this.label.three.element.style.backgroundColor = e;
    for (const s of this._endpoints)
      s.three.element.style.borderColor = e;
    this._material.color.set(t);
  }
};
var Ts = class _Ts {
  constructor(t) {
    A(this, "id", Xt.create());
    A(this, "points", new Wt());
    A(this, "tolerance", 5e-3);
    A(this, "_plane", null);
    A(this, "_rounding", 2);
    A(this, "_units", "m2");
    this.points.guard = (e) => {
      const s = [...this.points].some((n) => n.equals(e)), i = this.isPointInPlane(e);
      return !s && i;
    }, this.points.onItemAdded.add((e) => {
      if (this.plane) {
        const s = new Vector3();
        this.plane.projectPoint(e, s), e.copy(s);
      }
      this.points.size < 3 || this.points.size === 3 && this.computePlane();
    }), this.points.onItemDeleted.add(() => {
      this.points.size >= 3 || (this._plane = null);
    }), this.points.onCleared.add(() => {
      this._plane = null;
    }), t && this.points.add(...t);
  }
  // set plane(value: THREE.Plane) {
  //   const points = this._2dPoints;
  //   if (!points) return;
  //   this._plane = value;
  //   this.points.eventsEnabled = false;
  //   this.points.clear();
  //   const newPoints = points.map((point) => this.convertPointTo3D(point)!);
  //   this.points.add(...newPoints);
  //   this.points.eventsEnabled = true;
  // }
  get plane() {
    return this._plane;
  }
  get _coordinateSystem() {
    if (!this.plane)
      return null;
    const t = this.plane.normal, e = new Vector3(), s = new Vector3();
    return Math.abs(t.x) > Math.abs(t.z) ? e.set(-t.y, t.x, 0).normalize() : e.set(0, -t.z, t.y).normalize(), s.crossVectors(t, e).normalize(), {
      normal: t.clone(),
      x: e.clone(),
      y: s.clone()
    };
  }
  // The list of points projected into the plane's coordinate system
  get points2D() {
    if (!this.plane)
      if (this.points.size >= 3)
        this.computePlane();
      else
        return null;
    return [...this.points].map((e) => this.convertPointTo2D(e)).filter((e) => e !== null);
  }
  get center() {
    if (!this.plane || this.points.size < 3)
      return null;
    const t = this.points2D;
    if (!t || t.length === 0)
      return null;
    const e = t.reduce((s, i) => s.add(i), new Vector2()).divideScalar(t.length);
    return this.convertPointTo3D(e);
  }
  get value() {
    const t = this.points2D;
    if (!t)
      return 0;
    const e = Math.abs(ShapeUtils.area(t));
    return gn.convertUnits(
      e,
      "m2",
      this.units,
      this.rounding
    );
  }
  get boundingBox() {
    if (this.points.size === 0)
      return null;
    const t = new Box3();
    for (const e of this.points)
      t.expandByPoint(e);
    return t;
  }
  get perimeter() {
    const t = this.points2D;
    if (!t || t.length < 2)
      return 0;
    let e = 0;
    for (let s = 0; s < t.length; s++) {
      const i = t[s], n = t[(s + 1) % t.length];
      e += i.distanceTo(n);
    }
    return e;
  }
  set rounding(t) {
    this._rounding = t;
  }
  get rounding() {
    return this._rounding;
  }
  set units(t) {
    this._units = t;
  }
  get units() {
    return this._units;
  }
  // Returns if the given point falls in the plane of this area, based on the tolerance
  isPointInPlane(t) {
    if (!this.plane)
      return true;
    const e = this.plane.distanceToPoint(t);
    return Math.abs(e) < this.tolerance;
  }
  // Create an exact copy of this area
  clone() {
    return new _Ts([...this.points]);
  }
  // Computes the plane that defines this area based on the first three points
  computePlane() {
    const [t, e, s] = this.points;
    if (!(t && e && s))
      return null;
    const i = new Vector3().subVectors(e, t), n = new Vector3().subVectors(s, t), r = new Vector3().crossVectors(i, n).normalize();
    return this._plane = new Plane().setFromNormalAndCoplanarPoint(r, t), this.plane;
  }
  // Converts a point to the 2D space of this area
  convertPointTo2D(t) {
    if (!this.isPointInPlane(t) || !this.plane)
      return null;
    const e = this._coordinateSystem;
    if (!e)
      return null;
    const s = new Vector3();
    this.plane.projectPoint(t, s);
    const i = s.dot(e.x), n = s.dot(e.y);
    return new Vector2(i, n);
  }
  // Converts a point in the 2D space of this area to 3D
  convertPointTo3D(t) {
    if (!this.plane)
      return null;
    const e = this._coordinateSystem;
    if (!e)
      return null;
    const {
      x: s,
      y: i,
      normal: n
    } = e;
    return new Vector3().addScaledVector(s, t.x).addScaledVector(i, t.y).addScaledVector(n, -this.plane.constant);
  }
};
var cu = class extends is {
  constructor(e) {
    const s = document.createElement("div");
    s.style.backgroundColor = "blue", s.style.color = "white", s.style.padding = "6px", s.style.borderRadius = "6px", s.style.boxShadow = "0px 4px 6px rgba(0, 0, 0, 0.6)", s.style.zIndex = "-10";
    super(e, s);
    A(this, "_value", 0);
    A(this, "_units", "m2");
    A(this, "_worldUnits", "m2");
    A(this, "_color", new Color());
    A(this, "_textColor", new Color());
    A(this, "_rounding", 2);
    this.three.renderOrder = 1, s.textContent = this.formattedValue;
  }
  set value(e) {
    this._value = e;
  }
  get value() {
    return this._value;
  }
  set units(e) {
    this._units = e, this.three.element.textContent = this.formattedValue;
  }
  get units() {
    return this._units;
  }
  set worldUnits(e) {
    this._worldUnits = e, this.three.element.textContent = this.formattedValue;
  }
  get worldUnits() {
    return this._worldUnits;
  }
  set color(e) {
    this._color = e;
    const s = `#${e.getHexString()}`;
    this.three.element.style.backgroundColor = s;
  }
  get color() {
    return this._color;
  }
  set textColor(e) {
    this._textColor = e;
    const s = `#${e.getHexString()}`;
    this.three.element.style.color = s;
  }
  get textColor() {
    return this._textColor;
  }
  set rounding(e) {
    this._rounding = e, this.three.element.textContent = this.formattedValue;
  }
  get rounding() {
    return this._rounding;
  }
  get formattedValue() {
    return `${gn.convertUnits(
      this.value,
      this.worldUnits,
      // Input unit
      this.units,
      // Output unit
      this.rounding
    )} ${this.units}`;
  }
};
var hu = class {
  constructor(t, e, s = new Ts()) {
    A(this, "_root", new Group());
    A(this, "_components");
    A(this, "_material", new MeshLambertMaterial({
      color: "red",
      transparent: true,
      opacity: 0.5,
      side: DoubleSide,
      depthTest: false
    }));
    A(this, "_visible", true);
    A(this, "_color", new Color());
    A(this, "label");
    A(this, "three", new Mesh());
    A(this, "world");
    A(this, "area");
    A(this, "_triggerUpdate", () => this.update());
    this._components = t, this.world = e, this.area = s, this.world.scene.three.add(this.three), this.label = new cu(e), this._root.renderOrder = 2, this.visible = true, this.update(), s.points.onItemAdded.add(this._triggerUpdate), s.points.onItemDeleted.add(this._triggerUpdate), s.points.onCleared.add(this._triggerUpdate);
  }
  set material(t) {
    this._material.dispose(), this._material = t, this.three.material = t;
  }
  get material() {
    return this._material;
  }
  set visible(t) {
    this._visible = t, this.label.visible = t;
    const e = this.label.three;
    t ? (this._root.add(e, this.three), this.world.scene.three.add(this._root)) : (e.removeFromParent(), this._root.removeFromParent());
  }
  get visible() {
    return this._visible;
  }
  set rounding(t) {
    this.label.rounding = t;
  }
  get rounding() {
    return this.label.rounding;
  }
  set units(t) {
    this.label.units = t;
  }
  get units() {
    return this.label.units;
  }
  set color(t) {
    this._color = t, this.label.color = t, this._material.color.set(t);
  }
  get color() {
    return this._color;
  }
  updateMesh() {
    if (this.area.points.size < 3)
      return;
    const t = [...this.area.points], e = t.flatMap((n) => [n.x, n.y, n.z]), s = [];
    for (let n = 1; n < t.length - 1; n++)
      s.push(0, n, n + 1);
    this.three.geometry.dispose();
    const i = new BufferGeometry();
    i.setAttribute("position", new Float32BufferAttribute(e, 3)), i.setIndex(s), this.three.geometry = i, this.three.material = this.material;
  }
  update() {
    if (this.updateMesh(), this.area.value === 0)
      this.label.visible = false;
    else {
      this.label.value = this.area.value, this.label.visible = true;
      const t = this.area.center;
      t && this.label.three.position.copy(t);
    }
  }
  dispose() {
    this.label.dispose(), this._components.get(De).destroy(this._root, true, true), this.area.points.clear();
  }
};
var du = {
  length: "m",
  area: "m2",
  volume: "m3"
};
var Ha = class extends St {
  constructor(e, s) {
    super(e);
    A(this, "list", new Wt());
    A(this, "onDisposed", new tt());
    A(this, "snappings", [
      ze.LINE,
      ze.POINT,
      ze.FACE
    ]);
    A(this, "lines", new Wt());
    A(this, "fills", new Wt());
    A(this, "labels", new Wt());
    A(this, "_world", null);
    A(this, "measureType");
    A(this, "onPointerStop", new tt());
    A(this, "onPointerMove", new tt());
    A(this, "onStateChanged", new tt());
    A(this, "pointerStopTimeout", null);
    A(this, "onMove", () => {
      this.enabled && (this.pointerStopTimeout !== null && clearTimeout(this.pointerStopTimeout), this.pointerStopTimeout = window.setTimeout(() => {
        this.onPointerStop.trigger();
      }, 50), this.onPointerMove.trigger());
    });
    A(this, "onKeydown", (e2) => {
      this.enabled && e2.key === "Escape" && this.cancelCreation();
    });
    A(this, "onEnabledChange", new tt());
    A(this, "_enabled", false);
    A(this, "onVisibilityChange", new tt());
    A(this, "_visible", true);
    A(this, "_units");
    A(this, "_rounding", 2);
    A(this, "_linesEndpointElement", Va());
    A(this, "_linesMaterial", new LineBasicMaterial({
      color: "#0000FF",
      depthTest: false
    }));
    A(this, "_fillsMaterial", new MeshLambertMaterial({
      color: 2392594,
      side: DoubleSide,
      transparent: true,
      opacity: 0.3,
      depthTest: false
    }));
    A(this, "_color", new Color());
    A(this, "_vertexPicker", new dr(this.components));
    A(this, "create", (e2) => {
    });
    A(this, "endCreation", (e2) => {
    });
    A(this, "cancelCreation", () => {
    });
    A(this, "delete", (e2) => {
    });
    this.measureType = s, this._units = du[this.measureType], this.lines.onBeforeDelete.add((i) => i.dispose()), this.fills.onBeforeDelete.add((i) => i.dispose()), this.labels.onBeforeDelete.add((i) => i.dispose()), this.list.onCleared.add(() => {
      this.lines.clear(), this.fills.clear(), this.labels.clear();
    });
  }
  set world(e) {
    this._world = e, this._vertexPicker.world = e;
  }
  get world() {
    return this._world;
  }
  get unitsList() {
    let e = [];
    return this.measureType === "length" ? e = ["mm", "cm", "m", "km"] : this.measureType === "area" ? e = ["mm2", "cm2", "m2", "km2"] : e = ["mm3", "cm3", "m3", "km3"], e;
  }
  setEvents(e) {
    if (!this.world)
      throw new Error("Measurement: you must specify a world first!");
    if (this.world.isDisposing)
      return;
    if (!this.world.renderer)
      throw new Error("Measurement: the world needs a renderer!");
    const i = this.world.renderer.three.domElement.parentElement;
    i && (i.removeEventListener("pointermove", this.onMove), window.removeEventListener("keydown", this.onKeydown), e && (i.addEventListener("pointermove", this.onMove), window.addEventListener("keydown", this.onKeydown)));
  }
  set enabled(e) {
    this._enabled = e, this._vertexPicker.enabled = e, this.setEvents(e), this.cancelCreation(), this.onEnabledChange.trigger(e), this.onStateChanged.trigger(["enabled"]);
  }
  get enabled() {
    return this._enabled;
  }
  set visible(e) {
    this._visible = e;
    for (const s of this.lines)
      s.visible = e;
    for (const s of this.fills)
      s.visible = e;
    this.onVisibilityChange.trigger(e), this.onStateChanged.trigger(["visibility"]);
  }
  get visible() {
    return this._visible;
  }
  set units(e) {
    this._units = e;
    let s;
    if (e.endsWith("2") ? s = "area" : e.endsWith("3") ? s = "volume" : s = "length", s === "length") {
      for (const i of this.lines)
        i.units = e;
      for (const i of this.list)
        (i instanceof We || i instanceof Ts) && (i.units = e);
    } else if (s === "area")
      for (const i of this.fills)
        i.units = e;
    this.onStateChanged.trigger(["units"]);
  }
  get units() {
    return this._units;
  }
  set rounding(e) {
    this._rounding = e;
    for (const s of this.list)
      (s instanceof We || s instanceof Ts) && (s.rounding = e);
    for (const s of this.lines)
      s.rounding = e;
    for (const s of this.fills)
      s.rounding = e;
    this.onStateChanged.trigger(["rounding"]);
  }
  get rounding() {
    return this._rounding;
  }
  set linesEndpointElement(e) {
    this._linesEndpointElement = e;
    for (const s of this.lines)
      s.endpointElement = e;
  }
  get linesEndpointElement() {
    return this._linesEndpointElement;
  }
  set linesMaterial(e) {
    this._linesMaterial.dispose(), this._linesMaterial = e;
    for (const s of this.lines)
      s.material = e;
  }
  get linesMaterial() {
    return this._linesMaterial;
  }
  set fillsMaterial(e) {
    this._fillsMaterial.dispose(), this._fillsMaterial = e;
    for (const s of this.fills)
      s.material = e;
  }
  get fillsMaterial() {
    return this._fillsMaterial;
  }
  set color(e) {
    this._color = e, this._linesMaterial.color.set(e), this._fillsMaterial.color.set(e);
    for (const s of this.lines)
      s.color = e;
    for (const s of this.fills)
      s.color = e;
    this.onStateChanged.trigger(["color"]);
  }
  get color() {
    return this._color;
  }
  dispose() {
    this._vertexPicker.dispose(), this.list.clear(), this.linesMaterial.dispose(), this.fillsMaterial.dispose(), this.onDisposed.trigger();
  }
  createLineElement(e, s = null) {
    if (!this.world)
      throw new Error("Measurement: world is need!");
    return new tn(
      this.components,
      this.world,
      {
        line: e,
        startNormal: s ?? void 0,
        lineMaterial: this.linesMaterial,
        endpointElement: this.linesEndpointElement
      },
      this.rounding,
      this.units
    );
  }
  createFillElement(e) {
    if (!this.world)
      throw new Error("Measurement: world is need!");
    const s = new hu(this.components, this.world, e);
    return s.rounding = this.rounding, (this.units.endsWith("2") ? "area" : void 0) === "area" && (s.units = this.units), s;
  }
  addLineElementsFromPoints(e) {
    for (let s = 0; s < e.length; s++) {
      const i = e[s], n = e[(s + 1) % e.length], r = new We(i, n), o = this.createLineElement(r);
      o.label.visible = false, this.lines.add(o);
    }
  }
  getLineBoxes() {
    const e = [];
    for (const s of this.lines)
      e.push(s.boundingBox);
    return e;
  }
  getFillBoxes() {
    const e = [];
    for (const s of this.fills)
      e.push(s.three);
    return e;
  }
};
var ln = class ln2 extends Ha {
  constructor(e) {
    super(e, "area");
    A(this, "pickTolerance", 0.1);
    A(this, "tolerance", 5e-3);
    A(this, "modes", ["free", "square"]);
    A(this, "_mode", "free");
    A(this, "_temp", {
      isDragging: false,
      area: new Ts(),
      lines: new Wt(),
      point: new Vector3()
    });
    A(this, "computeLineElements", () => {
      this._temp.lines.clear();
      const e2 = [...this._temp.area.points];
      if (this._temp.area.isPointInPlane(this._temp.point) && e2.push(this._temp.point), !(e2.length < 2 || !this.world))
        for (let s = 0; s < e2.length; s++) {
          const i = e2[s], n = e2[(s + 1) % e2.length], r = new We(i, n), o = this.createLineElement(r);
          this._temp.lines.add(o);
        }
    });
    A(this, "create", async () => {
      if (!this.enabled)
        return;
      if (!this.world)
        throw new Error("Area Measurement: world is not defined!");
      const e2 = await this._vertexPicker.get({
        snappingClasses: this.snappings
      });
      if (!(e2 && e2.point))
        return;
      const { area: s, point: i } = this._temp;
      if (this._temp.isDragging || (s.tolerance = this.tolerance, s.points.clear(), this._temp.isDragging = true), s.points.size === 0 && i.copy(e2.point), s.points.add(i.clone()), this.mode === "square" && s.points.size === 2 && e2.normal) {
        const [n, r] = s.points, o = new Vector3().subVectors(r, n), a = o.clone(), c = o.clone().negate();
        Math.abs(o.y) >= 0.1 ? (a.y = 0, c.y = 0) : (a.x = 0, c.x = 0);
        const h = n.clone().add(a), d = r.clone().add(c);
        s.points.clear(), s.points.add(n, h, r, d), this.endCreation();
      }
    });
    A(this, "endCreation", () => {
      this.enabled && (this._temp.isDragging = false, this._temp.area.points.size >= 3 && this.list.add(this._temp.area.clone()), this._temp.area.points.clear(), this._temp.lines.clear());
    });
    A(this, "cancelCreation", () => {
      this.enabled && (this._temp.isDragging = false, this._temp.area.points.clear(), this._temp.lines.clear());
    });
    A(this, "delete", () => {
      if (!this.enabled || this.list.size === 0 || !this.world)
        return;
      const e2 = this.getFillBoxes(), n = this.components.get(me).get(this.world).castRayToObjects(e2), r = this.components.get(De);
      for (const c of e2)
        r.destroy(c);
      if (!n)
        return;
      const a = [...this.fills].find(
        (c) => c.three === n.object
      );
      a && (this.list.delete(a.area), this.lines.clear());
    });
    e.add(ln2.uuid, this), this.initHandlers(), this.color = new Color("#6528d7");
  }
  get mode() {
    return this._mode;
  }
  /**
   * Represents the current measurement mode being used.
   */
  set mode(e) {
    this._mode = e, this.cancelCreation(), this.onStateChanged.trigger(["mode"]);
  }
  initHandlers() {
    this.onVisibilityChange.add(() => {
      for (const e of this.lines)
        e.label.visible = false;
    }), this.list.onItemAdded.add((e) => {
      if (!this.world)
        return;
      const s = this.createFillElement(e);
      s.color = this.color, this.fills.add(s), this.addLineElementsFromPoints([...e.points]);
    }), this.list.onBeforeDelete.add((e) => {
      const s = [...this.fills].find((i) => i.area === e);
      s && this.fills.delete(s);
    }), this.onPointerStop.add(() => this.updatePreview()), this._temp.lines.onItemAdded.add((e) => e.label.visible = false), this._temp.lines.onBeforeDelete.add((e) => e.dispose()), this._temp.area.points.onItemAdded.add(() => {
      this.computeLineElements();
    }), this._temp.area.points.onItemDeleted.add(() => {
      this._temp.lines.clear();
    });
  }
  async updatePreview() {
    if (!this.enabled || !this.world)
      throw new Error("Measurement is not enabled or world is not defined!");
    const e = await this._vertexPicker.get({
      snappingClasses: this.snappings
    });
    if (!(e && e.point && this._temp.isDragging))
      return;
    const s = e.point.clone(), { plane: i } = this._temp.area;
    if (i) {
      const n = i.distanceToPoint(s);
      if (Math.abs(n) < 0.1) {
        const r = new Vector3();
        i.projectPoint(s, r), s.copy(r);
      }
    }
    this._temp.point.copy(s), this.computeLineElements();
  }
};
A(ln, "uuid", "09b78c1f-0ff1-4630-a818-ceda3d878c75");
var Vo = ln;
var cn = class cn2 extends Ha {
  constructor(e) {
    super(e, "length");
    A(this, "_temp", {
      isDragging: false,
      line: new We()
    });
    A(this, "modes", ["free", "edge"]);
    A(this, "_mode", "free");
    A(this, "create", () => {
      if (this.enabled) {
        if (!this._temp.isDragging) {
          this.initPreview();
          return;
        }
        this.endCreation();
      }
    });
    A(this, "endCreation", () => {
      this.enabled && this._temp.dimension && (this.list.add(this._temp.line.clone()), this.mode === "free" && (this._temp.dimension.dispose(), this._temp.dimension = void 0, this._temp.isDragging = false, this._temp.startNormal = void 0));
    });
    A(this, "cancelCreation", () => {
      var e2;
      this.enabled && (this._temp.isDragging = false, this._temp.dimension && ((e2 = this._temp.dimension) == null || e2.dispose(), this._temp.dimension = void 0));
    });
    A(this, "delete", () => {
      if (!this.enabled || this.list.size === 0 || !this.world)
        return;
      const e2 = this.getLineBoxes(), n = this.components.get(me).get(this.world).castRayToObjects(e2);
      if (!n)
        return;
      const o = [...this.lines].find(
        (a) => a.boundingBox === n.object
      );
      o && this.list.delete(o.line);
    });
    e.add(cn2.uuid, this), this.initHandlers();
  }
  get mode() {
    return this._mode;
  }
  /**
   * Represents the current measurement mode being used.
   */
  set mode(e) {
    this._mode = e, this.cancelCreation(), e === "edge" && this.initPreview(), this.onStateChanged.trigger(["mode"]);
  }
  initHandlers() {
    this.list.onItemAdded.add((e) => {
      const s = this.createLineElement(e, this._temp.startNormal);
      s.createBoundingBox(), this.lines.add(s);
    }), this.list.onBeforeDelete.add((e) => {
      const i = [...this.lines].find((n) => n.line === e);
      i && this.lines.delete(i);
    }), this.onPointerStop.add(() => this.updatePreviewLine()), this.onEnabledChange.add((e) => {
      e && this.mode === "edge" && this.initPreview();
    });
  }
  async initPreview() {
    if (!this.world)
      throw new Error("Measurement: world is need!");
    const e = await this._vertexPicker.get({
      snappingClasses: this.snappings
    });
    if (this.mode === "free") {
      if (!(e != null && e.point))
        return;
      const s = e.point;
      this._temp.line.set(s, s.clone()), this._temp.isDragging = true, this._temp.dimension = this.createLineElement(this._temp.line), this._temp.startNormal = e.normal ?? void 0;
    } else if (this.mode === "edge") {
      const s = e == null ? void 0 : e.snappedEdgeP1, i = e == null ? void 0 : e.snappedEdgeP2, n = s || new Vector3(), r = n || i;
      this._temp.line.set(n, r), this._temp.isDragging = true, this._temp.dimension = this.createLineElement(this._temp.line), this._temp.dimension.visible = !!(s && i);
    }
  }
  async updatePreviewLine() {
    if (!this.world)
      throw new Error("Measurement: world is need!");
    const e = await this._vertexPicker.get({
      snappingClasses: this.snappings
    });
    if (this.mode === "free") {
      if (!(e != null && e.point) || (this._temp.line.end.copy(e.point), !this._temp.dimension))
        return;
      this._temp.dimension.end = this._temp.line.end;
    } else if (this.mode === "edge") {
      const s = e == null ? void 0 : e.snappedEdgeP1, i = e == null ? void 0 : e.snappedEdgeP2;
      if (this._temp.dimension && (this._temp.dimension.visible = !!(s && i)), !(s && i) || (this._temp.line.start.copy(s), this._temp.line.end.copy(i), !this._temp.dimension))
        return;
      this._temp.dimension.start = this._temp.line.start, this._temp.dimension.end = this._temp.line.end;
    }
  }
};
A(cn, "uuid", "2f9bcacf-18a9-4be6-a293-e898eae64ea1");
var Ho = cn;

export {
  To,
  is,
  Bd,
  Oo,
  tu,
  yu,
  nu,
  Ks,
  Js,
  hr,
  Bo,
  Ro,
  ru,
  Wn,
  Uo,
  au,
  Fo,
  dr,
  We,
  tn,
  Ts,
  cu,
  hu,
  Ha,
  Vo,
  Ho
};
/*! Bundled license information:

@thatopen/components-front/dist/index.js:
  (*!
   * camera-controls
   * https://github.com/yomotsu/camera-controls
   * (c) 2017 @yomotsu
   * Released under the MIT License.
   *)
  (*!
  
  JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  <http://stuartk.com/jszip>
  
  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  JSZip uses the library pako released under the MIT license :
  https://github.com/nodeca/pako/blob/main/LICENSE
  *)
*/
//# sourceMappingURL=chunk-3DD7MWDN.js.map
