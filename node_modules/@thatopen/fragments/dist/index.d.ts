import * as flatbuffers from 'flatbuffers';
import { LineMaterial } from 'three/examples/jsm/Addons.js';
import { LineMaterialParameters } from 'three/examples/jsm/lines/LineMaterial.js';
import * as THREE from 'three';

export declare class Alignment {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Alignment;
    static getRootAsAlignment(bb: flatbuffers.ByteBuffer, obj?: Alignment): Alignment;
    static getSizePrefixedRootAsAlignment(bb: flatbuffers.ByteBuffer, obj?: Alignment): Alignment;
    absolute(index: number): number | null;
    absoluteLength(): number;
    absoluteArray(): Uint32Array | null;
    horizontal(index: number): number | null;
    horizontalLength(): number;
    horizontalArray(): Uint32Array | null;
    vertical(index: number): number | null;
    verticalLength(): number;
    verticalArray(): Uint32Array | null;
    static startAlignment(builder: flatbuffers.Builder): void;
    static addAbsolute(builder: flatbuffers.Builder, absoluteOffset: flatbuffers.Offset): void;
    static createAbsoluteVector(builder: flatbuffers.Builder, data: number[] | Uint32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createAbsoluteVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startAbsoluteVector(builder: flatbuffers.Builder, numElems: number): void;
    static addHorizontal(builder: flatbuffers.Builder, horizontalOffset: flatbuffers.Offset): void;
    static createHorizontalVector(builder: flatbuffers.Builder, data: number[] | Uint32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createHorizontalVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startHorizontalVector(builder: flatbuffers.Builder, numElems: number): void;
    static addVertical(builder: flatbuffers.Builder, verticalOffset: flatbuffers.Offset): void;
    static createVerticalVector(builder: flatbuffers.Builder, data: number[] | Uint32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createVerticalVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startVerticalVector(builder: flatbuffers.Builder, numElems: number): void;
    static endAlignment(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createAlignment(builder: flatbuffers.Builder, absoluteOffset: flatbuffers.Offset, horizontalOffset: flatbuffers.Offset, verticalOffset: flatbuffers.Offset): flatbuffers.Offset;
}

export declare type AlignmentCurve = {
    points: Float32Array;
    type: GeometryClass;
};

export declare type AlignmentData = {
    absolute: AlignmentCurve[];
    horizontal: AlignmentCurve[];
    vertical: AlignmentCurve[];
};

export declare class AsyncEvent<T> {
    enabled: boolean;
    add(handler: T extends void ? {
        (): Promise<void>;
    } : {
        (data: T): Promise<void>;
    }): void;
    remove(handler: T extends void ? {
        (): Promise<void>;
    } : {
        (data: T): Promise<void>;
    }): void;
    trigger: (data?: T) => Promise<void>;
    reset(): void;
    private handlers;
}

export declare class Attribute {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Attribute;
    static getRootAsAttribute(bb: flatbuffers.ByteBuffer, obj?: Attribute): Attribute;
    static getSizePrefixedRootAsAttribute(bb: flatbuffers.ByteBuffer, obj?: Attribute): Attribute;
    data(index: number): string;
    data(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;
    dataLength(): number;
    static startAttribute(builder: flatbuffers.Builder): void;
    static addData(builder: flatbuffers.Builder, dataOffset: flatbuffers.Offset): void;
    static createDataVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startDataVector(builder: flatbuffers.Builder, numElems: number): void;
    static endAttribute(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createAttribute(builder: flatbuffers.Builder, dataOffset: flatbuffers.Offset): flatbuffers.Offset;
}

/**
 * Represents attribute data for a model item.
 */
export declare type AttributeData = {
    /** The value of the attribute, which can be any type */
    value: any;
    /** Optional type identifier for the attribute value */
    type?: number;
};

/**
 * Interface representing the attributes of a model item.
 */
export declare interface Attributes {
    /** Unique local identifier for the item */
    localId: number;
    /** Optional category identifier */
    category?: number;
    /** Optional globally unique identifier */
    guid?: string;
    /** Additional arbitrary attributes can be added with any name and value */
    [name: string]: any;
}

export declare interface AttributesUniqueValuesParams {
    key?: string;
    get: RegExp;
    categories?: RegExp[];
    attributes?: {
        aggregation?: QueryAggregation;
        queries: GetItemsByAttributeParams[];
    };
}

/**
 * Interface representing a change event when attributes are added to a model item.
 */
declare interface AttrsAddChange {
    /** Indicates this is an "added" type change */
    type: "added";
    /** Record containing the newly added attribute data */
    data: Record<string, any>;
}

/**
 * Union type representing all possible attribute change types.
 */
export declare type AttrsChange = AttrsDeleteChange | AttrsModifyChange | AttrsAddChange;

/**
 * Interface representing a change event when attributes are deleted from a model item.
 */
declare interface AttrsDeleteChange {
    /** Indicates this is a "deleted" type change */
    type: "deleted";
}

/**
 * Interface representing a change event when attributes are modified in a model item.
 */
declare interface AttrsModifyChange {
    /** Indicates this is a "modified" type change */
    type: "modified";
    /** Record containing the newly added attribute data */
    added: Record<string, any>;
    /** Array of strings representing the deleted attribute keys */
    deleted: string[];
    /** Record containing the modified attribute data */
    modified: Record<string, any>;
}

export declare class Axis {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Axis;
    static getRootAsAxis(bb: flatbuffers.ByteBuffer, obj?: Axis): Axis;
    static getSizePrefixedRootAsAxis(bb: flatbuffers.ByteBuffer, obj?: Axis): Axis;
    wires(index: number, obj?: Wire): Wire | null;
    wiresLength(): number;
    order(index: number): number | null;
    orderLength(): number;
    orderArray(): Uint32Array | null;
    parts(index: number): AxisPartClass | null;
    partsLength(): number;
    partsArray(): Int8Array | null;
    wireSets(index: number, obj?: WireSet): WireSet | null;
    wireSetsLength(): number;
    circleCurves(index: number, obj?: CircleCurve): CircleCurve | null;
    circleCurvesLength(): number;
    static startAxis(builder: flatbuffers.Builder): void;
    static addWires(builder: flatbuffers.Builder, wiresOffset: flatbuffers.Offset): void;
    static startWiresVector(builder: flatbuffers.Builder, numElems: number): void;
    static addOrder(builder: flatbuffers.Builder, orderOffset: flatbuffers.Offset): void;
    static createOrderVector(builder: flatbuffers.Builder, data: number[] | Uint32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createOrderVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startOrderVector(builder: flatbuffers.Builder, numElems: number): void;
    static addParts(builder: flatbuffers.Builder, partsOffset: flatbuffers.Offset): void;
    static createPartsVector(builder: flatbuffers.Builder, data: AxisPartClass[]): flatbuffers.Offset;
    static startPartsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addWireSets(builder: flatbuffers.Builder, wireSetsOffset: flatbuffers.Offset): void;
    static createWireSetsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startWireSetsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addCircleCurves(builder: flatbuffers.Builder, circleCurvesOffset: flatbuffers.Offset): void;
    static startCircleCurvesVector(builder: flatbuffers.Builder, numElems: number): void;
    static endAxis(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createAxis(builder: flatbuffers.Builder, wiresOffset: flatbuffers.Offset, orderOffset: flatbuffers.Offset, partsOffset: flatbuffers.Offset, wireSetsOffset: flatbuffers.Offset, circleCurvesOffset: flatbuffers.Offset): flatbuffers.Offset;
}

export declare enum AxisPartClass {
    NONE = 0,
    WIRE = 1,
    WIRE_SET = 2,
    CIRCLE_CURVE = 3
}

export declare class BigShellHole {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): BigShellHole;
    static getRootAsBigShellHole(bb: flatbuffers.ByteBuffer, obj?: BigShellHole): BigShellHole;
    static getSizePrefixedRootAsBigShellHole(bb: flatbuffers.ByteBuffer, obj?: BigShellHole): BigShellHole;
    indices(index: number): number | null;
    indicesLength(): number;
    indicesArray(): Uint32Array | null;
    profileId(): number;
    mutate_profile_id(value: number): boolean;
    static startBigShellHole(builder: flatbuffers.Builder): void;
    static addIndices(builder: flatbuffers.Builder, indicesOffset: flatbuffers.Offset): void;
    static createIndicesVector(builder: flatbuffers.Builder, data: number[] | Uint32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createIndicesVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startIndicesVector(builder: flatbuffers.Builder, numElems: number): void;
    static addProfileId(builder: flatbuffers.Builder, profileId: number): void;
    static endBigShellHole(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createBigShellHole(builder: flatbuffers.Builder, indicesOffset: flatbuffers.Offset, profileId: number): flatbuffers.Offset;
}

export declare class BigShellProfile {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): BigShellProfile;
    static getRootAsBigShellProfile(bb: flatbuffers.ByteBuffer, obj?: BigShellProfile): BigShellProfile;
    static getSizePrefixedRootAsBigShellProfile(bb: flatbuffers.ByteBuffer, obj?: BigShellProfile): BigShellProfile;
    indices(index: number): number | null;
    indicesLength(): number;
    indicesArray(): Uint32Array | null;
    static startBigShellProfile(builder: flatbuffers.Builder): void;
    static addIndices(builder: flatbuffers.Builder, indicesOffset: flatbuffers.Offset): void;
    static createIndicesVector(builder: flatbuffers.Builder, data: number[] | Uint32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createIndicesVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startIndicesVector(builder: flatbuffers.Builder, numElems: number): void;
    static endBigShellProfile(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createBigShellProfile(builder: flatbuffers.Builder, indicesOffset: flatbuffers.Offset): flatbuffers.Offset;
}

/**
 * Union type representing all possible material types.
 */
export declare type BIMMaterial = LodMaterial | THREE.MeshLambertMaterial;

/**
 * Union type representing all possible mesh types.
 */
export declare type BIMMesh = THREE.Mesh | LODMesh;

export declare class BoundingBox {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): BoundingBox;
    min(obj?: FloatVector): FloatVector | null;
    max(obj?: FloatVector): FloatVector | null;
    static sizeOf(): number;
    static createBoundingBox(builder: flatbuffers.Builder, min_x: number, min_y: number, min_z: number, max_x: number, max_y: number, max_z: number): flatbuffers.Offset;
}

export declare class CircleCurve {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): CircleCurve;
    aperture(): number;
    mutate_aperture(value: number): boolean;
    position(obj?: FloatVector): FloatVector | null;
    radius(): number;
    mutate_radius(value: number): boolean;
    xDirection(obj?: FloatVector): FloatVector | null;
    yDirection(obj?: FloatVector): FloatVector | null;
    static sizeOf(): number;
    static createCircleCurve(builder: flatbuffers.Builder, aperture: number, position_x: number, position_y: number, position_z: number, radius: number, x_direction_x: number, x_direction_y: number, x_direction_z: number, y_direction_x: number, y_direction_y: number, y_direction_z: number): flatbuffers.Offset;
}

export declare class CircleExtrusion {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): CircleExtrusion;
    static getRootAsCircleExtrusion(bb: flatbuffers.ByteBuffer, obj?: CircleExtrusion): CircleExtrusion;
    static getSizePrefixedRootAsCircleExtrusion(bb: flatbuffers.ByteBuffer, obj?: CircleExtrusion): CircleExtrusion;
    radius(index: number): number | null;
    radiusLength(): number;
    radiusArray(): Float64Array | null;
    axes(index: number, obj?: Axis): Axis | null;
    axesLength(): number;
    static startCircleExtrusion(builder: flatbuffers.Builder): void;
    static addRadius(builder: flatbuffers.Builder, radiusOffset: flatbuffers.Offset): void;
    static createRadiusVector(builder: flatbuffers.Builder, data: number[] | Float64Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createRadiusVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startRadiusVector(builder: flatbuffers.Builder, numElems: number): void;
    static addAxes(builder: flatbuffers.Builder, axesOffset: flatbuffers.Offset): void;
    static createAxesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startAxesVector(builder: flatbuffers.Builder, numElems: number): void;
    static endCircleExtrusion(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createCircleExtrusion(builder: flatbuffers.Builder, radiusOffset: flatbuffers.Offset, axesOffset: flatbuffers.Offset): flatbuffers.Offset;
}

declare class Connection {
    private readonly _handlers;
    private readonly _handleInput;
    private _port?;
    constructor(handleInput: ThreadHandler);
    fetchMeshCompute(modelId: string, list: any[]): void;
    fetch(input: any, content?: any[]): Promise<any>;
    init(port: MessagePort): void;
    protected initConnection(connection: MessagePort): void;
    protected fetchConnection(_input: any): Promise<MessagePort>;
    private executeConnection;
    private manageOutput;
    private onInput;
    private manageConnection;
    private manageInput;
}

/**
 * Enum representing the current level of detail (LOD) for a mesh.
 */
export declare const enum CurrentLod {
    /** Represents the full geometry of the model */
    GEOMETRY = 0,
    /** Represents the wireframe representation of the model */
    WIRES = 1,
    /** Represents the invisible representation of the model */
    INVISIBLE = 2
}

/**
 * Union type representing all possible data buffer types.
 */
export declare type DataBuffer = Float32Array | Uint8ClampedArray | Int32Array | Uint8Array | Uint32Array | Float64Array | Int8Array | Uint16Array | Int16Array;

export declare class DataMap<K, V> extends Map<K, V> {
    readonly onItemSet: Event_2<{
        key: K;
        value: V;
    }>;
    readonly onItemUpdated: Event_2<{
        key: K;
        value: V;
    }>;
    readonly onItemDeleted: Event_2<K>;
    readonly onBeforeDelete: Event_2<{
        key: K;
        value: V;
    }>;
    readonly onCleared: Event_2<unknown>;
    set eventsEnabled(value: boolean);
    constructor(iterable?: Iterable<readonly [K, V]> | null | undefined);
    clear(): void;
    set(key: K, value: V): this;
    guard: (key: K, value: V) => boolean;
    delete(key: K): boolean;
    getKey(item: V): K | undefined;
    /**
     * Updates an item in the data map, triggering the corresponding event.
     *
     * @param item - The item to update.
     */
    update(item: V): void;
    /**
     * Deletes elements from the DataMap based on a provided predicate function.
     *
     * @param predicate A function that takes a value and its key as arguments and returns a boolean.
     *                  If the function returns true, the element is deleted.
     */
    deleteIf(predicate: (value: V, key: K) => boolean): void;
    /**
     * Replaces a key in the DataMap with a new key, transferring the associated value.
     *
     * @param oldKey - The key to be replaced.
     * @param newKey - The new key that will replace the old key.
     * @param fullReplace - If true, allows replacing an existing key with the new key. If false, the replacement will not occur if the new key already exists in the map. Defaults to false.
     * @returns True if the key was successfully replaced, false otherwise.
     */
    replaceKey(oldKey: K, newKey: K, fullReplace?: boolean): boolean;
    dispose(): void;
}

export declare class DataSet<T> extends Set<T> {
    readonly onUpdated: Event_2<undefined>;
    readonly onItemAdded: Event_2<T>;
    readonly onBeforeDelete: Event_2<T>;
    readonly onItemDeleted: Event_2<unknown>;
    readonly onCleared: Event_2<unknown>;
    set eventsEnabled(value: boolean);
    constructor(iterable?: Iterable<T> | null);
    clear(): void;
    add(...value: T[]): this;
    guard: (value: T) => boolean;
    delete(value: T): boolean;
    deleteIf(predicate: (value: T) => boolean): void;
    getIndex(item: T): number;
    dispose(): void;
}

export declare class DoubleVector {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): DoubleVector;
    x(): number;
    mutate_x(value: number): boolean;
    y(): number;
    mutate_y(value: number): boolean;
    z(): number;
    mutate_z(value: number): boolean;
    static sizeOf(): number;
    static createDoubleVector(builder: flatbuffers.Builder, x: number, y: number, z: number): flatbuffers.Offset;
}

declare class Event_2<T> {
    enabled: boolean;
    add(handler: T extends void ? {
        (): void;
    } : {
        (data: T): void;
    }): void;
    remove(handler: T extends void ? {
        (): void;
    } : {
        (data: T): void;
    }): void;
    trigger: (data?: T) => void;
    reset(): void;
    private handlers;
}
export { Event_2 as Event }

export declare class FloatVector {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): FloatVector;
    x(): number;
    mutate_x(value: number): boolean;
    y(): number;
    mutate_y(value: number): boolean;
    z(): number;
    mutate_z(value: number): boolean;
    static sizeOf(): number;
    static createFloatVector(builder: flatbuffers.Builder, x: number, y: number, z: number): flatbuffers.Offset;
}

declare class FragmentsConnection extends Connection {
    private readonly _data;
    constructor(handleInput: ThreadHandler, threadPath: string);
    delete(model: string): void;
    invoke(model: string, method: string, args?: any[]): Promise<any>;
    protected fetchConnection(input: any): Promise<MessagePort>;
    private setupNewThread;
    private setupThread;
    private newThread;
}

/**
 * The main class for managing a 3D model loaded from a fragments file.
 * Handles geometry, materials, visibility, highlighting, sections, and more.
 *
 * This class orchestrates multiple specialized managers to handle different aspects
 * of the model like mesh management, item data, raycasting, etc. It maintains the
 * overall state and provides the main interface for interacting with the model.
 *
 * The model data is loaded and processed asynchronously across multiple threads.
 */
export declare class FragmentsModel {
    /**
     * A map of attribute changes that have occurred in the model.
     * The key is the local ID of the item, and the value is the change.
     */
    readonly attrsChanges: Map<number, AttrsChange>;
    /**
     * A map of relation changes that have occurred in the model.
     * The key is the local ID of the item, and the value is the change.
     */
    readonly relsChanges: Map<number, RelsModifyChange>;
    /**
     * The connection to the threads that handle the model data.
     */
    readonly threads: FragmentsConnection;
    /**
     * A map of tiles that have been loaded for the model.
     * The key is the tile ID, and the value is the tile.
     */
    readonly tiles: DataMap<string | number, BIMMesh>;
    /**
     * The object that represents the model in the Three.js scene.
     */
    object: THREE.Object3D<THREE.Object3DEventMap>;
    /**
     * The graphics quality of the model. It ranges from 0 (lowest) to 1 (highest).
     */
    graphicsQuality: number;
    private readonly _boxManager;
    private readonly _itemsManager;
    private readonly _coordinatesManager;
    private readonly _setupManager;
    private readonly _viewManager;
    private readonly _raycastManager;
    private readonly _visibilityManager;
    private readonly _highlightManager;
    private readonly _sectionManager;
    private readonly _dataManager;
    private readonly _sequenceManager;
    private readonly _bbox;
    private readonly _alignmentsManager;
    private readonly _meshManager;
    private _isProcessing;
    private _isLoaded;
    private _frozen;
    private _isSetup;
    /**
     * The ID of the model.
     */
    get modelId(): string;
    /**
     * The bounding box of the whole model.
     */
    get box(): THREE.Box3;
    /**
     * Whether the model is busy loading data.
     */
    get isBusy(): boolean;
    /**
     * Whether the model should stop updating..
     */
    get frozen(): boolean;
    /**
     * Whether the model should stop updating..
     */
    set frozen(value: boolean);
    /**
     * The event that is triggered when the clipping planes are needed in the thread.
     * Set this method to pass your Three.js clipping planes to the model.
     */
    get getClippingPlanesEvent(): () => THREE.Plane[];
    /**
     * The event that is triggered when the clipping planes are needed in the thread.
     * Set this method to pass your Three.js clipping planes to the model.
     */
    set getClippingPlanesEvent(value: () => THREE.Plane[]);
    /**
     * The constructor of the fragments model. Don't use this directly. Use the {@link FragmentsModels.load} instead.
     */
    constructor(modelId: string, meshManager: MeshManager, threads: FragmentsConnection);
    /**
     * Dispose the model. Use this when you're done with the model.
     * If you use the {@link FragmentsModels.dispose} method, this will be called automatically for all models.
     */
    dispose(): Promise<void>;
    /**
     * Get the spatial structure of the model.
     */
    getSpatialStructure(): Promise<SpatialTreeItem>;
    /**
     * Get the local IDs corresponding to the specified GUIDs.
     * @param guids - Array of GUIDs to look up.
     */
    getLocalIdsByGuids(guids: string[]): Promise<(number | null)[]>;
    /**
     * Get all the categories of the model.
     */
    getCategories(): Promise<string[]>;
    getItemsWithGeometryCategories(): Promise<(string | null)[]>;
    /**
     * Get all the items of the model that have geometry.
     */
    getItemsWithGeometry(): Promise<Item[]>;
    /**
     * Get all the items ids of the model that have geometry.
     */
    getItemsIdsWithGeometry(): Promise<number[]>;
    /**
     * Get the metadata of the model.
     */
    getMetadata<T extends Record<string, any> = Record<string, any>>(): Promise<T>;
    /**
     * Get the GUIDs corresponding to the specified local IDs.
     * @param localIds - Array of local IDs to look up.
     */
    getGuidsByLocalIds(localIds: number[]): Promise<(string | null)[]>;
    /**
     * Get the buffer of the model.
     * @param raw - Whether to get the raw buffer. If false, it will be compressed.
     */
    getBuffer(raw?: boolean): Promise<ArrayBuffer>;
    /**
     * Get all the items of the model that belong to the specified category.
     * @param category - The category to look up.
     */
    getItemsOfCategories(categories: RegExp[]): Promise<{
        [category: string]: number[];
    }>;
    getGuids(): Promise<string[]>;
    getLocalIds(): Promise<number[]>;
    /**
     * Retrieves items based on the specified query parameters.
     *
     * @param params - The query parameters used to filter and retrieve items.
     * @returns A promise that resolves to the items matching the query.
     */
    getItemsByQuery(params: ItemsQueryParams): Promise<number[]>;
    getItemsMaterialDefinition(localIds: number[]): Promise<{
        definition: MaterialDefinition;
        localIds: number[];
    }[]>;
    /**
     * Retrieves the geometry data for the specified local IDs.
     *
     * The returned data is structured as an array of arrays of `MeshData`,
     * which contains the necessary information to reconstruct a `THREE.BufferGeometry`.
     *
     * @param localIds - An array of local IDs for which the geometry data is requested.
     */
    getItemsGeometry(localIds: number[]): Promise<MeshData[][]>;
    /**
     * Retrieves the total volume of items based on their local IDs.
     *
     * @param localIds An array of local IDs representing the items.
     * @returns A promise that resolves to the total volume of the specified items.
     */
    getItemsVolume(localIds: number[]): Promise<number>;
    /**
     * Retrieves the names of all attributes associated with the model.
     *
     * @returns A promise that resolves to an array of strings, where each string is the name of an attribute.
     */
    getAttributeNames(): Promise<string[]>;
    /**
     * Retrieves the attribute values associated with the model.
     *
     * @returns A promise that resolves to an array of attribute values.
     */
    getAttributeValues(): Promise<any[]>;
    getAttributesUniqueValues(params: AttributesUniqueValuesParams[]): Promise<Record<string, any[]>>;
    /**
     * Retrieves the attribute types associated with the model.
     *
     * @returns A promise that resolves to an array of attribute types.
     */
    getAttributeTypes(): Promise<string[]>;
    /**
     * Retrieves the names of all relations associated with this model.
     *
     * @returns A promise that resolves to an array of strings, where each string is the name of a relation.
     */
    getRelationNames(): Promise<string[]>;
    /**
     * Get the maximum local ID of the model.
     */
    getMaxLocalId(): Promise<number>;
    /**
     * Get an item by its ID.
     * @param id - The ID of the item to look up.
     */
    getItem(id: Identifier): Item;
    /**
     * Get the spatial structure children of the specified items.
     * @param ids - The IDs of the items to look up.
     */
    getItemsChildren(ids: Identifier[]): Promise<number[]>;
    /**
     * Get all the data of the specified items.
     * @param ids - The IDs of the items to look up.
     * @param config - The configuration of the items data.
     */
    getItemsData(ids: Identifier[], config?: Partial<ItemsDataConfig>): Promise<ItemData[]>;
    /**
     * Get the absolute positions of the specified items.
     * @param localIds - The local IDs of the items to look up.
     */
    getPositions(localIds?: number[]): Promise<THREE.Vector3[]>;
    /**
     * Gets coordinates of the model.
     */
    getCoordinates(): Promise<number[]>;
    /**
     * Retrieves the coordination matrix for the current model.
     *
     * This method utilizes the `_coordinatesManager` to compute and return a
     * `THREE.Matrix4` object based on the original model coordinates.
     */
    getCoordinationMatrix(): Promise<THREE.Matrix4>;
    /**
     * Get the merged bounding box of the specified items.
     * @param localIds - The local IDs of the items to look up.
     */
    getMergedBox(localIds: number[]): Promise<THREE.Box3>;
    /**
     * Get the individual bounding boxes of the specified items.
     * @param localIds - The local IDs of the items to look up.
     */
    getBoxes(localIds?: number[]): Promise<THREE.Box3[]>;
    /**
     * Get the absolute alignments of the model (if any).
     */
    getAlignments(): Promise<THREE.Group<THREE.Object3DEventMap>>;
    /**
     * Get the horizontal alignments of the model (if any).
     */
    getHorizontalAlignments(): Promise<THREE.Group<THREE.Object3DEventMap>>;
    /**
     * Get the vertical alignments of the model (if any).
     */
    getVerticalAlignments(): Promise<THREE.Group<THREE.Object3DEventMap>>;
    /**
     * Get the civil alignment styles of the model (if any).
     */
    getAlignmentStyles(): Promise<{
        interior: THREE.PointsMaterial;
        exterior: THREE.PointsMaterial;
        clear(): void;
        delete(key: GeometryClass): boolean;
        forEach(callbackfn: (value: LineMaterial, key: GeometryClass, map: Map<GeometryClass, LineMaterial>) => void, thisArg?: any): void;
        get(key: GeometryClass): LineMaterial | undefined;
        has(key: GeometryClass): boolean;
        set(key: GeometryClass, value: LineMaterial): Map<GeometryClass, LineMaterial>;
        size: number;
        entries(): IterableIterator<[GeometryClass, LineMaterial]>;
        keys(): IterableIterator<GeometryClass>;
        values(): IterableIterator<LineMaterial>;
        [Symbol.iterator](): IterableIterator<[GeometryClass, LineMaterial]>;
        [Symbol.toStringTag]: string;
    }>;
    /**
     * Sets a camera for the model. The model will use it to load tiles dinamically depending on the users view
     * (e.g. hiding items that are not in the view, setting the LOD to far away items, etc).
     * @param camera - The camera to use.
     */
    useCamera(camera: THREE.PerspectiveCamera | THREE.OrthographicCamera): void;
    /**
     * Performs a rectangle raycast on the model.
     * @param data - The data of the rectangle raycast.
     */
    rectangleRaycast(data: RectangleRaycastData): Promise<RectangleRaycastResult | null>;
    /**
     * Performs a raycast on the model.
     * @param data - The data of the raycast.
     */
    raycast(data: RaycastData): Promise<RaycastResult | null>;
    /**
     * Performs a raycast on the model with snapping.
     * @param data - The data of the raycast.
     */
    raycastWithSnapping(data: SnappingRaycastData): Promise<RaycastResult[] | null>;
    /**
     * Sets the visibility of the specified items.
     * @param localIds - The local IDs of the items to set the visibility of.
     * @param visible - Whether the items should be visible.
     */
    setVisible(localIds: number[] | undefined, visible: boolean): Promise<void>;
    /**
     * Toggles the visibility of the specified items.
     * @param localIds - The local IDs of the items to toggle the visibility of.
     */
    toggleVisible(localIds?: number[]): Promise<void>;
    /**
     * Gets the items by visibility.
     * @param visible - Whether the items should be visible.
     */
    getItemsByVisibility(visible: boolean): Promise<number[]>;
    /**
     * Gets the items by visibility.
     * @param localIds - The local IDs of the items to get the visibility of.
     */
    getVisible(localIds: number[]): Promise<boolean[]>;
    /**
     * Resets the visibility of all items.
     */
    resetVisible(): Promise<void>;
    /**
     * Highlights the specified items.
     * @param localIds - The local IDs of the items to highlight. If undefined, all items will be highlighted.
     * @param highlightMaterial - The material to use for the highlight.
     */
    highlight(localIds: number[] | undefined, highlightMaterial: MaterialDefinition): Promise<void>;
    /**
     * Gets the highlight of the specified items.
     * @param localIds - The local IDs of the items to get the highlight of. If undefined, it will return the highlight of all items.
     */
    getHighlight(localIds?: number[]): Promise<MaterialDefinition[]>;
    /**
     * Resets the highlight of the specified items.
     * @param localIds - The local IDs of the items to reset the highlight of. If undefined, it will reset the highlight of all items.
     */
    resetHighlight(localIds?: number[]): Promise<void>;
    /**
     * Gets the item IDs of the items that are highlighted.
     */
    getHighlightItemIds(): Promise<number[]>;
    /**
     * Gets the section (edges and fills) between the model and a given clipping plane.
     * @param plane - The plane to get the section of.
     */
    getSection(plane: THREE.Plane, localIds?: number[]): Promise<ModelSection>;
    /**
     * Processes a sequence of actions in the worker and computes the result based on the provided input.
     *
     * @param result - The type of item information to compute, used to select the appropriate result function.
     * @param fromItems - An array of selection types, each corresponding to an items selector function.
     * @param input - The initial input data to be processed by the sequence of actions.
     * @returns The computed result after processing the sequence of actions, or `null` if the result function is not found.
     * @experimental
     */
    getSequenced<T extends ItemInformationType, U extends ItemSelectionType>(result: T, fromItems: U[], inputs?: {
        selector?: Partial<Record<U, SelectionInputType<U>>>;
        result?: ResultInputType<T>;
    }): Promise<InformationResultType<T>>;
    handleRequest(request: any): Promise<void>;
    /**
     * Internal method to finish processing. Don't use this directly.
     */
    _finishProcessing(): void;
    /**
     * Internal method to refresh the view of the model. You shouldn't call this directly. Instead, use {@link FragmentsModels.update}.
     */
    _refreshView(): Promise<void>;
    /**
     * Internal method to set up the model. Don't use this directly.
     */
    _setup(data: ArrayBuffer, raw?: boolean, config?: VirtualModelConfig): Promise<void>;
}

/**
 * The main class for managing multiple 3D models loaded from fragments files.
 * Handles loading, disposing, updating, raycasting, highlighting and coordinating multiple FragmentsModel instances.
 *
 * This class acts as the main entry point for working with fragments models. It:
 * - Manages loading and disposing of models
 * - Coordinates updates across all loaded models
 * - Handles raycasting and hit testing
 * - Manages highlighting across models
 * - Handles base coordinate systems
 *
 */
export declare class FragmentsModels {
    /**
     * Event triggered when a model is loaded.
     * @event
     * @type {Event<FragmentsModel>}
     */
    readonly onModelLoaded: Event_2<FragmentsModel>;
    /**
     * The manager that handles all loaded fragments models.
     * Provides functionality to:
     * - Store and retrieve models by ID
     * - Track model loading/unloading
     * - Coordinate updates across models
     * - Handle model disposal
     */
    models: MeshManager;
    /** Settings that control the behavior of the FragmentsModels system */
    settings: {
        /** Whether to automatically coordinate model positions relative to the first loaded model */
        autoCoordinate: boolean;
        /** Maximum rate (in milliseconds) at which visual updates are performed */
        maxUpdateRate: number;
        /** Graphics quality level - 0 is low quality, 1 is high quality */
        graphicsQuality: number;
    };
    /** Coordinates of the first loaded model, used for coordinate system alignment */
    baseCoordinates: number[] | null;
    private readonly _connection;
    private _isDisposed;
    private _autoRedrawInterval;
    private _lastUpdate;
    /**
     * Creates a new FragmentsModels instance.
     * @param workerURL - The URL of the worker script that will handle the fragments processing.
     * This should point to a copy of the fragments worker file from @thatopen/fragments.
     */
    constructor(workerURL: string);
    /**
     * Loads a fragments model from an ArrayBuffer.
     * @param buffer - The ArrayBuffer containing the fragments data to load.
     * @param options - Configuration options for loading the model.
     * @param options.modelId - Unique identifier for the model.
     * @param options.camera - Optional camera to use for model culling and LOD.
     * @param options.raw - If true, loads raw (uncompressed) data. Default is false.
     * @param options.userData - Optional custom data to attach to the model.
     * @param options.virtualModelConfig - Optional configuration for virtual model setup.
     * @returns Promise resolving to the loaded FragmentsModel instance.
     */
    load(buffer: ArrayBuffer, options: {
        modelId: string;
        camera?: THREE.PerspectiveCamera | THREE.OrthographicCamera;
        raw?: boolean;
        userData?: Record<string, any>;
        virtualModelConfig?: VirtualModelConfig;
    }): Promise<FragmentsModel>;
    /**
     * Disposes of all models managed by this FragmentsModels instance.
     * After calling this method, the FragmentsModels instance should not be used anymore.
     */
    dispose(): Promise<void>;
    /**
     * Disposes of a specific model by its ID.
     * @param modelId - The unique identifier of the model to dispose.
     */
    disposeModel(modelId: string): Promise<void>;
    /**
     * Updates all models managed by this FragmentsModels instance.
     * @param force - If true, it will force all the models to finish all the pending requests.
     */
    update(force?: boolean): Promise<void>;
    private manageRequest;
    private newUpdateEvent;
    private newRequestEvent;
}

export declare class Geometries {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Geometries;
    static getRootAsGeometries(bb: flatbuffers.ByteBuffer, obj?: Geometries): Geometries;
    static getSizePrefixedRootAsGeometries(bb: flatbuffers.ByteBuffer, obj?: Geometries): Geometries;
    samples(index: number, obj?: GeometrySample): GeometrySample | null;
    samplesLength(): number;
    sampleIds(index: number): number | null;
    sampleIdsLength(): number;
    sampleIdsArray(): Uint32Array | null;
    representations(index: number, obj?: GeometryRepresentation): GeometryRepresentation | null;
    representationsLength(): number;
    representationIds(index: number): number | null;
    representationIdsLength(): number;
    representationIdsArray(): Uint32Array | null;
    transforms(index: number, obj?: Transform): Transform | null;
    transformsLength(): number;
    transformIds(index: number): number | null;
    transformIdsLength(): number;
    transformIdsArray(): Uint32Array | null;
    representationsSamples(index: number): number | null;
    representationsSamplesLength(): number;
    representationsSamplesArray(): Uint32Array | null;
    lines(index: number, obj?: GeometryLines): GeometryLines | null;
    linesLength(): number;
    walls(index: number, obj?: GeometryWall): GeometryWall | null;
    wallsLength(): number;
    static startGeometries(builder: flatbuffers.Builder): void;
    static addSamples(builder: flatbuffers.Builder, samplesOffset: flatbuffers.Offset): void;
    static startSamplesVector(builder: flatbuffers.Builder, numElems: number): void;
    static addSampleIds(builder: flatbuffers.Builder, sampleIdsOffset: flatbuffers.Offset): void;
    static createSampleIdsVector(builder: flatbuffers.Builder, data: number[] | Uint32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createSampleIdsVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startSampleIdsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addRepresentations(builder: flatbuffers.Builder, representationsOffset: flatbuffers.Offset): void;
    static startRepresentationsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addRepresentationIds(builder: flatbuffers.Builder, representationIdsOffset: flatbuffers.Offset): void;
    static createRepresentationIdsVector(builder: flatbuffers.Builder, data: number[] | Uint32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createRepresentationIdsVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startRepresentationIdsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addTransforms(builder: flatbuffers.Builder, transformsOffset: flatbuffers.Offset): void;
    static startTransformsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addTransformIds(builder: flatbuffers.Builder, transformIdsOffset: flatbuffers.Offset): void;
    static createTransformIdsVector(builder: flatbuffers.Builder, data: number[] | Uint32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createTransformIdsVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startTransformIdsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addRepresentationsSamples(builder: flatbuffers.Builder, representationsSamplesOffset: flatbuffers.Offset): void;
    static createRepresentationsSamplesVector(builder: flatbuffers.Builder, data: number[] | Uint32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createRepresentationsSamplesVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startRepresentationsSamplesVector(builder: flatbuffers.Builder, numElems: number): void;
    static addLines(builder: flatbuffers.Builder, linesOffset: flatbuffers.Offset): void;
    static createLinesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startLinesVector(builder: flatbuffers.Builder, numElems: number): void;
    static addWalls(builder: flatbuffers.Builder, wallsOffset: flatbuffers.Offset): void;
    static startWallsVector(builder: flatbuffers.Builder, numElems: number): void;
    static endGeometries(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createGeometries(builder: flatbuffers.Builder, samplesOffset: flatbuffers.Offset, sampleIdsOffset: flatbuffers.Offset, representationsOffset: flatbuffers.Offset, representationIdsOffset: flatbuffers.Offset, transformsOffset: flatbuffers.Offset, transformIdsOffset: flatbuffers.Offset, representationsSamplesOffset: flatbuffers.Offset, linesOffset: flatbuffers.Offset, wallsOffset: flatbuffers.Offset): flatbuffers.Offset;
}

export declare enum GeometryClass {
    NONE = 0,
    LINES = 1,
    ELLIPSE_ARC = 2,
    CLOTHOID = 3,
    PARABOLA = 4,
    WALLS = 5
}

export declare class GeometryLines {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): GeometryLines;
    static getRootAsGeometryLines(bb: flatbuffers.ByteBuffer, obj?: GeometryLines): GeometryLines;
    static getSizePrefixedRootAsGeometryLines(bb: flatbuffers.ByteBuffer, obj?: GeometryLines): GeometryLines;
    points(index: number): number | null;
    pointsLength(): number;
    pointsArray(): Float32Array | null;
    static startGeometryLines(builder: flatbuffers.Builder): void;
    static addPoints(builder: flatbuffers.Builder, pointsOffset: flatbuffers.Offset): void;
    static createPointsVector(builder: flatbuffers.Builder, data: number[] | Float32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createPointsVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startPointsVector(builder: flatbuffers.Builder, numElems: number): void;
    static endGeometryLines(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createGeometryLines(builder: flatbuffers.Builder, pointsOffset: flatbuffers.Offset): flatbuffers.Offset;
}

export declare class GeometryRepresentation {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): GeometryRepresentation;
    id(): number;
    mutate_id(value: number): boolean;
    geometryClass(): GeometryClass;
    mutate_geometry_class(value: GeometryClass): boolean;
    static sizeOf(): number;
    static createGeometryRepresentation(builder: flatbuffers.Builder, id: number, geometry_class: GeometryClass): flatbuffers.Offset;
}

export declare class GeometrySample {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): GeometrySample;
    id(): number;
    mutate_id(value: number): boolean;
    transform(): number;
    mutate_transform(value: number): boolean;
    static sizeOf(): number;
    static createGeometrySample(builder: flatbuffers.Builder, id: number, transform: number): flatbuffers.Offset;
}

export declare class GeometryWall {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): GeometryWall;
    start(obj?: FloatVector): FloatVector | null;
    end(obj?: FloatVector): FloatVector | null;
    height(): number;
    mutate_height(value: number): boolean;
    width(): number;
    mutate_width(value: number): boolean;
    offset(): number;
    mutate_offset(value: number): boolean;
    static sizeOf(): number;
    static createGeometryWall(builder: flatbuffers.Builder, start_x: number, start_y: number, start_z: number, end_x: number, end_y: number, end_z: number, height: number, width: number, offset: number): flatbuffers.Offset;
}

export declare type GetItemsByAttributeParams = {
    name: RegExp;
    value?: RegExp | RegExp[] | number | boolean;
    type?: RegExp;
    negate?: boolean;
    itemIds?: number[];
};

export declare type GetItemsByRelationParams = {
    /** Relation tag on the *source* item (e.g. "IsDefinedBy") */
    name: string;
    /** Set of *target* item localIds that must appear in the chosen relation */
    targetItemIds?: Set<number>;
    /** Optional subset of candidate *source* items; if omitted all items are scanned. */
    sourceItemIds?: Iterable<number>;
};

/**
 * Recursively converts a Flatbuffers object into a plain JavaScript object.
 * This function traverses the prototype chain of the Flatbuffers object and extracts all properties
 * and their values, handling both primitive values and nested objects/arrays.
 *
 * @param obj - The Flatbuffers object to convert
 * @param result - The target plain JavaScript object where the converted properties will be stored
 *
 */
export declare function getObject(obj: any, result: any): void;

/**
 * Type representing a unique identifier for a model item.
 * This can be either a string or a number.
 */
export declare type Identifier = string | number;

/**
 * A map that associates each unique integer identifier (IFC Entity ID) with its corresponding category name. This map is used to map IFC entities to their respective categories for easier identification and processing.
 */
export declare const ifcCategoryMap: {
    [key: number]: string;
};

export declare const ifcClasses: {
    base: Set<number>;
    materials: Set<number>;
    properties: Set<number>;
    types: Set<number>;
    elements: Set<number>;
};

/**
 * An objet to convert IFC files into fragments.
 */
export declare class IfcImporter {
    private _builder;
    /** Configuration for the web-ifc WASM module
     * @property {string} path - The path to the web-ifc WASM files
     * @property {boolean} absolute - Whether the path is absolute or relative
     */
    wasm: {
        path: string;
        absolute: boolean;
    };
    /** A set of attribute names to exclude from serialization.
     */
    attributesToExclude: Set<string>;
    /**
     * @summary Defines the relationships between IFC entities.
     * @description This map defines the relationships between IFC entities, specifying the relationship type,
     * and the properties that define the relationship in both directions.
     *
     * The keys of the map are IFC relationship types (e.g., `IFCRELDEFINESBYPROPERTIES`).
     * The values are objects that define the properties for relating and related entities.
     *
     * - `forRelating`: The property name on the relating entity.
     * - `forRelated`: The property name on the related entity.
     */
    relations: Map<number, {
        forRelating: string;
        forRelated: string;
    }>;
    /**
     * @summary A map containing sets of IFC classes, categorized into 'elements' and 'abstract'.
     * @remarks The 'elements' category contains a set of IFC classes representing physical elements.
     * The 'abstract' category contains a set of abstract IFC classes, including materials, properties, classifications, etc.
     */
    classes: {
        elements: DataSet<number>;
        abstract: DataSet<number>;
    };
    /**
     * Whether to include unique attributes from the imported IFC data.
     */
    includeUniqueAttributes: boolean;
    /**
     * Whether to include relation names from the imported IFC data.
     */
    includeRelationNames: boolean;
    /**
     * Whether to replace the IfcBuildingStorey.Elevation with the absolute storey elevation.
     * @remarks The value is calculated taking into consideration the relative positions between entities
     * and it is always given in meters.
     */
    replaceStoreyElevation: boolean;
    private get builder();
    /**
     * Processes IFC data and converts it into a fragments format.
     * @param data Configuration object for processing.
     * @param data.bytes Raw IFC file data as Uint8Array.
     * @param data.raw Whether to return raw uncompressed data. If false, the output fragments will be smaller.
     * @param data.readFromCallback Whether to read data from a callback function. Useful for node.js.
     * @param data.readCallback Callback function to read IFC data. Useful for node.js.
     */
    process(data: ProcessData): Promise<Uint8Array>;
    private clean;
}

/**
 * Type representing the result of an information query for a specific item type.
 * @template T - The type of item information to query.
 */
export declare type InformationResultType<T extends ItemInformationType> = MappedInformationResult[T];

/**
 * Represents a single item in a Fragments model.
 * This class provides methods to access and retrieve information about the item,
 * including its attributes, relations, geometry, and data.
 */
declare class Item {
    /**
     * The FragmentsModel instance that this item belongs to.
     */
    readonly model: FragmentsModel;
    /**
     * Creates a new Item instance.
     * @param model - The FragmentsModel instance that this item belongs to.
     * @param id - The identifier for the item, which can be either a number or a string.
     */
    constructor(model: FragmentsModel, id: Identifier);
    private _localId;
    /**
     * Gets the local ID of the item.
     */
    getLocalId(): Promise<number | null>;
    private _attributes;
    /**
     * Gets all the attributes of the item.
     */
    getAttributes(): Promise<ItemAttributes | null>;
    private _relations;
    /**
     * Gets all the relations of the item to other items.
     */
    getRelations(): Promise<ItemRelations | null>;
    private _guid;
    /**
     * Gets the GUID of the item.
     */
    getGuid(): Promise<string | null>;
    private _category;
    /**
     * Gets the category of the item.
     */
    getCategory(): Promise<string | null>;
    private _geometry;
    getGeometry(): Promise<ItemGeometry | null>;
    /**
     * Gets all the data of the item.
     */
    getData(collector?: number[]): Promise<{
        [x: string]: any;
    }>;
}

/**
 * Interface representing the attributes of an item in a Fragments model.
 */
export declare interface ItemAttribute {
    /** The value of the attribute, which can be any type */
    value: any;
    /** Optional type identifier for the attribute value */
    type?: string;
}

/**
 * Represents a collection of attributes for an item in a Fragments model.
 * This class extends the Map class to provide additional functionality for managing attributes.
 */
declare class ItemAttributes extends Map<string, AttributeData> {
    /**
     * A map of local IDs to their corresponding attribute changes.
     * This is used to track changes to the attributes over time.
     */
    tracker: Map<number, AttrsChange> | null;
    /**
     * The local ID of the item.
     */
    localId: number;
    /**
     * Gets the attributes as a plain javascript object.
     */
    get object(): Record<string, any>;
    /**
     * Creates a new ItemAttributes instance.
     * @param localId - The local ID of the item.
     * @param iterable - An optional iterable of key-value pairs to initialize the map with.
     */
    constructor(localId: number, iterable?: Iterable<readonly [string, AttributeData]> | null | undefined);
    /**
     * A function that acts as a guard for adding items to the set.
     * It determines whether a given value should be allowed to be added to the set.
     *
     * @param key - The key of the entry to be checked against the guard.
     * @param value - The value of the entry to be checked against the guard.
     * @returns A boolean indicating whether the value should be allowed to be added to the set.
     *          By default, this function always returns true, allowing all values to be added.
     *          You can override this behavior by providing a custom implementation.
     */
    guard: (key: string, value: AttributeData) => boolean;
    /**
     * Sets an attribute in the map.
     * @param key - The key of the attribute to set.
     * @param attr - The attribute data to set.
     * @returns The updated map.
     */
    set(key: string, attr: AttributeData): this;
    /**
     * Sets the value of an attribute in the map.
     * @param key - The key of the attribute to set.
     * @param value - The value of the attribute to set.
     * @returns The updated map.
     */
    setValue(key: string, value: any): this;
    /**
     * Sets the type of an attribute in the map.
     * @param key - The key of the attribute to set.
     * @param type - The type of the attribute to set.
     * @returns The updated map.
     */
    setType(key: string, type: number): this;
    /**
     * Deletes an attribute from the map.
     * @param key - The key of the attribute to delete.
     * @returns The updated map.
     */
    delete(key: string): boolean;
    /**
     * Gets the value of an attribute from the map.
     * @param key - The key of the attribute to get.
     */
    getValue(key: string): any;
    /**
     * Gets the type of an attribute from the map.
     * @param key - The key of the attribute to get.
     */
    getType(key: string): number | undefined;
}

/**
 * Enum representing the configuration class for an item in a Fragments model.
 */
export declare enum ItemConfigClass {
    /** Represents the visibility configuration for an item */
    VISIBLE = 0
}

/**
 * Interface representing the data of an item in a Fragments model.
 */
export declare interface ItemData {
    [name: string]: ItemAttribute | ItemData[];
}

/**
 * Represents the geometry of an item in a Fragments model.
 */
declare class ItemGeometry {
    /**
     * The model that the geometry belongs to.
     */
    readonly model: FragmentsModel;
    /**
     * The local ID of the item.
     */
    localId: number;
    /**
     * Creates a new ItemGeometry instance.
     * @param model - The model that the geometry belongs to.
     * @param localId - The local ID of the item.
     */
    constructor(model: FragmentsModel, localId: number);
    get(): Promise<MeshData[]>;
    private _indices;
    /**
     * Gets the indices of the item.
     */
    getIndices(): Promise<Uint8Array[] | Uint16Array[] | Uint32Array[] | null>;
    private _transform;
    /**
     * Gets the transform of the item.
     */
    getTransform(): Promise<THREE.Matrix4[] | null>;
    private _normals;
    /**
     * Gets the normals of the item.
     */
    getNormals(): Promise<Int16Array[] | null>;
    private _positions;
    /**
     * Gets the positions of the item.
     */
    getPositions(): Promise<Float32Array[] | Float64Array[] | null>;
    private _vertices;
    /**
     * Gets the vertices of the item.
     */
    getVertices(): Promise<THREE.Vector3[][] | null>;
    private _triangles;
    /**
     * Gets the triangles of the item.
     */
    getTriangles(): Promise<THREE.Triangle[][] | null>;
    private _position;
    /**
     * Gets the position of the item.
     */
    getPosition(): Promise<THREE.Vector3[] | null>;
    private _box;
    /**
     * Gets the box of the item.
     */
    getBox(): Promise<THREE.Box3[] | null>;
    /**
     * Sets the visibility of the item.
     * @param visible - Whether the item should be visible.
     */
    setVisibility(visible: boolean): Promise<void>;
    /**
     * Gets the visibility of the item.
     */
    getVisibility(): Promise<boolean>;
}

/**
 * Union type representing all possible item information types.
 */
export declare type ItemInformationType = "data" | "attributes" | "relations" | "guid" | "category" | "geometry" | "visibility" | "highlight" | "mergedBoxes" | "children";

/**
 * A class that extends Map to store and manage relations between items in a Fragments model.
 * Each relation is stored as a key-value pair where the key is a string identifier and
 * the value is a Set of item IDs that are related through that relation.
 */
declare class ItemRelations extends Map<string, Set<number>> {
    /**
     * A map that tracks the changes to the relations of the item.
     */
    tracker: Map<number, RelsChange> | null;
    /**
     * The local ID of the item.
     */
    localId: number;
    private get itemChanges();
    /**
     * Creates a new ItemRelations instance.
     * @param localId - The local ID of the item.
     * @param iterable - An optional iterable of key-value pairs to initialize the map with.
     */
    constructor(localId: number, iterable?: Iterable<readonly [string, Set<number>]> | null | undefined);
    /**
     * A function that acts as a guard for adding items to the set.
     * It determines whether a given value should be allowed to be added to the set.
     *
     * @param key - The key of the entry to be checked against the guard.
     * @param value - The value of the entry to be checked against the guard.
     * @returns A boolean indicating whether the value should be allowed to be added to the set.
     *          By default, this function always returns true, allowing all values to be added.
     *          You can override this behavior by providing a custom implementation.
     */
    guard: (key: string, value: Set<number>) => boolean;
    /**
     * Sets a new relation in the map.
     * @param key - The key of the relation.
     * @param value - The value of the relation.
     * @returns The ItemRelations instance.
     */
    set(key: string, value: Set<number>): this;
    /**
     * Adds a new item to a target relation.
     * @param key - The key of the relation.
     * @param item - The item to add to the relation.
     */
    add(key: string, item: number): boolean;
    /**
     * Removes an item from a target relation.
     * @param key - The key of the relation.
     * @param item - The item to remove from the relation.
     * @returns A boolean indicating whether the item was removed from the relation.
     */
    remove(key: string, item: number): boolean;
    /**
     * Deletes a relation from the map.
     * @param key - The key of the relation to delete.
     */
    delete(key: string): boolean;
    /**
     * An event handler that is called when items are requested.
     */
    onItemsRequested: ((ids: number[], includeRelations?: boolean) => Promise<Item[]>) | null;
    /**
     * Gets the items of a relation.
     * @param key - The key of the relation.
     */
    getItems(key: string): Promise<Item[] | null>;
}

/**
 * Interface representing the configuration for item data in a Fragments model.
 */
export declare interface ItemsDataConfig {
    /**
     * An array of attribute names to include in the item data.
     */
    attributes?: string[];
    /**
     * A boolean indicating whether to include default attributes in the item data.
     */
    attributesDefault: boolean;
    /**
     * A record of relation names to their configuration.
     */
    relations?: Record<string, {
        attributes: boolean;
        relations: boolean;
    }>;
    /**
     * The default configuration for relations.
     */
    relationsDefault: {
        attributes: boolean;
        relations: boolean;
    };
}

/**
 * Union type representing all possible item selection types.
 */
export declare type ItemSelectionType = "withCondition" | "ofCategory" | "withGeometry" | "children" | "withVisiblity" | "highlighted";

export declare type ItemsQueryParams = {
    categories?: RegExp[];
    attributes?: {
        aggregation?: QueryAggregation;
        queries: GetItemsByAttributeParams[];
    };
    relation?: {
        name: string;
        query?: ItemsQueryParams;
    };
};

/**
 * The maximum value for a 2-byte unsigned integer.
 */
export declare const limitOf2Bytes = 65536;

declare class LODGeometry extends THREE.InstancedBufferGeometry {
    isLODGeometry: boolean;
    isFiltered(): boolean;
    constructor();
    computeBoundingBox(): void;
    applyMatrix4(matrix: THREE.Matrix4): this;
    computeBoundingSphere(): void;
    getItemFilter(): THREE.InstancedBufferAttribute;
    getItemLast(): THREE.InterleavedBufferAttribute;
    getItemFirst(): THREE.InterleavedBufferAttribute;
    private applyTransformToBuffers;
    private updateBounds;
}

declare class LODManager {
    private _materials;
    private readonly white;
    constructor(materials: MaterialManager);
    createMesh(geometry: THREE.BufferGeometry, request: any): LODMesh;
    updateVisibility(mesh: LODMesh, status: any): void;
    processMesh(mesh: BIMMesh, request: any): void;
    private deleteAttributeEvent;
}

declare class LodMaterial extends THREE.ShaderMaterial {
    readonly isLodMaterial = true;
    readonly isLineMaterial = true;
    get lodSize(): THREE.Vector2;
    set lodColor(color: THREE.Color);
    set lodSize(value: THREE.Vector2);
    get lodColor(): THREE.Color;
    constructor(parameters: LineMaterialParameters);
}

declare class LODMesh extends THREE.Mesh {
    geometry: LODGeometry;
    material: LodMaterial[];
    constructor(geometry: LODGeometry, material: LodMaterial[]);
}

/**
 * Interface representing the result of an information query for a specific item type.
 * @template T - The type of item information to query.
 */
export declare interface MappedInformationResult {
    /**
     * An array of attribute records for the item.
     * Each record contains a string key and a value of type any.
     */
    attributes: (Record<string, {
        value: any;
        type?: string;
    }> | null)[];
    /**
     * An array of category strings for the item.
     */
    category: string[];
    /**
     * An array of child item IDs for the item.
     */
    children: number[];
    /**
     * An array of data records for the item.
     */
    data: ItemData[];
    /**
     * An array of geometry data for the item.
     */
    geometry: MeshData[][];
    /**
     * An array of GUID strings for the item.
     */
    guid: (string | null)[];
    /**
     * An array of highlight materials for the item.
     */
    highlight: MaterialDefinition[];
    /**
     * An array of relation records for the item.
     */
    relations: (Record<string, number[]> | null)[];
    /**
     * An array of visibility flags for the item.
     */
    visibility: boolean[];
    /**
     * The merged bounding box for the item.
     */
    mergedBoxes: THREE.Box3;
}

/**
 * Interface representing the input for a result query in a Fragments model.
 * @template T - The type of item information to query.
 */
export declare interface MappedResultInput {
    /**
     * A partial configuration for item data.
     */
    data: Partial<ItemsDataConfig>;
}

/**
 * Interface representing the input for a selection query in a Fragments model.
 */
export declare interface MappedSelectionInput {
    /**
     * The category of the item to select.
     */
    ofCategory: string;
}

export declare class Material {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Material;
    r(): number;
    mutate_r(value: number): boolean;
    g(): number;
    mutate_g(value: number): boolean;
    b(): number;
    mutate_b(value: number): boolean;
    a(): number;
    mutate_a(value: number): boolean;
    renderedFaces(): RenderedFaces;
    mutate_rendered_faces(value: RenderedFaces): boolean;
    stroke(): Stroke;
    mutate_stroke(value: Stroke): boolean;
    static sizeOf(): number;
    static createMaterial(builder: flatbuffers.Builder, r: number, g: number, b: number, a: number, rendered_faces: RenderedFaces, stroke: Stroke): flatbuffers.Offset;
}

export declare interface MaterialData {
    data: MaterialDefinition;
    transparent?: boolean;
    instancing?: boolean;
}

/**
 * Interface representing the definition of a material.
 */
export declare type MaterialDefinition = {
    /** The color of the material */
    color: THREE.Color;
    /** The faces rendered by the material */
    renderedFaces: RenderedFaces;
    /** The opacity of the material */
    opacity: number;
    /** Whether the material is transparent */
    transparent: boolean;
    /** An optional custom ID for the material */
    customId?: string;
    /**
     * Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write
     * will also be implicitly disabled.
     * @default true
     */
    depthTest?: boolean;
};

declare class MaterialManager {
    readonly list: DataMap<number, BIMMaterial>;
    private readonly _modelMaterialMapping;
    private readonly _definitions;
    private readonly _idGenerator;
    private readonly white;
    static resetColors(definitions: MaterialDefinition[]): void;
    dispose(modelId: string): void;
    get(data: MaterialDefinition, request: any): BIMMaterial;
    addDefinitions(modelID: string, materials: MaterialDefinition[]): void;
    createHighlights(mesh: BIMMesh, request: any): THREE.Material[];
    getFromRequest(request: any): BIMMaterial;
    private newLODMaterial;
    private getParameters;
    private new;
    private addMaterialToModel;
    private processHighlight;
    private getUniqueMaterial;
}

/**
 * Interface representing the data of a mesh.
 */
export declare type MeshData = {
    /** The transformation matrix of the mesh */
    transform: THREE.Matrix4;
    /** The indices of the mesh */
    indices?: Uint8Array | Uint16Array | Uint32Array;
    /** The positions of the mesh */
    positions?: Float32Array | Float64Array;
    /** The normals of the mesh */
    normals?: Int16Array;
};

export declare class Meshes {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Meshes;
    static getRootAsMeshes(bb: flatbuffers.ByteBuffer, obj?: Meshes): Meshes;
    static getSizePrefixedRootAsMeshes(bb: flatbuffers.ByteBuffer, obj?: Meshes): Meshes;
    coordinates(obj?: Transform): Transform | null;
    meshesItems(index: number): number | null;
    meshesItemsLength(): number;
    meshesItemsArray(): Uint32Array | null;
    samples(index: number, obj?: Sample): Sample | null;
    samplesLength(): number;
    representations(index: number, obj?: Representation): Representation | null;
    representationsLength(): number;
    materials(index: number, obj?: Material): Material | null;
    materialsLength(): number;
    circleExtrusions(index: number, obj?: CircleExtrusion): CircleExtrusion | null;
    circleExtrusionsLength(): number;
    shells(index: number, obj?: Shell): Shell | null;
    shellsLength(): number;
    localTransforms(index: number, obj?: Transform): Transform | null;
    localTransformsLength(): number;
    globalTransforms(index: number, obj?: Transform): Transform | null;
    globalTransformsLength(): number;
    static startMeshes(builder: flatbuffers.Builder): void;
    static addCoordinates(builder: flatbuffers.Builder, coordinatesOffset: flatbuffers.Offset): void;
    static addMeshesItems(builder: flatbuffers.Builder, meshesItemsOffset: flatbuffers.Offset): void;
    static createMeshesItemsVector(builder: flatbuffers.Builder, data: number[] | Uint32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createMeshesItemsVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startMeshesItemsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addSamples(builder: flatbuffers.Builder, samplesOffset: flatbuffers.Offset): void;
    static startSamplesVector(builder: flatbuffers.Builder, numElems: number): void;
    static addRepresentations(builder: flatbuffers.Builder, representationsOffset: flatbuffers.Offset): void;
    static startRepresentationsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addMaterials(builder: flatbuffers.Builder, materialsOffset: flatbuffers.Offset): void;
    static startMaterialsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addCircleExtrusions(builder: flatbuffers.Builder, circleExtrusionsOffset: flatbuffers.Offset): void;
    static createCircleExtrusionsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startCircleExtrusionsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addShells(builder: flatbuffers.Builder, shellsOffset: flatbuffers.Offset): void;
    static createShellsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startShellsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addLocalTransforms(builder: flatbuffers.Builder, localTransformsOffset: flatbuffers.Offset): void;
    static startLocalTransformsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addGlobalTransforms(builder: flatbuffers.Builder, globalTransformsOffset: flatbuffers.Offset): void;
    static startGlobalTransformsVector(builder: flatbuffers.Builder, numElems: number): void;
    static endMeshes(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createMeshes(builder: flatbuffers.Builder, coordinatesOffset: flatbuffers.Offset, meshesItemsOffset: flatbuffers.Offset, samplesOffset: flatbuffers.Offset, representationsOffset: flatbuffers.Offset, materialsOffset: flatbuffers.Offset, circleExtrusionsOffset: flatbuffers.Offset, shellsOffset: flatbuffers.Offset, localTransformsOffset: flatbuffers.Offset, globalTransformsOffset: flatbuffers.Offset): flatbuffers.Offset;
}

/**
 * A class that manages the creation and updating of meshes in a Fragments model.
 */
declare class MeshManager {
    /**
     * A map of FragmentsModel instances by their model ID.
     */
    readonly list: DataMap<string, FragmentsModel>;
    readonly materials: MaterialManager;
    readonly lod: LODManager;
    readonly requests: RequestsManager;
    private readonly updateThreshold;
    private _updateFinished;
    private _onUpdate;
    constructor(onUpdate: () => void);
    forceUpdateFinish(rate?: number): Promise<void>;
    update(): void;
    private setTileData;
    private processTileRequest;
    private createMesh;
    private setupBoundings;
    private create;
    private updateStatus;
    private cleanAttributeMemory;
    private setPositions;
    private setFaceIds;
    private setIndex;
    private setNormals;
    private setItemIds;
    private deleteAttribute;
    private setMeshData;
}

export declare class Model {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Model;
    static getRootAsModel(bb: flatbuffers.ByteBuffer, obj?: Model): Model;
    static getSizePrefixedRootAsModel(bb: flatbuffers.ByteBuffer, obj?: Model): Model;
    static bufferHasIdentifier(bb: flatbuffers.ByteBuffer): boolean;
    metadata(): string | null;
    metadata(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;
    guids(index: number): string;
    guids(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;
    guidsLength(): number;
    guidsItems(index: number): number | null;
    guidsItemsLength(): number;
    guidsItemsArray(): Uint32Array | null;
    maxLocalId(): number;
    mutate_max_local_id(value: number): boolean;
    localIds(index: number): number | null;
    localIdsLength(): number;
    localIdsArray(): Uint32Array | null;
    categories(index: number): string;
    categories(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;
    categoriesLength(): number;
    meshes(obj?: Meshes): Meshes | null;
    attributes(index: number, obj?: Attribute): Attribute | null;
    attributesLength(): number;
    relations(index: number, obj?: Relation): Relation | null;
    relationsLength(): number;
    relationsItems(index: number): number | null;
    relationsItemsLength(): number;
    relationsItemsArray(): Int32Array | null;
    guid(): string | null;
    guid(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;
    spatialStructure(obj?: SpatialStructure): SpatialStructure | null;
    alignments(index: number, obj?: Alignment): Alignment | null;
    alignmentsLength(): number;
    geometries(obj?: Geometries): Geometries | null;
    uniqueAttributes(index: number): string;
    uniqueAttributes(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;
    uniqueAttributesLength(): number;
    relationNames(index: number): string;
    relationNames(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;
    relationNamesLength(): number;
    static startModel(builder: flatbuffers.Builder): void;
    static addMetadata(builder: flatbuffers.Builder, metadataOffset: flatbuffers.Offset): void;
    static addGuids(builder: flatbuffers.Builder, guidsOffset: flatbuffers.Offset): void;
    static createGuidsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startGuidsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addGuidsItems(builder: flatbuffers.Builder, guidsItemsOffset: flatbuffers.Offset): void;
    static createGuidsItemsVector(builder: flatbuffers.Builder, data: number[] | Uint32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createGuidsItemsVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startGuidsItemsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addMaxLocalId(builder: flatbuffers.Builder, maxLocalId: number): void;
    static addLocalIds(builder: flatbuffers.Builder, localIdsOffset: flatbuffers.Offset): void;
    static createLocalIdsVector(builder: flatbuffers.Builder, data: number[] | Uint32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createLocalIdsVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startLocalIdsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addCategories(builder: flatbuffers.Builder, categoriesOffset: flatbuffers.Offset): void;
    static createCategoriesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startCategoriesVector(builder: flatbuffers.Builder, numElems: number): void;
    static addMeshes(builder: flatbuffers.Builder, meshesOffset: flatbuffers.Offset): void;
    static addAttributes(builder: flatbuffers.Builder, attributesOffset: flatbuffers.Offset): void;
    static createAttributesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startAttributesVector(builder: flatbuffers.Builder, numElems: number): void;
    static addRelations(builder: flatbuffers.Builder, relationsOffset: flatbuffers.Offset): void;
    static createRelationsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startRelationsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addRelationsItems(builder: flatbuffers.Builder, relationsItemsOffset: flatbuffers.Offset): void;
    static createRelationsItemsVector(builder: flatbuffers.Builder, data: number[] | Int32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createRelationsItemsVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startRelationsItemsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addGuid(builder: flatbuffers.Builder, guidOffset: flatbuffers.Offset): void;
    static addSpatialStructure(builder: flatbuffers.Builder, spatialStructureOffset: flatbuffers.Offset): void;
    static addAlignments(builder: flatbuffers.Builder, alignmentsOffset: flatbuffers.Offset): void;
    static createAlignmentsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startAlignmentsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addGeometries(builder: flatbuffers.Builder, geometriesOffset: flatbuffers.Offset): void;
    static addUniqueAttributes(builder: flatbuffers.Builder, uniqueAttributesOffset: flatbuffers.Offset): void;
    static createUniqueAttributesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startUniqueAttributesVector(builder: flatbuffers.Builder, numElems: number): void;
    static addRelationNames(builder: flatbuffers.Builder, relationNamesOffset: flatbuffers.Offset): void;
    static createRelationNamesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startRelationNamesVector(builder: flatbuffers.Builder, numElems: number): void;
    static endModel(builder: flatbuffers.Builder): flatbuffers.Offset;
    static finishModelBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset): void;
    static finishSizePrefixedModelBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset): void;
}

/**
 * Interface representing a map of model IDs to their corresponding local IDs.
 */
export declare interface ModelIdMap {
    [key: string]: number[] | undefined;
}

export declare interface ModelSection {
    buffer: Float32Array;
    index: number;
    fillsIndices: number[];
}

export declare enum MultiThreadingRequestClass {
    CREATE_MODEL = 0,
    DELETE_MODEL = 1,
    EXECUTE = 2,
    RAYCAST = 3,
    FETCH_BOXES = 4,
    REFRESH_VIEW = 5,
    RECOMPUTE_MESHES = 6,
    CREATE_MATERIAL = 7,
    THROW_ERROR = 8
}

export declare enum ObjectClass {
    LINE = 0,
    SHELL = 1
}

export declare interface ProcessData {
    id?: string;
    readFromCallback?: boolean;
    bytes?: Uint8Array;
    readCallback?: any;
    raw?: boolean;
    progressCallback?: (progress: number, data: ProgressData) => void;
}

export declare interface ProgressData {
    process: "geometries" | "attributes" | "relations" | "conversion";
    state: "start" | "inProgress" | "finish";
    class?: string;
    entitiesProcessed?: number;
}

export declare type QueryAggregation = "exclusive" | "inclusive";

/**
 * Interface representing the data for a raycast operation.
 */
export declare interface RaycastData {
    /** The camera used for the raycast */
    camera: THREE.PerspectiveCamera | THREE.OrthographicCamera;
    /** The mouse position */
    mouse: THREE.Vector2;
    /** The DOM element where the scene is rendered */
    dom: HTMLCanvasElement;
}

/**
 * Interface representing the result of a raycast operation.
 */
export declare interface RaycastResult {
    /** The local ID of the item */
    localId: number;
    /** The item ID */
    itemId: number;
    /** The point of the raycast */
    point: THREE.Vector3;
    /** The normal of the raycast */
    normal?: THREE.Vector3;
    /** The distance of the raycast */
    distance: number;
    /** The distance of the raycast from the ray origin */
    rayDistance?: number;
    /** The object that was hit */
    object: THREE.Object3D;
    /** The Fragments model that was hit */
    fragments: FragmentsModel;
    /** The ray used for the raycast */
    ray?: THREE.Ray;
    /** The frustum used for the raycast */
    frustum: THREE.Frustum;
    /** The representation class of the raycast */
    representationClass: RepresentationClass;
    /** The snapping class of the raycast */
    snappingClass: SnappingClass;
    /** The first edge of the snapped edge */
    snappedEdgeP1?: THREE.Vector3;
    /** The second edge of the snapped edge */
    snappedEdgeP2?: THREE.Vector3;
    /** The points of the raycasted face */
    facePoints?: Float32Array;
    /** The indices of the raycasted face */
    faceIndices?: Uint16Array;
}

/**
 * Interface representing the data for a rectangle raycast operation.
 */
export declare interface RectangleRaycastData {
    /** The camera used for the raycast */
    camera: THREE.PerspectiveCamera | THREE.OrthographicCamera;
    /** The DOM element where the scene is rendered */
    dom: HTMLCanvasElement;
    /** The top left corner of the rectangle */
    topLeft: THREE.Vector2;
    /** The bottom right corner of the rectangle */
    bottomRight: THREE.Vector2;
    /** Whether the rectangle is fully included in the view */
    fullyIncluded: boolean;
}

/**
 * Interface representing the result of a rectangle raycast operation.
 */
export declare interface RectangleRaycastResult {
    /** The local IDs of the items */
    localIds: number[];
    /** The Fragments model that was hit */
    fragments: FragmentsModel;
}

export declare class Relation {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Relation;
    static getRootAsRelation(bb: flatbuffers.ByteBuffer, obj?: Relation): Relation;
    static getSizePrefixedRootAsRelation(bb: flatbuffers.ByteBuffer, obj?: Relation): Relation;
    data(index: number): string;
    data(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;
    dataLength(): number;
    static startRelation(builder: flatbuffers.Builder): void;
    static addData(builder: flatbuffers.Builder, dataOffset: flatbuffers.Offset): void;
    static createDataVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startDataVector(builder: flatbuffers.Builder, numElems: number): void;
    static endRelation(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createRelation(builder: flatbuffers.Builder, dataOffset: flatbuffers.Offset): flatbuffers.Offset;
}

/**
 * Union type representing all possible relation change types.
 */
export declare type RelsChange = RelsModifyChange;

/**
 * Interface representing a change event when relations are modified in a model item.
 */
export declare interface RelsModifyChange {
    /** Indicates this is a "modified" type change */
    type: "modified";
    /** Record containing the newly added relation data */
    added: Record<string, Set<number>>;
    /** Set of strings representing the deleted relation keys */
    deleted: Set<string>;
    /** Record containing the removed relation data */
    removed: Record<string, Set<number>>;
    /** Record containing the modified relation data */
    modified: Record<string, Set<number>>;
}

export declare enum RenderedFaces {
    ONE = 0,
    TWO = 1
}

export declare class Representation {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Representation;
    id(): number;
    mutate_id(value: number): boolean;
    bbox(obj?: BoundingBox): BoundingBox | null;
    representationClass(): RepresentationClass;
    mutate_representation_class(value: RepresentationClass): boolean;
    static sizeOf(): number;
    static createRepresentation(builder: flatbuffers.Builder, id: number, bbox_min_x: number, bbox_min_y: number, bbox_min_z: number, bbox_max_x: number, bbox_max_y: number, bbox_max_z: number, representation_class: RepresentationClass): flatbuffers.Offset;
}

export declare enum RepresentationClass {
    NONE = 0,
    SHELL = 1,
    CIRCLE_EXTRUSION = 2
}

/**
 * Manages a list of requests for the MeshManager.
 */
declare class RequestsManager {
    /**
     * List of requests.
     */
    readonly list: any[];
    /**
     * Checks if there are any pending requests.
     *
     * @returns `true` if there are pending requests, otherwise `false`.
     */
    get arePending(): boolean;
    /**
     * Callback function to be invoked when a request with `TileRequestClass.FINISH` is added.
     */
    onFinish: () => void;
    handleRequest(meshes: MeshManager, request: any): Promise<void>;
    /**
     * Adds an array of requests to the list. If a request with `TileRequestClass.FINISH` is added,
     * the `onFinishRequest` callback is invoked.
     *
     * @param requests - Array of requests to be added.
     */
    add(requests: any[]): void;
    /**
     * Cleans the list by removing requests with the specified model ID and `TileRequestClass.FINISH`.
     *
     * @param modelID - The model ID to filter requests by.
     */
    clean(modelID: string): void;
    /**
     * Inserts a request into the list based on its `tileRequestClass`.
     *
     * @param request - The request to be inserted.
     * @returns `true` if the request was successfully inserted, otherwise `false`.
     */
    insert(request: any): boolean;
}

/**
 * Union type representing all possible result input types.
 */
export declare type ResultInputType<T extends ItemInformationType> = T extends keyof MappedResultInput ? MappedResultInput[T] : never;

export declare class Sample {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Sample;
    item(): number;
    mutate_item(value: number): boolean;
    material(): number;
    mutate_material(value: number): boolean;
    representation(): number;
    mutate_representation(value: number): boolean;
    localTransform(): number;
    mutate_local_transform(value: number): boolean;
    static sizeOf(): number;
    static createSample(builder: flatbuffers.Builder, item: number, material: number, representation: number, local_transform: number): flatbuffers.Offset;
}

/**
 * Union type representing all possible selection input types.
 */
export declare type SelectionInputType<T extends ItemSelectionType> = T extends keyof MappedSelectionInput ? MappedSelectionInput[T] : never;

export declare class Shell {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Shell;
    static getRootAsShell(bb: flatbuffers.ByteBuffer, obj?: Shell): Shell;
    static getSizePrefixedRootAsShell(bb: flatbuffers.ByteBuffer, obj?: Shell): Shell;
    profiles(index: number, obj?: ShellProfile): ShellProfile | null;
    profilesLength(): number;
    holes(index: number, obj?: ShellHole): ShellHole | null;
    holesLength(): number;
    points(index: number, obj?: FloatVector): FloatVector | null;
    pointsLength(): number;
    bigProfiles(index: number, obj?: BigShellProfile): BigShellProfile | null;
    bigProfilesLength(): number;
    bigHoles(index: number, obj?: BigShellHole): BigShellHole | null;
    bigHolesLength(): number;
    type(): ShellType;
    mutate_type(value: ShellType): boolean;
    static startShell(builder: flatbuffers.Builder): void;
    static addProfiles(builder: flatbuffers.Builder, profilesOffset: flatbuffers.Offset): void;
    static createProfilesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startProfilesVector(builder: flatbuffers.Builder, numElems: number): void;
    static addHoles(builder: flatbuffers.Builder, holesOffset: flatbuffers.Offset): void;
    static createHolesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startHolesVector(builder: flatbuffers.Builder, numElems: number): void;
    static addPoints(builder: flatbuffers.Builder, pointsOffset: flatbuffers.Offset): void;
    static startPointsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addBigProfiles(builder: flatbuffers.Builder, bigProfilesOffset: flatbuffers.Offset): void;
    static createBigProfilesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startBigProfilesVector(builder: flatbuffers.Builder, numElems: number): void;
    static addBigHoles(builder: flatbuffers.Builder, bigHolesOffset: flatbuffers.Offset): void;
    static createBigHolesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startBigHolesVector(builder: flatbuffers.Builder, numElems: number): void;
    static addType(builder: flatbuffers.Builder, type: ShellType): void;
    static endShell(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createShell(builder: flatbuffers.Builder, profilesOffset: flatbuffers.Offset, holesOffset: flatbuffers.Offset, pointsOffset: flatbuffers.Offset, bigProfilesOffset: flatbuffers.Offset, bigHolesOffset: flatbuffers.Offset, type: ShellType): flatbuffers.Offset;
}

export declare class ShellHole {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): ShellHole;
    static getRootAsShellHole(bb: flatbuffers.ByteBuffer, obj?: ShellHole): ShellHole;
    static getSizePrefixedRootAsShellHole(bb: flatbuffers.ByteBuffer, obj?: ShellHole): ShellHole;
    indices(index: number): number | null;
    indicesLength(): number;
    indicesArray(): Uint16Array | null;
    profileId(): number;
    mutate_profile_id(value: number): boolean;
    static startShellHole(builder: flatbuffers.Builder): void;
    static addIndices(builder: flatbuffers.Builder, indicesOffset: flatbuffers.Offset): void;
    static createIndicesVector(builder: flatbuffers.Builder, data: number[] | Uint16Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createIndicesVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startIndicesVector(builder: flatbuffers.Builder, numElems: number): void;
    static addProfileId(builder: flatbuffers.Builder, profileId: number): void;
    static endShellHole(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createShellHole(builder: flatbuffers.Builder, indicesOffset: flatbuffers.Offset, profileId: number): flatbuffers.Offset;
}

export declare class ShellProfile {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): ShellProfile;
    static getRootAsShellProfile(bb: flatbuffers.ByteBuffer, obj?: ShellProfile): ShellProfile;
    static getSizePrefixedRootAsShellProfile(bb: flatbuffers.ByteBuffer, obj?: ShellProfile): ShellProfile;
    indices(index: number): number | null;
    indicesLength(): number;
    indicesArray(): Uint16Array | null;
    static startShellProfile(builder: flatbuffers.Builder): void;
    static addIndices(builder: flatbuffers.Builder, indicesOffset: flatbuffers.Offset): void;
    static createIndicesVector(builder: flatbuffers.Builder, data: number[] | Uint16Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createIndicesVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startIndicesVector(builder: flatbuffers.Builder, numElems: number): void;
    static endShellProfile(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createShellProfile(builder: flatbuffers.Builder, indicesOffset: flatbuffers.Offset): flatbuffers.Offset;
}

export declare enum ShellType {
    NONE = 0,
    BIG = 1
}

/**
 * The main class for managing a 3D model loaded from a fragments file in a single thread. It's designed for easy data querying in the backend, so all the 3D visualization logic is not present.
 */
export declare class SingleThreadedFragmentsModel {
    private readonly _modelId;
    private _virtualModel;
    /**
     * The ID of the model.
     */
    get modelId(): string;
    /**
     * The constructor of the fragments model.
     */
    constructor(modelId: string, modelData: Uint8Array, raw?: boolean);
    /**
     * Dispose the model. Use this when you're done with the model.
     * If you use the {@link FragmentsModels.dispose} method, this will be called automatically for all models.
     */
    dispose(): void;
    /**
     * Get the spatial structure of the model.
     */
    getSpatialStructure(): SpatialTreeItem;
    /**
     * Get the local IDs corresponding to the specified GUIDs.
     * @param guids - Array of GUIDs to look up.
     */
    getLocalIdsByGuids(guids: string[]): (number | null)[];
    /**
     * Get all the categories of the model.
     */
    getCategories(): string[];
    /**
     * Get all the items of the model that have geometry.
     */
    getItemsWithGeometry(): number[];
    /**
     * Get the metadata of the model.
     */
    getMetadata<T extends Record<string, any> = Record<string, any>>(): T;
    /**
     * Get the GUIDs corresponding to the specified local IDs.
     * @param localIds - Array of local IDs to look up.
     */
    getGuidsByLocalIds(localIds: number[]): (string | null)[];
    /**
     * Get the buffer of the model.
     * @param raw - Whether to get the raw buffer. If false, it will be compressed.
     */
    getBuffer(raw?: boolean): ArrayBufferLike;
    /**
     * Get all the items of the model that belong to the specified category.
     * @param category - The category to look up.
     */
    getItemsOfCategories(categories: RegExp[]): {
        [category: string]: number[];
    };
    /**
     * Get the maximum local ID of the model.
     */
    getMaxLocalId(): number;
    /**
     * Get the spatial structure children of the specified items.
     * @param ids - The IDs of the items to look up.
     */
    getItemsChildren(ids: Identifier[]): void;
    /**
     * Get all the data of the specified items.
     * @param ids - The IDs of the items to look up.
     * @param config - The configuration of the items data.
     */
    getItemsData(ids: number[], config?: Partial<ItemsDataConfig>): ItemData[];
    /**
     * Get the absolute positions of the specified items.
     * @param localIds - The local IDs of the items to look up.
     */
    getPositions(localIds: number[]): {
        x: number;
        y: number;
        z: number;
    }[];
    /**
     * Gets coordinates of the model.
     */
    getCoordinates(): number[];
}

/**
 * Enum representing the snapping class for a raycast operation.
 */
export declare enum SnappingClass {
    /** Represents a point snapping class */
    POINT = 0,
    /** Represents a line snapping class */
    LINE = 1,
    /** Represents a face snapping class */
    FACE = 2
}

export declare interface SnappingRaycastData extends RaycastData {
    snappingClasses: SnappingClass[];
}

export declare class SpatialStructure {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): SpatialStructure;
    static getRootAsSpatialStructure(bb: flatbuffers.ByteBuffer, obj?: SpatialStructure): SpatialStructure;
    static getSizePrefixedRootAsSpatialStructure(bb: flatbuffers.ByteBuffer, obj?: SpatialStructure): SpatialStructure;
    localId(): number | null;
    mutate_local_id(value: number): boolean;
    category(): string | null;
    category(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;
    children(index: number, obj?: SpatialStructure): SpatialStructure | null;
    childrenLength(): number;
    static startSpatialStructure(builder: flatbuffers.Builder): void;
    static addLocalId(builder: flatbuffers.Builder, localId: number): void;
    static addCategory(builder: flatbuffers.Builder, categoryOffset: flatbuffers.Offset): void;
    static addChildren(builder: flatbuffers.Builder, childrenOffset: flatbuffers.Offset): void;
    static createChildrenVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startChildrenVector(builder: flatbuffers.Builder, numElems: number): void;
    static endSpatialStructure(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createSpatialStructure(builder: flatbuffers.Builder, localId: number | null, categoryOffset: flatbuffers.Offset, childrenOffset: flatbuffers.Offset): flatbuffers.Offset;
}

/**
 * Interface representing an item in a spatial tree.
 */
export declare interface SpatialTreeItem {
    /** The category of the item */
    category: string | null;
    /** The local ID of the item */
    localId: number | null;
    /** The children of the item */
    children?: SpatialTreeItem[];
}

export declare enum Stroke {
    DEFAULT = 0
}

declare type ThreadHandler = (args: any) => Promise<void> | void;

export declare enum TileRequestClass {
    UPDATE = 0,
    CREATE = 1,
    DELETE = 2,
    FINISH = 3
}

export declare class Transform {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Transform;
    position(obj?: DoubleVector): DoubleVector | null;
    xDirection(obj?: FloatVector): FloatVector | null;
    yDirection(obj?: FloatVector): FloatVector | null;
    static sizeOf(): number;
    static createTransform(builder: flatbuffers.Builder, position_x: number, position_y: number, position_z: number, x_direction_x: number, x_direction_y: number, x_direction_z: number, y_direction_x: number, y_direction_y: number, y_direction_z: number): flatbuffers.Offset;
}

/**
 * Interface representing the configuration for a virtual model.
 */
export declare interface VirtualModelConfig {
    /** Optional properties configuration for the virtual model */
    properties?: VirtualPropertiesConfig;
}

/**
 * Interface representing the configuration for virtual properties in a Fragments model.
 */
export declare interface VirtualPropertiesConfig {
    /** An array of extra relations to include in the virtual model */
    extraRelations?: {
        category: string;
        relation: string;
        inverseName: string;
    }[];
}

export declare class Wire {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Wire;
    p1(obj?: FloatVector): FloatVector | null;
    p2(obj?: FloatVector): FloatVector | null;
    static sizeOf(): number;
    static createWire(builder: flatbuffers.Builder, p1_x: number, p1_y: number, p1_z: number, p2_x: number, p2_y: number, p2_z: number): flatbuffers.Offset;
}

export declare class WireSet {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): WireSet;
    static getRootAsWireSet(bb: flatbuffers.ByteBuffer, obj?: WireSet): WireSet;
    static getSizePrefixedRootAsWireSet(bb: flatbuffers.ByteBuffer, obj?: WireSet): WireSet;
    ps(index: number, obj?: FloatVector): FloatVector | null;
    psLength(): number;
    static startWireSet(builder: flatbuffers.Builder): void;
    static addPs(builder: flatbuffers.Builder, psOffset: flatbuffers.Offset): void;
    static startPsVector(builder: flatbuffers.Builder, numElems: number): void;
    static endWireSet(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createWireSet(builder: flatbuffers.Builder, psOffset: flatbuffers.Offset): flatbuffers.Offset;
}

export { }
