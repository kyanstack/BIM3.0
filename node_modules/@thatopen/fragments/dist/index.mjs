var t,e,s,i,n,r,o,a,l,h,c,d,u,f,p,I,_,m,E,g,b,C,T,A,R,y,F,S,w,x,O,v,L,P,N,M,D,U,V,B,z,G,k,H,Y,W,j,q,Z,X,$,K,Q,J,tt,et,st,it,nt,rt=Object.defineProperty,ot=(t,e,s)=>(((t,e,s)=>{e in t?rt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s})(t,"symbol"!=typeof e?e+"":e,s),s),at=(t,e,s)=>{if(!e.has(t))throw TypeError("Cannot "+s)},lt=(t,e,s)=>(at(t,e,"read from private field"),s?s.call(t):e.get(t)),ht=(t,e,s)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,s)},ct=(t,e,s,i)=>(at(t,e,"write to private field"),i?i.call(t,s):e.set(t,s),s),dt=(t,e,s,i)=>({set _(i){ct(t,e,i,s)},get _(){return lt(t,e,i)}}),ut=(t,e,s)=>(at(t,e,"access private method"),s);import*as ft from"three";import{InstancedBufferGeometry as pt,Float32BufferAttribute as It,InstancedInterleavedBuffer as _t,InterleavedBufferAttribute as mt,WireframeGeometry as Et,Box3 as gt,Sphere as bt,Vector3 as Ct,ShaderMaterial as Tt,ShaderLib as At,UniformsUtils as Rt,Vector2 as yt,UniformsLib as Ft,Mesh as St,Vector4 as wt,Line3 as xt,Matrix4 as Ot,MathUtils as vt,BufferAttribute as Lt,Plane as Pt,Triangle as Nt,BackSide as Mt,DoubleSide as Dt,FrontSide as Ut,Ray as Vt}from"three";import*as Bt from"web-ifc";function zt(t,e){const s=Object.getPrototypeOf(t),i=Object.getOwnPropertyNames(s);for(const n of i){if("constructor"===n||"__init"===n)continue;if(n.includes("mutate_"))continue;if(n.match(/.*Array$/))continue;const i=s[n];if("function"==typeof i){const s=void 0!==t[`${n}Length`]&&void 0!==t[`${n}Array`];if(2===i.length||s){const s=t[`${n}Length`](),i=[];e[n]=i;for(let e=0;e<s;e++){const s=t[n](e);if("object"==typeof s&&null!==s&&"bb"in s){const t={};zt(s,t),i.push(t)}else i.push(s)}continue}const r=t[n]();if("object"!=typeof r||null===r){e[n]=r;continue}e[n]={},zt(r,e[n])}else e[n]=i}}const Gt={950732822:"IFCURIREFERENCE",4075327185:"IFCTIME",1209108979:"IFCTEMPERATURERATEOFCHANGEMEASURE",3457685358:"IFCSOUNDPRESSURELEVELMEASURE",4157543285:"IFCSOUNDPOWERLEVELMEASURE",2798247006:"IFCPROPERTYSETDEFINITIONSET",1790229001:"IFCPOSITIVEINTEGER",525895558:"IFCNONNEGATIVELENGTHMEASURE",1774176899:"IFCLINEINDEX",1275358634:"IFCLANGUAGEID",2541165894:"IFCDURATION",3701338814:"IFCDAYINWEEKNUMBER",2195413836:"IFCDATETIME",937566702:"IFCDATE",1683019596:"IFCCARDINALPOINTREFERENCE",2314439260:"IFCBINARY",1500781891:"IFCAREADENSITYMEASURE",3683503648:"IFCARCINDEX",4065007721:"IFCYEARNUMBER",1718600412:"IFCWARPINGMOMENTMEASURE",51269191:"IFCWARPINGCONSTANTMEASURE",2593997549:"IFCVOLUMETRICFLOWRATEMEASURE",3458127941:"IFCVOLUMEMEASURE",3345633955:"IFCVAPORPERMEABILITYMEASURE",1278329552:"IFCTORQUEMEASURE",2591213694:"IFCTIMESTAMP",2726807636:"IFCTIMEMEASURE",743184107:"IFCTHERMODYNAMICTEMPERATUREMEASURE",2016195849:"IFCTHERMALTRANSMITTANCEMEASURE",857959152:"IFCTHERMALRESISTANCEMEASURE",2281867870:"IFCTHERMALEXPANSIONCOEFFICIENTMEASURE",2645777649:"IFCTHERMALCONDUCTIVITYMEASURE",232962298:"IFCTHERMALADMITTANCEMEASURE",296282323:"IFCTEXTTRANSFORMATION",603696268:"IFCTEXTFONTNAME",3490877962:"IFCTEXTDECORATION",1460886941:"IFCTEXTALIGNMENT",2801250643:"IFCTEXT",58845555:"IFCTEMPERATUREGRADIENTMEASURE",361837227:"IFCSPECULARROUGHNESS",2757832317:"IFCSPECULAREXPONENT",3477203348:"IFCSPECIFICHEATCAPACITYMEASURE",993287707:"IFCSOUNDPRESSUREMEASURE",846465480:"IFCSOUNDPOWERMEASURE",3471399674:"IFCSOLIDANGLEMEASURE",408310005:"IFCSHEARMODULUSMEASURE",2190458107:"IFCSECTIONALAREAINTEGRALMEASURE",3467162246:"IFCSECTIONMODULUSMEASURE",2766185779:"IFCSECONDINMINUTE",3211557302:"IFCROTATIONALSTIFFNESSMEASURE",1755127002:"IFCROTATIONALMASSMEASURE",2133746277:"IFCROTATIONALFREQUENCYMEASURE",200335297:"IFCREAL",96294661:"IFCRATIOMEASURE",3972513137:"IFCRADIOACTIVITYMEASURE",3665567075:"IFCPRESSUREMEASURE",2169031380:"IFCPRESENTABLETEXT",1364037233:"IFCPOWERMEASURE",1245737093:"IFCPOSITIVERATIOMEASURE",3054510233:"IFCPOSITIVEPLANEANGLEMEASURE",2815919920:"IFCPOSITIVELENGTHMEASURE",4042175685:"IFCPLANEANGLEMEASURE",2642773653:"IFCPLANARFORCEMEASURE",2260317790:"IFCPARAMETERVALUE",929793134:"IFCPHMEASURE",2395907400:"IFCNUMERICMEASURE",2095195183:"IFCNORMALISEDRATIOMEASURE",765770214:"IFCMONTHINYEARNUMBER",2615040989:"IFCMONETARYMEASURE",3114022597:"IFCMOMENTOFINERTIAMEASURE",1648970520:"IFCMOLECULARWEIGHTMEASURE",3177669450:"IFCMOISTUREDIFFUSIVITYMEASURE",1753493141:"IFCMODULUSOFSUBGRADEREACTIONMEASURE",1052454078:"IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE",2173214787:"IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE",3341486342:"IFCMODULUSOFELASTICITYMEASURE",102610177:"IFCMINUTEINHOUR",3531705166:"IFCMASSPERLENGTHMEASURE",3124614049:"IFCMASSMEASURE",4017473158:"IFCMASSFLOWRATEMEASURE",1477762836:"IFCMASSDENSITYMEASURE",2486716878:"IFCMAGNETICFLUXMEASURE",286949696:"IFCMAGNETICFLUXDENSITYMEASURE",151039812:"IFCLUMINOUSINTENSITYMEASURE",2755797622:"IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE",2095003142:"IFCLUMINOUSFLUXMEASURE",503418787:"IFCLOGICAL",3086160713:"IFCLINEARVELOCITYMEASURE",1307019551:"IFCLINEARSTIFFNESSMEASURE",2128979029:"IFCLINEARMOMENTMEASURE",191860431:"IFCLINEARFORCEMEASURE",1243674935:"IFCLENGTHMEASURE",3258342251:"IFCLABEL",2054016361:"IFCKINEMATICVISCOSITYMEASURE",3192672207:"IFCISOTHERMALMOISTURECAPACITYMEASURE",3686016028:"IFCIONCONCENTRATIONMEASURE",3809634241:"IFCINTEGERCOUNTRATEMEASURE",1939436016:"IFCINTEGER",2679005408:"IFCINDUCTANCEMEASURE",3358199106:"IFCILLUMINANCEMEASURE",983778844:"IFCIDENTIFIER",2589826445:"IFCHOURINDAY",1158859006:"IFCHEATINGVALUEMEASURE",3113092358:"IFCHEATFLUXDENSITYMEASURE",3064340077:"IFCGLOBALLYUNIQUEID",3044325142:"IFCFREQUENCYMEASURE",1361398929:"IFCFORCEMEASURE",2590844177:"IFCFONTWEIGHT",2715512545:"IFCFONTVARIANT",1102727119:"IFCFONTSTYLE",2078135608:"IFCENERGYMEASURE",2506197118:"IFCELECTRICVOLTAGEMEASURE",2951915441:"IFCELECTRICRESISTANCEMEASURE",3790457270:"IFCELECTRICCURRENTMEASURE",2093906313:"IFCELECTRICCONDUCTANCEMEASURE",3818826038:"IFCELECTRICCHARGEMEASURE",1827137117:"IFCELECTRICCAPACITANCEMEASURE",69416015:"IFCDYNAMICVISCOSITYMEASURE",524656162:"IFCDOSEEQUIVALENTMEASURE",4134073009:"IFCDIMENSIONCOUNT",1514641115:"IFCDESCRIPTIVEMEASURE",300323983:"IFCDAYLIGHTSAVINGHOUR",86635668:"IFCDAYINMONTHNUMBER",94842927:"IFCCURVATUREMEASURE",1778710042:"IFCCOUNTMEASURE",3238673880:"IFCCONTEXTDEPENDENTMEASURE",3812528620:"IFCCOMPOUNDPLANEANGLEMEASURE",2991860651:"IFCCOMPLEXNUMBER",1867003952:"IFCBOXALIGNMENT",2735952531:"IFCBOOLEAN",2650437152:"IFCAREAMEASURE",632304761:"IFCANGULARVELOCITYMEASURE",360377573:"IFCAMOUNTOFSUBSTANCEMEASURE",4182062534:"IFCACCELERATIONMEASURE",3699917729:"IFCABSORBEDDOSEMEASURE",1971632696:"IFCGEOSLICE",2680139844:"IFCGEOMODEL",24726584:"IFCELECTRICFLOWTREATMENTDEVICE",3693000487:"IFCDISTRIBUTIONBOARD",3460952963:"IFCCONVEYORSEGMENT",3999819293:"IFCCAISSONFOUNDATION",3314249567:"IFCBOREHOLE",4196446775:"IFCBEARING",325726236:"IFCALIGNMENT",3425753595:"IFCTRACKELEMENT",991950508:"IFCSIGNAL",3798194928:"IFCREINFORCEDSOIL",3290496277:"IFCRAIL",1383356374:"IFCPAVEMENT",2182337498:"IFCNAVIGATIONELEMENT",234836483:"IFCMOORINGDEVICE",2078563270:"IFCMOBILETELECOMMUNICATIONSAPPLIANCE",1638804497:"IFCLIQUIDTERMINAL",1154579445:"IFCLINEARPOSITIONINGELEMENT",2696325953:"IFCKERB",2713699986:"IFCGEOTECHNICALASSEMBLY",2142170206:"IFCELECTRICFLOWTREATMENTDEVICETYPE",3376911765:"IFCEARTHWORKSFILL",1077100507:"IFCEARTHWORKSELEMENT",3071239417:"IFCEARTHWORKSCUT",479945903:"IFCDISTRIBUTIONBOARDTYPE",3426335179:"IFCDEEPFOUNDATION",1502416096:"IFCCOURSE",2940368186:"IFCCONVEYORSEGMENTTYPE",3203706013:"IFCCAISSONFOUNDATIONTYPE",3862327254:"IFCBUILTSYSTEM",1876633798:"IFCBUILTELEMENT",963979645:"IFCBRIDGEPART",644574406:"IFCBRIDGE",3649138523:"IFCBEARINGTYPE",1662888072:"IFCALIGNMENTVERTICAL",317615605:"IFCALIGNMENTSEGMENT",1545765605:"IFCALIGNMENTHORIZONTAL",4266260250:"IFCALIGNMENTCANT",3956297820:"IFCVIBRATIONDAMPERTYPE",1530820697:"IFCVIBRATIONDAMPER",840318589:"IFCVEHICLE",1953115116:"IFCTRANSPORTATIONDEVICE",618700268:"IFCTRACKELEMENTTYPE",2281632017:"IFCTENDONCONDUITTYPE",3663046924:"IFCTENDONCONDUIT",42703149:"IFCSINESPIRAL",1894708472:"IFCSIGNALTYPE",3599934289:"IFCSIGNTYPE",33720170:"IFCSIGN",1027922057:"IFCSEVENTHORDERPOLYNOMIALSPIRAL",544395925:"IFCSEGMENTEDREFERENCECURVE",3649235739:"IFCSECONDORDERPOLYNOMIALSPIRAL",550521510:"IFCROADPART",146592293:"IFCROAD",3818125796:"IFCRELADHERESTOELEMENT",4021432810:"IFCREFERENT",1891881377:"IFCRAILWAYPART",3992365140:"IFCRAILWAY",1763565496:"IFCRAILTYPE",1946335990:"IFCPOSITIONINGELEMENT",514975943:"IFCPAVEMENTTYPE",506776471:"IFCNAVIGATIONELEMENTTYPE",710110818:"IFCMOORINGDEVICETYPE",1950438474:"IFCMOBILETELECOMMUNICATIONSAPPLIANCETYPE",976884017:"IFCMARINEPART",525669439:"IFCMARINEFACILITY",1770583370:"IFCLIQUIDTERMINALTYPE",2176059722:"IFCLINEARELEMENT",679976338:"IFCKERBTYPE",3948183225:"IFCIMPACTPROTECTIONDEVICETYPE",2568555532:"IFCIMPACTPROTECTIONDEVICE",2898700619:"IFCGRADIENTCURVE",1594536857:"IFCGEOTECHNICALSTRATUM",4230923436:"IFCGEOTECHNICALELEMENT",4228831410:"IFCFACILITYPARTCOMMON",1310830890:"IFCFACILITYPART",24185140:"IFCFACILITY",4234616927:"IFCDIRECTRIXDERIVEDREFERENCESWEPTAREASOLID",1306400036:"IFCDEEPFOUNDATIONTYPE",4189326743:"IFCCOURSETYPE",2000195564:"IFCCOSINESPIRAL",3497074424:"IFCCLOTHOID",1626504194:"IFCBUILTELEMENTTYPE",3651464721:"IFCVEHICLETYPE",1229763772:"IFCTRIANGULATEDIRREGULARNETWORK",3665877780:"IFCTRANSPORTATIONDEVICETYPE",782932809:"IFCTHIRDORDERPOLYNOMIALSPIRAL",2735484536:"IFCSPIRAL",1356537516:"IFCSECTIONEDSURFACE",1290935644:"IFCSECTIONEDSOLIDHORIZONTAL",1862484736:"IFCSECTIONEDSOLID",1441486842:"IFCRELPOSITIONS",1033248425:"IFCRELASSOCIATESPROFILEDEF",3381221214:"IFCPOLYNOMIALCURVE",2485787929:"IFCOFFSETCURVEBYDISTANCES",590820931:"IFCOFFSETCURVE",3465909080:"IFCINDEXEDPOLYGONALTEXTUREMAP",593015953:"IFCDIRECTRIXCURVESWEPTAREASOLID",4212018352:"IFCCURVESEGMENT",3425423356:"IFCAXIS2PLACEMENTLINEAR",823603102:"IFCSEGMENT",2165702409:"IFCPOINTBYDISTANCEEXPRESSION",182550632:"IFCOPENCROSSPROFILEDEF",388784114:"IFCLINEARPLACEMENT",536804194:"IFCALIGNMENTHORIZONTALSEGMENT",3752311538:"IFCALIGNMENTCANTSEGMENT",1010789467:"IFCTEXTURECOORDINATEINDICESWITHVOIDS",222769930:"IFCTEXTURECOORDINATEINDICES",2691318326:"IFCQUANTITYNUMBER",3633395639:"IFCALIGNMENTVERTICALSEGMENT",2879124712:"IFCALIGNMENTPARAMETERSEGMENT",25142252:"IFCCONTROLLER",3087945054:"IFCALARM",4288193352:"IFCACTUATOR",630975310:"IFCUNITARYCONTROLELEMENT",4086658281:"IFCSENSOR",2295281155:"IFCPROTECTIVEDEVICETRIPPINGUNIT",182646315:"IFCFLOWINSTRUMENT",1426591983:"IFCFIRESUPPRESSIONTERMINAL",819412036:"IFCFILTER",3415622556:"IFCFAN",1003880860:"IFCELECTRICTIMECONTROL",402227799:"IFCELECTRICMOTOR",264262732:"IFCELECTRICGENERATOR",3310460725:"IFCELECTRICFLOWSTORAGEDEVICE",862014818:"IFCELECTRICDISTRIBUTIONBOARD",1904799276:"IFCELECTRICAPPLIANCE",1360408905:"IFCDUCTSILENCER",3518393246:"IFCDUCTSEGMENT",342316401:"IFCDUCTFITTING",562808652:"IFCDISTRIBUTIONCIRCUIT",4074379575:"IFCDAMPER",3640358203:"IFCCOOLINGTOWER",4136498852:"IFCCOOLEDBEAM",2272882330:"IFCCONDENSER",3571504051:"IFCCOMPRESSOR",3221913625:"IFCCOMMUNICATIONSAPPLIANCE",639361253:"IFCCOIL",3902619387:"IFCCHILLER",4217484030:"IFCCABLESEGMENT",1051757585:"IFCCABLEFITTING",3758799889:"IFCCABLECARRIERSEGMENT",635142910:"IFCCABLECARRIERFITTING",2938176219:"IFCBURNER",32344328:"IFCBOILER",2906023776:"IFCBEAMSTANDARDCASE",277319702:"IFCAUDIOVISUALAPPLIANCE",2056796094:"IFCAIRTOAIRHEATRECOVERY",177149247:"IFCAIRTERMINALBOX",1634111441:"IFCAIRTERMINAL",486154966:"IFCWINDOWSTANDARDCASE",4237592921:"IFCWASTETERMINAL",4156078855:"IFCWALLELEMENTEDCASE",4207607924:"IFCVALVE",4292641817:"IFCUNITARYEQUIPMENT",3179687236:"IFCUNITARYCONTROLELEMENTTYPE",3026737570:"IFCTUBEBUNDLE",3825984169:"IFCTRANSFORMER",812556717:"IFCTANK",1162798199:"IFCSWITCHINGDEVICE",385403989:"IFCSTRUCTURALLOADCASE",1404847402:"IFCSTACKTERMINAL",1999602285:"IFCSPACEHEATER",3420628829:"IFCSOLARDEVICE",3027962421:"IFCSLABSTANDARDCASE",3127900445:"IFCSLABELEMENTEDCASE",1329646415:"IFCSHADINGDEVICE",3053780830:"IFCSANITARYTERMINAL",2572171363:"IFCREINFORCINGBARTYPE",1232101972:"IFCRATIONALBSPLINECURVEWITHKNOTS",90941305:"IFCPUMP",655969474:"IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",738039164:"IFCPROTECTIVEDEVICE",1156407060:"IFCPLATESTANDARDCASE",3612865200:"IFCPIPESEGMENT",310824031:"IFCPIPEFITTING",3694346114:"IFCOUTLET",144952367:"IFCOUTERBOUNDARYCURVE",2474470126:"IFCMOTORCONNECTION",1911478936:"IFCMEMBERSTANDARDCASE",1437502449:"IFCMEDICALDEVICE",629592764:"IFCLIGHTFIXTURE",76236018:"IFCLAMP",2176052936:"IFCJUNCTIONBOX",4175244083:"IFCINTERCEPTOR",2068733104:"IFCHUMIDIFIER",3319311131:"IFCHEATEXCHANGER",2188021234:"IFCFLOWMETER",1209101575:"IFCEXTERNALSPATIALELEMENT",484807127:"IFCEVAPORATOR",3747195512:"IFCEVAPORATIVECOOLER",2814081492:"IFCENGINE",2417008758:"IFCELECTRICDISTRIBUTIONBOARDTYPE",3242481149:"IFCDOORSTANDARDCASE",3205830791:"IFCDISTRIBUTIONSYSTEM",400855858:"IFCCOMMUNICATIONSAPPLIANCETYPE",905975707:"IFCCOLUMNSTANDARDCASE",1677625105:"IFCCIVILELEMENT",3296154744:"IFCCHIMNEY",2674252688:"IFCCABLEFITTINGTYPE",2188180465:"IFCBURNERTYPE",1177604601:"IFCBUILDINGSYSTEM",39481116:"IFCBUILDINGELEMENTPARTTYPE",1136057603:"IFCBOUNDARYCURVE",2461110595:"IFCBSPLINECURVEWITHKNOTS",1532957894:"IFCAUDIOVISUALAPPLIANCETYPE",4088093105:"IFCWORKCALENDAR",4009809668:"IFCWINDOWTYPE",926996030:"IFCVOIDINGFEATURE",2391383451:"IFCVIBRATIONISOLATOR",2415094496:"IFCTENDONTYPE",3081323446:"IFCTENDONANCHORTYPE",413509423:"IFCSYSTEMFURNITUREELEMENT",3101698114:"IFCSURFACEFEATURE",3657597509:"IFCSTRUCTURALSURFACEACTION",2757150158:"IFCSTRUCTURALCURVEREACTION",1004757350:"IFCSTRUCTURALCURVEACTION",338393293:"IFCSTAIRTYPE",1072016465:"IFCSOLARDEVICETYPE",4074543187:"IFCSHADINGDEVICETYPE",2157484638:"IFCSEAMCURVE",2781568857:"IFCROOFTYPE",2310774935:"IFCREINFORCINGMESHTYPE",964333572:"IFCREINFORCINGELEMENTTYPE",683857671:"IFCRATIONALBSPLINESURFACEWITHKNOTS",1469900589:"IFCRAMPTYPE",2839578677:"IFCPOLYGONALFACESET",1158309216:"IFCPILETYPE",3079942009:"IFCOPENINGSTANDARDCASE",1114901282:"IFCMEDICALDEVICETYPE",3113134337:"IFCINTERSECTIONCURVE",3946677679:"IFCINTERCEPTORTYPE",2571569899:"IFCINDEXEDPOLYCURVE",3493046030:"IFCGEOGRAPHICELEMENT",1509553395:"IFCFURNITURE",1893162501:"IFCFOOTINGTYPE",2853485674:"IFCEXTERNALSPATIALSTRUCTUREELEMENT",4148101412:"IFCEVENT",132023988:"IFCENGINETYPE",2397081782:"IFCELEMENTASSEMBLYTYPE",2323601079:"IFCDOORTYPE",1213902940:"IFCCYLINDRICALSURFACE",1525564444:"IFCCONSTRUCTIONPRODUCTRESOURCETYPE",4105962743:"IFCCONSTRUCTIONMATERIALRESOURCETYPE",2185764099:"IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",15328376:"IFCCOMPOSITECURVEONSURFACE",3875453745:"IFCCOMPLEXPROPERTYTEMPLATE",3893394355:"IFCCIVILELEMENTTYPE",2197970202:"IFCCHIMNEYTYPE",167062518:"IFCBSPLINESURFACEWITHKNOTS",2887950389:"IFCBSPLINESURFACE",2603310189:"IFCADVANCEDBREPWITHVOIDS",1635779807:"IFCADVANCEDBREP",2916149573:"IFCTRIANGULATEDFACESET",1935646853:"IFCTOROIDALSURFACE",2387106220:"IFCTESSELLATEDFACESET",3206491090:"IFCTASKTYPE",699246055:"IFCSURFACECURVE",4095615324:"IFCSUBCONTRACTRESOURCETYPE",603775116:"IFCSTRUCTURALSURFACEREACTION",4015995234:"IFCSPHERICALSURFACE",2481509218:"IFCSPATIALZONETYPE",463610769:"IFCSPATIALZONE",710998568:"IFCSPATIALELEMENTTYPE",1412071761:"IFCSPATIALELEMENT",3663146110:"IFCSIMPLEPROPERTYTEMPLATE",3243963512:"IFCREVOLVEDAREASOLIDTAPERED",816062949:"IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",1521410863:"IFCRELSPACEBOUNDARY2NDLEVEL",3523091289:"IFCRELSPACEBOUNDARY1STLEVEL",427948657:"IFCRELINTERFERESELEMENTS",307848117:"IFCRELDEFINESBYTEMPLATE",1462361463:"IFCRELDEFINESBYOBJECT",2565941209:"IFCRELDECLARES",1027710054:"IFCRELASSIGNSTOGROUPBYFACTOR",3521284610:"IFCPROPERTYTEMPLATE",492091185:"IFCPROPERTYSETTEMPLATE",653396225:"IFCPROJECTLIBRARY",569719735:"IFCPROCEDURETYPE",3967405729:"IFCPREDEFINEDPROPERTYSET",1682466193:"IFCPCURVE",428585644:"IFCLABORRESOURCETYPE",2294589976:"IFCINDEXEDPOLYGONALFACEWITHVOIDS",178912537:"IFCINDEXEDPOLYGONALFACE",4095422895:"IFCGEOGRAPHICELEMENTTYPE",2652556860:"IFCFIXEDREFERENCESWEPTAREASOLID",2804161546:"IFCEXTRUDEDAREASOLIDTAPERED",4024345920:"IFCEVENTTYPE",2629017746:"IFCCURVEBOUNDEDSURFACE",1815067380:"IFCCREWRESOURCETYPE",3419103109:"IFCCONTEXT",2574617495:"IFCCONSTRUCTIONRESOURCETYPE",2059837836:"IFCCARTESIANPOINTLIST3D",1675464909:"IFCCARTESIANPOINTLIST2D",574549367:"IFCCARTESIANPOINTLIST",3406155212:"IFCADVANCEDFACE",3698973494:"IFCTYPERESOURCE",3736923433:"IFCTYPEPROCESS",901063453:"IFCTESSELLATEDITEM",1096409881:"IFCSWEPTDISKSOLIDPOLYGONAL",1042787934:"IFCRESOURCETIME",1608871552:"IFCRESOURCECONSTRAINTRELATIONSHIP",2943643501:"IFCRESOURCEAPPROVALRELATIONSHIP",2090586900:"IFCQUANTITYSET",1482703590:"IFCPROPERTYTEMPLATEDEFINITION",3778827333:"IFCPREDEFINEDPROPERTIES",2998442950:"IFCMIRROREDPROFILEDEF",853536259:"IFCMATERIALRELATIONSHIP",3404854881:"IFCMATERIALPROFILESETUSAGETAPERING",3079605661:"IFCMATERIALPROFILESETUSAGE",2852063980:"IFCMATERIALCONSTITUENTSET",3708119e3:"IFCMATERIALCONSTITUENT",1585845231:"IFCLAGTIME",2133299955:"IFCINDEXEDTRIANGLETEXTUREMAP",1437953363:"IFCINDEXEDTEXTUREMAP",3570813810:"IFCINDEXEDCOLOURMAP",1437805879:"IFCEXTERNALREFERENCERELATIONSHIP",297599258:"IFCEXTENDEDPROPERTIES",211053100:"IFCEVENTTIME",2713554722:"IFCCONVERSIONBASEDUNITWITHOFFSET",3285139300:"IFCCOLOURRGBLIST",1236880293:"IFCWORKTIME",1199560280:"IFCTIMEPERIOD",3611470254:"IFCTEXTUREVERTEXLIST",2771591690:"IFCTASKTIMERECURRING",1549132990:"IFCTASKTIME",2043862942:"IFCTABLECOLUMN",2934153892:"IFCSURFACEREINFORCEMENTAREA",609421318:"IFCSTRUCTURALLOADORRESULT",3478079324:"IFCSTRUCTURALLOADCONFIGURATION",1054537805:"IFCSCHEDULINGTIME",2439245199:"IFCRESOURCELEVELRELATIONSHIP",2433181523:"IFCREFERENCE",3915482550:"IFCRECURRENCEPATTERN",986844984:"IFCPROPERTYABSTRACTION",3843373140:"IFCPROJECTEDCRS",677532197:"IFCPRESENTATIONITEM",1507914824:"IFCMATERIALUSAGEDEFINITION",552965576:"IFCMATERIALPROFILEWITHOFFSETS",164193824:"IFCMATERIALPROFILESET",2235152071:"IFCMATERIALPROFILE",1847252529:"IFCMATERIALLAYERWITHOFFSETS",760658860:"IFCMATERIALDEFINITION",3057273783:"IFCMAPCONVERSION",4294318154:"IFCEXTERNALINFORMATION",1466758467:"IFCCOORDINATEREFERENCESYSTEM",1785450214:"IFCCOORDINATEOPERATION",775493141:"IFCCONNECTIONVOLUMEGEOMETRY",979691226:"IFCREINFORCINGBAR",3700593921:"IFCELECTRICDISTRIBUTIONPOINT",1062813311:"IFCDISTRIBUTIONCONTROLELEMENT",1052013943:"IFCDISTRIBUTIONCHAMBERELEMENT",578613899:"IFCCONTROLLERTYPE",2454782716:"IFCCHAMFEREDGEFEATURE",753842376:"IFCBEAM",3001207471:"IFCALARMTYPE",2874132201:"IFCACTUATORTYPE",3304561284:"IFCWINDOW",3512223829:"IFCWALLSTANDARDCASE",2391406946:"IFCWALL",3313531582:"IFCVIBRATIONISOLATORTYPE",2347447852:"IFCTENDONANCHOR",3824725483:"IFCTENDON",2515109513:"IFCSTRUCTURALANALYSISMODEL",4252922144:"IFCSTAIRFLIGHT",331165859:"IFCSTAIR",1529196076:"IFCSLAB",1783015770:"IFCSENSORTYPE",1376911519:"IFCROUNDEDEDGEFEATURE",2016517767:"IFCROOF",2320036040:"IFCREINFORCINGMESH",3027567501:"IFCREINFORCINGELEMENT",3055160366:"IFCRATIONALBEZIERCURVE",3283111854:"IFCRAMPFLIGHT",3024970846:"IFCRAMP",2262370178:"IFCRAILING",3171933400:"IFCPLATE",1687234759:"IFCPILE",1073191201:"IFCMEMBER",900683007:"IFCFOOTING",3508470533:"IFCFLOWTREATMENTDEVICE",2223149337:"IFCFLOWTERMINAL",707683696:"IFCFLOWSTORAGEDEVICE",987401354:"IFCFLOWSEGMENT",3132237377:"IFCFLOWMOVINGDEVICE",4037862832:"IFCFLOWINSTRUMENTTYPE",4278956645:"IFCFLOWFITTING",2058353004:"IFCFLOWCONTROLLER",4222183408:"IFCFIRESUPPRESSIONTERMINALTYPE",1810631287:"IFCFILTERTYPE",346874300:"IFCFANTYPE",1658829314:"IFCENERGYCONVERSIONDEVICE",857184966:"IFCELECTRICALELEMENT",1634875225:"IFCELECTRICALCIRCUIT",712377611:"IFCELECTRICTIMECONTROLTYPE",1217240411:"IFCELECTRICMOTORTYPE",1365060375:"IFCELECTRICHEATERTYPE",1534661035:"IFCELECTRICGENERATORTYPE",3277789161:"IFCELECTRICFLOWSTORAGEDEVICETYPE",663422040:"IFCELECTRICAPPLIANCETYPE",855621170:"IFCEDGEFEATURE",2030761528:"IFCDUCTSILENCERTYPE",3760055223:"IFCDUCTSEGMENTTYPE",869906466:"IFCDUCTFITTINGTYPE",395920057:"IFCDOOR",3041715199:"IFCDISTRIBUTIONPORT",3040386961:"IFCDISTRIBUTIONFLOWELEMENT",1945004755:"IFCDISTRIBUTIONELEMENT",2063403501:"IFCDISTRIBUTIONCONTROLELEMENTTYPE",1599208980:"IFCDISTRIBUTIONCHAMBERELEMENTTYPE",2635815018:"IFCDISCRETEACCESSORYTYPE",1335981549:"IFCDISCRETEACCESSORY",4147604152:"IFCDIAMETERDIMENSION",3961806047:"IFCDAMPERTYPE",3495092785:"IFCCURTAINWALL",1973544240:"IFCCOVERING",2954562838:"IFCCOOLINGTOWERTYPE",335055490:"IFCCOOLEDBEAMTYPE",488727124:"IFCCONSTRUCTIONPRODUCTRESOURCE",1060000209:"IFCCONSTRUCTIONMATERIALRESOURCE",3898045240:"IFCCONSTRUCTIONEQUIPMENTRESOURCE",1163958913:"IFCCONDITIONCRITERION",2188551683:"IFCCONDITION",2816379211:"IFCCONDENSERTYPE",3850581409:"IFCCOMPRESSORTYPE",843113511:"IFCCOLUMN",2301859152:"IFCCOILTYPE",2611217952:"IFCCIRCLE",2951183804:"IFCCHILLERTYPE",1285652485:"IFCCABLESEGMENTTYPE",3293546465:"IFCCABLECARRIERSEGMENTTYPE",395041908:"IFCCABLECARRIERFITTINGTYPE",1909888760:"IFCBUILDINGELEMENTPROXYTYPE",1095909175:"IFCBUILDINGELEMENTPROXY",2979338954:"IFCBUILDINGELEMENTPART",52481810:"IFCBUILDINGELEMENTCOMPONENT",3299480353:"IFCBUILDINGELEMENT",231477066:"IFCBOILERTYPE",1916977116:"IFCBEZIERCURVE",819618141:"IFCBEAMTYPE",1967976161:"IFCBSPLINECURVE",3460190687:"IFCASSET",2470393545:"IFCANGULARDIMENSION",1871374353:"IFCAIRTOAIRHEATRECOVERYTYPE",3352864051:"IFCAIRTERMINALTYPE",1411407467:"IFCAIRTERMINALBOXTYPE",3821786052:"IFCACTIONREQUEST",1213861670:"IFC2DCOMPOSITECURVE",1033361043:"IFCZONE",3342526732:"IFCWORKSCHEDULE",4218914973:"IFCWORKPLAN",1028945134:"IFCWORKCONTROL",1133259667:"IFCWASTETERMINALTYPE",1898987631:"IFCWALLTYPE",2769231204:"IFCVIRTUALELEMENT",728799441:"IFCVALVETYPE",1911125066:"IFCUNITARYEQUIPMENTTYPE",1600972822:"IFCTUBEBUNDLETYPE",3593883385:"IFCTRIMMEDCURVE",1620046519:"IFCTRANSPORTELEMENT",1692211062:"IFCTRANSFORMERTYPE",1637806684:"IFCTIMESERIESSCHEDULE",5716631:"IFCTANKTYPE",2254336722:"IFCSYSTEM",2315554128:"IFCSWITCHINGDEVICETYPE",148013059:"IFCSUBCONTRACTRESOURCE",1975003073:"IFCSTRUCTURALSURFACECONNECTION",2986769608:"IFCSTRUCTURALRESULTGROUP",1235345126:"IFCSTRUCTURALPOINTREACTION",734778138:"IFCSTRUCTURALPOINTCONNECTION",2082059205:"IFCSTRUCTURALPOINTACTION",3987759626:"IFCSTRUCTURALPLANARACTIONVARYING",1621171031:"IFCSTRUCTURALPLANARACTION",1252848954:"IFCSTRUCTURALLOADGROUP",1721250024:"IFCSTRUCTURALLINEARACTIONVARYING",1807405624:"IFCSTRUCTURALLINEARACTION",2445595289:"IFCSTRUCTURALCURVEMEMBERVARYING",214636428:"IFCSTRUCTURALCURVEMEMBER",4243806635:"IFCSTRUCTURALCURVECONNECTION",1179482911:"IFCSTRUCTURALCONNECTION",682877961:"IFCSTRUCTURALACTION",1039846685:"IFCSTAIRFLIGHTTYPE",3112655638:"IFCSTACKTERMINALTYPE",3812236995:"IFCSPACETYPE",652456506:"IFCSPACEPROGRAM",1305183839:"IFCSPACEHEATERTYPE",3856911033:"IFCSPACE",2533589738:"IFCSLABTYPE",4097777520:"IFCSITE",4105383287:"IFCSERVICELIFE",3517283431:"IFCSCHEDULETIMECONTROL",1768891740:"IFCSANITARYTERMINALTYPE",2863920197:"IFCRELASSIGNSTASKS",160246688:"IFCRELAGGREGATES",2324767716:"IFCRAMPFLIGHTTYPE",2893384427:"IFCRAILINGTYPE",3248260540:"IFCRADIUSDIMENSION",2250791053:"IFCPUMPTYPE",1842657554:"IFCPROTECTIVEDEVICETYPE",3651124850:"IFCPROJECTIONELEMENT",3642467123:"IFCPROJECTORDERRECORD",2904328755:"IFCPROJECTORDER",2744685151:"IFCPROCEDURE",3740093272:"IFCPORT",3724593414:"IFCPOLYLINE",4017108033:"IFCPLATETYPE",4231323485:"IFCPIPESEGMENTTYPE",804291784:"IFCPIPEFITTINGTYPE",3327091369:"IFCPERMIT",2382730787:"IFCPERFORMANCEHISTORY",2837617999:"IFCOUTLETTYPE",3425660407:"IFCORDERACTION",3588315303:"IFCOPENINGELEMENT",4143007308:"IFCOCCUPANT",1916936684:"IFCMOVE",977012517:"IFCMOTORCONNECTIONTYPE",3181161470:"IFCMEMBERTYPE",2108223431:"IFCMECHANICALFASTENERTYPE",377706215:"IFCMECHANICALFASTENER",2506943328:"IFCLINEARDIMENSION",1161773419:"IFCLIGHTFIXTURETYPE",1051575348:"IFCLAMPTYPE",3827777499:"IFCLABORRESOURCE",4288270099:"IFCJUNCTIONBOXTYPE",2391368822:"IFCINVENTORY",1806887404:"IFCHUMIDIFIERTYPE",1251058090:"IFCHEATEXCHANGERTYPE",2706460486:"IFCGROUP",3009204131:"IFCGRID",200128114:"IFCGASTERMINALTYPE",814719939:"IFCFURNITURESTANDARD",263784265:"IFCFURNISHINGELEMENT",3009222698:"IFCFLOWTREATMENTDEVICETYPE",2297155007:"IFCFLOWTERMINALTYPE",1339347760:"IFCFLOWSTORAGEDEVICETYPE",1834744321:"IFCFLOWSEGMENTTYPE",1482959167:"IFCFLOWMOVINGDEVICETYPE",3815607619:"IFCFLOWMETERTYPE",3198132628:"IFCFLOWFITTINGTYPE",3907093117:"IFCFLOWCONTROLLERTYPE",1287392070:"IFCFEATUREELEMENTSUBTRACTION",2143335405:"IFCFEATUREELEMENTADDITION",2827207264:"IFCFEATUREELEMENT",2489546625:"IFCFASTENERTYPE",647756555:"IFCFASTENER",3737207727:"IFCFACETEDBREPWITHVOIDS",807026263:"IFCFACETEDBREP",3390157468:"IFCEVAPORATORTYPE",3174744832:"IFCEVAPORATIVECOOLERTYPE",3272907226:"IFCEQUIPMENTSTANDARD",1962604670:"IFCEQUIPMENTELEMENT",2107101300:"IFCENERGYCONVERSIONDEVICETYPE",1704287377:"IFCELLIPSE",2590856083:"IFCELEMENTCOMPONENTTYPE",1623761950:"IFCELEMENTCOMPONENT",4123344466:"IFCELEMENTASSEMBLY",1758889154:"IFCELEMENT",360485395:"IFCELECTRICALBASEPROPERTIES",3849074793:"IFCDISTRIBUTIONFLOWELEMENTTYPE",3256556792:"IFCDISTRIBUTIONELEMENTTYPE",681481545:"IFCDIMENSIONCURVEDIRECTEDCALLOUT",1457835157:"IFCCURTAINWALLTYPE",3295246426:"IFCCREWRESOURCE",1916426348:"IFCCOVERINGTYPE",1419761937:"IFCCOSTSCHEDULE",3895139033:"IFCCOSTITEM",3293443760:"IFCCONTROL",2559216714:"IFCCONSTRUCTIONRESOURCE",2510884976:"IFCCONIC",3732776249:"IFCCOMPOSITECURVE",300633059:"IFCCOLUMNTYPE",2937912522:"IFCCIRCLEHOLLOWPROFILEDEF",3124254112:"IFCBUILDINGSTOREY",1950629157:"IFCBUILDINGELEMENTTYPE",4031249490:"IFCBUILDING",1260505505:"IFCBOUNDEDCURVE",3649129432:"IFCBOOLEANCLIPPINGRESULT",1334484129:"IFCBLOCK",3207858831:"IFCASYMMETRICISHAPEPROFILEDEF",1674181508:"IFCANNOTATION",2296667514:"IFCACTOR",2097647324:"IFCTRANSPORTELEMENTTYPE",3473067441:"IFCTASK",1580310250:"IFCSYSTEMFURNITUREELEMENTTYPE",4124788165:"IFCSURFACEOFREVOLUTION",2809605785:"IFCSURFACEOFLINEAREXTRUSION",2028607225:"IFCSURFACECURVESWEPTAREASOLID",4070609034:"IFCSTRUCTUREDDIMENSIONCALLOUT",2218152070:"IFCSTRUCTURALSURFACEMEMBERVARYING",3979015343:"IFCSTRUCTURALSURFACEMEMBER",3689010777:"IFCSTRUCTURALREACTION",530289379:"IFCSTRUCTURALMEMBER",3136571912:"IFCSTRUCTURALITEM",3544373492:"IFCSTRUCTURALACTIVITY",451544542:"IFCSPHERE",3893378262:"IFCSPATIALSTRUCTUREELEMENTTYPE",2706606064:"IFCSPATIALSTRUCTUREELEMENT",3626867408:"IFCRIGHTCIRCULARCYLINDER",4158566097:"IFCRIGHTCIRCULARCONE",1856042241:"IFCREVOLVEDAREASOLID",2914609552:"IFCRESOURCE",1401173127:"IFCRELVOIDSELEMENT",3451746338:"IFCRELSPACEBOUNDARY",366585022:"IFCRELSERVICESBUILDINGS",4122056220:"IFCRELSEQUENCE",1058617721:"IFCRELSCHEDULESCOSTITEMS",1245217292:"IFCRELREFERENCEDINSPATIALSTRUCTURE",750771296:"IFCRELPROJECTSELEMENT",202636808:"IFCRELOVERRIDESPROPERTIES",2051452291:"IFCRELOCCUPIESSPACES",3268803585:"IFCRELNESTS",4189434867:"IFCRELINTERACTIONREQUIREMENTS",279856033:"IFCRELFLOWCONTROLELEMENTS",3940055652:"IFCRELFILLSELEMENT",781010003:"IFCRELDEFINESBYTYPE",4186316022:"IFCRELDEFINESBYPROPERTIES",693640335:"IFCRELDEFINES",2551354335:"IFCRELDECOMPOSES",2802773753:"IFCRELCOVERSSPACES",886880790:"IFCRELCOVERSBLDGELEMENTS",3242617779:"IFCRELCONTAINEDINSPATIALSTRUCTURE",3678494232:"IFCRELCONNECTSWITHREALIZINGELEMENTS",504942748:"IFCRELCONNECTSWITHECCENTRICITY",1638771189:"IFCRELCONNECTSSTRUCTURALMEMBER",3912681535:"IFCRELCONNECTSSTRUCTURALELEMENT",2127690289:"IFCRELCONNECTSSTRUCTURALACTIVITY",3190031847:"IFCRELCONNECTSPORTS",4201705270:"IFCRELCONNECTSPORTTOELEMENT",3945020480:"IFCRELCONNECTSPATHELEMENTS",1204542856:"IFCRELCONNECTSELEMENTS",826625072:"IFCRELCONNECTS",2851387026:"IFCRELASSOCIATESPROFILEPROPERTIES",2655215786:"IFCRELASSOCIATESMATERIAL",3840914261:"IFCRELASSOCIATESLIBRARY",982818633:"IFCRELASSOCIATESDOCUMENT",2728634034:"IFCRELASSOCIATESCONSTRAINT",919958153:"IFCRELASSOCIATESCLASSIFICATION",4095574036:"IFCRELASSOCIATESAPPROVAL",1327628568:"IFCRELASSOCIATESAPPLIEDVALUE",1865459582:"IFCRELASSOCIATES",205026976:"IFCRELASSIGNSTORESOURCE",3372526763:"IFCRELASSIGNSTOPROJECTORDER",2857406711:"IFCRELASSIGNSTOPRODUCT",4278684876:"IFCRELASSIGNSTOPROCESS",1307041759:"IFCRELASSIGNSTOGROUP",2495723537:"IFCRELASSIGNSTOCONTROL",1683148259:"IFCRELASSIGNSTOACTOR",3939117080:"IFCRELASSIGNS",3454111270:"IFCRECTANGULARTRIMMEDSURFACE",2798486643:"IFCRECTANGULARPYRAMID",2770003689:"IFCRECTANGLEHOLLOWPROFILEDEF",3219374653:"IFCPROXY",1451395588:"IFCPROPERTYSET",4194566429:"IFCPROJECTIONCURVE",103090709:"IFCPROJECT",4208778838:"IFCPRODUCT",2945172077:"IFCPROCESS",220341763:"IFCPLANE",603570806:"IFCPLANARBOX",3566463478:"IFCPERMEABLECOVERINGPROPERTIES",3505215534:"IFCOFFSETCURVE3D",3388369263:"IFCOFFSETCURVE2D",3888040117:"IFCOBJECT",1425443689:"IFCMANIFOLDSOLIDBREP",1281925730:"IFCLINE",572779678:"IFCLSHAPEPROFILEDEF",1484403080:"IFCISHAPEPROFILEDEF",987898635:"IFCGEOMETRICCURVESET",1268542332:"IFCFURNITURETYPE",4238390223:"IFCFURNISHINGELEMENTTYPE",3455213021:"IFCFLUIDFLOWPROPERTIES",315944413:"IFCFILLAREASTYLETILES",4203026998:"IFCFILLAREASTYLETILESYMBOLWITHSTYLE",374418227:"IFCFILLAREASTYLEHATCHING",2047409740:"IFCFACEBASEDSURFACEMODEL",477187591:"IFCEXTRUDEDAREASOLID",80994333:"IFCENERGYPROPERTIES",2835456948:"IFCELLIPSEPROFILEDEF",2777663545:"IFCELEMENTARYSURFACE",339256511:"IFCELEMENTTYPE",1883228015:"IFCELEMENTQUANTITY",1472233963:"IFCEDGELOOP",4006246654:"IFCDRAUGHTINGPREDEFINEDCURVEFONT",445594917:"IFCDRAUGHTINGPREDEFINEDCOLOUR",3073041342:"IFCDRAUGHTINGCALLOUT",526551008:"IFCDOORSTYLE",1714330368:"IFCDOORPANELPROPERTIES",2963535650:"IFCDOORLININGPROPERTIES",32440307:"IFCDIRECTION",4054601972:"IFCDIMENSIONCURVETERMINATOR",606661476:"IFCDIMENSIONCURVE",693772133:"IFCDEFINEDSYMBOL",2827736869:"IFCCURVEBOUNDEDPLANE",2601014836:"IFCCURVE",2147822146:"IFCCSGSOLID",2506170314:"IFCCSGPRIMITIVE3D",194851669:"IFCCRANERAILFSHAPEPROFILEDEF",4133800736:"IFCCRANERAILASHAPEPROFILEDEF",2485617015:"IFCCOMPOSITECURVESEGMENT",2205249479:"IFCCLOSEDSHELL",1383045692:"IFCCIRCLEPROFILEDEF",1416205885:"IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",3331915920:"IFCCARTESIANTRANSFORMATIONOPERATOR3D",3486308946:"IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",3749851601:"IFCCARTESIANTRANSFORMATIONOPERATOR2D",59481748:"IFCCARTESIANTRANSFORMATIONOPERATOR",1123145078:"IFCCARTESIANPOINT",2898889636:"IFCCSHAPEPROFILEDEF",2713105998:"IFCBOXEDHALFSPACE",2581212453:"IFCBOUNDINGBOX",4182860854:"IFCBOUNDEDSURFACE",2736907675:"IFCBOOLEANRESULT",2740243338:"IFCAXIS2PLACEMENT3D",3125803723:"IFCAXIS2PLACEMENT2D",4261334040:"IFCAXIS1PLACEMENT",1302238472:"IFCANNOTATIONSURFACE",2265737646:"IFCANNOTATIONFILLAREAOCCURRENCE",669184980:"IFCANNOTATIONFILLAREA",3288037868:"IFCANNOTATIONCURVEOCCURRENCE",2543172580:"IFCZSHAPEPROFILEDEF",1299126871:"IFCWINDOWSTYLE",512836454:"IFCWINDOWPANELPROPERTIES",336235671:"IFCWINDOWLININGPROPERTIES",2759199220:"IFCVERTEXLOOP",1417489154:"IFCVECTOR",427810014:"IFCUSHAPEPROFILEDEF",2347495698:"IFCTYPEPRODUCT",1628702193:"IFCTYPEOBJECT",1345879162:"IFCTWODIRECTIONREPEATFACTOR",2715220739:"IFCTRAPEZIUMPROFILEDEF",3124975700:"IFCTEXTLITERALWITHEXTENT",4282788508:"IFCTEXTLITERAL",3028897424:"IFCTERMINATORSYMBOL",3071757647:"IFCTSHAPEPROFILEDEF",230924584:"IFCSWEPTSURFACE",1260650574:"IFCSWEPTDISKSOLID",2247615214:"IFCSWEPTAREASOLID",1878645084:"IFCSURFACESTYLERENDERING",2513912981:"IFCSURFACE",2233826070:"IFCSUBEDGE",3653947884:"IFCSTRUCTURALSTEELPROFILEPROPERTIES",3843319758:"IFCSTRUCTURALPROFILEPROPERTIES",1190533807:"IFCSTRUCTURALLOADSINGLEFORCEWARPING",1597423693:"IFCSTRUCTURALLOADSINGLEFORCE",1973038258:"IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",2473145415:"IFCSTRUCTURALLOADSINGLEDISPLACEMENT",2668620305:"IFCSTRUCTURALLOADPLANARFORCE",1595516126:"IFCSTRUCTURALLOADLINEARFORCE",390701378:"IFCSPACETHERMALLOADPROPERTIES",1202362311:"IFCSOUNDVALUE",2485662743:"IFCSOUNDPROPERTIES",723233188:"IFCSOLIDMODEL",2609359061:"IFCSLIPPAGECONNECTIONCONDITION",4124623270:"IFCSHELLBASEDSURFACEMODEL",2411513650:"IFCSERVICELIFEFACTOR",1509187699:"IFCSECTIONEDSPINE",2778083089:"IFCROUNDEDRECTANGLEPROFILEDEF",478536968:"IFCRELATIONSHIP",3765753017:"IFCREINFORCEMENTDEFINITIONPROPERTIES",3413951693:"IFCREGULARTIMESERIES",3615266464:"IFCRECTANGLEPROFILEDEF",110355661:"IFCPROPERTYTABLEVALUE",3650150729:"IFCPROPERTYSINGLEVALUE",3357820518:"IFCPROPERTYSETDEFINITION",941946838:"IFCPROPERTYREFERENCEVALUE",2752243245:"IFCPROPERTYLISTVALUE",4166981789:"IFCPROPERTYENUMERATEDVALUE",1680319473:"IFCPROPERTYDEFINITION",871118103:"IFCPROPERTYBOUNDEDVALUE",673634403:"IFCPRODUCTDEFINITIONSHAPE",179317114:"IFCPREDEFINEDPOINTMARKERSYMBOL",433424934:"IFCPREDEFINEDDIMENSIONSYMBOL",2559016684:"IFCPREDEFINEDCURVEFONT",759155922:"IFCPREDEFINEDCOLOUR",2775532180:"IFCPOLYGONALBOUNDEDHALFSPACE",2924175390:"IFCPOLYLOOP",1423911732:"IFCPOINTONSURFACE",4022376103:"IFCPOINTONCURVE",2067069095:"IFCPOINT",1663979128:"IFCPLANAREXTENT",2004835150:"IFCPLACEMENT",597895409:"IFCPIXELTEXTURE",3021840470:"IFCPHYSICALCOMPLEXQUANTITY",2519244187:"IFCPATH",2529465313:"IFCPARAMETERIZEDPROFILEDEF",1029017970:"IFCORIENTEDEDGE",2665983363:"IFCOPENSHELL",2833995503:"IFCONEDIRECTIONREPEATFACTOR",219451334:"IFCOBJECTDEFINITION",1430189142:"IFCMECHANICALCONCRETEMATERIALPROPERTIES",2022407955:"IFCMATERIALDEFINITIONREPRESENTATION",2347385850:"IFCMAPPEDITEM",1008929658:"IFCLOOP",2624227202:"IFCLOCALPLACEMENT",3422422726:"IFCLIGHTSOURCESPOT",1520743889:"IFCLIGHTSOURCEPOSITIONAL",4266656042:"IFCLIGHTSOURCEGONIOMETRIC",2604431987:"IFCLIGHTSOURCEDIRECTIONAL",125510826:"IFCLIGHTSOURCEAMBIENT",1402838566:"IFCLIGHTSOURCE",3741457305:"IFCIRREGULARTIMESERIES",3905492369:"IFCIMAGETEXTURE",2445078500:"IFCHYGROSCOPICMATERIALPROPERTIES",812098782:"IFCHALFSPACESOLID",178086475:"IFCGRIDPLACEMENT",3590301190:"IFCGEOMETRICSET",4142052618:"IFCGEOMETRICREPRESENTATIONSUBCONTEXT",2453401579:"IFCGEOMETRICREPRESENTATIONITEM",3448662350:"IFCGEOMETRICREPRESENTATIONCONTEXT",1446786286:"IFCGENERALPROFILEPROPERTIES",803998398:"IFCGENERALMATERIALPROPERTIES",3857492461:"IFCFUELPROPERTIES",738692330:"IFCFILLAREASTYLE",4219587988:"IFCFAILURECONNECTIONCONDITION",3008276851:"IFCFACESURFACE",803316827:"IFCFACEOUTERBOUND",1809719519:"IFCFACEBOUND",2556980723:"IFCFACE",1860660968:"IFCEXTENDEDMATERIALPROPERTIES",476780140:"IFCEDGECURVE",3900360178:"IFCEDGE",4170525392:"IFCDRAUGHTINGPREDEFINEDTEXTFONT",3732053477:"IFCDOCUMENTREFERENCE",1694125774:"IFCDIMENSIONPAIR",2273265877:"IFCDIMENSIONCALLOUTRELATIONSHIP",3632507154:"IFCDERIVEDPROFILEDEF",3800577675:"IFCCURVESTYLE",2889183280:"IFCCONVERSIONBASEDUNIT",3050246964:"IFCCONTEXTDEPENDENTUNIT",45288368:"IFCCONNECTIONPOINTECCENTRICITY",1981873012:"IFCCONNECTIONCURVEGEOMETRY",370225590:"IFCCONNECTEDFACESET",1485152156:"IFCCOMPOSITEPROFILEDEF",2542286263:"IFCCOMPLEXPROPERTY",776857604:"IFCCOLOURRGB",647927063:"IFCCLASSIFICATIONREFERENCE",3150382593:"IFCCENTERLINEPROFILEDEF",616511568:"IFCBLOBTEXTURE",2705031697:"IFCARBITRARYPROFILEDEFWITHVOIDS",1310608509:"IFCARBITRARYOPENPROFILEDEF",3798115385:"IFCARBITRARYCLOSEDPROFILEDEF",2297822566:"IFCANNOTATIONTEXTOCCURRENCE",3612888222:"IFCANNOTATIONSYMBOLOCCURRENCE",962685235:"IFCANNOTATIONSURFACEOCCURRENCE",2442683028:"IFCANNOTATIONOCCURRENCE",1065908215:"IFCWATERPROPERTIES",891718957:"IFCVIRTUALGRIDINTERSECTION",1907098498:"IFCVERTEXPOINT",3304826586:"IFCVERTEXBASEDTEXTUREMAP",2799835756:"IFCVERTEX",180925521:"IFCUNITASSIGNMENT",1735638870:"IFCTOPOLOGYREPRESENTATION",1377556343:"IFCTOPOLOGICALREPRESENTATIONITEM",581633288:"IFCTIMESERIESVALUE",1718945513:"IFCTIMESERIESREFERENCERELATIONSHIP",3101149627:"IFCTIMESERIES",3317419933:"IFCTHERMALMATERIALPROPERTIES",1210645708:"IFCTEXTUREVERTEX",2552916305:"IFCTEXTUREMAP",1742049831:"IFCTEXTURECOORDINATEGENERATOR",280115917:"IFCTEXTURECOORDINATE",1484833681:"IFCTEXTSTYLEWITHBOXCHARACTERISTICS",1640371178:"IFCTEXTSTYLETEXTMODEL",2636378356:"IFCTEXTSTYLEFORDEFINEDFONT",1983826977:"IFCTEXTSTYLEFONTMODEL",1447204868:"IFCTEXTSTYLE",912023232:"IFCTELECOMADDRESS",531007025:"IFCTABLEROW",985171141:"IFCTABLE",1290481447:"IFCSYMBOLSTYLE",626085974:"IFCSURFACETEXTURE",1351298697:"IFCSURFACESTYLEWITHTEXTURES",846575682:"IFCSURFACESTYLESHADING",1607154358:"IFCSURFACESTYLEREFRACTION",3303107099:"IFCSURFACESTYLELIGHTING",1300840506:"IFCSURFACESTYLE",3049322572:"IFCSTYLEDREPRESENTATION",3958052878:"IFCSTYLEDITEM",2830218821:"IFCSTYLEMODEL",3408363356:"IFCSTRUCTURALLOADTEMPERATURE",2525727697:"IFCSTRUCTURALLOADSTATIC",2162789131:"IFCSTRUCTURALLOAD",2273995522:"IFCSTRUCTURALCONNECTIONCONDITION",3692461612:"IFCSIMPLEPROPERTY",4240577450:"IFCSHAPEREPRESENTATION",3982875396:"IFCSHAPEMODEL",867548509:"IFCSHAPEASPECT",4165799628:"IFCSECTIONREINFORCEMENTPROPERTIES",2042790032:"IFCSECTIONPROPERTIES",448429030:"IFCSIUNIT",2341007311:"IFCROOT",3679540991:"IFCRIBPLATEPROFILEPROPERTIES",1660063152:"IFCREPRESENTATIONMAP",3008791417:"IFCREPRESENTATIONITEM",3377609919:"IFCREPRESENTATIONCONTEXT",1076942058:"IFCREPRESENTATION",1222501353:"IFCRELAXATION",1580146022:"IFCREINFORCEMENTBARPROPERTIES",2692823254:"IFCREFERENCESVALUEDOCUMENT",825690147:"IFCQUANTITYWEIGHT",2405470396:"IFCQUANTITYVOLUME",3252649465:"IFCQUANTITYTIME",931644368:"IFCQUANTITYLENGTH",2093928680:"IFCQUANTITYCOUNT",2044713172:"IFCQUANTITYAREA",3710013099:"IFCPROPERTYENUMERATION",148025276:"IFCPROPERTYDEPENDENCYRELATIONSHIP",3896028662:"IFCPROPERTYCONSTRAINTRELATIONSHIP",2598011224:"IFCPROPERTY",2802850158:"IFCPROFILEPROPERTIES",3958567839:"IFCPROFILEDEF",2267347899:"IFCPRODUCTSOFCOMBUSTIONPROPERTIES",2095639259:"IFCPRODUCTREPRESENTATION",2417041796:"IFCPRESENTATIONSTYLEASSIGNMENT",3119450353:"IFCPRESENTATIONSTYLE",1304840413:"IFCPRESENTATIONLAYERWITHSTYLE",2022622350:"IFCPRESENTATIONLAYERASSIGNMENT",1775413392:"IFCPREDEFINEDTEXTFONT",3213052703:"IFCPREDEFINEDTERMINATORSYMBOL",990879717:"IFCPREDEFINEDSYMBOL",3727388367:"IFCPREDEFINEDITEM",3355820592:"IFCPOSTALADDRESS",2226359599:"IFCPHYSICALSIMPLEQUANTITY",2483315170:"IFCPHYSICALQUANTITY",101040310:"IFCPERSONANDORGANIZATION",2077209135:"IFCPERSON",1207048766:"IFCOWNERHISTORY",1411181986:"IFCORGANIZATIONRELATIONSHIP",4251960020:"IFCORGANIZATION",1227763645:"IFCOPTICALMATERIALPROPERTIES",2251480897:"IFCOBJECTIVE",3701648758:"IFCOBJECTPLACEMENT",1918398963:"IFCNAMEDUNIT",2706619895:"IFCMONETARYUNIT",3368373690:"IFCMETRIC",677618848:"IFCMECHANICALSTEELMATERIALPROPERTIES",4256014907:"IFCMECHANICALMATERIALPROPERTIES",2597039031:"IFCMEASUREWITHUNIT",3265635763:"IFCMATERIALPROPERTIES",2199411900:"IFCMATERIALLIST",1303795690:"IFCMATERIALLAYERSETUSAGE",3303938423:"IFCMATERIALLAYERSET",248100487:"IFCMATERIALLAYER",1847130766:"IFCMATERIALCLASSIFICATIONRELATIONSHIP",1838606355:"IFCMATERIAL",30780891:"IFCLOCALTIME",1566485204:"IFCLIGHTINTENSITYDISTRIBUTION",4162380809:"IFCLIGHTDISTRIBUTIONDATA",3452421091:"IFCLIBRARYREFERENCE",2655187982:"IFCLIBRARYINFORMATION",3020489413:"IFCIRREGULARTIMESERIESVALUE",852622518:"IFCGRIDAXIS",3548104201:"IFCEXTERNALLYDEFINEDTEXTFONT",3207319532:"IFCEXTERNALLYDEFINEDSYMBOL",1040185647:"IFCEXTERNALLYDEFINEDSURFACESTYLE",2242383968:"IFCEXTERNALLYDEFINEDHATCHSTYLE",3200245327:"IFCEXTERNALREFERENCE",1648886627:"IFCENVIRONMENTALIMPACTVALUE",3796139169:"IFCDRAUGHTINGCALLOUTRELATIONSHIP",770865208:"IFCDOCUMENTINFORMATIONRELATIONSHIP",1154170062:"IFCDOCUMENTINFORMATION",1376555844:"IFCDOCUMENTELECTRONICFORMAT",2949456006:"IFCDIMENSIONALEXPONENTS",1045800335:"IFCDERIVEDUNITELEMENT",1765591967:"IFCDERIVEDUNIT",1072939445:"IFCDATEANDTIME",3510044353:"IFCCURVESTYLEFONTPATTERN",2367409068:"IFCCURVESTYLEFONTANDSCALING",1105321065:"IFCCURVESTYLEFONT",539742890:"IFCCURRENCYRELATIONSHIP",602808272:"IFCCOSTVALUE",1065062679:"IFCCOORDINATEDUNIVERSALTIMEOFFSET",347226245:"IFCCONSTRAINTRELATIONSHIP",613356794:"IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP",1658513725:"IFCCONSTRAINTAGGREGATIONRELATIONSHIP",1959218052:"IFCCONSTRAINT",2732653382:"IFCCONNECTIONSURFACEGEOMETRY",4257277454:"IFCCONNECTIONPORTGEOMETRY",2614616156:"IFCCONNECTIONPOINTGEOMETRY",2859738748:"IFCCONNECTIONGEOMETRY",3264961684:"IFCCOLOURSPECIFICATION",3639012971:"IFCCLASSIFICATIONNOTATIONFACET",938368621:"IFCCLASSIFICATIONNOTATION",1098599126:"IFCCLASSIFICATIONITEMRELATIONSHIP",1767535486:"IFCCLASSIFICATIONITEM",747523909:"IFCCLASSIFICATION",622194075:"IFCCALENDARDATE",2069777674:"IFCBOUNDARYNODECONDITIONWARPING",1387855156:"IFCBOUNDARYNODECONDITION",3367102660:"IFCBOUNDARYFACECONDITION",1560379544:"IFCBOUNDARYEDGECONDITION",4037036970:"IFCBOUNDARYCONDITION",3869604511:"IFCAPPROVALRELATIONSHIP",390851274:"IFCAPPROVALPROPERTYRELATIONSHIP",2080292479:"IFCAPPROVALACTORRELATIONSHIP",130549933:"IFCAPPROVAL",1110488051:"IFCAPPLIEDVALUERELATIONSHIP",411424972:"IFCAPPLIEDVALUE",639542469:"IFCAPPLICATION",618182010:"IFCADDRESS",3630933823:"IFCACTORROLE",599546466:"FILE_DESCRIPTION",1390159747:"FILE_NAME",1109904537:"FILE_SCHEMA"};class kt{constructor(){ot(this,"enabled",!0),ot(this,"trigger",(t=>{if(!this.enabled)return;const e=this.handlers.slice(0);for(const s of e)s(t)})),ot(this,"handlers",[])}add(t){this.handlers.push(t)}remove(t){this.handlers=this.handlers.filter((e=>e!==t))}reset(){this.handlers.length=0}}class Ht{constructor(){ot(this,"enabled",!0),ot(this,"trigger",(async t=>{if(!this.enabled)return;const e=this.handlers.slice(0);for(const s of e)await s(t)})),ot(this,"handlers",[])}add(t){this.handlers.push(t)}remove(t){this.handlers=this.handlers.filter((e=>e!==t))}reset(){this.handlers.length=0}}class Yt extends Map{constructor(t){super(t),ot(this,"onItemSet",new kt),ot(this,"onItemUpdated",new kt),ot(this,"onItemDeleted",new kt),ot(this,"onBeforeDelete",new kt),ot(this,"onCleared",new kt),ot(this,"guard",(()=>!0))}set eventsEnabled(t){this.onItemSet.enabled=t,this.onItemUpdated.enabled=t,this.onItemDeleted.enabled=t,this.onBeforeDelete.enabled=t,this.onCleared.enabled=t}clear(){for(const[t,e]of this)this.onBeforeDelete.trigger({key:t,value:e});super.clear(),this.onCleared.trigger()}set(t,e){const s=this.has(t);if(!(this.guard??(()=>!0))(t,e))return this;const i=super.set(t,e);return s?(this.onItemUpdated||(this.onItemUpdated=new kt),this.onItemUpdated.trigger({key:t,value:e})):(this.onItemSet||(this.onItemSet=new kt),this.onItemSet.trigger({key:t,value:e})),i}delete(t){const e=this.get(t);if(!e)return!1;this.onBeforeDelete.trigger({key:t,value:e});const s=super.delete(t);return s&&this.onItemDeleted.trigger(t),s}getKey(t){for(const[e,s]of this)if(s===t)return e}update(t){const e=this.getKey(t);e&&this.set(e,t)}deleteIf(t){for(const[e,s]of this)t(s,e)&&this.delete(e)}replaceKey(t,e,s=!1){const i=this.get(t);if(!i)return!1;return!(this.get(e)&&!s)&&(this.eventsEnabled=!1,this.delete(t),this.eventsEnabled=!0,this.set(e,i),!0)}dispose(){this.clear(),this.onItemSet.reset(),this.onItemDeleted.reset(),this.onItemUpdated.reset(),this.onCleared.reset(),this.onBeforeDelete.reset()}}class Wt extends Set{constructor(t){super(t),ot(this,"onUpdated",new kt),ot(this,"onItemAdded",new kt),ot(this,"onBeforeDelete",new kt),ot(this,"onItemDeleted",new kt),ot(this,"onCleared",new kt),ot(this,"guard",(()=>!0))}set eventsEnabled(t){this.onUpdated.enabled=t,this.onItemAdded.enabled=t,this.onItemDeleted.enabled=t,this.onBeforeDelete.enabled=t,this.onCleared.enabled=t}clear(){for(const t of this)this.onBeforeDelete.trigger(t);super.clear(),this.onCleared.trigger(),this.onUpdated.trigger()}add(...t){for(const e of t){if(this.has(e))continue;(this.guard??(()=>!0))(e)&&(super.add(e),this.onItemAdded||(this.onItemAdded=new kt),this.onItemAdded.trigger(e))}return this.onUpdated||(this.onUpdated=new kt),this.onUpdated.trigger(),this}delete(t){if(!this.has(t))return!1;this.onBeforeDelete.trigger(t);const e=super.delete(t);return e&&(this.onItemDeleted.trigger(),this.onUpdated.trigger()),e}deleteIf(t){for(const e of this)t(e)&&this.delete(e)}getIndex(t){let e=0;for(const s of this){if(s===t)return e;e++}return-1}dispose(){this.clear(),this.onItemAdded.reset(),this.onItemDeleted.reset(),this.onCleared.reset(),this.onBeforeDelete.reset(),this.onUpdated.reset()}}const jt=new Int32Array(2),qt=new Float32Array(jt.buffer),Zt=new Float64Array(jt.buffer),Xt=1===new Uint16Array(new Uint8Array([1,0]).buffer)[0];var $t,Kt;(Kt=$t||($t={}))[Kt.UTF8_BYTES=1]="UTF8_BYTES",Kt[Kt.UTF16_STRING=2]="UTF16_STRING";class Qt{constructor(t){this.bytes_=t,this.position_=0,this.text_decoder_=new TextDecoder}static allocate(t){return new Qt(new Uint8Array(t))}clear(){this.position_=0}bytes(){return this.bytes_}position(){return this.position_}setPosition(t){this.position_=t}capacity(){return this.bytes_.length}readInt8(t){return this.readUint8(t)<<24>>24}readUint8(t){return this.bytes_[t]}readInt16(t){return this.readUint16(t)<<16>>16}readUint16(t){return this.bytes_[t]|this.bytes_[t+1]<<8}readInt32(t){return this.bytes_[t]|this.bytes_[t+1]<<8|this.bytes_[t+2]<<16|this.bytes_[t+3]<<24}readUint32(t){return this.readInt32(t)>>>0}readInt64(t){return BigInt.asIntN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readUint64(t){return BigInt.asUintN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readFloat32(t){return jt[0]=this.readInt32(t),qt[0]}readFloat64(t){return jt[Xt?0:1]=this.readInt32(t),jt[Xt?1:0]=this.readInt32(t+4),Zt[0]}writeInt8(t,e){this.bytes_[t]=e}writeUint8(t,e){this.bytes_[t]=e}writeInt16(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8}writeUint16(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8}writeInt32(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24}writeUint32(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24}writeInt64(t,e){this.writeInt32(t,Number(BigInt.asIntN(32,e))),this.writeInt32(t+4,Number(BigInt.asIntN(32,e>>BigInt(32))))}writeUint64(t,e){this.writeUint32(t,Number(BigInt.asUintN(32,e))),this.writeUint32(t+4,Number(BigInt.asUintN(32,e>>BigInt(32))))}writeFloat32(t,e){qt[0]=e,this.writeInt32(t,jt[0])}writeFloat64(t,e){Zt[0]=e,this.writeInt32(t,jt[Xt?0:1]),this.writeInt32(t+4,jt[Xt?1:0])}getBufferIdentifier(){if(this.bytes_.length<this.position_+4+4)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");let t="";for(let e=0;e<4;e++)t+=String.fromCharCode(this.readInt8(this.position_+4+e));return t}__offset(t,e){const s=t-this.readInt32(t);return e<this.readInt16(s)?this.readInt16(s+e):0}__union(t,e){return t.bb_pos=e+this.readInt32(e),t.bb=this,t}__string(t,e){t+=this.readInt32(t);const s=this.readInt32(t);t+=4;const i=this.bytes_.subarray(t,t+s);return e===$t.UTF8_BYTES?i:this.text_decoder_.decode(i)}__union_with_string(t,e){return"string"==typeof t?this.__string(e):this.__union(t,e)}__indirect(t){return t+this.readInt32(t)}__vector(t){return t+this.readInt32(t)+4}__vector_len(t){return this.readInt32(t+this.readInt32(t))}__has_identifier(t){if(4!=t.length)throw new Error("FlatBuffers: file identifier must be length 4");for(let e=0;e<4;e++)if(t.charCodeAt(e)!=this.readInt8(this.position()+4+e))return!1;return!0}createScalarList(t,e){const s=[];for(let i=0;i<e;++i){const e=t(i);null!==e&&s.push(e)}return s}createObjList(t,e){const s=[];for(let i=0;i<e;++i){const e=t(i);null!==e&&s.push(e.unpack())}return s}}class Jt{constructor(t){let e;this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null,this.text_encoder=new TextEncoder,e=t||1024,this.bb=Qt.allocate(e),this.space=e}clear(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null}forceDefaults(t){this.force_defaults=t}dataBuffer(){return this.bb}asUint8Array(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())}prep(t,e){t>this.minalign&&(this.minalign=t);const s=1+~(this.bb.capacity()-this.space+e)&t-1;for(;this.space<s+t+e;){const t=this.bb.capacity();this.bb=Jt.growByteBuffer(this.bb),this.space+=this.bb.capacity()-t}this.pad(s)}pad(t){for(let e=0;e<t;e++)this.bb.writeInt8(--this.space,0)}writeInt8(t){this.bb.writeInt8(this.space-=1,t)}writeInt16(t){this.bb.writeInt16(this.space-=2,t)}writeInt32(t){this.bb.writeInt32(this.space-=4,t)}writeInt64(t){this.bb.writeInt64(this.space-=8,t)}writeFloat32(t){this.bb.writeFloat32(this.space-=4,t)}writeFloat64(t){this.bb.writeFloat64(this.space-=8,t)}addInt8(t){this.prep(1,0),this.writeInt8(t)}addInt16(t){this.prep(2,0),this.writeInt16(t)}addInt32(t){this.prep(4,0),this.writeInt32(t)}addInt64(t){this.prep(8,0),this.writeInt64(t)}addFloat32(t){this.prep(4,0),this.writeFloat32(t)}addFloat64(t){this.prep(8,0),this.writeFloat64(t)}addFieldInt8(t,e,s){(this.force_defaults||e!=s)&&(this.addInt8(e),this.slot(t))}addFieldInt16(t,e,s){(this.force_defaults||e!=s)&&(this.addInt16(e),this.slot(t))}addFieldInt32(t,e,s){(this.force_defaults||e!=s)&&(this.addInt32(e),this.slot(t))}addFieldInt64(t,e,s){(this.force_defaults||e!==s)&&(this.addInt64(e),this.slot(t))}addFieldFloat32(t,e,s){(this.force_defaults||e!=s)&&(this.addFloat32(e),this.slot(t))}addFieldFloat64(t,e,s){(this.force_defaults||e!=s)&&(this.addFloat64(e),this.slot(t))}addFieldOffset(t,e,s){(this.force_defaults||e!=s)&&(this.addOffset(e),this.slot(t))}addFieldStruct(t,e,s){e!=s&&(this.nested(e),this.slot(t))}nested(t){if(t!=this.offset())throw new TypeError("FlatBuffers: struct must be serialized inline.")}notNested(){if(this.isNested)throw new TypeError("FlatBuffers: object serialization must not be nested.")}slot(t){null!==this.vtable&&(this.vtable[t]=this.offset())}offset(){return this.bb.capacity()-this.space}static growByteBuffer(t){const e=t.capacity();if(3221225472&e)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");const s=e<<1,i=Qt.allocate(s);return i.setPosition(s-e),i.bytes().set(t.bytes(),s-e),i}addOffset(t){this.prep(4,0),this.writeInt32(this.offset()-t+4)}startObject(t){this.notNested(),null==this.vtable&&(this.vtable=[]),this.vtable_in_use=t;for(let e=0;e<t;e++)this.vtable[e]=0;this.isNested=!0,this.object_start=this.offset()}endObject(){if(null==this.vtable||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);const t=this.offset();let e=this.vtable_in_use-1;for(;e>=0&&0==this.vtable[e];e--);const s=e+1;for(;e>=0;e--)this.addInt16(0!=this.vtable[e]?t-this.vtable[e]:0);this.addInt16(t-this.object_start);const i=2*(s+2);this.addInt16(i);let n=0;const r=this.space;t:for(e=0;e<this.vtables.length;e++){const t=this.bb.capacity()-this.vtables[e];if(i==this.bb.readInt16(t)){for(let e=2;e<i;e+=2)if(this.bb.readInt16(r+e)!=this.bb.readInt16(t+e))continue t;n=this.vtables[e];break}}return n?(this.space=this.bb.capacity()-t,this.bb.writeInt32(this.space,n-t)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-t,this.offset()-t)),this.isNested=!1,t}finish(t,e,s){const i=s?4:0;if(e){const t=e;if(this.prep(this.minalign,8+i),4!=t.length)throw new TypeError("FlatBuffers: file identifier must be length 4");for(let e=3;e>=0;e--)this.writeInt8(t.charCodeAt(e))}this.prep(this.minalign,4+i),this.addOffset(t),i&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)}finishSizePrefixed(t,e){this.finish(t,e,!0)}requiredField(t,e){const s=this.bb.capacity()-t,i=s-this.bb.readInt32(s);if(!(e<this.bb.readInt16(i)&&0!=this.bb.readInt16(i+e)))throw new TypeError("FlatBuffers: field "+e+" must be set")}startVector(t,e,s){this.notNested(),this.vector_num_elems=e,this.prep(4,t*e),this.prep(s,t*e)}endVector(){return this.writeInt32(this.vector_num_elems),this.offset()}createSharedString(t){if(!t)return 0;if(this.string_maps||(this.string_maps=new Map),this.string_maps.has(t))return this.string_maps.get(t);const e=this.createString(t);return this.string_maps.set(t,e),e}createString(t){if(null==t)return 0;let e;return e=t instanceof Uint8Array?t:this.text_encoder.encode(t),this.addInt8(0),this.startVector(1,e.length,1),this.bb.setPosition(this.space-=e.length),this.bb.bytes().set(e,this.space),this.endVector()}createByteVector(t){return null==t?0:(this.startVector(1,t.length,1),this.bb.setPosition(this.space-=t.length),this.bb.bytes().set(t,this.space),this.endVector())}createObjectOffset(t){return null===t?0:"string"==typeof t?this.createString(t):t.pack(this)}createObjectOffsetList(t){const e=[];for(let s=0;s<t.length;++s){const i=t[s];if(null===i)throw new TypeError("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");e.push(this.createObjectOffset(i))}return e}createStructOffsetList(t,e){return e(this,t.length),this.createObjectOffsetList(t.slice().reverse()),this.endVector()}}class te{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAlignment(t,e){return(e||new te).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAlignment(t,e){return t.setPosition(t.position()+4),(e||new te).__init(t.readInt32(t.position())+t.position(),t)}absolute(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}absoluteLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}absoluteArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}horizontal(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}horizontalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}horizontalArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}vertical(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}verticalLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}verticalArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startAlignment(t){t.startObject(3)}static addAbsolute(t,e){t.addFieldOffset(0,e,0)}static createAbsoluteVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startAbsoluteVector(t,e){t.startVector(4,e,4)}static addHorizontal(t,e){t.addFieldOffset(1,e,0)}static createHorizontalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startHorizontalVector(t,e){t.startVector(4,e,4)}static addVertical(t,e){t.addFieldOffset(2,e,0)}static createVerticalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startVerticalVector(t,e){t.startVector(4,e,4)}static endAlignment(t){return t.endObject()}static createAlignment(t,e,s,i){return te.startAlignment(t),te.addAbsolute(t,e),te.addHorizontal(t,s),te.addVertical(t,i),te.endAlignment(t)}}class ee{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAttribute(t,e){return(e||new ee).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAttribute(t,e){return t.setPosition(t.position()+4),(e||new ee).__init(t.readInt32(t.position())+t.position(),t)}data(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}dataLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startAttribute(t){t.startObject(1)}static addData(t,e){t.addFieldOffset(0,e,0)}static createDataVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startDataVector(t,e){t.startVector(4,e,4)}static endAttribute(t){const e=t.endObject();return t.requiredField(e,4),e}static createAttribute(t,e){return ee.startAttribute(t),ee.addData(t,e),ee.endAttribute(t)}}class se{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}x(){return this.bb.readFloat32(this.bb_pos)}mutate_x(t){return this.bb.writeFloat32(this.bb_pos+0,t),!0}y(){return this.bb.readFloat32(this.bb_pos+4)}mutate_y(t){return this.bb.writeFloat32(this.bb_pos+4,t),!0}z(){return this.bb.readFloat32(this.bb_pos+8)}mutate_z(t){return this.bb.writeFloat32(this.bb_pos+8,t),!0}static sizeOf(){return 12}static createFloatVector(t,e,s,i){return t.prep(4,12),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class ie{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}aperture(){return this.bb.readFloat32(this.bb_pos)}mutate_aperture(t){return this.bb.writeFloat32(this.bb_pos+0,t),!0}position(t){return(t||new se).__init(this.bb_pos+4,this.bb)}radius(){return this.bb.readFloat32(this.bb_pos+16)}mutate_radius(t){return this.bb.writeFloat32(this.bb_pos+16,t),!0}xDirection(t){return(t||new se).__init(this.bb_pos+20,this.bb)}yDirection(t){return(t||new se).__init(this.bb_pos+32,this.bb)}static sizeOf(){return 44}static createCircleCurve(t,e,s,i,n,r,o,a,l,h,c,d){return t.prep(4,44),t.prep(4,12),t.writeFloat32(d),t.writeFloat32(c),t.writeFloat32(h),t.prep(4,12),t.writeFloat32(l),t.writeFloat32(a),t.writeFloat32(o),t.writeFloat32(r),t.prep(4,12),t.writeFloat32(n),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class ne{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}p1(t){return(t||new se).__init(this.bb_pos,this.bb)}p2(t){return(t||new se).__init(this.bb_pos+12,this.bb)}static sizeOf(){return 24}static createWire(t,e,s,i,n,r,o){return t.prep(4,24),t.prep(4,12),t.writeFloat32(o),t.writeFloat32(r),t.writeFloat32(n),t.prep(4,12),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class re{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsWireSet(t,e){return(e||new re).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsWireSet(t,e){return t.setPosition(t.position()+4),(e||new re).__init(t.readInt32(t.position())+t.position(),t)}ps(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new se).__init(this.bb.__vector(this.bb_pos+s)+12*t,this.bb):null}psLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startWireSet(t){t.startObject(1)}static addPs(t,e){t.addFieldOffset(0,e,0)}static startPsVector(t,e){t.startVector(12,e,4)}static endWireSet(t){return t.endObject()}static createWireSet(t,e){return re.startWireSet(t),re.addPs(t,e),re.endWireSet(t)}}class oe{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAxis(t,e){return(e||new oe).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAxis(t,e){return t.setPosition(t.position()+4),(e||new oe).__init(t.readInt32(t.position())+t.position(),t)}wires(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new ne).__init(this.bb.__vector(this.bb_pos+s)+24*t,this.bb):null}wiresLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}order(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}orderLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}orderArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}parts(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt8(this.bb.__vector(this.bb_pos+e)+t):0}partsLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}partsArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Int8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}wireSets(t,e){const s=this.bb.__offset(this.bb_pos,10);return s?(e||new re).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}wireSetsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}circleCurves(t,e){const s=this.bb.__offset(this.bb_pos,12);return s?(e||new ie).__init(this.bb.__vector(this.bb_pos+s)+44*t,this.bb):null}circleCurvesLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}static startAxis(t){t.startObject(5)}static addWires(t,e){t.addFieldOffset(0,e,0)}static startWiresVector(t,e){t.startVector(24,e,4)}static addOrder(t,e){t.addFieldOffset(1,e,0)}static createOrderVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startOrderVector(t,e){t.startVector(4,e,4)}static addParts(t,e){t.addFieldOffset(2,e,0)}static createPartsVector(t,e){t.startVector(1,e.length,1);for(let s=e.length-1;s>=0;s--)t.addInt8(e[s]);return t.endVector()}static startPartsVector(t,e){t.startVector(1,e,1)}static addWireSets(t,e){t.addFieldOffset(3,e,0)}static createWireSetsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startWireSetsVector(t,e){t.startVector(4,e,4)}static addCircleCurves(t,e){t.addFieldOffset(4,e,0)}static startCircleCurvesVector(t,e){t.startVector(44,e,4)}static endAxis(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,6),t.requiredField(e,8),t.requiredField(e,10),t.requiredField(e,12),e}static createAxis(t,e,s,i,n,r){return oe.startAxis(t),oe.addWires(t,e),oe.addOrder(t,s),oe.addParts(t,i),oe.addWireSets(t,n),oe.addCircleCurves(t,r),oe.endAxis(t)}}var ae=(t=>(t[t.NONE=0]="NONE",t[t.WIRE=1]="WIRE",t[t.WIRE_SET=2]="WIRE_SET",t[t.CIRCLE_CURVE=3]="CIRCLE_CURVE",t))(ae||{});class le{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsBigShellHole(t,e){return(e||new le).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsBigShellHole(t,e){return t.setPosition(t.position()+4),(e||new le).__init(t.readInt32(t.position())+t.position(),t)}indices(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}indicesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}indicesArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}profileId(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint16(this.bb_pos+t):0}mutate_profile_id(t){const e=this.bb.__offset(this.bb_pos,6);return 0!==e&&(this.bb.writeUint16(this.bb_pos+e,t),!0)}static startBigShellHole(t){t.startObject(2)}static addIndices(t,e){t.addFieldOffset(0,e,0)}static createIndicesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIndicesVector(t,e){t.startVector(4,e,4)}static addProfileId(t,e){t.addFieldInt16(1,e,0)}static endBigShellHole(t){const e=t.endObject();return t.requiredField(e,4),e}static createBigShellHole(t,e,s){return le.startBigShellHole(t),le.addIndices(t,e),le.addProfileId(t,s),le.endBigShellHole(t)}}class he{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsBigShellProfile(t,e){return(e||new he).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsBigShellProfile(t,e){return t.setPosition(t.position()+4),(e||new he).__init(t.readInt32(t.position())+t.position(),t)}indices(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}indicesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}indicesArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startBigShellProfile(t){t.startObject(1)}static addIndices(t,e){t.addFieldOffset(0,e,0)}static createIndicesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIndicesVector(t,e){t.startVector(4,e,4)}static endBigShellProfile(t){const e=t.endObject();return t.requiredField(e,4),e}static createBigShellProfile(t,e){return he.startBigShellProfile(t),he.addIndices(t,e),he.endBigShellProfile(t)}}class ce{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}min(t){return(t||new se).__init(this.bb_pos,this.bb)}max(t){return(t||new se).__init(this.bb_pos+12,this.bb)}static sizeOf(){return 24}static createBoundingBox(t,e,s,i,n,r,o){return t.prep(4,24),t.prep(4,12),t.writeFloat32(o),t.writeFloat32(r),t.writeFloat32(n),t.prep(4,12),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class de{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsCircleExtrusion(t,e){return(e||new de).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCircleExtrusion(t,e){return t.setPosition(t.position()+4),(e||new de).__init(t.readInt32(t.position())+t.position(),t)}radius(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readFloat64(this.bb.__vector(this.bb_pos+e)+8*t):0}radiusLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}radiusArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float64Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}axes(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?(e||new oe).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}axesLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}static startCircleExtrusion(t){t.startObject(2)}static addRadius(t,e){t.addFieldOffset(0,e,0)}static createRadiusVector(t,e){t.startVector(8,e.length,8);for(let s=e.length-1;s>=0;s--)t.addFloat64(e[s]);return t.endVector()}static startRadiusVector(t,e){t.startVector(8,e,8)}static addAxes(t,e){t.addFieldOffset(1,e,0)}static createAxesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAxesVector(t,e){t.startVector(4,e,4)}static endCircleExtrusion(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,6),e}static createCircleExtrusion(t,e,s){return de.startCircleExtrusion(t),de.addRadius(t,e),de.addAxes(t,s),de.endCircleExtrusion(t)}}class ue{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}x(){return this.bb.readFloat64(this.bb_pos)}mutate_x(t){return this.bb.writeFloat64(this.bb_pos+0,t),!0}y(){return this.bb.readFloat64(this.bb_pos+8)}mutate_y(t){return this.bb.writeFloat64(this.bb_pos+8,t),!0}z(){return this.bb.readFloat64(this.bb_pos+16)}mutate_z(t){return this.bb.writeFloat64(this.bb_pos+16,t),!0}static sizeOf(){return 24}static createDoubleVector(t,e,s,i){return t.prep(8,24),t.writeFloat64(i),t.writeFloat64(s),t.writeFloat64(e),t.offset()}}class fe{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsGeometryLines(t,e){return(e||new fe).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsGeometryLines(t,e){return t.setPosition(t.position()+4),(e||new fe).__init(t.readInt32(t.position())+t.position(),t)}points(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}pointsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}pointsArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startGeometryLines(t){t.startObject(1)}static addPoints(t,e){t.addFieldOffset(0,e,0)}static createPointsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startPointsVector(t,e){t.startVector(4,e,4)}static endGeometryLines(t){const e=t.endObject();return t.requiredField(e,4),e}static createGeometryLines(t,e){return fe.startGeometryLines(t),fe.addPoints(t,e),fe.endGeometryLines(t)}}class pe{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}id(){return this.bb.readUint32(this.bb_pos)}mutate_id(t){return this.bb.writeUint32(this.bb_pos+0,t),!0}geometryClass(){return this.bb.readInt8(this.bb_pos+4)}mutate_geometry_class(t){return this.bb.writeInt8(this.bb_pos+4,t),!0}static sizeOf(){return 8}static createGeometryRepresentation(t,e,s){return t.prep(4,8),t.pad(3),t.writeInt8(s),t.writeInt32(e),t.offset()}}class Ie{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}id(){return this.bb.readUint32(this.bb_pos)}mutate_id(t){return this.bb.writeUint32(this.bb_pos+0,t),!0}transform(){return this.bb.readUint32(this.bb_pos+4)}mutate_transform(t){return this.bb.writeUint32(this.bb_pos+4,t),!0}static sizeOf(){return 8}static createGeometrySample(t,e,s){return t.prep(4,8),t.writeInt32(s),t.writeInt32(e),t.offset()}}class _e{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}start(t){return(t||new se).__init(this.bb_pos,this.bb)}end(t){return(t||new se).__init(this.bb_pos+12,this.bb)}height(){return this.bb.readFloat32(this.bb_pos+24)}mutate_height(t){return this.bb.writeFloat32(this.bb_pos+24,t),!0}width(){return this.bb.readFloat32(this.bb_pos+28)}mutate_width(t){return this.bb.writeFloat32(this.bb_pos+28,t),!0}offset(){return this.bb.readFloat32(this.bb_pos+32)}mutate_offset(t){return this.bb.writeFloat32(this.bb_pos+32,t),!0}static sizeOf(){return 36}static createGeometryWall(t,e,s,i,n,r,o,a,l,h){return t.prep(4,36),t.writeFloat32(h),t.writeFloat32(l),t.writeFloat32(a),t.prep(4,12),t.writeFloat32(o),t.writeFloat32(r),t.writeFloat32(n),t.prep(4,12),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class me{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}position(t){return(t||new ue).__init(this.bb_pos,this.bb)}xDirection(t){return(t||new se).__init(this.bb_pos+24,this.bb)}yDirection(t){return(t||new se).__init(this.bb_pos+36,this.bb)}static sizeOf(){return 48}static createTransform(t,e,s,i,n,r,o,a,l,h){return t.prep(8,48),t.prep(4,12),t.writeFloat32(h),t.writeFloat32(l),t.writeFloat32(a),t.prep(4,12),t.writeFloat32(o),t.writeFloat32(r),t.writeFloat32(n),t.prep(8,24),t.writeFloat64(i),t.writeFloat64(s),t.writeFloat64(e),t.offset()}}class Ee{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsGeometries(t,e){return(e||new Ee).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsGeometries(t,e){return t.setPosition(t.position()+4),(e||new Ee).__init(t.readInt32(t.position())+t.position(),t)}samples(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new Ie).__init(this.bb.__vector(this.bb_pos+s)+8*t,this.bb):null}samplesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}sampleIds(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}sampleIdsLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}sampleIdsArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}representations(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new pe).__init(this.bb.__vector(this.bb_pos+s)+8*t,this.bb):null}representationsLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}representationIds(t){const e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}representationIdsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}representationIdsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}transforms(t,e){const s=this.bb.__offset(this.bb_pos,12);return s?(e||new me).__init(this.bb.__vector(this.bb_pos+s)+48*t,this.bb):null}transformsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}transformIds(t){const e=this.bb.__offset(this.bb_pos,14);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}transformIdsLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}transformIdsArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}representationsSamples(t){const e=this.bb.__offset(this.bb_pos,16);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}representationsSamplesLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}representationsSamplesArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}lines(t,e){const s=this.bb.__offset(this.bb_pos,18);return s?(e||new fe).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}linesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}walls(t,e){const s=this.bb.__offset(this.bb_pos,20);return s?(e||new _e).__init(this.bb.__vector(this.bb_pos+s)+36*t,this.bb):null}wallsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}static startGeometries(t){t.startObject(9)}static addSamples(t,e){t.addFieldOffset(0,e,0)}static startSamplesVector(t,e){t.startVector(8,e,4)}static addSampleIds(t,e){t.addFieldOffset(1,e,0)}static createSampleIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startSampleIdsVector(t,e){t.startVector(4,e,4)}static addRepresentations(t,e){t.addFieldOffset(2,e,0)}static startRepresentationsVector(t,e){t.startVector(8,e,4)}static addRepresentationIds(t,e){t.addFieldOffset(3,e,0)}static createRepresentationIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startRepresentationIdsVector(t,e){t.startVector(4,e,4)}static addTransforms(t,e){t.addFieldOffset(4,e,0)}static startTransformsVector(t,e){t.startVector(48,e,8)}static addTransformIds(t,e){t.addFieldOffset(5,e,0)}static createTransformIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startTransformIdsVector(t,e){t.startVector(4,e,4)}static addRepresentationsSamples(t,e){t.addFieldOffset(6,e,0)}static createRepresentationsSamplesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startRepresentationsSamplesVector(t,e){t.startVector(4,e,4)}static addLines(t,e){t.addFieldOffset(7,e,0)}static createLinesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startLinesVector(t,e){t.startVector(4,e,4)}static addWalls(t,e){t.addFieldOffset(8,e,0)}static startWallsVector(t,e){t.startVector(36,e,4)}static endGeometries(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,8),t.requiredField(e,12),t.requiredField(e,18),e}static createGeometries(t,e,s,i,n,r,o,a,l,h){return Ee.startGeometries(t),Ee.addSamples(t,e),Ee.addSampleIds(t,s),Ee.addRepresentations(t,i),Ee.addRepresentationIds(t,n),Ee.addTransforms(t,r),Ee.addTransformIds(t,o),Ee.addRepresentationsSamples(t,a),Ee.addLines(t,l),Ee.addWalls(t,h),Ee.endGeometries(t)}}var ge=(t=>(t[t.NONE=0]="NONE",t[t.LINES=1]="LINES",t[t.ELLIPSE_ARC=2]="ELLIPSE_ARC",t[t.CLOTHOID=3]="CLOTHOID",t[t.PARABOLA=4]="PARABOLA",t[t.WALLS=5]="WALLS",t))(ge||{});class be{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}r(){return this.bb.readUint8(this.bb_pos)}mutate_r(t){return this.bb.writeUint8(this.bb_pos+0,t),!0}g(){return this.bb.readUint8(this.bb_pos+1)}mutate_g(t){return this.bb.writeUint8(this.bb_pos+1,t),!0}b(){return this.bb.readUint8(this.bb_pos+2)}mutate_b(t){return this.bb.writeUint8(this.bb_pos+2,t),!0}a(){return this.bb.readUint8(this.bb_pos+3)}mutate_a(t){return this.bb.writeUint8(this.bb_pos+3,t),!0}renderedFaces(){return this.bb.readInt8(this.bb_pos+4)}mutate_rendered_faces(t){return this.bb.writeInt8(this.bb_pos+4,t),!0}stroke(){return this.bb.readInt8(this.bb_pos+5)}mutate_stroke(t){return this.bb.writeInt8(this.bb_pos+5,t),!0}static sizeOf(){return 6}static createMaterial(t,e,s,i,n,r,o){return t.prep(1,6),t.writeInt8(o),t.writeInt8(r),t.writeInt8(n),t.writeInt8(i),t.writeInt8(s),t.writeInt8(e),t.offset()}}class Ce{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}id(){return this.bb.readUint32(this.bb_pos)}mutate_id(t){return this.bb.writeUint32(this.bb_pos+0,t),!0}bbox(t){return(t||new ce).__init(this.bb_pos+4,this.bb)}representationClass(){return this.bb.readInt8(this.bb_pos+28)}mutate_representation_class(t){return this.bb.writeInt8(this.bb_pos+28,t),!0}static sizeOf(){return 32}static createRepresentation(t,e,s,i,n,r,o,a,l){return t.prep(4,32),t.pad(3),t.writeInt8(l),t.prep(4,24),t.prep(4,12),t.writeFloat32(a),t.writeFloat32(o),t.writeFloat32(r),t.prep(4,12),t.writeFloat32(n),t.writeFloat32(i),t.writeFloat32(s),t.writeInt32(e),t.offset()}}class Te{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}item(){return this.bb.readUint32(this.bb_pos)}mutate_item(t){return this.bb.writeUint32(this.bb_pos+0,t),!0}material(){return this.bb.readUint32(this.bb_pos+4)}mutate_material(t){return this.bb.writeUint32(this.bb_pos+4,t),!0}representation(){return this.bb.readUint32(this.bb_pos+8)}mutate_representation(t){return this.bb.writeUint32(this.bb_pos+8,t),!0}localTransform(){return this.bb.readUint32(this.bb_pos+12)}mutate_local_transform(t){return this.bb.writeUint32(this.bb_pos+12,t),!0}static sizeOf(){return 16}static createSample(t,e,s,i,n){return t.prep(4,16),t.writeInt32(n),t.writeInt32(i),t.writeInt32(s),t.writeInt32(e),t.offset()}}class Ae{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShellHole(t,e){return(e||new Ae).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShellHole(t,e){return t.setPosition(t.position()+4),(e||new Ae).__init(t.readInt32(t.position())+t.position(),t)}indices(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint16(this.bb.__vector(this.bb_pos+e)+2*t):0}indicesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}indicesArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint16Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}profileId(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint16(this.bb_pos+t):0}mutate_profile_id(t){const e=this.bb.__offset(this.bb_pos,6);return 0!==e&&(this.bb.writeUint16(this.bb_pos+e,t),!0)}static startShellHole(t){t.startObject(2)}static addIndices(t,e){t.addFieldOffset(0,e,0)}static createIndicesVector(t,e){t.startVector(2,e.length,2);for(let s=e.length-1;s>=0;s--)t.addInt16(e[s]);return t.endVector()}static startIndicesVector(t,e){t.startVector(2,e,2)}static addProfileId(t,e){t.addFieldInt16(1,e,0)}static endShellHole(t){const e=t.endObject();return t.requiredField(e,4),e}static createShellHole(t,e,s){return Ae.startShellHole(t),Ae.addIndices(t,e),Ae.addProfileId(t,s),Ae.endShellHole(t)}}class Re{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShellProfile(t,e){return(e||new Re).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShellProfile(t,e){return t.setPosition(t.position()+4),(e||new Re).__init(t.readInt32(t.position())+t.position(),t)}indices(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint16(this.bb.__vector(this.bb_pos+e)+2*t):0}indicesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}indicesArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint16Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startShellProfile(t){t.startObject(1)}static addIndices(t,e){t.addFieldOffset(0,e,0)}static createIndicesVector(t,e){t.startVector(2,e.length,2);for(let s=e.length-1;s>=0;s--)t.addInt16(e[s]);return t.endVector()}static startIndicesVector(t,e){t.startVector(2,e,2)}static endShellProfile(t){const e=t.endObject();return t.requiredField(e,4),e}static createShellProfile(t,e){return Re.startShellProfile(t),Re.addIndices(t,e),Re.endShellProfile(t)}}var ye=(t=>(t[t.NONE=0]="NONE",t[t.BIG=1]="BIG",t))(ye||{});class Fe{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShell(t,e){return(e||new Fe).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShell(t,e){return t.setPosition(t.position()+4),(e||new Fe).__init(t.readInt32(t.position())+t.position(),t)}profiles(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new Re).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}profilesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}holes(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?(e||new Ae).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}holesLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}points(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new se).__init(this.bb.__vector(this.bb_pos+s)+12*t,this.bb):null}pointsLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}bigProfiles(t,e){const s=this.bb.__offset(this.bb_pos,10);return s?(e||new he).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}bigProfilesLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}bigHoles(t,e){const s=this.bb.__offset(this.bb_pos,12);return s?(e||new le).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}bigHolesLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}type(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.readInt8(this.bb_pos+t):ye.NONE}mutate_type(t){const e=this.bb.__offset(this.bb_pos,14);return 0!==e&&(this.bb.writeInt8(this.bb_pos+e,t),!0)}static startShell(t){t.startObject(6)}static addProfiles(t,e){t.addFieldOffset(0,e,0)}static createProfilesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startProfilesVector(t,e){t.startVector(4,e,4)}static addHoles(t,e){t.addFieldOffset(1,e,0)}static createHolesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startHolesVector(t,e){t.startVector(4,e,4)}static addPoints(t,e){t.addFieldOffset(2,e,0)}static startPointsVector(t,e){t.startVector(12,e,4)}static addBigProfiles(t,e){t.addFieldOffset(3,e,0)}static createBigProfilesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startBigProfilesVector(t,e){t.startVector(4,e,4)}static addBigHoles(t,e){t.addFieldOffset(4,e,0)}static createBigHolesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startBigHolesVector(t,e){t.startVector(4,e,4)}static addType(t,e){t.addFieldInt8(5,e,ye.NONE)}static endShell(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,6),t.requiredField(e,8),t.requiredField(e,10),t.requiredField(e,12),e}static createShell(t,e,s,i,n,r,o){return Fe.startShell(t),Fe.addProfiles(t,e),Fe.addHoles(t,s),Fe.addPoints(t,i),Fe.addBigProfiles(t,n),Fe.addBigHoles(t,r),Fe.addType(t,o),Fe.endShell(t)}}class Se{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsMeshes(t,e){return(e||new Se).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsMeshes(t,e){return t.setPosition(t.position()+4),(e||new Se).__init(t.readInt32(t.position())+t.position(),t)}coordinates(t){const e=this.bb.__offset(this.bb_pos,4);return e?(t||new me).__init(this.bb_pos+e,this.bb):null}meshesItems(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}meshesItemsLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}meshesItemsArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}samples(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new Te).__init(this.bb.__vector(this.bb_pos+s)+16*t,this.bb):null}samplesLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}representations(t,e){const s=this.bb.__offset(this.bb_pos,10);return s?(e||new Ce).__init(this.bb.__vector(this.bb_pos+s)+32*t,this.bb):null}representationsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}materials(t,e){const s=this.bb.__offset(this.bb_pos,12);return s?(e||new be).__init(this.bb.__vector(this.bb_pos+s)+6*t,this.bb):null}materialsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}circleExtrusions(t,e){const s=this.bb.__offset(this.bb_pos,14);return s?(e||new de).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}circleExtrusionsLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}shells(t,e){const s=this.bb.__offset(this.bb_pos,16);return s?(e||new Fe).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}shellsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}localTransforms(t,e){const s=this.bb.__offset(this.bb_pos,18);return s?(e||new me).__init(this.bb.__vector(this.bb_pos+s)+48*t,this.bb):null}localTransformsLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}globalTransforms(t,e){const s=this.bb.__offset(this.bb_pos,20);return s?(e||new me).__init(this.bb.__vector(this.bb_pos+s)+48*t,this.bb):null}globalTransformsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}static startMeshes(t){t.startObject(9)}static addCoordinates(t,e){t.addFieldStruct(0,e,0)}static addMeshesItems(t,e){t.addFieldOffset(1,e,0)}static createMeshesItemsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startMeshesItemsVector(t,e){t.startVector(4,e,4)}static addSamples(t,e){t.addFieldOffset(2,e,0)}static startSamplesVector(t,e){t.startVector(16,e,4)}static addRepresentations(t,e){t.addFieldOffset(3,e,0)}static startRepresentationsVector(t,e){t.startVector(32,e,4)}static addMaterials(t,e){t.addFieldOffset(4,e,0)}static startMaterialsVector(t,e){t.startVector(6,e,1)}static addCircleExtrusions(t,e){t.addFieldOffset(5,e,0)}static createCircleExtrusionsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startCircleExtrusionsVector(t,e){t.startVector(4,e,4)}static addShells(t,e){t.addFieldOffset(6,e,0)}static createShellsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startShellsVector(t,e){t.startVector(4,e,4)}static addLocalTransforms(t,e){t.addFieldOffset(7,e,0)}static startLocalTransformsVector(t,e){t.startVector(48,e,8)}static addGlobalTransforms(t,e){t.addFieldOffset(8,e,0)}static startGlobalTransformsVector(t,e){t.startVector(48,e,8)}static endMeshes(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,6),t.requiredField(e,8),t.requiredField(e,10),t.requiredField(e,12),t.requiredField(e,14),t.requiredField(e,16),t.requiredField(e,18),t.requiredField(e,20),e}static createMeshes(t,e,s,i,n,r,o,a,l,h){return Se.startMeshes(t),Se.addCoordinates(t,e),Se.addMeshesItems(t,s),Se.addSamples(t,i),Se.addRepresentations(t,n),Se.addMaterials(t,r),Se.addCircleExtrusions(t,o),Se.addShells(t,a),Se.addLocalTransforms(t,l),Se.addGlobalTransforms(t,h),Se.endMeshes(t)}}class we{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsRelation(t,e){return(e||new we).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsRelation(t,e){return t.setPosition(t.position()+4),(e||new we).__init(t.readInt32(t.position())+t.position(),t)}data(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}dataLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startRelation(t){t.startObject(1)}static addData(t,e){t.addFieldOffset(0,e,0)}static createDataVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startDataVector(t,e){t.startVector(4,e,4)}static endRelation(t){const e=t.endObject();return t.requiredField(e,4),e}static createRelation(t,e){return we.startRelation(t),we.addData(t,e),we.endRelation(t)}}class xe{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSpatialStructure(t,e){return(e||new xe).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSpatialStructure(t,e){return t.setPosition(t.position()+4),(e||new xe).__init(t.readInt32(t.position())+t.position(),t)}localId(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb_pos+t):null}mutate_local_id(t){const e=this.bb.__offset(this.bb_pos,4);return 0!==e&&(this.bb.writeUint32(this.bb_pos+e,t),!0)}category(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}children(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new xe).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}childrenLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}static startSpatialStructure(t){t.startObject(3)}static addLocalId(t,e){t.addFieldInt32(0,e,null)}static addCategory(t,e){t.addFieldOffset(1,e,0)}static addChildren(t,e){t.addFieldOffset(2,e,0)}static createChildrenVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startChildrenVector(t,e){t.startVector(4,e,4)}static endSpatialStructure(t){return t.endObject()}static createSpatialStructure(t,e,s,i){return xe.startSpatialStructure(t),null!==e&&xe.addLocalId(t,e),xe.addCategory(t,s),xe.addChildren(t,i),xe.endSpatialStructure(t)}}class Oe{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsModel(t,e){return(e||new Oe).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsModel(t,e){return t.setPosition(t.position()+4),(e||new Oe).__init(t.readInt32(t.position())+t.position(),t)}static bufferHasIdentifier(t){return t.__has_identifier("0001")}metadata(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}guids(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}guidsLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}guidsItems(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}guidsItemsLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}guidsItemsArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}maxLocalId(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readUint32(this.bb_pos+t):0}mutate_max_local_id(t){const e=this.bb.__offset(this.bb_pos,10);return 0!==e&&(this.bb.writeUint32(this.bb_pos+e,t),!0)}localIds(t){const e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}localIdsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}localIdsArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}categories(t,e){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}categoriesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}meshes(t){const e=this.bb.__offset(this.bb_pos,16);return e?(t||new Se).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}attributes(t,e){const s=this.bb.__offset(this.bb_pos,18);return s?(e||new ee).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}attributesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}relations(t,e){const s=this.bb.__offset(this.bb_pos,20);return s?(e||new we).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}relationsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}relationsItems(t){const e=this.bb.__offset(this.bb_pos,22);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}relationsItemsLength(){const t=this.bb.__offset(this.bb_pos,22);return t?this.bb.__vector_len(this.bb_pos+t):0}relationsItemsArray(){const t=this.bb.__offset(this.bb_pos,22);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}guid(t){const e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__string(this.bb_pos+e,t):null}spatialStructure(t){const e=this.bb.__offset(this.bb_pos,26);return e?(t||new xe).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}alignments(t,e){const s=this.bb.__offset(this.bb_pos,28);return s?(e||new te).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}alignmentsLength(){const t=this.bb.__offset(this.bb_pos,28);return t?this.bb.__vector_len(this.bb_pos+t):0}geometries(t){const e=this.bb.__offset(this.bb_pos,30);return e?(t||new Ee).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}uniqueAttributes(t,e){const s=this.bb.__offset(this.bb_pos,32);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}uniqueAttributesLength(){const t=this.bb.__offset(this.bb_pos,32);return t?this.bb.__vector_len(this.bb_pos+t):0}relationNames(t,e){const s=this.bb.__offset(this.bb_pos,34);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}relationNamesLength(){const t=this.bb.__offset(this.bb_pos,34);return t?this.bb.__vector_len(this.bb_pos+t):0}static startModel(t){t.startObject(16)}static addMetadata(t,e){t.addFieldOffset(0,e,0)}static addGuids(t,e){t.addFieldOffset(1,e,0)}static createGuidsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startGuidsVector(t,e){t.startVector(4,e,4)}static addGuidsItems(t,e){t.addFieldOffset(2,e,0)}static createGuidsItemsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startGuidsItemsVector(t,e){t.startVector(4,e,4)}static addMaxLocalId(t,e){t.addFieldInt32(3,e,0)}static addLocalIds(t,e){t.addFieldOffset(4,e,0)}static createLocalIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startLocalIdsVector(t,e){t.startVector(4,e,4)}static addCategories(t,e){t.addFieldOffset(5,e,0)}static createCategoriesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startCategoriesVector(t,e){t.startVector(4,e,4)}static addMeshes(t,e){t.addFieldOffset(6,e,0)}static addAttributes(t,e){t.addFieldOffset(7,e,0)}static createAttributesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAttributesVector(t,e){t.startVector(4,e,4)}static addRelations(t,e){t.addFieldOffset(8,e,0)}static createRelationsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startRelationsVector(t,e){t.startVector(4,e,4)}static addRelationsItems(t,e){t.addFieldOffset(9,e,0)}static createRelationsItemsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startRelationsItemsVector(t,e){t.startVector(4,e,4)}static addGuid(t,e){t.addFieldOffset(10,e,0)}static addSpatialStructure(t,e){t.addFieldOffset(11,e,0)}static addAlignments(t,e){t.addFieldOffset(12,e,0)}static createAlignmentsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAlignmentsVector(t,e){t.startVector(4,e,4)}static addGeometries(t,e){t.addFieldOffset(13,e,0)}static addUniqueAttributes(t,e){t.addFieldOffset(14,e,0)}static createUniqueAttributesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startUniqueAttributesVector(t,e){t.startVector(4,e,4)}static addRelationNames(t,e){t.addFieldOffset(15,e,0)}static createRelationNamesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startRelationNamesVector(t,e){t.startVector(4,e,4)}static endModel(t){const e=t.endObject();return t.requiredField(e,6),t.requiredField(e,8),t.requiredField(e,12),t.requiredField(e,14),t.requiredField(e,16),t.requiredField(e,24),e}static finishModelBuffer(t,e){t.finish(e,"0001")}static finishSizePrefixedModelBuffer(t,e){t.finish(e,"0001",!0)}}var ve=(t=>(t[t.ONE=0]="ONE",t[t.TWO=1]="TWO",t))(ve||{}),Le=(t=>(t[t.NONE=0]="NONE",t[t.SHELL=1]="SHELL",t[t.CIRCLE_EXTRUSION=2]="CIRCLE_EXTRUSION",t))(Le||{}),Pe=(t=>(t[t.DEFAULT=0]="DEFAULT",t))(Pe||{});const Ne=65536;var Me=(t=>(t[t.LINE=0]="LINE",t[t.SHELL=1]="SHELL",t))(Me||{}),De=(t=>(t[t.UPDATE=0]="UPDATE",t[t.CREATE=1]="CREATE",t[t.DELETE=2]="DELETE",t[t.FINISH=3]="FINISH",t))(De||{}),Ue=(t=>(t[t.GEOMETRY=0]="GEOMETRY",t[t.WIRES=1]="WIRES",t[t.INVISIBLE=2]="INVISIBLE",t))(Ue||{}),Ve=(t=>(t[t.CREATE_MODEL=0]="CREATE_MODEL",t[t.DELETE_MODEL=1]="DELETE_MODEL",t[t.EXECUTE=2]="EXECUTE",t[t.RAYCAST=3]="RAYCAST",t[t.FETCH_BOXES=4]="FETCH_BOXES",t[t.REFRESH_VIEW=5]="REFRESH_VIEW",t[t.RECOMPUTE_MESHES=6]="RECOMPUTE_MESHES",t[t.CREATE_MATERIAL=7]="CREATE_MATERIAL",t[t.THROW_ERROR=8]="THROW_ERROR",t))(Ve||{}),Be=(t=>(t[t.VISIBLE=0]="VISIBLE",t))(Be||{}),ze=(t=>(t[t.POINT=0]="POINT",t[t.LINE=1]="LINE",t[t.FACE=2]="FACE",t))(ze||{});class Ge{static containedInParallelPlanes(t,e){let s=!0;for(const i of t){const t=i.distanceToPoint(e);s=s&&t>=0}return s}static collides(t,e,s){for(const i of e){if(this.getPointDistance(i,s,t)<0)return!1}return!0}static getPointDistance(t,e,s){const i=t.normal;for(const t of this.dimensions){const n=i[t]>=0!==e;this.tempPoint[t]=n?s.max[t]:s.min[t]}return t.distanceToPoint(this.tempPoint)}}ot(Ge,"tempPoint",new ft.Vector3),ot(Ge,"dimensions",["x","y","z"]);class ke{static transform(t,e,s=new ft.Frustum){for(let i=0;i<s.planes.length;i++){const n=s.planes[i],r=t.planes[i];n.copy(r),n.applyMatrix4(e)}return s}static isIncluded(t,e){return Ge.collides(t,e,!0)}static collides(t,e){return Ge.collides(t,e,!1)}}function He(t,e,s=2){const i=e&&e.length,n=i?e[0]*s:t.length;let r=Ye(t,0,n,s,!0);const o=[];if(!r||r.next===r.prev)return o;let a,l,h;if(i&&(r=function(t,e,s,i){const n=[];for(let s=0,r=e.length;s<r;s++){const o=Ye(t,e[s]*i,s<r-1?e[s+1]*i:t.length,i,!1);o===o.next&&(o.steiner=!0),n.push(es(o))}n.sort(Ke);for(let t=0;t<n.length;t++)s=Qe(n[t],s);return s}(t,e,r,s)),t.length>80*s){a=1/0,l=1/0;let e=-1/0,i=-1/0;for(let r=s;r<n;r+=s){const s=t[r],n=t[r+1];s<a&&(a=s),n<l&&(l=n),s>e&&(e=s),n>i&&(i=n)}h=Math.max(e-a,i-l),h=0!==h?32767/h:0}return je(r,o,s,a,l,h,0),o}function Ye(t,e,s,i,n){let r;if(n===function(t,e,s,i){let n=0;for(let r=e,o=s-i;r<s;r+=i)n+=(t[o]-t[r])*(t[r+1]+t[o+1]),o=r;return n}(t,e,s,i)>0)for(let n=e;n<s;n+=i)r=us(n/i|0,t[n],t[n+1],r);else for(let n=s-i;n>=e;n-=i)r=us(n/i|0,t[n],t[n+1],r);return r&&os(r,r.next)&&(fs(r),r=r.next),r}function We(t,e){if(!t)return t;e||(e=t);let s,i=t;do{if(s=!1,i.steiner||!os(i,i.next)&&0!==rs(i.prev,i,i.next))i=i.next;else{if(fs(i),i=e=i.prev,i===i.next)break;s=!0}}while(s||i!==e);return e}function je(t,e,s,i,n,r,o){if(!t)return;!o&&r&&function(t,e,s,i){let n=t;do{0===n.z&&(n.z=ts(n.x,n.y,e,s,i)),n.prevZ=n.prev,n.nextZ=n.next,n=n.next}while(n!==t);n.prevZ.nextZ=null,n.prevZ=null,function(t){let e,s=1;do{let i,n=t;t=null;let r=null;for(e=0;n;){e++;let o=n,a=0;for(let t=0;t<s&&(a++,o=o.nextZ,o);t++);let l=s;for(;a>0||l>0&&o;)0!==a&&(0===l||!o||n.z<=o.z)?(i=n,n=n.nextZ,a--):(i=o,o=o.nextZ,l--),r?r.nextZ=i:t=i,i.prevZ=r,r=i;n=o}r.nextZ=null,s*=2}while(e>1)}(n)}(t,i,n,r);let a=t;for(;t.prev!==t.next;){const l=t.prev,h=t.next;if(r?Ze(t,i,n,r):qe(t))e.push(l.i,t.i,h.i),fs(t),t=h.next,a=h.next;else if((t=h)===a){o?1===o?je(t=Xe(We(t),e),e,s,i,n,r,2):2===o&&$e(t,e,s,i,n,r):je(We(t),e,s,i,n,r,1);break}}}function qe(t){const e=t.prev,s=t,i=t.next;if(rs(e,s,i)>=0)return!1;const n=e.x,r=s.x,o=i.x,a=e.y,l=s.y,h=i.y,c=Math.min(n,r,o),d=Math.min(a,l,h),u=Math.max(n,r,o),f=Math.max(a,l,h);let p=i.next;for(;p!==e;){if(p.x>=c&&p.x<=u&&p.y>=d&&p.y<=f&&is(n,a,r,l,o,h,p.x,p.y)&&rs(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}function Ze(t,e,s,i){const n=t.prev,r=t,o=t.next;if(rs(n,r,o)>=0)return!1;const a=n.x,l=r.x,h=o.x,c=n.y,d=r.y,u=o.y,f=Math.min(a,l,h),p=Math.min(c,d,u),I=Math.max(a,l,h),_=Math.max(c,d,u),m=ts(f,p,e,s,i),E=ts(I,_,e,s,i);let g=t.prevZ,b=t.nextZ;for(;g&&g.z>=m&&b&&b.z<=E;){if(g.x>=f&&g.x<=I&&g.y>=p&&g.y<=_&&g!==n&&g!==o&&is(a,c,l,d,h,u,g.x,g.y)&&rs(g.prev,g,g.next)>=0)return!1;if(g=g.prevZ,b.x>=f&&b.x<=I&&b.y>=p&&b.y<=_&&b!==n&&b!==o&&is(a,c,l,d,h,u,b.x,b.y)&&rs(b.prev,b,b.next)>=0)return!1;b=b.nextZ}for(;g&&g.z>=m;){if(g.x>=f&&g.x<=I&&g.y>=p&&g.y<=_&&g!==n&&g!==o&&is(a,c,l,d,h,u,g.x,g.y)&&rs(g.prev,g,g.next)>=0)return!1;g=g.prevZ}for(;b&&b.z<=E;){if(b.x>=f&&b.x<=I&&b.y>=p&&b.y<=_&&b!==n&&b!==o&&is(a,c,l,d,h,u,b.x,b.y)&&rs(b.prev,b,b.next)>=0)return!1;b=b.nextZ}return!0}function Xe(t,e){let s=t;do{const i=s.prev,n=s.next.next;!os(i,n)&&as(i,s,s.next,n)&&cs(i,n)&&cs(n,i)&&(e.push(i.i,s.i,n.i),fs(s),fs(s.next),s=t=n),s=s.next}while(s!==t);return We(s)}function $e(t,e,s,i,n,r){let o=t;do{let t=o.next.next;for(;t!==o.prev;){if(o.i!==t.i&&ns(o,t)){let a=ds(o,t);return o=We(o,o.next),a=We(a,a.next),je(o,e,s,i,n,r,0),void je(a,e,s,i,n,r,0)}t=t.next}o=o.next}while(o!==t)}function Ke(t,e){let s=t.x-e.x;if(0===s&&(s=t.y-e.y,0===s)){s=(t.next.y-t.y)/(t.next.x-t.x)-(e.next.y-e.y)/(e.next.x-e.x)}return s}function Qe(t,e){const s=function(t,e){let s=e;const i=t.x,n=t.y;let r,o=-1/0;if(os(t,s))return s;do{if(os(t,s.next))return s.next;if(n<=s.y&&n>=s.next.y&&s.next.y!==s.y){const t=s.x+(n-s.y)*(s.next.x-s.x)/(s.next.y-s.y);if(t<=i&&t>o&&(o=t,r=s.x<s.next.x?s:s.next,t===i))return r}s=s.next}while(s!==e);if(!r)return null;const a=r,l=r.x,h=r.y;let c=1/0;s=r;do{if(i>=s.x&&s.x>=l&&i!==s.x&&ss(n<h?i:o,n,l,h,n<h?o:i,n,s.x,s.y)){const e=Math.abs(n-s.y)/(i-s.x);cs(s,t)&&(e<c||e===c&&(s.x>r.x||s.x===r.x&&Je(r,s)))&&(r=s,c=e)}s=s.next}while(s!==a);return r}(t,e);if(!s)return e;const i=ds(s,t);return We(i,i.next),We(s,s.next)}function Je(t,e){return rs(t.prev,t,e.prev)<0&&rs(e.next,t,t.next)<0}function ts(t,e,s,i,n){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-s)*n|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-i)*n|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function es(t){let e=t,s=t;do{(e.x<s.x||e.x===s.x&&e.y<s.y)&&(s=e),e=e.next}while(e!==t);return s}function ss(t,e,s,i,n,r,o,a){return(n-o)*(e-a)>=(t-o)*(r-a)&&(t-o)*(i-a)>=(s-o)*(e-a)&&(s-o)*(r-a)>=(n-o)*(i-a)}function is(t,e,s,i,n,r,o,a){return!(t===o&&e===a)&&ss(t,e,s,i,n,r,o,a)}function ns(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let s=t;do{if(s.i!==t.i&&s.next.i!==t.i&&s.i!==e.i&&s.next.i!==e.i&&as(s,s.next,t,e))return!0;s=s.next}while(s!==t);return!1}(t,e)&&(cs(t,e)&&cs(e,t)&&function(t,e){let s=t,i=!1;const n=(t.x+e.x)/2,r=(t.y+e.y)/2;do{s.y>r!=s.next.y>r&&s.next.y!==s.y&&n<(s.next.x-s.x)*(r-s.y)/(s.next.y-s.y)+s.x&&(i=!i),s=s.next}while(s!==t);return i}(t,e)&&(rs(t.prev,t,e.prev)||rs(t,e.prev,e))||os(t,e)&&rs(t.prev,t,t.next)>0&&rs(e.prev,e,e.next)>0)}function rs(t,e,s){return(e.y-t.y)*(s.x-e.x)-(e.x-t.x)*(s.y-e.y)}function os(t,e){return t.x===e.x&&t.y===e.y}function as(t,e,s,i){const n=hs(rs(t,e,s)),r=hs(rs(t,e,i)),o=hs(rs(s,i,t)),a=hs(rs(s,i,e));return n!==r&&o!==a||(!(0!==n||!ls(t,s,e))||(!(0!==r||!ls(t,i,e))||(!(0!==o||!ls(s,t,i))||!(0!==a||!ls(s,e,i)))))}function ls(t,e,s){return e.x<=Math.max(t.x,s.x)&&e.x>=Math.min(t.x,s.x)&&e.y<=Math.max(t.y,s.y)&&e.y>=Math.min(t.y,s.y)}function hs(t){return t>0?1:t<0?-1:0}function cs(t,e){return rs(t.prev,t,t.next)<0?rs(t,e,t.next)>=0&&rs(t,t.prev,e)>=0:rs(t,e,t.prev)<0||rs(t,t.next,e)<0}function ds(t,e){const s=ps(t.i,t.x,t.y),i=ps(e.i,e.x,e.y),n=t.next,r=e.prev;return t.next=e,e.prev=t,s.next=n,n.prev=s,i.next=s,s.prev=i,r.next=i,i.prev=r,i}function us(t,e,s,i){const n=ps(t,e,s);return i?(n.next=i.next,n.prev=i,i.next.prev=n,i.next=n):(n.prev=n,n.next=n),n}function fs(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function ps(t,e,s){return{i:t,x:e,y:s,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}class Is{constructor(){ot(this,"_inverseMatrix",new ft.Matrix4),ot(this,"_localPlane",new ft.Plane),ot(this,"_tempLine",new ft.Line3),ot(this,"_tempVector",new ft.Vector3),ot(this,"_plane"),ot(this,"_plane2DCoordinateSystem",new ft.Matrix4),ot(this,"_precission",1e4)}get plane(){if(!this._plane)throw new Error("Fragments: Plane not set");return this._plane}set plane(t){this._plane=t}createEdges(t){const{meshes:e,posAttr:s}=t;let i=0;s.array.fill(0);const n=[];let r=0;const o=new ft.Mesh;for(const t of e)if(t.geometry){if(t.geometry.boundsTree||t.geometry.computeBoundsTree(),!t.geometry.boundsTree)throw new Error("Fragments: Bounds tree not found for edges generation.");if(t instanceof ft.InstancedMesh){if(0===t.count)continue;const e=t;for(let a=0;a<e.count;a++){o.geometry=t.geometry,o.matrix.copy(t.matrix);const l=new ft.Matrix4;e.getMatrixAt(a,l),o.applyMatrix4(l),o.applyMatrix4(t.matrixWorld),o.updateMatrix(),o.updateMatrixWorld(),this._inverseMatrix.copy(o.matrixWorld).invert(),this._localPlane.copy(this.plane).applyMatrix4(this._inverseMatrix),i=this.shapecast(o,s,i),i!==r&&(n.push(i),r=i)}}else this._inverseMatrix.copy(t.matrixWorld).invert(),this._localPlane.copy(this.plane).applyMatrix4(this._inverseMatrix),i=this.shapecast(t,s,i),i!==r&&(n.push(i),r=i)}return{indexes:n,index:i}}createFills(t,e){this.updatePlane2DCoordinateSystem();const s=[];let i=0;for(let n=0;n<e.length;n++){const r=e[n],o=[];for(let t=i;t<r;t+=2)o.push(3*t);const a=this.computeFill(o,t);for(const t of a)s.push(t);i=r}return s}computeFill(t,e){const s=new Map,i={},n=new Map;let r=0;const o=new Map,a=new Map,l=new Set,h=this._precission;for(let c=0;c<t.length;c++){const d=t[c];let u=0,f=0,p=0,I=0;const _=e[d],m=e[d+1],E=e[d+2],g=e[d+3],b=e[d+4],C=e[d+5];if(this._tempVector.set(_,m,E),this._tempVector.applyMatrix4(this._plane2DCoordinateSystem),u=Math.trunc(this._tempVector.x*h)/h,f=Math.trunc(this._tempVector.y*h)/h,this._tempVector.set(g,b,C),this._tempVector.applyMatrix4(this._plane2DCoordinateSystem),p=Math.trunc(this._tempVector.x*h)/h,I=Math.trunc(this._tempVector.y*h)/h,u===p&&f===I)continue;const T=`${u}|${f}`,A=`${p}|${I}`;s.has(T)||s.set(T,d/3),s.has(A)||s.set(A,d/3+1);const R=s.get(T),y=s.get(A);i[R]=[u,f],i[y]=[p,I];const F=a.has(R),S=o.has(R),w=a.has(y),x=o.has(y);if(!(F||S||w||x))a.set(R,r),o.set(y,r),l.add(r),n.set(r,[R,y]),r++;else if(F&&x){const t=a.get(R),e=o.get(y);if(t!==e){const s=n.get(e),i=n.get(t);if(!s||!i)continue;n.delete(t),l.delete(t),o.set(i[i.length-1],e),o.delete(s[s.length-1]);for(const t of i)s.push(t)}else l.delete(e);a.delete(R),o.delete(y)}else if(S&&w){const t=a.get(y),e=o.get(R);if(t!==e){const s=n.get(e),i=n.get(t);if(!s||!i)continue;n.delete(t),l.delete(t),o.set(i[i.length-1],e),o.delete(s[s.length-1]);for(const t of i)s.push(t)}else l.delete(e);a.delete(y),o.delete(R)}else if(F&&w){const t=a.get(y),e=a.get(R),s=n.get(e),i=n.get(t);if(!s||!i)continue;n.delete(t),l.delete(t),a.delete(s[0]),a.delete(i[0]),o.delete(i[i.length-1]),a.set(i[i.length-1],e),i.reverse(),s.splice(0,0,...i)}else if(S&&x){const t=o.get(y),e=o.get(R),s=n.get(e),i=n.get(t);if(!s||!i)continue;n.delete(t),l.delete(t),o.delete(s[s.length-1]),o.delete(i[i.length-1]),a.delete(i[0]),o.set(i[0],e),i.reverse(),s.push(...i)}else if(F){const t=a.get(R),e=n.get(t);if(!e)continue;e.unshift(y),a.delete(R),a.set(y,t)}else if(S){const t=o.get(R),e=n.get(t);if(!e)continue;e.push(y),o.delete(R),o.set(y,t)}else if(w){const t=a.get(y),e=n.get(t);if(!e)continue;e.unshift(R),a.delete(y),a.set(R,t)}else if(x){const t=o.get(y),e=n.get(t);if(!e)continue;e.push(R),o.delete(y),o.set(R,t)}}const c=[];for(const[t,e]of n){if(l.has(t))continue;const s=[],n=new Map;let r=0;for(const t of e){const e=i[t];s.push(e[0],e[1]),n.set(r++,t)}const o=He(s);for(const t of o){const e=n.get(t);if(void 0===e)throw new Error("Fragments: Map error!");c.push(e)}}return c}updatePlane2DCoordinateSystem(){this._plane2DCoordinateSystem=new ft.Matrix4;const t=this.plane.normal,e=new ft.Vector3;let s,i;if(this.plane.coplanarPoint(e),Math.abs(t.z)>.99)s=new ft.Vector3(1,0,0),i=new ft.Vector3(0,1,0);else if(Math.abs(t.x)>.99)s=new ft.Vector3(0,1,0),i=new ft.Vector3(0,0,1);else if(Math.abs(t.y)>.99)s=new ft.Vector3(1,0,0),i=new ft.Vector3(0,0,1);else{const e=Math.abs(t.x)<.5?new ft.Vector3(1,0,0):new ft.Vector3(0,1,0);s=new ft.Vector3,s.crossVectors(e,t).normalize(),i=new ft.Vector3,i.crossVectors(t,s).normalize()}this._plane2DCoordinateSystem.fromArray([s.x,s.y,s.z,0,i.x,i.y,i.z,0,t.x,t.y,t.z,0,e.x,e.y,e.z,1]),this._plane2DCoordinateSystem.invert()}shapecast(t,e,s){return t.geometry.boundsTree.shapecast({intersectsBounds:t=>this._localPlane.intersectsBox(t),intersectsTriangle:i=>{let n=0;if(this._tempLine.start.copy(i.a),this._tempLine.end.copy(i.b),this._localPlane.intersectLine(this._tempLine,this._tempVector)){const i=this._tempVector.applyMatrix4(t.matrixWorld);e.setXYZ(s,i.x,i.y,i.z),n++,s++}if(this._tempLine.start.copy(i.b),this._tempLine.end.copy(i.c),this._localPlane.intersectLine(this._tempLine,this._tempVector)){const i=this._tempVector.applyMatrix4(t.matrixWorld);e.setXYZ(s,i.x,i.y,i.z),n++,s++}if(this._tempLine.start.copy(i.c),this._tempLine.end.copy(i.a),this._localPlane.intersectLine(this._tempLine,this._tempVector)){const i=this._tempVector.applyMatrix4(t.matrixWorld);e.setXYZ(s,i.x,i.y,i.z),n++,s++}2!==n&&(s-=n)}}),s}}class _s{constructor(){ot(this,"int"),ot(this,"float"),ot(this,"buffer"),ot(this,"s1",4),ot(this,"s2",8);const{intBuffer:t,floatBuffer:e,buffer:s}=this.newBuffers();this.int=t,this.float=e,this.buffer=s}newBuffers(){const t=new Int32Array(1),e=t.buffer;return{intBuffer:t,floatBuffer:new Float32Array(e),buffer:new Uint8Array(e)}}}class ms{static check(t){const e=Number.isInteger(t),s=t<this._max,i=t>this._min;return e&&s&&i}}ot(ms,"_max",2147483647),ot(ms,"_min",-2147483648);const Es=class t{constructor(){ot(this,"_core",new _s),ot(this,"_handlers"),ot(this,"_result",-1),ot(this,"handleObject",(t=>{const e=Object.keys(t);for(const s of e)t.hasOwnProperty(s)&&this.compute(t[s])})),ot(this,"handleString",(t=>{const e=t.length;for(let s=0;s<e;++s){const e=t.codePointAt(s);this._core.int[0]=e,this.update()}})),ot(this,"handleBoolean",(t=>{this._core.int[0]=t?1:0,this.update()})),ot(this,"handleNumber",(t=>{(ms.check(t)?this._core.int:this._core.float)[0]=t,this.update()})),this._handlers=this.newHandlers()}get value(){return~this._result}fromMaterialData(t){const{modelId:e,objectClass:s,currentLod:i,templateId:n,...r}=t;this.reset(),this.compute(e),this.compute(s),this.compute(r),this.compute(i),this.compute(void 0!==n)}generate(t){this.reset();for(const e of t)this.compute(e);return this.value}compute(t){return this.getHandler(t)(t),this}reset(){return this._result=-1,this}getHandler(t){const e=typeof t,s=this._handlers[e];if(!s)throw new Error("Fragments: Unsupported input type");return s}newHandlers(){return{number:this.handleNumber,boolean:this.handleBoolean,string:this.handleString,object:this.handleObject}}update(){for(let e=0;e<this._core.s1;++e){this._result^=this._core.buffer[e];for(let e=0;e<this._core.s2;++e)1&this._result?this._result=this._result>>1^t._polynomial:this._result>>=1}}};ot(Es,"_polynomial",2197175160);let gs=Es;const bs=class t{constructor(t,e){ot(this,"_first"),this._first=this.newData(t,e)}static getComplementary(t,e){let s=0;const i=t.position.length;s=this.makeBufferComplementary(i,t,s,e),s!==1/0&&e(s,1/0)}static get(t,e,s,i){const{filtered:n,position:r,size:o}=this.getData(t,s);return this.setAllBufferData(n,e,r,o,i),{position:r,size:o}}fullOf(t){const e=this._first.following,s=this._first.data;return null===e&&s===t}update(t,e){const s=this.getBufferData(t);if(!(s.data===e)){const{a:i,c:n,b:r}=this.newBuffers(t,s,e);this.setupInputData(s,i,n),this.setupUpdateBuffers(i,r,n)}}size(t){let e=0,s=this._first;for(;null!==s;){this.doesFilterPass(t,s)&&e++,s=s.following}return e}static setAllBufferData(t,e,s,i,n){for(let r=0;r<t.length;++r){const o=t[r];this.transform(o,e),this.setBuffers(s,i,r),n&&n(r,o.data)}}static makeBufferComplementary(t,e,s,i){for(let n=0;n<t;++n){const t=this.getBuffers(e,n),{position:r,size:o}=t;r>s&&i(s,r-s),s=r+o}return s}static setBuffers(t,e,s){t[s]=this._tempData.position;const i=this._tempData.size===1/0;e[s]=i?this._inf:this._tempData.size}add(e,s,i){if(!t._stash.length)return this.newData(s,i,e);const n=t._stash.pop();if(!n)throw new Error("Fragments: No stash found");return n.position=e,n.size=s,n.data=i,n}remove(e){e&&(e.following=null,e.past=null,t._stash.push(e))}static getData(t,e){const s=t.filter(e),i=s.length;return{filtered:s,position:new Uint32Array(i),size:new Uint32Array(i)}}filter(t){const e=[];let s=this._first;for(;null!==s;){this.doesFilterPass(t,s)&&e.push(s),s=s.following}return e}static transform(t,e){const s=this.getTempData(),i=t.position+t.size,n=i===e.length;if(s.position=e[t.position],n)s.size=1/0;else{const t=e[i];s.size=t-s.position}return s}static getBuffers(t,e){const s=t.position[e];let i;return i=t.size[e]===this._inf?1/0:t.size[e],{position:s,size:i}}static getTempData(){return this._tempData?this._tempData:{position:0,size:0}}doesFilterPass(t,e){return!t||t(e.data)}setupUpdateBuffers(t,e,s){this.chainBuffers(t,e,s),this.setupFirstBuffer(t,e),this.setupLastBuffer(s,e),this.setupMiddleBufferStart(e),this.setupMiddleBufferEnd(e)}setupMiddleBufferEnd(t){var e;if((null==(e=t.following)?void 0:e.data)===t.data){if(!t.following)return;const e=t.following.size+t.size,s=t.following.following;t.size=e,this.remove(t.following),t.following=s,t.following&&(t.following.past=t)}}setupFirstBuffer(t,e){t.size||(t.past?t.past.following=e:this._first=e,e.past=t.past,this.remove(t))}setupMiddleBufferStart(t){var e;if((null==(e=t.past)?void 0:e.data)===t.data){if(!t.past)return;t.size=t.past.size+t.size,t.position=t.past.position;const e=t.past.past;this.remove(t.past),t.past=e,t.past?t.past.following=t:this._first=t}}chainBuffers(t,e,s){t.following=e,e.past=t,e.following=s,s.past=e}setupLastBuffer(t,e){t.size||(t.following&&(t.following.past=e),e.following=t.following,this.remove(t))}newBuffers(t,e,s){const i=t-e.position,n=this.add(e.position,i,e.data),r=this.add(t,1,s),o=e.size-n.size-1;return{a:n,c:this.add(t+1,o,e.data),b:r}}setupInputData(t,e,s){t.past?(t.past.following=e,e.past=t.past):this._first=e,t.following&&(t.following.past=s,s.following=t.following),this.remove(t)}newData(t,e,s=0){return{position:s,size:t,past:null,following:null,data:e}}getBufferData(t){let e=this._first;for(;;){const s=null===e,i=e.position<=t,n=t<e.position+e.size;if(s||i&&n)return e;e=e.following}}};ot(bs,"_stash",[]),ot(bs,"_tempData",{position:0,size:0}),ot(bs,"_inf",4294967295);let Cs=bs;class Ts{static fixNumber(t){return Number.isNaN(t)?0:Number.isFinite(t)?t:0}static forEach(t,e){if(Array.isArray(t)){let s=0;for(const i of t)e(i,s++)}else e(t,0)}}class As{static estimateCapacity(){const t=this.capacityFactor,e=window.screen.width,s=window.screen.height,i=window.devicePixelRatio;return Math.trunc(e*s*i*i*t)}}ot(As,"capacityFactor",200);class Rs{static check(t,e,s){const i=this.get(s),n=t[e];return Boolean(n&i)}static apply(t,e,s,i){const n=this.get(s);i?t[e]|=n:t[e]&=~n}static checkMemory(t){if(t>Ne)throw new Error("Fragments: Memory overflow!")}static get(t){return 1<<t}}class ys{static parseMaterial(t){const e=t.r()/255,s=t.g()/255,i=t.b()/255,n=t.a()/255,r=t.a()<255;return{color:new ft.Color(e,s,i),renderedFaces:t.renderedFaces(),opacity:n,transparent:r}}static parseBox(t,e){this.getBox(t,e,"min"),this.getBox(t,e,"max")}static parseTransform(t,e){return this.getVector(t,"position",this._doubleVector),this.getVector(t,"xDirection",this._floatVector),this.getVector(t,"yDirection",this._floatVector),this.computeZVector(),this.setTransform(e),e}static setTransform(t){const{x:e,y:s,z:i}=this._temp.xDirection,{x:n,y:r,z:o}=this._temp.yDirection,{x:a,y:l,z:h}=this._temp.zDirection,{x:c,y:d,z:u}=this._temp.position;t.set(e,n,a,c,s,r,l,d,i,o,h,u,0,0,0,1)}static getBox(t,e,s){t[s](this._floatVector);const i=this._floatVector.x(),n=this._floatVector.y(),r=this._floatVector.z();e[s].x=Ts.fixNumber(i),e[s].y=Ts.fixNumber(n),e[s].z=Ts.fixNumber(r)}static getVector(t,e,s){t[e](s);const i=this._temp[e],n=s.x(),r=s.y(),o=s.z();i.x=Ts.fixNumber(n),i.y=Ts.fixNumber(r),i.z=Ts.fixNumber(o)}static computeZVector(){this._temp.zDirection.crossVectors(this._temp.xDirection,this._temp.yDirection)}}ot(ys,"_temp",{position:new ft.Vector3,xDirection:new ft.Vector3,yDirection:new ft.Vector3,zDirection:new ft.Vector3}),ot(ys,"_doubleVector",new ue),ot(ys,"_floatVector",new se);const Fs=class{static get(t,e,s){this.fetchSampleTransform(t,e),this.fetchItemTransform(t,e),s.multiplyMatrices(this._item,this._sample)}static getBox(t,e){t.bbox(this._box),ys.parseBox(this._box,e)}static getBoxData(t){this._min.copy(t.min),this._max.copy(t.max),this._center.addVectors(this._min,this._max),this._center.divideScalar(2),t.getSize(this._distance)}static boxSize(t){return this.getBoxData(t),this.applyTransformer(),this._edge.start=this._min.clone(),this._edge.end=this._max.clone(),this._edge}static applyTransformer(){const{x:t,y:e,z:s}=this._distance,i=Math.max(t,e,s);t===i?this._transformers.x():e===i?this._transformers.y():this._transformers.z()}static fetchItemTransform(t,e){const s=t.item();e.globalTransforms(s,this._transform),ys.parseTransform(this._transform,this._item)}static fetchSampleTransform(t,e){const s=t.localTransform();e.localTransforms(s,this._transform),ys.parseTransform(this._transform,this._sample)}static setBoxZ(){this._min.set(this._center.x,this._center.y,this._min.z),this._max.set(this._center.x,this._center.y,this._max.z)}static setBoxY(){this._min.set(this._center.x,this._min.y,this._center.z),this._max.set(this._center.x,this._max.y,this._center.z)}static setBoxX(){this._min.set(this._min.x,this._center.y,this._center.z),this._max.set(this._max.x,this._center.y,this._center.z)}};ot(Fs,"_transform",new me),ot(Fs,"_min",new ft.Vector3),ot(Fs,"_max",new ft.Vector3),ot(Fs,"_center",new ft.Vector3),ot(Fs,"_distance",new ft.Vector3),ot(Fs,"_edge",new ft.Line3),ot(Fs,"_item",new ft.Matrix4),ot(Fs,"_sample",new ft.Matrix4),ot(Fs,"_box",new ce),ot(Fs,"_transformers",{x:()=>Fs.setBoxX(),y:()=>Fs.setBoxY(),z:()=>Fs.setBoxZ()});let Ss=Fs;class ws{static getWidth(t){return t.getSize(this._temp.vector),this._temp.vector.x>this._temp.vector.y&&this._temp.vector.set(this._temp.vector.y,this._temp.vector.x,this._temp.vector.z),this._temp.vector.y>this._temp.vector.z&&this._temp.vector.set(this._temp.vector.x,this._temp.vector.z,this._temp.vector.y),this._temp.vector.x>this._temp.vector.y&&this._temp.vector.set(this._temp.vector.y,this._temp.vector.x,this._temp.vector.z),this._temp.vector.y}}ot(ws,"_temp",{vector:new ft.Vector3});class xs{static getEarcutDimensions(t){const e=Math.abs(t.x),s=Math.abs(t.y),i=Math.abs(t.z);if(i>e&&i>s){return t.z>0?[0,1]:[1,0]}if(s>e&&s>i){return t.y>0?[2,0]:[0,2]}return t.x>0?[1,2]:[2,1]}}const Os=new gt,vs=new Ct;class Ls extends pt{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.setAttribute("position",new It([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.setAttribute("uv",new It([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))}applyMatrix4(t){const e=this.attributes.instanceStart,s=this.attributes.instanceEnd;return void 0!==e&&(e.applyMatrix4(t),s.applyMatrix4(t),e.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}setPositions(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const s=new _t(e,6,1);return this.setAttribute("instanceStart",new mt(s,3,0)),this.setAttribute("instanceEnd",new mt(s,3,3)),this.instanceCount=this.attributes.instanceStart.count,this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const s=new _t(e,6,1);return this.setAttribute("instanceColorStart",new mt(s,3,0)),this.setAttribute("instanceColorEnd",new mt(s,3,3)),this}fromWireframeGeometry(t){return this.setPositions(t.attributes.position.array),this}fromEdgesGeometry(t){return this.setPositions(t.attributes.position.array),this}fromMesh(t){return this.fromWireframeGeometry(new Et(t.geometry)),this}fromLineSegments(t){const e=t.geometry;return this.setPositions(e.attributes.position.array),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new gt);const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;void 0!==t&&void 0!==e&&(this.boundingBox.setFromBufferAttribute(t),Os.setFromBufferAttribute(e),this.boundingBox.union(Os))}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new bt),null===this.boundingBox&&this.computeBoundingBox();const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;if(void 0!==t&&void 0!==e){const s=this.boundingSphere.center;this.boundingBox.getCenter(s);let i=0;for(let n=0,r=t.count;n<r;n++)vs.fromBufferAttribute(t,n),i=Math.max(i,s.distanceToSquared(vs)),vs.fromBufferAttribute(e,n),i=Math.max(i,s.distanceToSquared(vs));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}}Ft.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new yt(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}},At.line={uniforms:Rt.merge([Ft.common,Ft.fog,Ft.line]),vertexShader:"\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );\n\t\t\t\tvec3 worldUp = normalize( cross( worldDir, tmpFwd ) );\n\t\t\t\tvec3 worldFwd = cross( worldDir, worldUp );\n\t\t\t\tworldPos = position.y < 0.5 ? start: end;\n\n\t\t\t\t// height offset\n\t\t\t\tfloat hw = linewidth * 0.5;\n\t\t\t\tworldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.xyz += worldFwd * hw;\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\tworldPos.xyz -= worldFwd * 2.0 * hw;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",fragmentShader:"\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t"};class Ps extends Tt{constructor(t){super({type:"LineMaterial",uniforms:Rt.clone(At.line.uniforms),vertexShader:At.line.vertexShader,fragmentShader:At.line.fragmentShader,clipping:!0}),this.isLineMaterial=!0,this.setValues(t)}get color(){return this.uniforms.diffuse.value}set color(t){this.uniforms.diffuse.value=t}get worldUnits(){return"WORLD_UNITS"in this.defines}set worldUnits(t){!0===t?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}get linewidth(){return this.uniforms.linewidth.value}set linewidth(t){this.uniforms.linewidth&&(this.uniforms.linewidth.value=t)}get dashed(){return"USE_DASH"in this.defines}set dashed(t){!0===t!==this.dashed&&(this.needsUpdate=!0),!0===t?this.defines.USE_DASH="":delete this.defines.USE_DASH}get dashScale(){return this.uniforms.dashScale.value}set dashScale(t){this.uniforms.dashScale.value=t}get dashSize(){return this.uniforms.dashSize.value}set dashSize(t){this.uniforms.dashSize.value=t}get dashOffset(){return this.uniforms.dashOffset.value}set dashOffset(t){this.uniforms.dashOffset.value=t}get gapSize(){return this.uniforms.gapSize.value}set gapSize(t){this.uniforms.gapSize.value=t}get opacity(){return this.uniforms.opacity.value}set opacity(t){this.uniforms&&(this.uniforms.opacity.value=t)}get resolution(){return this.uniforms.resolution.value}set resolution(t){this.uniforms.resolution.value.copy(t)}get alphaToCoverage(){return"USE_ALPHA_TO_COVERAGE"in this.defines}set alphaToCoverage(t){this.defines&&(!0===t!==this.alphaToCoverage&&(this.needsUpdate=!0),!0===t?this.defines.USE_ALPHA_TO_COVERAGE="":delete this.defines.USE_ALPHA_TO_COVERAGE)}}const Ns=new wt,Ms=new Ct,Ds=new Ct,Us=new wt,Vs=new wt,Bs=new wt,zs=new Ct,Gs=new Ot,ks=new xt,Hs=new Ct,Ys=new gt,Ws=new bt,js=new wt;let qs,Zs;function Xs(t,e,s){return js.set(0,0,-e,1).applyMatrix4(t.projectionMatrix),js.multiplyScalar(1/js.w),js.x=Zs/s.width,js.y=Zs/s.height,js.applyMatrix4(t.projectionMatrixInverse),js.multiplyScalar(1/js.w),Math.abs(Math.max(js.x,js.y))}class $s extends St{constructor(t=new Ls,e=new Ps({color:16777215*Math.random()})){super(t,e),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const t=this.geometry,e=t.attributes.instanceStart,s=t.attributes.instanceEnd,i=new Float32Array(2*e.count);for(let t=0,n=0,r=e.count;t<r;t++,n+=2)Ms.fromBufferAttribute(e,t),Ds.fromBufferAttribute(s,t),i[n]=0===n?0:i[n-1],i[n+1]=i[n]+Ms.distanceTo(Ds);const n=new _t(i,2,1);return t.setAttribute("instanceDistanceStart",new mt(n,1,0)),t.setAttribute("instanceDistanceEnd",new mt(n,1,1)),this}raycast(t,e){const s=this.material.worldUnits,i=t.camera;null!==i||s||console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const n=void 0!==t.params.Line2&&t.params.Line2.threshold||0;qs=t.ray;const r=this.matrixWorld,o=this.geometry,a=this.material;let l,h;if(Zs=a.linewidth+n,null===o.boundingSphere&&o.computeBoundingSphere(),Ws.copy(o.boundingSphere).applyMatrix4(r),s)l=.5*Zs;else{l=Xs(i,Math.max(i.near,Ws.distanceToPoint(qs.origin)),a.resolution)}if(Ws.radius+=l,!1!==qs.intersectsSphere(Ws)){if(null===o.boundingBox&&o.computeBoundingBox(),Ys.copy(o.boundingBox).applyMatrix4(r),s)h=.5*Zs;else{h=Xs(i,Math.max(i.near,Ys.distanceToPoint(qs.origin)),a.resolution)}Ys.expandByScalar(h),!1!==qs.intersectsBox(Ys)&&(s?function(t,e){const s=t.matrixWorld,i=t.geometry,n=i.attributes.instanceStart,r=i.attributes.instanceEnd;for(let o=0,a=Math.min(i.instanceCount,n.count);o<a;o++){ks.start.fromBufferAttribute(n,o),ks.end.fromBufferAttribute(r,o),ks.applyMatrix4(s);const i=new Ct,a=new Ct;qs.distanceSqToSegment(ks.start,ks.end,a,i),a.distanceTo(i)<.5*Zs&&e.push({point:a,pointOnLine:i,distance:qs.origin.distanceTo(a),object:t,face:null,faceIndex:o,uv:null,uv1:null})}}(this,e):function(t,e,s){const i=e.projectionMatrix,n=t.material.resolution,r=t.matrixWorld,o=t.geometry,a=o.attributes.instanceStart,l=o.attributes.instanceEnd,h=Math.min(o.instanceCount,a.count),c=-e.near;qs.at(1,Bs),Bs.w=1,Bs.applyMatrix4(e.matrixWorldInverse),Bs.applyMatrix4(i),Bs.multiplyScalar(1/Bs.w),Bs.x*=n.x/2,Bs.y*=n.y/2,Bs.z=0,zs.copy(Bs),Gs.multiplyMatrices(e.matrixWorldInverse,r);for(let e=0,o=h;e<o;e++){if(Us.fromBufferAttribute(a,e),Vs.fromBufferAttribute(l,e),Us.w=1,Vs.w=1,Us.applyMatrix4(Gs),Vs.applyMatrix4(Gs),Us.z>c&&Vs.z>c)continue;if(Us.z>c){const t=Us.z-Vs.z,e=(Us.z-c)/t;Us.lerp(Vs,e)}else if(Vs.z>c){const t=Vs.z-Us.z,e=(Vs.z-c)/t;Vs.lerp(Us,e)}Us.applyMatrix4(i),Vs.applyMatrix4(i),Us.multiplyScalar(1/Us.w),Vs.multiplyScalar(1/Vs.w),Us.x*=n.x/2,Us.y*=n.y/2,Vs.x*=n.x/2,Vs.y*=n.y/2,ks.start.copy(Us),ks.start.z=0,ks.end.copy(Vs),ks.end.z=0;const o=ks.closestPointToPointParameter(zs,!0);ks.at(o,Hs);const h=vt.lerp(Us.z,Vs.z,o),d=h>=-1&&h<=1,u=zs.distanceTo(Hs)<.5*Zs;if(d&&u){ks.start.fromBufferAttribute(a,e),ks.end.fromBufferAttribute(l,e),ks.start.applyMatrix4(r),ks.end.applyMatrix4(r);const i=new Ct,n=new Ct;qs.distanceSqToSegment(ks.start,ks.end,n,i),s.push({point:n,pointOnLine:i,distance:qs.origin.distanceTo(n),object:t,face:null,faceIndex:e,uv:null,uv1:null})}}}(this,i,e))}}onBeforeRender(t){const e=this.material.uniforms;e&&e.resolution&&(t.getViewport(Ns),this.material.uniforms.resolution.value.set(Ns.z,Ns.w))}}class Ks extends Ls{constructor(){super(),this.isLineGeometry=!0,this.type="LineGeometry"}setPositions(t){const e=t.length-3,s=new Float32Array(2*e);for(let i=0;i<e;i+=3)s[2*i]=t[i],s[2*i+1]=t[i+1],s[2*i+2]=t[i+2],s[2*i+3]=t[i+3],s[2*i+4]=t[i+4],s[2*i+5]=t[i+5];return super.setPositions(s),this}setColors(t){const e=t.length-3,s=new Float32Array(2*e);for(let i=0;i<e;i+=3)s[2*i]=t[i],s[2*i+1]=t[i+1],s[2*i+2]=t[i+2],s[2*i+3]=t[i+3],s[2*i+4]=t[i+4],s[2*i+5]=t[i+5];return super.setColors(s),this}setFromPoints(t){const e=t.length-1,s=new Float32Array(6*e);for(let i=0;i<e;i++)s[6*i]=t[i].x,s[6*i+1]=t[i].y,s[6*i+2]=t[i].z||0,s[6*i+3]=t[i+1].x,s[6*i+4]=t[i+1].y,s[6*i+5]=t[i+1].z||0;return super.setPositions(s),this}fromLine(t){const e=t.geometry;return this.setPositions(e.attributes.position.array),this}}class Qs extends $s{constructor(t=new Ks,e=new Ps({color:16777215*Math.random()})){super(t,e),this.isLine2=!0,this.type="Line2"}}class Js{constructor(t){ot(this,"model"),ot(this,"_endpointsMaterials",{interior:new ft.PointsMaterial({color:15658734,size:8,sizeAttenuation:!1,depthTest:!1}),exterior:new ft.PointsMaterial({color:16777215,size:16,sizeAttenuation:!1,depthTest:!1})}),ot(this,"_absoluteAlignments",new ft.Group),ot(this,"_horizontalAlignments",new ft.Group),ot(this,"_verticalAlignments",new ft.Group),ot(this,"_alignmentMaterials",new Map([[ge.NONE,new Ps({color:16777215,linewidth:5,depthTest:!1})],[ge.LINES,new Ps({color:16711935,linewidth:5,depthTest:!1})],[ge.CLOTHOID,new Ps({color:16711680,linewidth:5,depthTest:!1})],[ge.ELLIPSE_ARC,new Ps({color:65535,linewidth:5,depthTest:!1})],[ge.PARABOLA,new Ps({color:255,linewidth:5,depthTest:!1})]])),this.model=t}async getAlignments(){return this._absoluteAlignments.children.length||await this.constructAlignments(),this._absoluteAlignments}async getHorizontalAlignments(){return this._horizontalAlignments.children.length||await this.constructAlignments(),this._horizontalAlignments}async getVerticalAlignments(){return this._verticalAlignments.children.length||await this.constructAlignments(),this._verticalAlignments}async getAlignmentStyles(){return{...this._alignmentMaterials,...this._endpointsMaterials}}async constructAlignments(){const t=await this.model.threads.invoke(this.model.modelId,"getAlignments");for(const e of t)this.constructLine(e.absolute,this._absoluteAlignments),this.constructLine(e.horizontal,this._horizontalAlignments),this.constructLine(e.vertical,this._verticalAlignments)}constructLine(t,e){if(!t.length)return;const s=[],i=[],n=new ft.Group;e.add(n);const r=t[0].points,o=t[t.length-1].points;i.push(o[0],o[1],o[2]),i.push(r[r.length-3],r[r.length-2],r[r.length-1]);for(const e of t){const t=e.points;s.push(t[0],t[1],t[2]),s.push(t[t.length-3],t[t.length-2],t[t.length-1]);const i=new Ks;i.setPositions(t);const r=this._alignmentMaterials.get(e.type),o=new Qs(i,r);n.add(o),o.renderOrder=1,o.userData.points=t}const{interior:a,exterior:l}=this._endpointsMaterials;this.constructPoints(s,a,n),this.constructPoints(i,l,n)}constructPoints(t,e,s){const i=new ft.Points,n=new ft.BufferGeometry,r=new Float32Array(t),o=new ft.BufferAttribute(r,3);n.setAttribute("position",o),i.geometry=n,i.material=e,s.add(i),i.renderOrder=2}dispose(){this._absoluteAlignments.removeFromParent();for(const t of this._absoluteAlignments.children){const e=t;e.geometry.dispose(),e.geometry=void 0,e.material=void 0}for(const t of Object.values(this._alignmentMaterials))t.dispose();this._alignmentMaterials={}}}class ti{async setup(t,e,s,i,n){const r=this.getCreateModelMessage(t,s,i,n),o=this.formatModelData(s),a=await t.threads.fetch(r,o);this.updateBox(e,a)}formatModelData(t){if(t instanceof ArrayBuffer)return[t]}updateBox(t,e){t.min.copy(e.boundingBox.min),t.max.copy(e.boundingBox.max)}getCreateModelMessage(t,e,s,i){return{class:Ve.CREATE_MODEL,modelId:t.modelId,modelData:e,raw:s,config:i}}}class ei{async getBoxes(t,e){const s=this.getIndividualBoxesIds(e),i=this.getBoxRequest(t,s),n=await t.threads.fetch(i);return this.getAllBoxes(n,t)}async getMergedBox(t,e){const s=this.getBoxRequest(t,[e]),{boxes:i}=await t.threads.fetch(s),[n]=i;return this.getAbsoluteBox(n,t)}getAbsoluteBox(t,e){const s=new ft.Box3;return s.copy(t),s.applyMatrix4(e.object.matrixWorld),s}getIndividualBoxesIds(t){if(!t)return;const e=[];for(const s of t)e.push([s]);return e}getAllBoxes(t,e){const s=t.boxes,i=[];for(const t of s){const s=new ft.Box3;s.copy(t),s.applyMatrix4(e.object.matrixWorld),i.push(s)}return i}getBoxRequest(t,e){return{class:Ve.FETCH_BOXES,modelId:t.modelId,localIds:e}}}class si{constructor(){ot(this,"_coordinationMatrices",new Map)}async getCoordinationMatrix(t){let e=this._coordinationMatrices.get(t.modelId);if(e)return e;e=new ft.Matrix4,this._coordinationMatrices.set(t.modelId,e);const[s,i,n,r,o,a,l,h,c]=await this.getCoordinates(t),d=new ft.Vector3(r,o,a),u=new ft.Vector3(l,h,c),f=(new ft.Vector3).crossVectors(d,u);return e.set(r,l,f.x,s,o,h,f.y,i,a,c,f.z,n,0,0,0,1),e}async getCoordinates(t){const e=t.modelId;return t.threads.invoke(e,"getCoordinates")}async getPositions(t,e){const s=[e],i=await t.threads.invoke(t.modelId,"getPositions",s);return this.getAbsolutePositions(i,t)}getAbsolutePositions(t,e){const s=[];for(const i of t){const{x:t,y:n,z:r}=i,o=new ft.Vector3(t,n,r);o.applyMatrix4(e.object.matrixWorld),s.push(o)}return s}}class ii extends Map{constructor(t,e){super(e),ot(this,"tracker",null),ot(this,"localId"),ot(this,"guard",(()=>!0)),this.localId=t}get object(){const t={};for(const[e,s]of this.entries())t[e]=s.value;return t}set(t,e){if(!(this.guard??(()=>!0))(t,e))return this;const s=void 0!==e.type?e:{value:e.value,type:this.getType(t)};if(!this.tracker)return super.set(t,s);if(null===this.localId)return console.warn("Item attributes are missing a valid localId. Changes can't be tracked."),super.set(t,s);let i=this.tracker.get(this.localId);return i||(i={type:"modified",added:{},deleted:[],modified:{}},this.tracker.set(this.localId,i)),"added"===i.type?i.data[t]=s:"modified"===i.type&&(this.has(t)?i.modified[t]=s:i.deleted.includes(t)?(i.deleted=i.deleted.filter((e=>e!==t)),i.modified[t]=s):i.added[t]=s),super.set(t,s)}setValue(t,e){return this.set(t,{value:e,type:this.getType(t)})}setType(t,e){const s=this.getValue(t);return s?this.set(t,{value:s,type:e}):this}delete(t){if(!this.tracker)return super.delete(t);const e=this.get("localId");if(void 0===e||"number"!=typeof e)return console.warn("Item attributes are missing a valid localId. Changes can't be tracked."),"localId"!==t&&super.delete(t);if("localId"===t)return!1;if(!this.has(t))return!1;let s=this.tracker.get(e);return s||(s={type:"modified",added:{},deleted:[],modified:{}},this.tracker.set(e,s)),"added"===s.type?delete s.data[t]:"modified"===s.type&&(t in s.added?delete s.added[t]:t in s.modified?(delete s.modified[t],s.deleted.push(t)):s.deleted.push(t)),super.delete(t)}getValue(t){const e=this.get(t);return e?e.value:null}getType(t){var e;return null==(e=this.get(t))?void 0:e.type}}class ni extends Map{constructor(t,e){super(e),ot(this,"tracker",null),ot(this,"localId"),ot(this,"guard",(()=>!0)),ot(this,"onItemsRequested",null),this.localId=t}get itemChanges(){if(!this.tracker)return null;if(!this.localId)return console.warn("Item relations can't be tracked."),null;let t=this.tracker.get(this.localId);return t||(t={type:"modified",added:{},deleted:new Set,removed:{},modified:{}},this.tracker.set(this.localId,t)),t}set(t,e){const s=this.has(t);if(!(this.guard??(()=>!0))(t,e))return this;const i=this.itemChanges;return i?(s?i.modified[t]=e:i.added[t]=e,super.set(t,e)):super.set(t,e)}add(t,e){var s;const i=this.has(t);let n=this.get(t);if(!n)return n=new Set([e]),this.set(t,n),!0;if(!n||n.has(e))return!1;const r=this.itemChanges;if(!r)return n.add(e),!0;if(i)if(null==(s=r.removed[t])?void 0:s.has(e))r.removed[t].delete(e),0===r.removed[t].size&&delete r.removed[t];else{let s=r.modified[t];s||(s=new Set,r.modified[t]=s),s.add(e)}else{let s=r.added[t];s||(s=new Set,r.added[t]=s),s.add(e)}return n.add(e),!0}remove(t,e){var s;const i=this.get(t);if(!i)return!1;if(!i.has(e))return!1;const n=this.itemChanges;if(!n)return i.delete(e);if(null==(s=n.modified[t])?void 0:s.has(e))n.modified[t].delete(e),0===n.modified[t].size&&delete n.modified[t];else{let s=n.removed[t];s||(s=new Set,n.removed[t]=s),s.add(e)}return i.delete(e)}delete(t){if(!this.has(t))return!1;const e=this.itemChanges;return e?(e.deleted.add(t),super.delete(t)):super.delete(t)}async getItems(t){if(!this.onItemsRequested)return null;const e=this.get(t);if(!e)return null;return await this.onItemsRequested([...e])}}class ri{constructor(t,e){ot(this,"model"),ot(this,"localId"),ot(this,"_indices",null),ot(this,"_transform",null),ot(this,"_normals",null),ot(this,"_positions",null),ot(this,"_vertices",null),ot(this,"_triangles",null),ot(this,"_position",null),ot(this,"_box",null),this.model=t,this.localId=e}async get(){const[t]=await this.model.threads.invoke(this.model.modelId,"getItemsGeometry",[[this.localId]]);for(const e of t){e.transform=(new ft.Matrix4).fromArray(e.transform.elements);const{indices:t,normals:s,positions:i,transform:n}=e;this._indices||(this._indices=[]),this._normals||(this._normals=[]),this._positions||(this._positions=[]),this._transform||(this._transform=[]),this._indices.push(t),this._normals.push(s),this._positions.push(i),this._transform.push(n)}return t}async getIndices(){return null!==this._indices||await this.get(),this._indices}async getTransform(){return null!==this._transform||await this.get(),this._transform}async getNormals(){return null!==this._normals||await this.get(),this._normals}async getPositions(){return null!==this._positions||await this.get(),this._positions}async getVertices(){if(this._vertices)return this._vertices;const t=await this.getPositions(),e=await this.getTransform();if(!t||!e)return this._vertices;this._vertices=[];for(let s=0;s<t.length;s++){const i=t[s],n=e[s];if(!i||!n)continue;const r=[];this._vertices.push(r);const o=Object.keys(i).length/3,a=[];for(let t=0;t<o;t++){const e=i[3*t],s=i[3*t+1],o=i[3*t+2];if("number"!=typeof e||"number"!=typeof s||"number"!=typeof o)continue;const l=`${e},${s},${o}`;if(a.includes(l))continue;a.push(l);const h=new ft.Vector3(e,s,o);h.applyMatrix4(n),r.push(h)}}return this._vertices}async getTriangles(){if(this._triangles)return this._triangles;const t=await this.getIndices(),e=await this.getPositions(),s=await this.getTransform();if(!t||!e||!s)return this._triangles;this._triangles=[];for(let i=0;i<t.length;i++){const n=t[i],r=e[i],o=s[i];if(!n||!r||!o)continue;const a=[];this._triangles.push(a);for(let t=0;t<n.length;t+=3){const e=n[t],s=n[t+1],i=n[t+2],l=new ft.Vector3(r[3*e],r[3*e+1],r[3*e+2]),h=new ft.Vector3(r[3*s],r[3*s+1],r[3*s+2]),c=new ft.Vector3(r[3*i],r[3*i+1],r[3*i+2]);l.applyMatrix4(o),h.applyMatrix4(o),c.applyMatrix4(o),a.push(new ft.Triangle(l,h,c))}}return this._triangles}async getPosition(){if(!this._position){if(null===this.localId)return null;this._position=await this.model.getPositions([this.localId])}return this._position}async getBox(){if(!this._box){if(null===this.localId)return null;this._box=await this.model.getBoxes([this.localId])}return this._box}async setVisibility(t){await this.model.setVisible([this.localId],t)}async getVisibility(){const[t]=await this.model.getVisible([this.localId]);return t}}class oi{constructor(t,e){ot(this,"model"),ot(this,"_localId",null),ot(this,"_attributes",null),ot(this,"_relations",null),ot(this,"_guid",null),ot(this,"_category",null),ot(this,"_geometry",null),this.model=t,"number"==typeof e&&(this._localId=e),"string"==typeof e&&(this._guid=e)}async getLocalId(){if(!this._localId){if(!this._guid)throw new Error("Fragments: Item localId couldn't be get.");[this._localId]=await this.model.threads.invoke(this.model.modelId,"getLocalIdsByGuids",[[this._guid]])}return this._localId}async getAttributes(){if(this._attributes)return this._attributes;const t=await this.getLocalId();if(null===t)return null;const e=await this.model.threads.invoke(this.model.modelId,"getItemAttributes",[t]);if(this._attributes=new ii(t),!e){const e=this.model.attrsChanges.get(t);if(!e||"added"!==e.type)return null;this._attributes.localId=t;for(const[t,s]of Object.entries(e.data))this._attributes.set(t,s);return this._attributes}const s=this.model.attrsChanges.get(t);if(s&&"modified"===s.type)for(const[t,e]of Object.entries(s.added))this._attributes.set(t,e);for(const t in e){const{value:i,type:n}=e[t];"modified"===(null==s?void 0:s.type)&&s.deleted.includes(t)||("modified"===(null==s?void 0:s.type)&&t in s.modified?this._attributes.set(t,s.modified[t]):this._attributes.set(t,{value:i,type:n}))}return this._attributes.tracker=this.model.attrsChanges,this._attributes}async getRelations(){if(this._relations)return this._relations;const t=await this.getLocalId();if(null===t)return null;const e=await this.model.threads.invoke(this.model.modelId,"getItemRelations",[t]);if(!e)return null;this._relations=new ni(t),this._relations.onItemsRequested=async t=>{const e=[];for(const s of t){const t=this.model.getItem(s);t&&e.push(t)}return e};const s=this.model.relsChanges.get(t);if(s&&"modified"===s.type)for(const[t,e]of Object.entries(s.added))this._relations.set(t,e);for(const[t,i]of Object.entries(e))if("modified"!==(null==s?void 0:s.type)||!s.deleted.has(t))if("modified"===(null==s?void 0:s.type)&&t in s.modified){const e=new Set([...s.modified[t],...i]);this._relations.set(t,new Set(e))}else this._relations.set(t,new Set(i));return this._relations.tracker=this.model.relsChanges,this._relations}async getGuid(){if(!this._guid){const t=await this.getLocalId();if(null===t)return null;[this._guid]=await this.model.threads.invoke(this.model.modelId,"getGuidsByLocalIds",[[t]])}return this._guid}async getCategory(){if(!this._category){const t=await this.getLocalId();if(null===t)return null;this._category=await this.model.threads.invoke(this.model.modelId,"getItemCategory",[t])}return this._category}async getGeometry(){if(this._geometry)return this._geometry;const t=await this.getLocalId();if(null===t)return null;return new ri(this.model,t)}async getData(t=[]){var e;const s=await this.getLocalId();if(null==s)return{};t.push(s);const i=null==(e=await this.getAttributes())?void 0:e.object,n=await this.getRelations(),r={};if(n)for(const e of n.keys()){const s=[];r[e]=s;const i=await n.getItems(e);if(i)for(const e of i){const i=await e.getLocalId();if(!i)continue;if(void 0!==t.find((t=>t===i)))continue;t.push(i);const n=await e.getData(t);n&&s.push(n)}}return{...i,...r}}}class ai{getItem(t,e){return new oi(t,e)}async getItemsData(t,e,s){return t.threads.invoke(t.modelId,"getItemsData",[e,s])}async getItemsChildren(t,e){return t.threads.invoke(t.modelId,"getItemsChildren",[e])}}class li{constructor(){ot(this,"getClippingPlanesEvent",(()=>[])),ot(this,"_tempMatrix",new ft.Matrix4),ot(this,"_tempVec",new ft.Vector3),ot(this,"_tempFrustum",new ft.Frustum),ot(this,"_updateCameraPositionEvent",(()=>{})),ot(this,"_updateCameraFrustumEvent",(()=>{})),ot(this,"_updateFOVEvent",(()=>{})),ot(this,"_updateOrthoSizeEvent",(()=>{}))}async refreshView(t,e){const s=this.setup(e,t),i=ke.transform(this._tempFrustum,this._tempMatrix),n=this.newViewRequest(i,s,t);await t.threads.fetch(n)}useCamera(t){const e=new ft.Matrix4;this.setCameraPosition(t),this.setCameraFrustum(t,e),this.setFov(t),this.setOrtho()}getOrthoSize(){let t=this._updateOrthoSizeEvent();if(t){t*=this._tempMatrix.getMaxScaleOnAxis()}return t}setup(t,e){t.requests.clean(e.modelId),this._tempMatrix.copy(e.object.matrixWorld).invert(),this._updateCameraPositionEvent(this._tempVec),this._updateCameraFrustumEvent(this._tempFrustum);return this._updateFOVEvent()}newViewRequest(t,e,s){const i=this.newView(t,e,s),n={};return n.class=Ve.REFRESH_VIEW,n.modelId=s.modelId,n.cameraFrustum=t,n.view=i,n}newView(t,e,s){const i={};return i.cameraFrustum=t,i.cameraPosition=this._tempVec.applyMatrix4(this._tempMatrix),i.fov=e,i.orthogonalDimension=this.getOrthoSize(),i.viewSize=Math.max(window.innerWidth,window.innerHeight),i.graphicThreshold=As.estimateCapacity(),i.graphicQuality=-1.5*s.graphicsQuality+2,i.clippingPlanes=this.getPlanes(),i.modelPlacement=s.object.matrixWorld,i}setOrtho(){this._updateOrthoSizeEvent=()=>{}}setFov(t){this._updateFOVEvent=()=>{if(t instanceof ft.PerspectiveCamera)return t.fov}}getPlanes(){const t=[],e=this.getClippingPlanesEvent();for(const s of e){const e=s.clone();e.applyMatrix4(this._tempMatrix),t.push(e)}return t}setCameraPosition(t){this._updateCameraPositionEvent=e=>{e.copy(t.position)}}setCameraFrustum(t,e){this._updateCameraFrustumEvent=s=>{t.updateProjectionMatrix(),t.updateWorldMatrix(!0,!0);const{projectionMatrix:i,matrixWorldInverse:n}=t;e.multiplyMatrices(i,n),s.setFromProjectionMatrix(e)}}}class hi{constructor(){ot(this,"_caster",new ft.Raycaster),ot(this,"_ray",new ft.Ray),ot(this,"_frustum",new ft.Frustum),ot(this,"_inverseTransform",new ft.Matrix4),ot(this,"_t",new ft.Plane),ot(this,"_r",new ft.Plane),ot(this,"_b",new ft.Plane),ot(this,"_l",new ft.Plane),ot(this,"_n",new ft.Plane),ot(this,"_f",new ft.Plane),ot(this,"_tl",new ft.Vector3),ot(this,"_tr",new ft.Vector3),ot(this,"_bl",new ft.Vector3),ot(this,"_br",new ft.Vector3),ot(this,"_tln",new ft.Vector3),ot(this,"_brn",new ft.Vector3),ot(this,"_tlp",new ft.Vector2),ot(this,"_brp",new ft.Vector2),ot(this,"distance",10)}async raycast(t,e){const{frustum:s,ray:i}=this.getRayAndFrustum(e),n=this.getRequest(t,s,i);if(!n)return null;const r=await t.threads.fetch(n);if(r.results&&r.results.length){const[e]=r.results;return this.getResult({hit:e,frustum:s,ray:i,model:t})}return null}async rectangleRaycast(t,e,s){const i=this.getFrustum(s),n=this.getRequest(t,i);if(!n)return null;n.fullyIncluded=s.fullyIncluded;const r=await t.threads.fetch(n);return r.localIds&&r.localIds.length?this.newRectangleCastResponse(r,e):null}async raycastWithSnapping(t,e){const{frustum:s,ray:i}=this.getRayAndFrustum(e),n=this.getRequest(t,s,i);if(!n)return null;n.snappingClass=e.snappingClasses;const r=await t.threads.fetch(n);return r.results?this.newRaycastSnapResult(r,s,i,t):null}screenRectToFrustum(t,e,s,i){return this.screenToCast(t,s,this._tlp),this.screenToCast(e,s,this._brp),this.setVectors(i),this.setPlanes(i),this.newFrustum()}screenToCasterPoint(t,e,s){const i=this.screenToCast(t,e);return this._caster.setFromCamera(i,s),this._caster.ray.clone()}setPlanes(t){this.setBasePoints(),t.getWorldDirection(this._n.normal),this.setEnds(t)}setVectors(t){this.setVector(this._tl,this._tlp,this._tlp,1,t),this.setVector(this._tr,this._brp,this._tlp,1,t),this.setVector(this._bl,this._tlp,this._brp,1,t),this.setVector(this._br,this._brp,this._brp,1,t),this.setVector(this._tln,this._tlp,this._tlp,0,t),this.setVector(this._brn,this._brp,this._brp,0,t)}newFrustum(){return new ft.Frustum(this._t,this._b,this._l,this._r,this._f,this._n)}setEnds(t){this._n.constant=t.position.length(),this._f.normal=this._n.normal,this._f.constant=1/0}screenToCast(t,e,s=new ft.Vector2){const i=e.getBoundingClientRect(),n=i.width/e.clientWidth,r=i.height/e.clientHeight,o=(t.x-i.left)/n,a=(t.y-i.top)/r;return s.x=o/e.clientWidth*2-1,s.y=-a/e.clientHeight*2+1,s}setVector(t,e,s,i,n){t.set(e.x,s.y,i),t.unproject(n)}setPlane(t,e,s,i){t.setFromCoplanarPoints(e,s,i)}setBasePoints(){this.setPlane(this._t,this._tln,this._tl,this._tr),this.setPlane(this._r,this._brn,this._tr,this._br),this.setPlane(this._b,this._brn,this._br,this._bl),this.setPlane(this._l,this._tln,this._bl,this._tl)}setupRay(t,e){t&&(this._ray.copy(t),this._ray.applyMatrix4(this._inverseTransform),e.ray=this._ray)}setupMatrix(t){this._inverseTransform.copy(t.matrixWorld),this._inverseTransform.invert()}getRequest(t,e,s){const{object:i,box:n,modelId:r}=t;return e.intersectsBox(n)?this.newCastRequest(i,r,s,e):null}getRayAndFrustum(t){this.updateCamera(t.camera);const{bottomLeft:e,topRight:s}=this.getCorners(t.mouse);return{ray:this.screenToCasterPoint(t.mouse,t.dom,t.camera),frustum:this.screenRectToFrustum(e,s,t.dom,t.camera)}}getFrustum(t){return this.updateCamera(t.camera),this.screenRectToFrustum(t.topLeft,t.bottomRight,t.dom,t.camera)}getCorners(t){return{bottomLeft:t.clone().subScalar(this.distance),topRight:t.clone().addScalar(this.distance)}}getResult(t){const{hit:e,frustum:s,ray:i,model:n}=t,r={};return this.setPoint(n,e,r),this.setNormal(n,e,r),this.setDistance(n,e,r),this.setRayDistance(n,e,r),this.setBasicHitData(n,e,r,i,s),this.setSnapEdge(n,e,r,"snappedEdgeP1"),this.setSnapEdge(n,e,r,"snappedEdgeP2"),r.facePoints=e.facePoints,r.faceIndices=e.faceIndices,r}updateCamera(t){t.updateProjectionMatrix(),t.updateWorldMatrix(!0,!0)}newCastRequest(t,e,s,i){this.setupMatrix(t);const n={};return n.class=Ve.RAYCAST,n.modelId=e,this.setupRay(s,n),ke.transform(i,this._inverseTransform,this._frustum),n.frustum=this._frustum,n}setSnapEdge(t,e,s,i){if(e[i]){const n=new ft.Vector3;n.copy(e[i]),n.applyMatrix4(t.object.matrixWorld),s[i]=n}else s[i]=void 0}setNormal(t,e,s){if(e.normal){const i=new ft.Vector3;return i.copy(e.normal),i.transformDirection(t.object.matrixWorld),i.normalize(),void(s.normal=i)}s.normal=void 0}setDistance(t,e,s){const i=Math.sqrt(e.cameraSquaredDistance),n=t.object.matrixWorld.getMaxScaleOnAxis();s.distance=i*n}setPoint(t,e,s){const i=new ft.Vector3;i.copy(e.point),i.applyMatrix4(t.object.matrixWorld),s.point=i}newRaycastSnapResult(t,e,s,i){const n=[];for(const r of t.results){const t=this.getResult({hit:r,frustum:e,ray:s,model:i});n.push(t)}return n}newRectangleCastResponse(t,e){return{localIds:t.localIds,fragments:e.list.get(t.modelId)}}setRayDistance(t,e,s){if(void 0===e.raySquaredDistance)s.rayDistance=void 0;else{const i=t.object.matrixWorld.getMaxScaleOnAxis(),n=Math.sqrt(e.raySquaredDistance);s.rayDistance=n*i}}setBasicHitData(t,e,s,i,n){s.itemId=e.itemId,s.localId=e.localId,s.object=t.object,s.fragments=t,s.ray=i,s.frustum=n,s.representationClass=e.representationClass,s.snappingClass=e.snappingClass}}class ci{async resetVisible(t){await t.threads.invoke(t.modelId,"resetVisible")}async getItemsByVisibility(t,e){return t.threads.invoke(t.modelId,"getItemsByVisibility",[e])}async getVisible(t,e){return t.threads.invoke(t.modelId,"getVisible",[e])}}class di{}ot(di,"vertex","\n            #include <common>\n            #include <clipping_planes_pars_vertex>\n\n            attribute float itemFilter;\n            uniform vec2 lodSize;\n            attribute vec3 itemFirst;\n            attribute vec3 itemLast;\n\n            float lodWidth = 2.0;\n            \n            void cutLodLine(const in vec4 first, inout vec4 second ) {\n                float projValue1 = projectionMatrix[2][2];\n                float projValue2 = projectionMatrix[3][2];\n                float approxResult = -(projValue2 / projValue1) / 2.0;\n                float diff1 = approxResult - first.z;\n                float diff2 = second.z - first.z;\n                float cutFilter = diff1 / diff2;\n                second.xyz = mix(first.xyz, second.xyz, cutFilter);\n            }\n                \n            void main() {\n                if (itemFilter == 0.0) {\n                    gl_Position = vec4(0,0,0,0);\n                    return;\n                }\n\n                vec4 rawFirst = vec4(itemFirst, 1.0);\n                vec4 rawLast = vec4(itemLast, 1.0);\n                vec4 first = modelViewMatrix * rawFirst;\n                vec4 last = modelViewMatrix * rawLast;\n                \n                bool lodPerspective = projectionMatrix[2][3] == -1.0;\n                if (lodPerspective) {\n                    bool firstCut = first.z < 0.0 && last.z >= 0.0;\n                    bool lastCut = last.z < 0.0 && first.z >= 0.0;\n                    if (firstCut) {\n                        cutLodLine( first, last );\n                    } else if (lastCut) {\n                        cutLodLine( last, first );\n                    }\n                }\n\n                vec4 firstCut = projectionMatrix * first;\n                vec4 lastCut = projectionMatrix * last;\n                vec3 firstNdc = firstCut.xyz / firstCut.w;\n                vec3 lastNdc = lastCut.xyz / lastCut.w;\n\n                vec2 lodOrientation = lastNdc.xy - firstNdc.xy;\n\n                float lodRatio = lodSize.x / lodSize.y;\n                lodOrientation.x *= lodRatio;\n                lodOrientation = normalize(lodOrientation);\n                \n                vec2 lodDistance = vec2(lodOrientation.y, - lodOrientation.x);\n                lodOrientation.x /= lodRatio;\n                lodDistance.x /= lodRatio;\n\n                if (position.x < 0.0) { \n                    lodDistance *= - 1.0;\n                }\n\n                if (position.y < 0.0) {\n                    lodDistance += -lodOrientation;\n                } else if (position.y > 1.0) {\n                    lodDistance += lodOrientation;\n                }\n\n                lodDistance *= lodWidth;\n                lodDistance /= lodSize.y;\n\n                bool isFirst = position.y < 0.5;\n                vec4 lodPosition = isFirst ? firstCut : lastCut;\n                lodDistance *= lodPosition.w;\n                lodPosition.xy += lodDistance;\n                gl_Position = lodPosition;\n\n                vec4 mvPosition = isFirst ? first : last;\n                #include <clipping_planes_vertex>\n            }\n    "),ot(di,"fragment","\n            #include <common>\n            #include <clipping_planes_pars_fragment>\n\n            uniform vec3 lodColor;\n            uniform float lodOpacity;\n\n            void main() {\n                #include <clipping_planes_fragment>\n                gl_FragColor = vec4(lodColor, lodOpacity);\n                #include <colorspace_fragment>\n            }\n    ");const ui=class t{static setupLodMeshResize(t){t.onBeforeRender=e=>{e.getSize(t.material[0].lodSize)}}static setupLodAttributes(e){e.setIndex(t.indices),e.setAttribute("position",t.vertices)}static setLodBuffer(t,e,s){let i=t.getItemFirst(),n=t.getItemLast(),r=this.setItemFirst(t,i,e,n);const o=this.resetAttributes(i,r,e,n);({itemFirst:i,dataBuffer:r,itemLast:n}=o),this.setupFinish(s,r),t.setAttribute("itemFirst",i),t.setAttribute("itemLast",n)}static setLodVisibility(t,e){const s=this.setupItemFilter(t);this.applyVisibilityState(t,e,s),s.needsUpdate=!0}static getInterAttribute(t,e){return t.getAttribute(e)}static computeLodSphere(e){if(!e.boundingSphere)return;const s=e.getItemFirst();if(s){const i=t.getLodMidPoint(e,s),n=t.getLodRadius(i,s);e.boundingSphere.radius=n}}static newLodMaterialParams(t){const e={lodColor:{value:new ft.Color(t.color)},lodSize:{value:new ft.Vector2(1,1)},lodOpacity:{value:t.opacity??1}};return{uniforms:ft.UniformsUtils.merge([ft.UniformsLib.common,e]),transparent:t.transparent??!1,vertexShader:di.vertex,fragmentShader:di.fragment}}static setLodFilter(t,e){const s=t.getItemFilter(),i=s.array;for(let t=0;t<e.position.length;++t){const s=e.position[t]/2,n=e.size[t]/2;4294967295===n?i.fill(1,s):i.fill(1,s,s+n)}s.needsUpdate=!0}static getInstancedAttribute(t,e){return t.getAttribute(e)}static computeLodBox(t){if(!t.boundingBox)return;const e=t.getItemFirst();if(e){const s=e.data.array;t.boundingBox.setFromArray(s)}else t.boundingBox.makeEmpty()}static setDataBuffer(t,e,s){return(t=e.data).array=s,t.needsUpdate=!0,t}static disposeAllData(e){delete e.attributes.itemFilter,delete e.attributes.position,e.index=null,e.dispose(),t.setupLodAttributes(e)}static setItemFirst(t,e,s,i){let n=null;if(e){s.length===e.data.array.length?n=this.setDataBuffer(n,e,s):(e=void 0,this.disposeAllData(t))}return n}static setupFinish(t,e){t&&(e.onUploadCallback=t)}static resetAttributes(t,e,s,i){return t||(e=new ft.InstancedInterleavedBuffer(s,6,1),t=new ft.InterleavedBufferAttribute(e,3,0),i=new ft.InterleavedBufferAttribute(e,3,3)),{itemFirst:t,dataBuffer:e,itemLast:i}}static setupItemFilter(t){const e=t.getItemFirst().count;let s=t.getItemFilter();return s?s.array.fill(0):(s=new ft.InstancedBufferAttribute(new Uint8Array(e),1),t.setAttribute("itemFilter",s)),s}static applyVisibilityState(t,e,s){!0!==e?e&&this.setLodFilter(t,e):s.array.fill(1)}static getLodMidPoint(t,e){const s=t.boundingSphere.center;return this.tempBox.setFromArray(e.data.array),this.tempBox.getCenter(s),s}static getLodRadius(e,s){let i=0;const n=s.data.array.length;for(let r=0;r<n;r+=3){const n=s.data.array;t.tempVec.fromArray(n,r);const o=e.distanceToSquared(t.tempVec);i=Math.max(i,o)}return Math.sqrt(i)}};ot(ui,"tempVec",new ft.Vector3),ot(ui,"tempBox",new ft.Box3),ot(ui,"vertices",new ft.Float32BufferAttribute([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),ot(ui,"indices",new ft.Uint8BufferAttribute([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5],1));let fi=ui;class pi extends ft.Mesh{constructor(t,e){super(t,e),ot(this,"geometry"),ot(this,"material"),this.geometry=t,this.material=e,fi.setupLodMeshResize(this)}}class Ii extends ft.InstancedBufferGeometry{constructor(){super(),ot(this,"isLODGeometry",!0),fi.setupLodAttributes(this)}isFiltered(){const t=this.getItemFilter();return Boolean(t)}computeBoundingBox(){this.boundingBox||(this.boundingBox=new ft.Box3),fi.computeLodBox(this)}applyMatrix4(t){return this.applyTransformToBuffers(t),this.updateBounds(),this}computeBoundingSphere(){this.boundingSphere||(this.boundingSphere=new ft.Sphere),fi.computeLodSphere(this)}getItemFilter(){return fi.getInstancedAttribute(this,"itemFilter")}getItemLast(){return fi.getInterAttribute(this,"itemLast")}getItemFirst(){return fi.getInterAttribute(this,"itemFirst")}applyTransformToBuffers(t){this.getItemFirst().applyMatrix4(t);this.getItemLast().applyMatrix4(t)}updateBounds(){this.boundingBox&&this.computeBoundingBox(),this.boundingSphere&&this.computeBoundingSphere()}}class _i extends ft.ShaderMaterial{constructor(t){super(fi.newLodMaterialParams(t)),ot(this,"isLodMaterial",!0),ot(this,"isLineMaterial",!0),this.clipping=!0,this.lights=!1,this.needsUpdate=!0}get lodSize(){return this.uniforms.lodSize.value}set lodColor(t){this.uniforms.lodColor.value=t}set lodSize(t){this.uniforms.lodSize.value.copy(t)}get lodColor(){return this.uniforms.lodColor.value}}class mi{constructor(){ot(this,"list",new Yt),ot(this,"_modelMaterialMapping",new Map),ot(this,"_definitions",new Map),ot(this,"_idGenerator",new gs),ot(this,"white",4294967295)}static resetColors(t){for(const e of t){if(!e||!e.color)continue;const{color:t}=e;if(t.isColor)continue;const{r:s,g:i,b:n}=t;e.color=new ft.Color(s,i,n)}}dispose(t){this._definitions.delete(t);const e=this._modelMaterialMapping.get(t);if(e){for(const t of e){const e=this.list.get(t);e&&(e.dispose(),this.list.delete(t))}this._modelMaterialMapping.delete(t)}}get(t,e){const{modelId:s,objectClass:i,currentLod:n,templateId:r}=e;if(!s||void 0===i||void 0===n)throw new Error("Fragments: material definition information is missing to create the material.");this._idGenerator.fromMaterialData({modelId:s,objectClass:i,currentLod:n,templateId:r,...t});const{value:o}=this._idGenerator;return this.getUniqueMaterial(o,t,e)}addDefinitions(t,e){const s=this._definitions.get(t);s?s.push(...e):this._definitions.set(t,e)}createHighlights(t,e){const{tileData:{highlightData:s,highlightIds:i},modelId:n,material:r}=e,{geometry:o}=t,a=t.material.slice(0,2),l=new Map,h=this._definitions.get(n);if(!h)return a;for(let t=0;t<s.position.length;t++){const n=i[t];this.processHighlight(l,n,h,r,e,a);const c=s.position[t],d=s.size[t],u=d===this.white?1/0:d;o.addGroup(c,u,l.get(i[t]))}return a}getFromRequest(t){const{material:e,modelId:s}=t,i=this._definitions.get(s),n=null==i?void 0:i[e];if(!n)throw new Error(`Fragments: Missing mesh material for index ${e}`);return this.get(n,t)}newLODMaterial(t,e){const{data:s}=t,i=new ft.Color(s.color);e.currentLod===Ue.WIRES&&i.multiplyScalar(.85);const n={color:i,...this.getParameters(s)},r=new _i(n);return r.userData={customId:s.customId},r}getParameters(t){const{opacity:e,transparent:s}=t;return{opacity:e,transparent:s||e<1,clipIntersection:!1}}new(t,e){const{objectClass:s,templateId:i}=e;let n;if(s===Me.SHELL)n=new ft.MeshLambertMaterial({color:t.color,transparent:t.opacity<1,opacity:t.opacity,userData:{customId:t.customId},depthTest:t.depthTest??!0});else{if(s!==Me.LINE)throw new Error("Fragments: Unsupported object class");n=this.newLODMaterial({data:t,instancing:void 0!==i},e)}return n}addMaterialToModel(t,e){let s=this._modelMaterialMapping.get(t);s||(s=new Set,this._modelMaterialMapping.set(t,s)),s.add(e)}processHighlight(t,e,s,i,n,r){if(!t.has(e)){const o={...s[i],...s[e]},a=this.get(o,n);r.push(a),t.set(e,r.length-1)}}getUniqueMaterial(t,e,s){const i=s.modelId;let n=this.list.get(t);return n||(n=this.new(e,s),this.list.set(t,n),this.addMaterialToModel(i,t),n)}}class Ei{async getHighlight(t,e){const s=await t.threads.invoke(t.modelId,"getHighlight",[e]);return mi.resetColors(s),s}async highlight(t,e,s){await t.threads.invoke(t.modelId,"highlight",[e,s])}async getHighlightItemIds(t){return t.threads.invoke(t.modelId,"getHighlightItemIds")}async resetHighlight(t,e){await t.threads.invoke(t.modelId,"resetHighlight",[e])}}class gi{async getSection(t,e,s){const i=[e,s];return await t.threads.invoke(t.modelId,"getSection",i)}}class bi{async dispose(t,e,s){e.list.delete(t.modelId),await this.requestModelDelete(t),t.threads.delete(t.modelId),this.deleteAllTiles(t),e.materials.dispose(t.modelId),s.dispose()}async getBuffer(t,e){return t.threads.invoke(t.modelId,"getBuffer",[e])}async getCategories(t){return t.threads.invoke(t.modelId,"getCategories")}async getMaxLocalId(t){return t.threads.invoke(t.modelId,"getMaxLocalId")}async getLocalIdsByGuids(t,e){return t.threads.invoke(t.modelId,"getLocalIdsByGuids",[e])}async getSpatialStructure(t){return t.threads.invoke(t.modelId,"getSpatialStructure")}async getItemsWithGeometry(t){return(await t.threads.invoke(t.modelId,"getItemsWithGeometry",[])).map((e=>t.getItem(e)))}async getItemsWithGeometryCategories(t){return t.threads.invoke(t.modelId,"getItemsWithGeometryCategories",[])}async getItemsIdsWithGeometry(t){return t.threads.invoke(t.modelId,"getItemsWithGeometry",[])}async getItemsOfCategories(t,e){const s=[e];return await t.threads.invoke(t.modelId,"getItemsOfCategories",s)}async getItemsByQuery(t,e){const s=[e];return await t.threads.invoke(t.modelId,"getItemsByQuery",s)}async getMetadata(t){return t.threads.invoke(t.modelId,"getMetadata",[])}async getGuidsByLocalIds(t,e){return t.threads.invoke(t.modelId,"getGuidsByLocalIds",[e])}async requestModelDelete(t){await t.threads.fetch({class:Ve.DELETE_MODEL,modelId:t.modelId})}deleteAllTiles(t){for(const[e]of t.tiles)t.tiles.delete(e)}}class Ci{async getSequenced(t,e,s,i){const n=[e,s,i];return await t.threads.invoke(t.modelId,"getSequenced",n)}}class Ti{constructor(t,e,s){ot(this,"attrsChanges",new Map),ot(this,"relsChanges",new Map),ot(this,"threads"),ot(this,"tiles",new Yt),ot(this,"object",new ft.Object3D),ot(this,"graphicsQuality",0),ot(this,"_boxManager",new ei),ot(this,"_itemsManager",new ai),ot(this,"_coordinatesManager",new si),ot(this,"_setupManager",new ti),ot(this,"_viewManager",new li),ot(this,"_raycastManager",new hi),ot(this,"_visibilityManager",new ci),ot(this,"_highlightManager",new Ei),ot(this,"_sectionManager",new gi),ot(this,"_dataManager",new bi),ot(this,"_sequenceManager",new Ci),ot(this,"_bbox",new ft.Box3),ot(this,"_alignmentsManager"),ot(this,"_meshManager"),ot(this,"_isProcessing",!1),ot(this,"_isLoaded",!1),ot(this,"_frozen",!1),ot(this,"_isSetup",!1),this.object.name=t,this.object.up.set(0,0,1),this._meshManager=e,this.threads=s,this._alignmentsManager=new Js(this),this.tiles.onItemSet.add((({value:t})=>this.object.add(t))),this.tiles.onBeforeDelete.add((({value:t})=>{this.object.remove(t),t.geometry.dispose(),Ts.forEach(t.material,(t=>t.dispose()))}))}get modelId(){return this.object.name}get box(){return this._bbox.clone().applyMatrix4(this.object.matrixWorld)}get isBusy(){const t=this._meshManager.requests.arePending;return!this._isLoaded||this._isProcessing||t}get frozen(){return Boolean(this._frozen)}set frozen(t){t!==this._frozen&&(this._frozen=t,t||this._refreshView())}get getClippingPlanesEvent(){return this._viewManager.getClippingPlanesEvent}set getClippingPlanesEvent(t){this._viewManager.getClippingPlanesEvent=t}async dispose(){this._isLoaded=!1,await this._dataManager.dispose(this,this._meshManager,this._alignmentsManager)}async getSpatialStructure(){return this._dataManager.getSpatialStructure(this)}async getLocalIdsByGuids(t){return this._dataManager.getLocalIdsByGuids(this,t)}async getCategories(){return this._dataManager.getCategories(this)}async getItemsWithGeometryCategories(){return this._dataManager.getItemsWithGeometryCategories(this)}async getItemsWithGeometry(){return this._dataManager.getItemsWithGeometry(this)}async getItemsIdsWithGeometry(){return this._dataManager.getItemsIdsWithGeometry(this)}async getMetadata(){return this._dataManager.getMetadata(this)}async getGuidsByLocalIds(t){return this._dataManager.getGuidsByLocalIds(this,t)}async getBuffer(t=!1){return this._dataManager.getBuffer(this,t)}async getItemsOfCategories(t){return this._dataManager.getItemsOfCategories(this,t)}async getGuids(){return await this.threads.invoke(this.modelId,"getGuids",[])}async getLocalIds(){return await this.threads.invoke(this.modelId,"getLocalIds",[])}async getItemsByQuery(t){return this._dataManager.getItemsByQuery(this,t)}async getItemsMaterialDefinition(t){return await this.threads.invoke(this.modelId,"getItemsMaterialDefinition",[t])}async getItemsGeometry(t){return await this.threads.invoke(this.modelId,"getItemsGeometry",[t])}async getItemsVolume(t){return await this.threads.invoke(this.modelId,"getItemsVolume",[t])}async getAttributeNames(){return await this.threads.invoke(this.modelId,"getAttributeNames",[])}async getAttributeValues(){return await this.threads.invoke(this.modelId,"getAttributeValues",[])}async getAttributesUniqueValues(t){return await this.threads.invoke(this.modelId,"getAttributesUniqueValues",[t])}async getAttributeTypes(){return await this.threads.invoke(this.modelId,"getAttributeTypes",[])}async getRelationNames(){return await this.threads.invoke(this.modelId,"getRelationNames",[])}async getMaxLocalId(){return this._dataManager.getMaxLocalId(this)}getItem(t){return this._itemsManager.getItem(this,t)}async getItemsChildren(t){return this._itemsManager.getItemsChildren(this,t)}async getItemsData(t,e){return this._itemsManager.getItemsData(this,t,e)}async getPositions(t){return this._coordinatesManager.getPositions(this,t)}async getCoordinates(){return this._coordinatesManager.getCoordinates(this)}async getCoordinationMatrix(){return this._coordinatesManager.getCoordinationMatrix(this)}async getMergedBox(t){return this._boxManager.getMergedBox(this,t)}async getBoxes(t){return this._boxManager.getBoxes(this,t)}async getAlignments(){return this._alignmentsManager.getAlignments()}async getHorizontalAlignments(){return this._alignmentsManager.getHorizontalAlignments()}async getVerticalAlignments(){return this._alignmentsManager.getVerticalAlignments()}getAlignmentStyles(){return this._alignmentsManager.getAlignmentStyles()}useCamera(t){this._viewManager.useCamera(t)}async rectangleRaycast(t){return this._raycastManager.rectangleRaycast(this,this._meshManager,t)}async raycast(t){return this._raycastManager.raycast(this,t)}async raycastWithSnapping(t){return this._raycastManager.raycastWithSnapping(this,t)}async setVisible(t,e){const s=[t,e];await this.threads.invoke(this.modelId,"setVisible",s)}async toggleVisible(t){const e=[t];await this.threads.invoke(this.modelId,"toggleVisible",e)}async getItemsByVisibility(t){return this._visibilityManager.getItemsByVisibility(this,t)}async getVisible(t){return this._visibilityManager.getVisible(this,t)}async resetVisible(){return this._visibilityManager.resetVisible(this)}async highlight(t,e){return this._highlightManager.highlight(this,t,e)}async getHighlight(t){return this._highlightManager.getHighlight(this,t)}async resetHighlight(t){return this._highlightManager.resetHighlight(this,t)}async getHighlightItemIds(){return this._highlightManager.getHighlightItemIds(this)}async getSection(t,e){return this._sectionManager.getSection(this,t,e)}async getSequenced(t,e,s){return this._sequenceManager.getSequenced(this,t,e,s)}async handleRequest(t){await this._meshManager.requests.handleRequest(this._meshManager,t)}_finishProcessing(){this._isProcessing=!1}async _refreshView(){this.frozen||(this._isProcessing=!0,await this._viewManager.refreshView(this,this._meshManager))}async _setup(t,e,s){this._isSetup||(this._setupManager.setup(this,this._bbox,t,e,s),this._isLoaded=!0,this._isProcessing=!0,this._isSetup=!0)}}class Ai{constructor(){ot(this,"list",[]),ot(this,"onFinish",(()=>{}))}get arePending(){return this.list.length>0}async handleRequest(t,e){if(e.class===Ve.RECOMPUTE_MESHES)this.add(e.list),e.list=void 0;else if(e.class===Ve.CREATE_MATERIAL){const{materialDefinitions:s,modelId:i}=e;mi.resetColors(s),t.materials.addDefinitions(i,s),e.materialDefinitions=void 0}else e.class===Ve.THROW_ERROR&&console.error(e)}add(t){for(const e of t)this.insert(e)||this.list.push(e),e.tileRequestClass===De.FINISH&&this.onFinish()}clean(t){const e=this.list.filter((e=>e.modelId!==t||e.tileRequestClass!==De.FINISH));this.list=e}insert(t){const{modelId:e,tileId:s,tileRequestClass:i,tileData:n}=t;if(void 0===s)return!1;if(i===De.DELETE){const t=this.list.filter((t=>!((t.tileRequestClass===De.CREATE||t.tileRequestClass===De.DELETE)&&t.modelId===e&&t.tileId===s)));this.list=t}if(i===De.CREATE){const t=this.list.filter((t=>!(t.tileRequestClass===De.CREATE&&t.modelId===e&&t.tileId===s)));this.list=t}if(i===De.UPDATE){const t=this.list.find((t=>t.modelId===e&&t.tileId===s));if(t)return t.tileRequestClass!==De.CREATE&&t.tileRequestClass!==De.UPDATE||(t.tileData=n),!0}return!1}}class Ri{constructor(t){ot(this,"_materials"),ot(this,"white",4294967295),this._materials=t}createMesh(t,e){const s=this._materials.getFromRequest(e);if(!("isLodMaterial"in s)||!s.isLodMaterial)throw new Error("Fragments: material is not an instance of LodMaterial.");const{positions:i}=e;if(!i)throw new Error("Fragments: no positions provided to create the LOD mesh.");const n=new Ii,r=this.deleteAttributeEvent(t);fi.setLodBuffer(n,i,r);return new pi(n,[s])}updateVisibility(t,e){const{geometry:s}=t,{visibilityData:i,highlightData:n}=e;fi.setLodVisibility(s,i),n?(fi.setLodFilter(s,n),Cs.getComplementary(n,((t,e)=>{s.addGroup(t,e,0)}))):s.addGroup(0,1/0,0)}processMesh(t,e){const{geometry:s}=t,{tileData:{visibilityData:i},currentLod:n}=e;if(n===Ue.WIRES&&t instanceof pi)this.updateVisibility(t,e.tileData);else if(i&&i.position.length>0)for(let t=0;t<i.position.length;++t){const e=i.size[t]===this.white,n=i.position[t],r=e?1/0:i.size[t];s.addGroup(n,r,0)}}deleteAttributeEvent(t){return function(){delete this.array}}}class yi{constructor(t){ot(this,"list",new Yt),ot(this,"materials",new mi),ot(this,"lod",new Ri(this.materials)),ot(this,"requests",new Ai),ot(this,"updateThreshold",4),ot(this,"_updateFinished",!0),ot(this,"_onUpdate"),this._onUpdate=t,this.requests.onFinish=()=>this._updateFinished=!0}forceUpdateFinish(t=200){return new Promise((e=>{this._updateFinished=!1;const s=setInterval((()=>{this.update(),this._updateFinished&&(clearInterval(s),e())}),t)}))}update(){const t=performance.now();for(;this.requests.arePending;){const e=this.requests.list.shift();if(e&&(this.processTileRequest(e),this._onUpdate(),performance.now()-t>this.updateThreshold))return}}setTileData(t,e){const{tileId:s,itemId:i,matrix:n,aabb:r}=e;this.setMeshData(t,s,i,n),this.setupBoundings(t,r),this.updateStatus(t,e)}processTileRequest(t){const{tileRequestClass:e,tileId:s,modelId:i}=t,n=this.list.get(i);if(n)if(e===De.CREATE){const e=this.create(t);this.setTileData(e,t),n.tiles.set(e.userData.tileId,e)}else if(e===De.DELETE)n.tiles.delete(s);else if(e===De.UPDATE){const e=n.tiles.get(s);e&&this.updateStatus(e,t)}else e===De.FINISH&&n._finishProcessing()}createMesh(t){const{indices:e,positions:s,normals:i,itemIds:n,faceIds:r}=t,o=new ft.BufferGeometry;this.setIndex(o,e),this.setPositions(s,o),this.setNormals(i,o),this.setItemIds(n,o),this.setFaceIds(r,o);const a=this.materials.getFromRequest(t);return new ft.Mesh(o,[a])}setupBoundings(t,e){const{geometry:s}=t,i=(new ft.Box3).copy(e),n=new ft.Sphere;i.getBoundingSphere(n),s.boundingBox=i,s.boundingSphere=n}create(t){if(t.objectClass===Me.SHELL)return this.createMesh(t);if(t.objectClass===Me.LINE){const e=new ft.BufferGeometry;return this.lod.createMesh(e,t)}throw new Error(`Fragments: object class ${t.objectClass} is not supported.`)}updateStatus(t,e){const{tileData:{highlightData:s},currentLod:i}=e,{geometry:n}=t;if(n.clearGroups(),this.lod.processMesh(t,e),!s||i===Ue.WIRES)return;const r=this.materials.createHighlights(t,e);t.material=r}cleanAttributeMemory(t,e){t.attributes[e].onUpload(this.deleteAttribute(t))}setPositions(t,e){if(!t)throw new Error("Fragments: no positions provided to create the mesh.");e.setAttribute("position",new ft.BufferAttribute(t,3)),this.cleanAttributeMemory(e,"position")}setFaceIds(t,e){t&&(e.setAttribute("color",new ft.BufferAttribute(t,3)),this.cleanAttributeMemory(e,"color"))}setIndex(t,e){if(!e)throw new Error("Fragments: no indices provided to create the mesh.");t.setIndex(new ft.BufferAttribute(e,1)),t.index.onUpload(this.deleteAttribute(t))}setNormals(t,e){t&&e.setAttribute("normal",new ft.BufferAttribute(t,3,!0)),this.cleanAttributeMemory(e,"normal")}setItemIds(t,e){t&&(e.setAttribute("id",new ft.BufferAttribute(t,1,!1)),this.cleanAttributeMemory(e,"id"))}deleteAttribute(t){return function(){delete this.array}}setMeshData(t,e,s,i){t.userData={tileId:e,itemId:s},t.matrixAutoUpdate=!1,t.applyMatrix4(i),t.matrix.copy(i)}}class Fi{constructor(){ot(this,"_list",new Map),ot(this,"_communicationKey",0)}setupInput(t){t.requestId=this._communicationKey++}set(t,e,s){const i=this.newHandler(e,s);this._list.set(t,i)}run(t){const e=this._list.get(t.requestId);this._list.delete(t.requestId),e(t)}newHandler(t,e){return s=>{s.errorInfo?t(s.errorInfo):e(s)}}}class Si{static newThread(t){return new Worker(t,{type:"module"})}static newUpdater(t,e){return setInterval(t,e)}static getMeshComputeRequest(t,e){return{class:Ve.RECOMPUTE_MESHES,modelId:t,list:e}}static planeSet(t){const e=[];for(const s of t){const t=this.array(s.normal),i=s.constant,n=new ft.Plane(t,i);e.push(n)}return e}static data(t){var e,s;if(void 0!==(null==t?void 0:t.elements))return Si.transform(t);if(void 0!==(null==t?void 0:t.origin)&&void 0!==(null==t?void 0:t.direction))return Si.beam(t);if(void 0!==(null==t?void 0:t.planes))return Si.frustum(t);const i=void 0!==(null==t?void 0:t.normal),n=void 0!==(null==t?void 0:t.constant);if(i&&n)return Si.plane(t);const r=void 0!==(null==(e=t[0])?void 0:e.normal),o=void 0!==(null==(s=t[0])?void 0:s.constant);if(r&&o)return Si.planeSet(t);const a=void 0!==(null==t?void 0:t.x),l=void 0!==(null==t?void 0:t.y),h=void 0!==(null==t?void 0:t.z);return a&&l&&h?Si.array(t):t}static getExecuteRequest(t,e,s){const i=Array.from(s);return{class:Ve.EXECUTE,modelId:t,function:e,parameters:i}}static plane(t){const e=this.array(t.normal),s=t.constant;return new ft.Plane(e,s)}static getRequestContent(t){const e=[];for(const s of t.list)Si.setupCreateRequest(s,e),Si.setupUpdateRequest(s,e);return e}static array(t){const e=new ft.Vector3;return e.set(t.x,t.y,t.z),e}static cleanRequests(t){const e=[],s=Si;for(const i of t){s.isFinishRequest(i)||e.push(i)}return e}static frustum(t){const e=this.planeSet(t.planes),[s,i,n,r,o,a]=e;return new ft.Frustum(s,i,n,r,o,a)}static beam(t){const e=this.array(t.origin),s=this.array(t.direction);return new ft.Ray(e,s)}static transform(t){const e=new ft.Matrix4;return e.copy(t),e}static deleteUpdater(t){clearInterval(t)}static areCoresAvailable(t){const e=Si.getCpuCapacity();return t<Math.max(e,2)}static isFinishRequest(t){return t.tileRequestClass===De.FINISH}static setupUpdateRequest(t,e){t.tileRequestClass===De.UPDATE&&this.addAllTileData(t,e)}static getCpuCapacity(){var t;return(null==(t=globalThis.navigator)?void 0:t.hardwareConcurrency)?navigator.hardwareConcurrency-3:0}static addAllTileData(t,e){this.addRequestTileData(t,e,"visibilityData");this.addRequestTileData(t,e,"highlightData",["highlightIds"])}static addRequestContent(t,e,s){if(!e[t])return;const i=e[t].buffer;s.push(i)}static addRequestTileData(t,e,s,i=[]){const n=t.tileData[s];if(n){e.push(n.position.buffer),e.push(n.size.buffer);for(const s of i)e.push(t.tileData[s].buffer)}}static setupCreateRequest(t,e){if(t.tileRequestClass!==De.CREATE)return;const s=this.getCreateRequestIds();for(const i of s)this.addRequestContent(i,t,e);this.addAllTileData(t,e)}static getCreateRequestIds(){return["positions","indices","normals","itemIds"]}}class wi{constructor(t){ot(this,"_handlers",new Fi),ot(this,"_handleInput"),ot(this,"_port"),ot(this,"onInput",(t=>{t.data.toMainThread?this._handlers.run(t.data):this.manageInput(t.data)})),this._handleInput=t}fetchMeshCompute(t,e){const s=Si,i=s.getMeshComputeRequest(t,e),n=s.getRequestContent(i);this.fetch(i,n)}fetch(t,e){return this._handlers.setupInput(t),new Promise(((s,i)=>{this._handlers.set(t.requestId,i,s),this.executeConnection(t,e)}))}init(t){this._port=t,this.initConnection(t)}initConnection(t){t.onmessage=this.onInput}async fetchConnection(t){if(!this._port)throw new Error("Fragments: Connection not initialized");return this._port}async executeConnection(t,e){(await this.fetchConnection(t)).postMessage(t,e)}async manageOutput(t){const e=await this.fetchConnection(t);t.toMainThread=!0,e.postMessage(t)}async manageConnection(t){try{await this._handleInput(t)}catch(e){t.errorInfo=e.toString(),console.error(e)}}async manageInput(t){await this.manageConnection(t),await this.manageOutput(t)}}class xi{constructor(t){ot(this,"_modelThread",new Map),ot(this,"_threadsModelAmount",new Map),ot(this,"_threadPort",new Map),ot(this,"_threadPath"),ot(this,"_placeholder"),this._placeholder={},this._threadPath=t}get path(){return this._threadPath}usePlaceholder(t){this._modelThread.set(t,this._placeholder)}getAmount(t){return this._threadsModelAmount.get(t)}getThread(t){return this._modelThread.get(t)}getAndCheckThread(t){const e=this._modelThread.get(t);if(e===this._placeholder)throw new Error("Fragments: Error fetching thread!");return e}set(t,e){this._modelThread.set(t,e)}deleteModel(t){const e=this.getThreadSafe(t),s=this.getAmountSafe(e)-1;this.setAmount(e,s),this._modelThread.delete(t)}getThreadSafe(t){const e=this.getThread(t);if(!e)throw new Error(`Fragments: Thread for model ${t} not found`);return e}deleteThread(t){this._threadsModelAmount.delete(t),this._threadPort.delete(t),t.terminate()}getThreadAmount(){return this._threadsModelAmount.size}balanceThreadLoad(t){const{lessBusyThread:e,modelAmount:s}=this.getLessBusyThread();return this._threadsModelAmount.set(e,s+1),this._modelThread.set(t.modelId,e),this._threadPort.get(e)}getAmountSafe(t){const e=this.getAmount(t);if(!e)throw new Error(`Fragments: Amount for thread ${t} not found`);return e}setPort(t,e){this._threadPort.set(t,e)}setAmount(t,e){this._threadsModelAmount.set(t,e)}getPort(t){return this._threadPort.get(t)}getLessBusyThread(){let t=Number.MAX_VALUE,e=this._threadsModelAmount.keys().next().value;for(const[s,i]of this._threadsModelAmount)i<t&&(t=i,e=s);return{lessBusyThread:e,modelAmount:t}}}class Oi extends wi{constructor(t,e){super(t),ot(this,"_data"),this._data=new xi(e)}delete(t){const e=this._data.getThreadSafe(t),s=this._data.getAmountSafe(e)-1;this._data.deleteModel(t),0===s&&this._data.deleteThread(e)}async invoke(t,e,s=[]){const i=Si.getExecuteRequest(t,e,s);return(await this.fetch(i)).result}async fetchConnection(t){const e=this._data.getAndCheckThread(t.modelId);return e?this._data.getPort(e):this.setupNewThread(t)}setupNewThread(t){const e=Si;this._data.usePlaceholder(t.modelId);const s=this._data.getThreadAmount();return e.areCoresAvailable(s)?this.newThread(t,this._data.path):this._data.balanceThreadLoad(t)}setupThread(t){const e=new MessageChannel,s=e.port1,i=e.port2;this.initConnection(s),this._data.setPort(t,s),t.postMessage(i,[i])}newThread(t,e){const s=Si.newThread(e);return this.setupThread(s),this._data.setAmount(s,1),this._data.set(t.modelId,s),this._data.getPort(s)}}
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */function vi(t){let e=t.length;for(;--e>=0;)t[e]=0}const Li=256,Pi=286,Ni=30,Mi=15,Di=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),Ui=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),Vi=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),Bi=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),zi=new Array(576);vi(zi);const Gi=new Array(60);vi(Gi);const ki=new Array(512);vi(ki);const Hi=new Array(256);vi(Hi);const Yi=new Array(29);vi(Yi);const Wi=new Array(Ni);function ji(t,e,s,i,n){this.static_tree=t,this.extra_bits=e,this.extra_base=s,this.elems=i,this.max_length=n,this.has_stree=t&&t.length}let qi,Zi,Xi;function $i(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}vi(Wi);const Ki=t=>t<256?ki[t]:ki[256+(t>>>7)],Qi=(t,e)=>{t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255},Ji=(t,e,s)=>{t.bi_valid>16-s?(t.bi_buf|=e<<t.bi_valid&65535,Qi(t,t.bi_buf),t.bi_buf=e>>16-t.bi_valid,t.bi_valid+=s-16):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=s)},tn=(t,e,s)=>{Ji(t,s[2*e],s[2*e+1])},en=(t,e)=>{let s=0;do{s|=1&t,t>>>=1,s<<=1}while(--e>0);return s>>>1},sn=(t,e,s)=>{const i=new Array(16);let n,r,o=0;for(n=1;n<=Mi;n++)o=o+s[n-1]<<1,i[n]=o;for(r=0;r<=e;r++){let e=t[2*r+1];0!==e&&(t[2*r]=en(i[e]++,e))}},nn=t=>{let e;for(e=0;e<Pi;e++)t.dyn_ltree[2*e]=0;for(e=0;e<Ni;e++)t.dyn_dtree[2*e]=0;for(e=0;e<19;e++)t.bl_tree[2*e]=0;t.dyn_ltree[512]=1,t.opt_len=t.static_len=0,t.sym_next=t.matches=0},rn=t=>{t.bi_valid>8?Qi(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0},on=(t,e,s,i)=>{const n=2*e,r=2*s;return t[n]<t[r]||t[n]===t[r]&&i[e]<=i[s]},an=(t,e,s)=>{const i=t.heap[s];let n=s<<1;for(;n<=t.heap_len&&(n<t.heap_len&&on(e,t.heap[n+1],t.heap[n],t.depth)&&n++,!on(e,i,t.heap[n],t.depth));)t.heap[s]=t.heap[n],s=n,n<<=1;t.heap[s]=i},ln=(t,e,s)=>{let i,n,r,o,a=0;if(0!==t.sym_next)do{i=255&t.pending_buf[t.sym_buf+a++],i+=(255&t.pending_buf[t.sym_buf+a++])<<8,n=t.pending_buf[t.sym_buf+a++],0===i?tn(t,n,e):(r=Hi[n],tn(t,r+Li+1,e),o=Di[r],0!==o&&(n-=Yi[r],Ji(t,n,o)),i--,r=Ki(i),tn(t,r,s),o=Ui[r],0!==o&&(i-=Wi[r],Ji(t,i,o)))}while(a<t.sym_next);tn(t,256,e)},hn=(t,e)=>{const s=e.dyn_tree,i=e.stat_desc.static_tree,n=e.stat_desc.has_stree,r=e.stat_desc.elems;let o,a,l,h=-1;for(t.heap_len=0,t.heap_max=573,o=0;o<r;o++)0!==s[2*o]?(t.heap[++t.heap_len]=h=o,t.depth[o]=0):s[2*o+1]=0;for(;t.heap_len<2;)l=t.heap[++t.heap_len]=h<2?++h:0,s[2*l]=1,t.depth[l]=0,t.opt_len--,n&&(t.static_len-=i[2*l+1]);for(e.max_code=h,o=t.heap_len>>1;o>=1;o--)an(t,s,o);l=r;do{o=t.heap[1],t.heap[1]=t.heap[t.heap_len--],an(t,s,1),a=t.heap[1],t.heap[--t.heap_max]=o,t.heap[--t.heap_max]=a,s[2*l]=s[2*o]+s[2*a],t.depth[l]=(t.depth[o]>=t.depth[a]?t.depth[o]:t.depth[a])+1,s[2*o+1]=s[2*a+1]=l,t.heap[1]=l++,an(t,s,1)}while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],((t,e)=>{const s=e.dyn_tree,i=e.max_code,n=e.stat_desc.static_tree,r=e.stat_desc.has_stree,o=e.stat_desc.extra_bits,a=e.stat_desc.extra_base,l=e.stat_desc.max_length;let h,c,d,u,f,p,I=0;for(u=0;u<=Mi;u++)t.bl_count[u]=0;for(s[2*t.heap[t.heap_max]+1]=0,h=t.heap_max+1;h<573;h++)c=t.heap[h],u=s[2*s[2*c+1]+1]+1,u>l&&(u=l,I++),s[2*c+1]=u,c>i||(t.bl_count[u]++,f=0,c>=a&&(f=o[c-a]),p=s[2*c],t.opt_len+=p*(u+f),r&&(t.static_len+=p*(n[2*c+1]+f)));if(0!==I){do{for(u=l-1;0===t.bl_count[u];)u--;t.bl_count[u]--,t.bl_count[u+1]+=2,t.bl_count[l]--,I-=2}while(I>0);for(u=l;0!==u;u--)for(c=t.bl_count[u];0!==c;)d=t.heap[--h],d>i||(s[2*d+1]!==u&&(t.opt_len+=(u-s[2*d+1])*s[2*d],s[2*d+1]=u),c--)}})(t,e),sn(s,h,t.bl_count)},cn=(t,e,s)=>{let i,n,r=-1,o=e[1],a=0,l=7,h=4;for(0===o&&(l=138,h=3),e[2*(s+1)+1]=65535,i=0;i<=s;i++)n=o,o=e[2*(i+1)+1],++a<l&&n===o||(a<h?t.bl_tree[2*n]+=a:0!==n?(n!==r&&t.bl_tree[2*n]++,t.bl_tree[32]++):a<=10?t.bl_tree[34]++:t.bl_tree[36]++,a=0,r=n,0===o?(l=138,h=3):n===o?(l=6,h=3):(l=7,h=4))},dn=(t,e,s)=>{let i,n,r=-1,o=e[1],a=0,l=7,h=4;for(0===o&&(l=138,h=3),i=0;i<=s;i++)if(n=o,o=e[2*(i+1)+1],!(++a<l&&n===o)){if(a<h)do{tn(t,n,t.bl_tree)}while(0!=--a);else 0!==n?(n!==r&&(tn(t,n,t.bl_tree),a--),tn(t,16,t.bl_tree),Ji(t,a-3,2)):a<=10?(tn(t,17,t.bl_tree),Ji(t,a-3,3)):(tn(t,18,t.bl_tree),Ji(t,a-11,7));a=0,r=n,0===o?(l=138,h=3):n===o?(l=6,h=3):(l=7,h=4)}};let un=!1;const fn=(t,e,s,i)=>{Ji(t,0+(i?1:0),3),rn(t),Qi(t,s),Qi(t,~s),s&&t.pending_buf.set(t.window.subarray(e,e+s),t.pending),t.pending+=s};var pn={_tr_init:t=>{un||((()=>{let t,e,s,i,n;const r=new Array(16);for(s=0,i=0;i<28;i++)for(Yi[i]=s,t=0;t<1<<Di[i];t++)Hi[s++]=i;for(Hi[s-1]=i,n=0,i=0;i<16;i++)for(Wi[i]=n,t=0;t<1<<Ui[i];t++)ki[n++]=i;for(n>>=7;i<Ni;i++)for(Wi[i]=n<<7,t=0;t<1<<Ui[i]-7;t++)ki[256+n++]=i;for(e=0;e<=Mi;e++)r[e]=0;for(t=0;t<=143;)zi[2*t+1]=8,t++,r[8]++;for(;t<=255;)zi[2*t+1]=9,t++,r[9]++;for(;t<=279;)zi[2*t+1]=7,t++,r[7]++;for(;t<=287;)zi[2*t+1]=8,t++,r[8]++;for(sn(zi,287,r),t=0;t<Ni;t++)Gi[2*t+1]=5,Gi[2*t]=en(t,5);qi=new ji(zi,Di,257,Pi,Mi),Zi=new ji(Gi,Ui,0,Ni,Mi),Xi=new ji(new Array(0),Vi,0,19,7)})(),un=!0),t.l_desc=new $i(t.dyn_ltree,qi),t.d_desc=new $i(t.dyn_dtree,Zi),t.bl_desc=new $i(t.bl_tree,Xi),t.bi_buf=0,t.bi_valid=0,nn(t)},_tr_stored_block:fn,_tr_flush_block:(t,e,s,i)=>{let n,r,o=0;t.level>0?(2===t.strm.data_type&&(t.strm.data_type=(t=>{let e,s=4093624447;for(e=0;e<=31;e++,s>>>=1)if(1&s&&0!==t.dyn_ltree[2*e])return 0;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return 1;for(e=32;e<Li;e++)if(0!==t.dyn_ltree[2*e])return 1;return 0})(t)),hn(t,t.l_desc),hn(t,t.d_desc),o=(t=>{let e;for(cn(t,t.dyn_ltree,t.l_desc.max_code),cn(t,t.dyn_dtree,t.d_desc.max_code),hn(t,t.bl_desc),e=18;e>=3&&0===t.bl_tree[2*Bi[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e})(t),n=t.opt_len+3+7>>>3,r=t.static_len+3+7>>>3,r<=n&&(n=r)):n=r=s+5,s+4<=n&&-1!==e?fn(t,e,s,i):4===t.strategy||r===n?(Ji(t,2+(i?1:0),3),ln(t,zi,Gi)):(Ji(t,4+(i?1:0),3),((t,e,s,i)=>{let n;for(Ji(t,e-257,5),Ji(t,s-1,5),Ji(t,i-4,4),n=0;n<i;n++)Ji(t,t.bl_tree[2*Bi[n]+1],3);dn(t,t.dyn_ltree,e-1),dn(t,t.dyn_dtree,s-1)})(t,t.l_desc.max_code+1,t.d_desc.max_code+1,o+1),ln(t,t.dyn_ltree,t.dyn_dtree)),nn(t),i&&rn(t)},_tr_tally:(t,e,s)=>(t.pending_buf[t.sym_buf+t.sym_next++]=e,t.pending_buf[t.sym_buf+t.sym_next++]=e>>8,t.pending_buf[t.sym_buf+t.sym_next++]=s,0===e?t.dyn_ltree[2*s]++:(t.matches++,e--,t.dyn_ltree[2*(Hi[s]+Li+1)]++,t.dyn_dtree[2*Ki(e)]++),t.sym_next===t.sym_end),_tr_align:t=>{Ji(t,2,3),tn(t,256,zi),(t=>{16===t.bi_valid?(Qi(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)})(t)}};var In=(t,e,s,i)=>{let n=65535&t,r=t>>>16&65535,o=0;for(;0!==s;){o=s>2e3?2e3:s,s-=o;do{n=n+e[i++]|0,r=r+n|0}while(--o);n%=65521,r%=65521}return n|r<<16};const _n=new Uint32Array((()=>{let t,e=[];for(var s=0;s<256;s++){t=s;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[s]=t}return e})());var mn=(t,e,s,i)=>{const n=_n,r=i+s;t^=-1;for(let s=i;s<r;s++)t=t>>>8^n[255&(t^e[s])];return~t},En={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},gn={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init:bn,_tr_stored_block:Cn,_tr_flush_block:Tn,_tr_tally:An,_tr_align:Rn}=pn,{Z_NO_FLUSH:yn,Z_PARTIAL_FLUSH:Fn,Z_FULL_FLUSH:Sn,Z_FINISH:wn,Z_BLOCK:xn,Z_OK:On,Z_STREAM_END:vn,Z_STREAM_ERROR:Ln,Z_DATA_ERROR:Pn,Z_BUF_ERROR:Nn,Z_DEFAULT_COMPRESSION:Mn,Z_FILTERED:Dn,Z_HUFFMAN_ONLY:Un,Z_RLE:Vn,Z_FIXED:Bn,Z_DEFAULT_STRATEGY:zn,Z_UNKNOWN:Gn,Z_DEFLATED:kn}=gn,Hn=258,Yn=262,Wn=42,jn=113,qn=666,Zn=(t,e)=>(t.msg=En[e],e),Xn=t=>2*t-(t>4?9:0),$n=t=>{let e=t.length;for(;--e>=0;)t[e]=0},Kn=t=>{let e,s,i,n=t.w_size;e=t.hash_size,i=e;do{s=t.head[--i],t.head[i]=s>=n?s-n:0}while(--e);e=n,i=e;do{s=t.prev[--i],t.prev[i]=s>=n?s-n:0}while(--e)};let Qn=(t,e,s)=>(e<<t.hash_shift^s)&t.hash_mask;const Jn=t=>{const e=t.state;let s=e.pending;s>t.avail_out&&(s=t.avail_out),0!==s&&(t.output.set(e.pending_buf.subarray(e.pending_out,e.pending_out+s),t.next_out),t.next_out+=s,e.pending_out+=s,t.total_out+=s,t.avail_out-=s,e.pending-=s,0===e.pending&&(e.pending_out=0))},tr=(t,e)=>{Tn(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,Jn(t.strm)},er=(t,e)=>{t.pending_buf[t.pending++]=e},sr=(t,e)=>{t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e},ir=(t,e,s,i)=>{let n=t.avail_in;return n>i&&(n=i),0===n?0:(t.avail_in-=n,e.set(t.input.subarray(t.next_in,t.next_in+n),s),1===t.state.wrap?t.adler=In(t.adler,e,n,s):2===t.state.wrap&&(t.adler=mn(t.adler,e,n,s)),t.next_in+=n,t.total_in+=n,n)},nr=(t,e)=>{let s,i,n=t.max_chain_length,r=t.strstart,o=t.prev_length,a=t.nice_match;const l=t.strstart>t.w_size-Yn?t.strstart-(t.w_size-Yn):0,h=t.window,c=t.w_mask,d=t.prev,u=t.strstart+Hn;let f=h[r+o-1],p=h[r+o];t.prev_length>=t.good_match&&(n>>=2),a>t.lookahead&&(a=t.lookahead);do{if(s=e,h[s+o]===p&&h[s+o-1]===f&&h[s]===h[r]&&h[++s]===h[r+1]){r+=2,s++;do{}while(h[++r]===h[++s]&&h[++r]===h[++s]&&h[++r]===h[++s]&&h[++r]===h[++s]&&h[++r]===h[++s]&&h[++r]===h[++s]&&h[++r]===h[++s]&&h[++r]===h[++s]&&r<u);if(i=Hn-(u-r),r=u-Hn,i>o){if(t.match_start=e,o=i,i>=a)break;f=h[r+o-1],p=h[r+o]}}}while((e=d[e&c])>l&&0!=--n);return o<=t.lookahead?o:t.lookahead},rr=t=>{const e=t.w_size;let s,i,n;do{if(i=t.window_size-t.lookahead-t.strstart,t.strstart>=e+(e-Yn)&&(t.window.set(t.window.subarray(e,e+e-i),0),t.match_start-=e,t.strstart-=e,t.block_start-=e,t.insert>t.strstart&&(t.insert=t.strstart),Kn(t),i+=e),0===t.strm.avail_in)break;if(s=ir(t.strm,t.window,t.strstart+t.lookahead,i),t.lookahead+=s,t.lookahead+t.insert>=3)for(n=t.strstart-t.insert,t.ins_h=t.window[n],t.ins_h=Qn(t,t.ins_h,t.window[n+1]);t.insert&&(t.ins_h=Qn(t,t.ins_h,t.window[n+3-1]),t.prev[n&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=n,n++,t.insert--,!(t.lookahead+t.insert<3)););}while(t.lookahead<Yn&&0!==t.strm.avail_in)},or=(t,e)=>{let s,i,n,r=t.pending_buf_size-5>t.w_size?t.w_size:t.pending_buf_size-5,o=0,a=t.strm.avail_in;do{if(s=65535,n=t.bi_valid+42>>3,t.strm.avail_out<n)break;if(n=t.strm.avail_out-n,i=t.strstart-t.block_start,s>i+t.strm.avail_in&&(s=i+t.strm.avail_in),s>n&&(s=n),s<r&&(0===s&&e!==wn||e===yn||s!==i+t.strm.avail_in))break;o=e===wn&&s===i+t.strm.avail_in?1:0,Cn(t,0,0,o),t.pending_buf[t.pending-4]=s,t.pending_buf[t.pending-3]=s>>8,t.pending_buf[t.pending-2]=~s,t.pending_buf[t.pending-1]=~s>>8,Jn(t.strm),i&&(i>s&&(i=s),t.strm.output.set(t.window.subarray(t.block_start,t.block_start+i),t.strm.next_out),t.strm.next_out+=i,t.strm.avail_out-=i,t.strm.total_out+=i,t.block_start+=i,s-=i),s&&(ir(t.strm,t.strm.output,t.strm.next_out,s),t.strm.next_out+=s,t.strm.avail_out-=s,t.strm.total_out+=s)}while(0===o);return a-=t.strm.avail_in,a&&(a>=t.w_size?(t.matches=2,t.window.set(t.strm.input.subarray(t.strm.next_in-t.w_size,t.strm.next_in),0),t.strstart=t.w_size,t.insert=t.strstart):(t.window_size-t.strstart<=a&&(t.strstart-=t.w_size,t.window.set(t.window.subarray(t.w_size,t.w_size+t.strstart),0),t.matches<2&&t.matches++,t.insert>t.strstart&&(t.insert=t.strstart)),t.window.set(t.strm.input.subarray(t.strm.next_in-a,t.strm.next_in),t.strstart),t.strstart+=a,t.insert+=a>t.w_size-t.insert?t.w_size-t.insert:a),t.block_start=t.strstart),t.high_water<t.strstart&&(t.high_water=t.strstart),o?4:e!==yn&&e!==wn&&0===t.strm.avail_in&&t.strstart===t.block_start?2:(n=t.window_size-t.strstart,t.strm.avail_in>n&&t.block_start>=t.w_size&&(t.block_start-=t.w_size,t.strstart-=t.w_size,t.window.set(t.window.subarray(t.w_size,t.w_size+t.strstart),0),t.matches<2&&t.matches++,n+=t.w_size,t.insert>t.strstart&&(t.insert=t.strstart)),n>t.strm.avail_in&&(n=t.strm.avail_in),n&&(ir(t.strm,t.window,t.strstart,n),t.strstart+=n,t.insert+=n>t.w_size-t.insert?t.w_size-t.insert:n),t.high_water<t.strstart&&(t.high_water=t.strstart),n=t.bi_valid+42>>3,n=t.pending_buf_size-n>65535?65535:t.pending_buf_size-n,r=n>t.w_size?t.w_size:n,i=t.strstart-t.block_start,(i>=r||(i||e===wn)&&e!==yn&&0===t.strm.avail_in&&i<=n)&&(s=i>n?n:i,o=e===wn&&0===t.strm.avail_in&&s===i?1:0,Cn(t,t.block_start,s,o),t.block_start+=s,Jn(t.strm)),o?3:1)},ar=(t,e)=>{let s,i;for(;;){if(t.lookahead<Yn){if(rr(t),t.lookahead<Yn&&e===yn)return 1;if(0===t.lookahead)break}if(s=0,t.lookahead>=3&&(t.ins_h=Qn(t,t.ins_h,t.window[t.strstart+3-1]),s=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==s&&t.strstart-s<=t.w_size-Yn&&(t.match_length=nr(t,s)),t.match_length>=3)if(i=An(t,t.strstart-t.match_start,t.match_length-3),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=3){t.match_length--;do{t.strstart++,t.ins_h=Qn(t,t.ins_h,t.window[t.strstart+3-1]),s=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart}while(0!=--t.match_length);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=Qn(t,t.ins_h,t.window[t.strstart+1]);else i=An(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(tr(t,!1),0===t.strm.avail_out))return 1}return t.insert=t.strstart<2?t.strstart:2,e===wn?(tr(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(tr(t,!1),0===t.strm.avail_out)?1:2},lr=(t,e)=>{let s,i,n;for(;;){if(t.lookahead<Yn){if(rr(t),t.lookahead<Yn&&e===yn)return 1;if(0===t.lookahead)break}if(s=0,t.lookahead>=3&&(t.ins_h=Qn(t,t.ins_h,t.window[t.strstart+3-1]),s=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=2,0!==s&&t.prev_length<t.max_lazy_match&&t.strstart-s<=t.w_size-Yn&&(t.match_length=nr(t,s),t.match_length<=5&&(t.strategy===Dn||3===t.match_length&&t.strstart-t.match_start>4096)&&(t.match_length=2)),t.prev_length>=3&&t.match_length<=t.prev_length){n=t.strstart+t.lookahead-3,i=An(t,t.strstart-1-t.prev_match,t.prev_length-3),t.lookahead-=t.prev_length-1,t.prev_length-=2;do{++t.strstart<=n&&(t.ins_h=Qn(t,t.ins_h,t.window[t.strstart+3-1]),s=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart)}while(0!=--t.prev_length);if(t.match_available=0,t.match_length=2,t.strstart++,i&&(tr(t,!1),0===t.strm.avail_out))return 1}else if(t.match_available){if(i=An(t,0,t.window[t.strstart-1]),i&&tr(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return 1}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=An(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<2?t.strstart:2,e===wn?(tr(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(tr(t,!1),0===t.strm.avail_out)?1:2};function hr(t,e,s,i,n){this.good_length=t,this.max_lazy=e,this.nice_length=s,this.max_chain=i,this.func=n}const cr=[new hr(0,0,0,0,or),new hr(4,4,8,4,ar),new hr(4,5,16,8,ar),new hr(4,6,32,32,ar),new hr(4,4,16,16,lr),new hr(8,16,32,32,lr),new hr(8,16,128,128,lr),new hr(8,32,128,256,lr),new hr(32,128,258,1024,lr),new hr(32,258,258,4096,lr)];function dr(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=kn,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),$n(this.dyn_ltree),$n(this.dyn_dtree),$n(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),$n(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),$n(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const ur=t=>{if(!t)return 1;const e=t.state;return!e||e.strm!==t||e.status!==Wn&&57!==e.status&&69!==e.status&&73!==e.status&&91!==e.status&&103!==e.status&&e.status!==jn&&e.status!==qn?1:0},fr=t=>{if(ur(t))return Zn(t,Ln);t.total_in=t.total_out=0,t.data_type=Gn;const e=t.state;return e.pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=2===e.wrap?57:e.wrap?Wn:jn,t.adler=2===e.wrap?0:1,e.last_flush=-2,bn(e),On},pr=t=>{const e=fr(t);var s;return e===On&&((s=t.state).window_size=2*s.w_size,$n(s.head),s.max_lazy_match=cr[s.level].max_lazy,s.good_match=cr[s.level].good_length,s.nice_match=cr[s.level].nice_length,s.max_chain_length=cr[s.level].max_chain,s.strstart=0,s.block_start=0,s.lookahead=0,s.insert=0,s.match_length=s.prev_length=2,s.match_available=0,s.ins_h=0),e},Ir=(t,e,s,i,n,r)=>{if(!t)return Ln;let o=1;if(e===Mn&&(e=6),i<0?(o=0,i=-i):i>15&&(o=2,i-=16),n<1||n>9||s!==kn||i<8||i>15||e<0||e>9||r<0||r>Bn||8===i&&1!==o)return Zn(t,Ln);8===i&&(i=9);const a=new dr;return t.state=a,a.strm=t,a.status=Wn,a.wrap=o,a.gzhead=null,a.w_bits=i,a.w_size=1<<a.w_bits,a.w_mask=a.w_size-1,a.hash_bits=n+7,a.hash_size=1<<a.hash_bits,a.hash_mask=a.hash_size-1,a.hash_shift=~~((a.hash_bits+3-1)/3),a.window=new Uint8Array(2*a.w_size),a.head=new Uint16Array(a.hash_size),a.prev=new Uint16Array(a.w_size),a.lit_bufsize=1<<n+6,a.pending_buf_size=4*a.lit_bufsize,a.pending_buf=new Uint8Array(a.pending_buf_size),a.sym_buf=a.lit_bufsize,a.sym_end=3*(a.lit_bufsize-1),a.level=e,a.strategy=r,a.method=s,pr(t)};var _r={deflateInit:(t,e)=>Ir(t,e,kn,15,8,zn),deflateInit2:Ir,deflateReset:pr,deflateResetKeep:fr,deflateSetHeader:(t,e)=>ur(t)||2!==t.state.wrap?Ln:(t.state.gzhead=e,On),deflate:(t,e)=>{if(ur(t)||e>xn||e<0)return t?Zn(t,Ln):Ln;const s=t.state;if(!t.output||0!==t.avail_in&&!t.input||s.status===qn&&e!==wn)return Zn(t,0===t.avail_out?Nn:Ln);const i=s.last_flush;if(s.last_flush=e,0!==s.pending){if(Jn(t),0===t.avail_out)return s.last_flush=-1,On}else if(0===t.avail_in&&Xn(e)<=Xn(i)&&e!==wn)return Zn(t,Nn);if(s.status===qn&&0!==t.avail_in)return Zn(t,Nn);if(s.status===Wn&&0===s.wrap&&(s.status=jn),s.status===Wn){let e=kn+(s.w_bits-8<<4)<<8,i=-1;if(i=s.strategy>=Un||s.level<2?0:s.level<6?1:6===s.level?2:3,e|=i<<6,0!==s.strstart&&(e|=32),e+=31-e%31,sr(s,e),0!==s.strstart&&(sr(s,t.adler>>>16),sr(s,65535&t.adler)),t.adler=1,s.status=jn,Jn(t),0!==s.pending)return s.last_flush=-1,On}if(57===s.status)if(t.adler=0,er(s,31),er(s,139),er(s,8),s.gzhead)er(s,(s.gzhead.text?1:0)+(s.gzhead.hcrc?2:0)+(s.gzhead.extra?4:0)+(s.gzhead.name?8:0)+(s.gzhead.comment?16:0)),er(s,255&s.gzhead.time),er(s,s.gzhead.time>>8&255),er(s,s.gzhead.time>>16&255),er(s,s.gzhead.time>>24&255),er(s,9===s.level?2:s.strategy>=Un||s.level<2?4:0),er(s,255&s.gzhead.os),s.gzhead.extra&&s.gzhead.extra.length&&(er(s,255&s.gzhead.extra.length),er(s,s.gzhead.extra.length>>8&255)),s.gzhead.hcrc&&(t.adler=mn(t.adler,s.pending_buf,s.pending,0)),s.gzindex=0,s.status=69;else if(er(s,0),er(s,0),er(s,0),er(s,0),er(s,0),er(s,9===s.level?2:s.strategy>=Un||s.level<2?4:0),er(s,3),s.status=jn,Jn(t),0!==s.pending)return s.last_flush=-1,On;if(69===s.status){if(s.gzhead.extra){let e=s.pending,i=(65535&s.gzhead.extra.length)-s.gzindex;for(;s.pending+i>s.pending_buf_size;){let n=s.pending_buf_size-s.pending;if(s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex,s.gzindex+n),s.pending),s.pending=s.pending_buf_size,s.gzhead.hcrc&&s.pending>e&&(t.adler=mn(t.adler,s.pending_buf,s.pending-e,e)),s.gzindex+=n,Jn(t),0!==s.pending)return s.last_flush=-1,On;e=0,i-=n}let n=new Uint8Array(s.gzhead.extra);s.pending_buf.set(n.subarray(s.gzindex,s.gzindex+i),s.pending),s.pending+=i,s.gzhead.hcrc&&s.pending>e&&(t.adler=mn(t.adler,s.pending_buf,s.pending-e,e)),s.gzindex=0}s.status=73}if(73===s.status){if(s.gzhead.name){let e,i=s.pending;do{if(s.pending===s.pending_buf_size){if(s.gzhead.hcrc&&s.pending>i&&(t.adler=mn(t.adler,s.pending_buf,s.pending-i,i)),Jn(t),0!==s.pending)return s.last_flush=-1,On;i=0}e=s.gzindex<s.gzhead.name.length?255&s.gzhead.name.charCodeAt(s.gzindex++):0,er(s,e)}while(0!==e);s.gzhead.hcrc&&s.pending>i&&(t.adler=mn(t.adler,s.pending_buf,s.pending-i,i)),s.gzindex=0}s.status=91}if(91===s.status){if(s.gzhead.comment){let e,i=s.pending;do{if(s.pending===s.pending_buf_size){if(s.gzhead.hcrc&&s.pending>i&&(t.adler=mn(t.adler,s.pending_buf,s.pending-i,i)),Jn(t),0!==s.pending)return s.last_flush=-1,On;i=0}e=s.gzindex<s.gzhead.comment.length?255&s.gzhead.comment.charCodeAt(s.gzindex++):0,er(s,e)}while(0!==e);s.gzhead.hcrc&&s.pending>i&&(t.adler=mn(t.adler,s.pending_buf,s.pending-i,i))}s.status=103}if(103===s.status){if(s.gzhead.hcrc){if(s.pending+2>s.pending_buf_size&&(Jn(t),0!==s.pending))return s.last_flush=-1,On;er(s,255&t.adler),er(s,t.adler>>8&255),t.adler=0}if(s.status=jn,Jn(t),0!==s.pending)return s.last_flush=-1,On}if(0!==t.avail_in||0!==s.lookahead||e!==yn&&s.status!==qn){let i=0===s.level?or(s,e):s.strategy===Un?((t,e)=>{let s;for(;;){if(0===t.lookahead&&(rr(t),0===t.lookahead)){if(e===yn)return 1;break}if(t.match_length=0,s=An(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,s&&(tr(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===wn?(tr(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(tr(t,!1),0===t.strm.avail_out)?1:2})(s,e):s.strategy===Vn?((t,e)=>{let s,i,n,r;const o=t.window;for(;;){if(t.lookahead<=Hn){if(rr(t),t.lookahead<=Hn&&e===yn)return 1;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=3&&t.strstart>0&&(n=t.strstart-1,i=o[n],i===o[++n]&&i===o[++n]&&i===o[++n])){r=t.strstart+Hn;do{}while(i===o[++n]&&i===o[++n]&&i===o[++n]&&i===o[++n]&&i===o[++n]&&i===o[++n]&&i===o[++n]&&i===o[++n]&&n<r);t.match_length=Hn-(r-n),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=3?(s=An(t,1,t.match_length-3),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(s=An(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),s&&(tr(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===wn?(tr(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(tr(t,!1),0===t.strm.avail_out)?1:2})(s,e):cr[s.level].func(s,e);if(3!==i&&4!==i||(s.status=qn),1===i||3===i)return 0===t.avail_out&&(s.last_flush=-1),On;if(2===i&&(e===Fn?Rn(s):e!==xn&&(Cn(s,0,0,!1),e===Sn&&($n(s.head),0===s.lookahead&&(s.strstart=0,s.block_start=0,s.insert=0))),Jn(t),0===t.avail_out))return s.last_flush=-1,On}return e!==wn?On:s.wrap<=0?vn:(2===s.wrap?(er(s,255&t.adler),er(s,t.adler>>8&255),er(s,t.adler>>16&255),er(s,t.adler>>24&255),er(s,255&t.total_in),er(s,t.total_in>>8&255),er(s,t.total_in>>16&255),er(s,t.total_in>>24&255)):(sr(s,t.adler>>>16),sr(s,65535&t.adler)),Jn(t),s.wrap>0&&(s.wrap=-s.wrap),0!==s.pending?On:vn)},deflateEnd:t=>{if(ur(t))return Ln;const e=t.state.status;return t.state=null,e===jn?Zn(t,Pn):On},deflateSetDictionary:(t,e)=>{let s=e.length;if(ur(t))return Ln;const i=t.state,n=i.wrap;if(2===n||1===n&&i.status!==Wn||i.lookahead)return Ln;if(1===n&&(t.adler=In(t.adler,e,s,0)),i.wrap=0,s>=i.w_size){0===n&&($n(i.head),i.strstart=0,i.block_start=0,i.insert=0);let t=new Uint8Array(i.w_size);t.set(e.subarray(s-i.w_size,s),0),e=t,s=i.w_size}const r=t.avail_in,o=t.next_in,a=t.input;for(t.avail_in=s,t.next_in=0,t.input=e,rr(i);i.lookahead>=3;){let t=i.strstart,e=i.lookahead-2;do{i.ins_h=Qn(i,i.ins_h,i.window[t+3-1]),i.prev[t&i.w_mask]=i.head[i.ins_h],i.head[i.ins_h]=t,t++}while(--e);i.strstart=t,i.lookahead=2,rr(i)}return i.strstart+=i.lookahead,i.block_start=i.strstart,i.insert=i.lookahead,i.lookahead=0,i.match_length=i.prev_length=2,i.match_available=0,t.next_in=o,t.input=a,t.avail_in=r,i.wrap=n,On},deflateInfo:"pako deflate (from Nodeca project)"};const mr=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var Er=function(t){const e=Array.prototype.slice.call(arguments,1);for(;e.length;){const s=e.shift();if(s){if("object"!=typeof s)throw new TypeError(s+"must be non-object");for(const e in s)mr(s,e)&&(t[e]=s[e])}}return t},gr=t=>{let e=0;for(let s=0,i=t.length;s<i;s++)e+=t[s].length;const s=new Uint8Array(e);for(let e=0,i=0,n=t.length;e<n;e++){let n=t[e];s.set(n,i),i+=n.length}return s};let br=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(t){br=!1}const Cr=new Uint8Array(256);for(let t=0;t<256;t++)Cr[t]=t>=252?6:t>=248?5:t>=240?4:t>=224?3:t>=192?2:1;Cr[254]=Cr[254]=1;var Tr=t=>{if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(t);let e,s,i,n,r,o=t.length,a=0;for(n=0;n<o;n++)s=t.charCodeAt(n),55296==(64512&s)&&n+1<o&&(i=t.charCodeAt(n+1),56320==(64512&i)&&(s=65536+(s-55296<<10)+(i-56320),n++)),a+=s<128?1:s<2048?2:s<65536?3:4;for(e=new Uint8Array(a),r=0,n=0;r<a;n++)s=t.charCodeAt(n),55296==(64512&s)&&n+1<o&&(i=t.charCodeAt(n+1),56320==(64512&i)&&(s=65536+(s-55296<<10)+(i-56320),n++)),s<128?e[r++]=s:s<2048?(e[r++]=192|s>>>6,e[r++]=128|63&s):s<65536?(e[r++]=224|s>>>12,e[r++]=128|s>>>6&63,e[r++]=128|63&s):(e[r++]=240|s>>>18,e[r++]=128|s>>>12&63,e[r++]=128|s>>>6&63,e[r++]=128|63&s);return e},Ar=(t,e)=>{const s=e||t.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(t.subarray(0,e));let i,n;const r=new Array(2*s);for(n=0,i=0;i<s;){let e=t[i++];if(e<128){r[n++]=e;continue}let o=Cr[e];if(o>4)r[n++]=65533,i+=o-1;else{for(e&=2===o?31:3===o?15:7;o>1&&i<s;)e=e<<6|63&t[i++],o--;o>1?r[n++]=65533:e<65536?r[n++]=e:(e-=65536,r[n++]=55296|e>>10&1023,r[n++]=56320|1023&e)}}return((t,e)=>{if(e<65534&&t.subarray&&br)return String.fromCharCode.apply(null,t.length===e?t:t.subarray(0,e));let s="";for(let i=0;i<e;i++)s+=String.fromCharCode(t[i]);return s})(r,n)},Rr=(t,e)=>{(e=e||t.length)>t.length&&(e=t.length);let s=e-1;for(;s>=0&&128==(192&t[s]);)s--;return s<0||0===s?e:s+Cr[t[s]]>e?s:e};var yr=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0};const Fr=Object.prototype.toString,{Z_NO_FLUSH:Sr,Z_SYNC_FLUSH:wr,Z_FULL_FLUSH:xr,Z_FINISH:Or,Z_OK:vr,Z_STREAM_END:Lr,Z_DEFAULT_COMPRESSION:Pr,Z_DEFAULT_STRATEGY:Nr,Z_DEFLATED:Mr}=gn;function Dr(t){this.options=Er({level:Pr,method:Mr,chunkSize:16384,windowBits:15,memLevel:8,strategy:Nr},t||{});let e=this.options;e.raw&&e.windowBits>0?e.windowBits=-e.windowBits:e.gzip&&e.windowBits>0&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new yr,this.strm.avail_out=0;let s=_r.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(s!==vr)throw new Error(En[s]);if(e.header&&_r.deflateSetHeader(this.strm,e.header),e.dictionary){let t;if(t="string"==typeof e.dictionary?Tr(e.dictionary):"[object ArrayBuffer]"===Fr.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary,s=_r.deflateSetDictionary(this.strm,t),s!==vr)throw new Error(En[s]);this._dict_set=!0}}function Ur(t,e){const s=new Dr(e);if(s.push(t,!0),s.err)throw s.msg||En[s.err];return s.result}Dr.prototype.push=function(t,e){const s=this.strm,i=this.options.chunkSize;let n,r;if(this.ended)return!1;for(r=e===~~e?e:!0===e?Or:Sr,"string"==typeof t?s.input=Tr(t):"[object ArrayBuffer]"===Fr.call(t)?s.input=new Uint8Array(t):s.input=t,s.next_in=0,s.avail_in=s.input.length;;)if(0===s.avail_out&&(s.output=new Uint8Array(i),s.next_out=0,s.avail_out=i),(r===wr||r===xr)&&s.avail_out<=6)this.onData(s.output.subarray(0,s.next_out)),s.avail_out=0;else{if(n=_r.deflate(s,r),n===Lr)return s.next_out>0&&this.onData(s.output.subarray(0,s.next_out)),n=_r.deflateEnd(this.strm),this.onEnd(n),this.ended=!0,n===vr;if(0!==s.avail_out){if(r>0&&s.next_out>0)this.onData(s.output.subarray(0,s.next_out)),s.avail_out=0;else if(0===s.avail_in)break}else this.onData(s.output)}return!0},Dr.prototype.onData=function(t){this.chunks.push(t)},Dr.prototype.onEnd=function(t){t===vr&&(this.result=gr(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg};var Vr={Deflate:Dr,deflate:Ur,deflateRaw:function(t,e){return(e=e||{}).raw=!0,Ur(t,e)},gzip:function(t,e){return(e=e||{}).gzip=!0,Ur(t,e)}};const Br=16209;var zr=function(t,e){let s,i,n,r,o,a,l,h,c,d,u,f,p,I,_,m,E,g,b,C,T,A,R,y;const F=t.state;s=t.next_in,R=t.input,i=s+(t.avail_in-5),n=t.next_out,y=t.output,r=n-(e-t.avail_out),o=n+(t.avail_out-257),a=F.dmax,l=F.wsize,h=F.whave,c=F.wnext,d=F.window,u=F.hold,f=F.bits,p=F.lencode,I=F.distcode,_=(1<<F.lenbits)-1,m=(1<<F.distbits)-1;t:do{f<15&&(u+=R[s++]<<f,f+=8,u+=R[s++]<<f,f+=8),E=p[u&_];e:for(;;){if(g=E>>>24,u>>>=g,f-=g,g=E>>>16&255,0===g)y[n++]=65535&E;else{if(!(16&g)){if(64&g){if(32&g){F.mode=16191;break t}t.msg="invalid literal/length code",F.mode=Br;break t}E=p[(65535&E)+(u&(1<<g)-1)];continue e}for(b=65535&E,g&=15,g&&(f<g&&(u+=R[s++]<<f,f+=8),b+=u&(1<<g)-1,u>>>=g,f-=g),f<15&&(u+=R[s++]<<f,f+=8,u+=R[s++]<<f,f+=8),E=I[u&m];;){if(g=E>>>24,u>>>=g,f-=g,g=E>>>16&255,16&g){if(C=65535&E,g&=15,f<g&&(u+=R[s++]<<f,f+=8,f<g&&(u+=R[s++]<<f,f+=8)),C+=u&(1<<g)-1,C>a){t.msg="invalid distance too far back",F.mode=Br;break t}if(u>>>=g,f-=g,g=n-r,C>g){if(g=C-g,g>h&&F.sane){t.msg="invalid distance too far back",F.mode=Br;break t}if(T=0,A=d,0===c){if(T+=l-g,g<b){b-=g;do{y[n++]=d[T++]}while(--g);T=n-C,A=y}}else if(c<g){if(T+=l+c-g,g-=c,g<b){b-=g;do{y[n++]=d[T++]}while(--g);if(T=0,c<b){g=c,b-=g;do{y[n++]=d[T++]}while(--g);T=n-C,A=y}}}else if(T+=c-g,g<b){b-=g;do{y[n++]=d[T++]}while(--g);T=n-C,A=y}for(;b>2;)y[n++]=A[T++],y[n++]=A[T++],y[n++]=A[T++],b-=3;b&&(y[n++]=A[T++],b>1&&(y[n++]=A[T++]))}else{T=n-C;do{y[n++]=y[T++],y[n++]=y[T++],y[n++]=y[T++],b-=3}while(b>2);b&&(y[n++]=y[T++],b>1&&(y[n++]=y[T++]))}break}if(64&g){t.msg="invalid distance code",F.mode=Br;break t}E=I[(65535&E)+(u&(1<<g)-1)]}}break}}while(s<i&&n<o);b=f>>3,s-=b,f-=b<<3,u&=(1<<f)-1,t.next_in=s,t.next_out=n,t.avail_in=s<i?i-s+5:5-(s-i),t.avail_out=n<o?o-n+257:257-(n-o),F.hold=u,F.bits=f};const Gr=15,kr=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),Hr=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),Yr=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),Wr=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]);var jr=(t,e,s,i,n,r,o,a)=>{const l=a.bits;let h,c,d,u,f,p,I=0,_=0,m=0,E=0,g=0,b=0,C=0,T=0,A=0,R=0,y=null;const F=new Uint16Array(16),S=new Uint16Array(16);let w,x,O,v=null;for(I=0;I<=Gr;I++)F[I]=0;for(_=0;_<i;_++)F[e[s+_]]++;for(g=l,E=Gr;E>=1&&0===F[E];E--);if(g>E&&(g=E),0===E)return n[r++]=20971520,n[r++]=20971520,a.bits=1,0;for(m=1;m<E&&0===F[m];m++);for(g<m&&(g=m),T=1,I=1;I<=Gr;I++)if(T<<=1,T-=F[I],T<0)return-1;if(T>0&&(0===t||1!==E))return-1;for(S[1]=0,I=1;I<Gr;I++)S[I+1]=S[I]+F[I];for(_=0;_<i;_++)0!==e[s+_]&&(o[S[e[s+_]]++]=_);if(0===t?(y=v=o,p=20):1===t?(y=kr,v=Hr,p=257):(y=Yr,v=Wr,p=0),R=0,_=0,I=m,f=r,b=g,C=0,d=-1,A=1<<g,u=A-1,1===t&&A>852||2===t&&A>592)return 1;for(;;){w=I-C,o[_]+1<p?(x=0,O=o[_]):o[_]>=p?(x=v[o[_]-p],O=y[o[_]-p]):(x=96,O=0),h=1<<I-C,c=1<<b,m=c;do{c-=h,n[f+(R>>C)+c]=w<<24|x<<16|O}while(0!==c);for(h=1<<I-1;R&h;)h>>=1;if(0!==h?(R&=h-1,R+=h):R=0,_++,0==--F[I]){if(I===E)break;I=e[s+o[_]]}if(I>g&&(R&u)!==d){for(0===C&&(C=g),f+=m,b=I-C,T=1<<b;b+C<E&&(T-=F[b+C],!(T<=0));)b++,T<<=1;if(A+=1<<b,1===t&&A>852||2===t&&A>592)return 1;d=R&u,n[d]=g<<24|b<<16|f-r}}return 0!==R&&(n[f+R]=I-C<<24|64<<16),a.bits=g,0};const{Z_FINISH:qr,Z_BLOCK:Zr,Z_TREES:Xr,Z_OK:$r,Z_STREAM_END:Kr,Z_NEED_DICT:Qr,Z_STREAM_ERROR:Jr,Z_DATA_ERROR:to,Z_MEM_ERROR:eo,Z_BUF_ERROR:so,Z_DEFLATED:io}=gn,no=16180,ro=16190,oo=16191,ao=16192,lo=16194,ho=16199,co=16200,uo=16206,fo=16209,po=t=>(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24);function Io(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const _o=t=>{if(!t)return 1;const e=t.state;return!e||e.strm!==t||e.mode<no||e.mode>16211?1:0},mo=t=>{if(_o(t))return Jr;const e=t.state;return t.total_in=t.total_out=e.total=0,t.msg="",e.wrap&&(t.adler=1&e.wrap),e.mode=no,e.last=0,e.havedict=0,e.flags=-1,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new Int32Array(852),e.distcode=e.distdyn=new Int32Array(592),e.sane=1,e.back=-1,$r},Eo=t=>{if(_o(t))return Jr;const e=t.state;return e.wsize=0,e.whave=0,e.wnext=0,mo(t)},go=(t,e)=>{let s;if(_o(t))return Jr;const i=t.state;return e<0?(s=0,e=-e):(s=5+(e>>4),e<48&&(e&=15)),e&&(e<8||e>15)?Jr:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=s,i.wbits=e,Eo(t))},bo=(t,e)=>{if(!t)return Jr;const s=new Io;t.state=s,s.strm=t,s.window=null,s.mode=no;const i=go(t,e);return i!==$r&&(t.state=null),i};let Co,To,Ao=!0;const Ro=t=>{if(Ao){Co=new Int32Array(512),To=new Int32Array(32);let e=0;for(;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(jr(1,t.lens,0,288,Co,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;jr(2,t.lens,0,32,To,0,t.work,{bits:5}),Ao=!1}t.lencode=Co,t.lenbits=9,t.distcode=To,t.distbits=5},yo=(t,e,s,i)=>{let n;const r=t.state;return null===r.window&&(r.wsize=1<<r.wbits,r.wnext=0,r.whave=0,r.window=new Uint8Array(r.wsize)),i>=r.wsize?(r.window.set(e.subarray(s-r.wsize,s),0),r.wnext=0,r.whave=r.wsize):(n=r.wsize-r.wnext,n>i&&(n=i),r.window.set(e.subarray(s-i,s-i+n),r.wnext),(i-=n)?(r.window.set(e.subarray(s-i,s),0),r.wnext=i,r.whave=r.wsize):(r.wnext+=n,r.wnext===r.wsize&&(r.wnext=0),r.whave<r.wsize&&(r.whave+=n))),0};var Fo={inflateReset:Eo,inflateReset2:go,inflateResetKeep:mo,inflateInit:t=>bo(t,15),inflateInit2:bo,inflate:(t,e)=>{let s,i,n,r,o,a,l,h,c,d,u,f,p,I,_,m,E,g,b,C,T,A,R=0;const y=new Uint8Array(4);let F,S;const w=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(_o(t)||!t.output||!t.input&&0!==t.avail_in)return Jr;s=t.state,s.mode===oo&&(s.mode=ao),o=t.next_out,n=t.output,l=t.avail_out,r=t.next_in,i=t.input,a=t.avail_in,h=s.hold,c=s.bits,d=a,u=l,A=$r;t:for(;;)switch(s.mode){case no:if(0===s.wrap){s.mode=ao;break}for(;c<16;){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}if(2&s.wrap&&35615===h){0===s.wbits&&(s.wbits=15),s.check=0,y[0]=255&h,y[1]=h>>>8&255,s.check=mn(s.check,y,2,0),h=0,c=0,s.mode=16181;break}if(s.head&&(s.head.done=!1),!(1&s.wrap)||(((255&h)<<8)+(h>>8))%31){t.msg="incorrect header check",s.mode=fo;break}if((15&h)!==io){t.msg="unknown compression method",s.mode=fo;break}if(h>>>=4,c-=4,T=8+(15&h),0===s.wbits&&(s.wbits=T),T>15||T>s.wbits){t.msg="invalid window size",s.mode=fo;break}s.dmax=1<<s.wbits,s.flags=0,t.adler=s.check=1,s.mode=512&h?16189:oo,h=0,c=0;break;case 16181:for(;c<16;){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}if(s.flags=h,(255&s.flags)!==io){t.msg="unknown compression method",s.mode=fo;break}if(57344&s.flags){t.msg="unknown header flags set",s.mode=fo;break}s.head&&(s.head.text=h>>8&1),512&s.flags&&4&s.wrap&&(y[0]=255&h,y[1]=h>>>8&255,s.check=mn(s.check,y,2,0)),h=0,c=0,s.mode=16182;case 16182:for(;c<32;){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}s.head&&(s.head.time=h),512&s.flags&&4&s.wrap&&(y[0]=255&h,y[1]=h>>>8&255,y[2]=h>>>16&255,y[3]=h>>>24&255,s.check=mn(s.check,y,4,0)),h=0,c=0,s.mode=16183;case 16183:for(;c<16;){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}s.head&&(s.head.xflags=255&h,s.head.os=h>>8),512&s.flags&&4&s.wrap&&(y[0]=255&h,y[1]=h>>>8&255,s.check=mn(s.check,y,2,0)),h=0,c=0,s.mode=16184;case 16184:if(1024&s.flags){for(;c<16;){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}s.length=h,s.head&&(s.head.extra_len=h),512&s.flags&&4&s.wrap&&(y[0]=255&h,y[1]=h>>>8&255,s.check=mn(s.check,y,2,0)),h=0,c=0}else s.head&&(s.head.extra=null);s.mode=16185;case 16185:if(1024&s.flags&&(f=s.length,f>a&&(f=a),f&&(s.head&&(T=s.head.extra_len-s.length,s.head.extra||(s.head.extra=new Uint8Array(s.head.extra_len)),s.head.extra.set(i.subarray(r,r+f),T)),512&s.flags&&4&s.wrap&&(s.check=mn(s.check,i,f,r)),a-=f,r+=f,s.length-=f),s.length))break t;s.length=0,s.mode=16186;case 16186:if(2048&s.flags){if(0===a)break t;f=0;do{T=i[r+f++],s.head&&T&&s.length<65536&&(s.head.name+=String.fromCharCode(T))}while(T&&f<a);if(512&s.flags&&4&s.wrap&&(s.check=mn(s.check,i,f,r)),a-=f,r+=f,T)break t}else s.head&&(s.head.name=null);s.length=0,s.mode=16187;case 16187:if(4096&s.flags){if(0===a)break t;f=0;do{T=i[r+f++],s.head&&T&&s.length<65536&&(s.head.comment+=String.fromCharCode(T))}while(T&&f<a);if(512&s.flags&&4&s.wrap&&(s.check=mn(s.check,i,f,r)),a-=f,r+=f,T)break t}else s.head&&(s.head.comment=null);s.mode=16188;case 16188:if(512&s.flags){for(;c<16;){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}if(4&s.wrap&&h!==(65535&s.check)){t.msg="header crc mismatch",s.mode=fo;break}h=0,c=0}s.head&&(s.head.hcrc=s.flags>>9&1,s.head.done=!0),t.adler=s.check=0,s.mode=oo;break;case 16189:for(;c<32;){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}t.adler=s.check=po(h),h=0,c=0,s.mode=ro;case ro:if(0===s.havedict)return t.next_out=o,t.avail_out=l,t.next_in=r,t.avail_in=a,s.hold=h,s.bits=c,Qr;t.adler=s.check=1,s.mode=oo;case oo:if(e===Zr||e===Xr)break t;case ao:if(s.last){h>>>=7&c,c-=7&c,s.mode=uo;break}for(;c<3;){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}switch(s.last=1&h,h>>>=1,c-=1,3&h){case 0:s.mode=16193;break;case 1:if(Ro(s),s.mode=ho,e===Xr){h>>>=2,c-=2;break t}break;case 2:s.mode=16196;break;case 3:t.msg="invalid block type",s.mode=fo}h>>>=2,c-=2;break;case 16193:for(h>>>=7&c,c-=7&c;c<32;){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}if((65535&h)!=(h>>>16^65535)){t.msg="invalid stored block lengths",s.mode=fo;break}if(s.length=65535&h,h=0,c=0,s.mode=lo,e===Xr)break t;case lo:s.mode=16195;case 16195:if(f=s.length,f){if(f>a&&(f=a),f>l&&(f=l),0===f)break t;n.set(i.subarray(r,r+f),o),a-=f,r+=f,l-=f,o+=f,s.length-=f;break}s.mode=oo;break;case 16196:for(;c<14;){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}if(s.nlen=257+(31&h),h>>>=5,c-=5,s.ndist=1+(31&h),h>>>=5,c-=5,s.ncode=4+(15&h),h>>>=4,c-=4,s.nlen>286||s.ndist>30){t.msg="too many length or distance symbols",s.mode=fo;break}s.have=0,s.mode=16197;case 16197:for(;s.have<s.ncode;){for(;c<3;){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}s.lens[w[s.have++]]=7&h,h>>>=3,c-=3}for(;s.have<19;)s.lens[w[s.have++]]=0;if(s.lencode=s.lendyn,s.lenbits=7,F={bits:s.lenbits},A=jr(0,s.lens,0,19,s.lencode,0,s.work,F),s.lenbits=F.bits,A){t.msg="invalid code lengths set",s.mode=fo;break}s.have=0,s.mode=16198;case 16198:for(;s.have<s.nlen+s.ndist;){for(;R=s.lencode[h&(1<<s.lenbits)-1],_=R>>>24,m=R>>>16&255,E=65535&R,!(_<=c);){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}if(E<16)h>>>=_,c-=_,s.lens[s.have++]=E;else{if(16===E){for(S=_+2;c<S;){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}if(h>>>=_,c-=_,0===s.have){t.msg="invalid bit length repeat",s.mode=fo;break}T=s.lens[s.have-1],f=3+(3&h),h>>>=2,c-=2}else if(17===E){for(S=_+3;c<S;){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}h>>>=_,c-=_,T=0,f=3+(7&h),h>>>=3,c-=3}else{for(S=_+7;c<S;){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}h>>>=_,c-=_,T=0,f=11+(127&h),h>>>=7,c-=7}if(s.have+f>s.nlen+s.ndist){t.msg="invalid bit length repeat",s.mode=fo;break}for(;f--;)s.lens[s.have++]=T}}if(s.mode===fo)break;if(0===s.lens[256]){t.msg="invalid code -- missing end-of-block",s.mode=fo;break}if(s.lenbits=9,F={bits:s.lenbits},A=jr(1,s.lens,0,s.nlen,s.lencode,0,s.work,F),s.lenbits=F.bits,A){t.msg="invalid literal/lengths set",s.mode=fo;break}if(s.distbits=6,s.distcode=s.distdyn,F={bits:s.distbits},A=jr(2,s.lens,s.nlen,s.ndist,s.distcode,0,s.work,F),s.distbits=F.bits,A){t.msg="invalid distances set",s.mode=fo;break}if(s.mode=ho,e===Xr)break t;case ho:s.mode=co;case co:if(a>=6&&l>=258){t.next_out=o,t.avail_out=l,t.next_in=r,t.avail_in=a,s.hold=h,s.bits=c,zr(t,u),o=t.next_out,n=t.output,l=t.avail_out,r=t.next_in,i=t.input,a=t.avail_in,h=s.hold,c=s.bits,s.mode===oo&&(s.back=-1);break}for(s.back=0;R=s.lencode[h&(1<<s.lenbits)-1],_=R>>>24,m=R>>>16&255,E=65535&R,!(_<=c);){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}if(m&&!(240&m)){for(g=_,b=m,C=E;R=s.lencode[C+((h&(1<<g+b)-1)>>g)],_=R>>>24,m=R>>>16&255,E=65535&R,!(g+_<=c);){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}h>>>=g,c-=g,s.back+=g}if(h>>>=_,c-=_,s.back+=_,s.length=E,0===m){s.mode=16205;break}if(32&m){s.back=-1,s.mode=oo;break}if(64&m){t.msg="invalid literal/length code",s.mode=fo;break}s.extra=15&m,s.mode=16201;case 16201:if(s.extra){for(S=s.extra;c<S;){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}s.length+=h&(1<<s.extra)-1,h>>>=s.extra,c-=s.extra,s.back+=s.extra}s.was=s.length,s.mode=16202;case 16202:for(;R=s.distcode[h&(1<<s.distbits)-1],_=R>>>24,m=R>>>16&255,E=65535&R,!(_<=c);){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}if(!(240&m)){for(g=_,b=m,C=E;R=s.distcode[C+((h&(1<<g+b)-1)>>g)],_=R>>>24,m=R>>>16&255,E=65535&R,!(g+_<=c);){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}h>>>=g,c-=g,s.back+=g}if(h>>>=_,c-=_,s.back+=_,64&m){t.msg="invalid distance code",s.mode=fo;break}s.offset=E,s.extra=15&m,s.mode=16203;case 16203:if(s.extra){for(S=s.extra;c<S;){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}s.offset+=h&(1<<s.extra)-1,h>>>=s.extra,c-=s.extra,s.back+=s.extra}if(s.offset>s.dmax){t.msg="invalid distance too far back",s.mode=fo;break}s.mode=16204;case 16204:if(0===l)break t;if(f=u-l,s.offset>f){if(f=s.offset-f,f>s.whave&&s.sane){t.msg="invalid distance too far back",s.mode=fo;break}f>s.wnext?(f-=s.wnext,p=s.wsize-f):p=s.wnext-f,f>s.length&&(f=s.length),I=s.window}else I=n,p=o-s.offset,f=s.length;f>l&&(f=l),l-=f,s.length-=f;do{n[o++]=I[p++]}while(--f);0===s.length&&(s.mode=co);break;case 16205:if(0===l)break t;n[o++]=s.length,l--,s.mode=co;break;case uo:if(s.wrap){for(;c<32;){if(0===a)break t;a--,h|=i[r++]<<c,c+=8}if(u-=l,t.total_out+=u,s.total+=u,4&s.wrap&&u&&(t.adler=s.check=s.flags?mn(s.check,n,u,o-u):In(s.check,n,u,o-u)),u=l,4&s.wrap&&(s.flags?h:po(h))!==s.check){t.msg="incorrect data check",s.mode=fo;break}h=0,c=0}s.mode=16207;case 16207:if(s.wrap&&s.flags){for(;c<32;){if(0===a)break t;a--,h+=i[r++]<<c,c+=8}if(4&s.wrap&&h!==(4294967295&s.total)){t.msg="incorrect length check",s.mode=fo;break}h=0,c=0}s.mode=16208;case 16208:A=Kr;break t;case fo:A=to;break t;case 16210:return eo;default:return Jr}return t.next_out=o,t.avail_out=l,t.next_in=r,t.avail_in=a,s.hold=h,s.bits=c,(s.wsize||u!==t.avail_out&&s.mode<fo&&(s.mode<uo||e!==qr))&&yo(t,t.output,t.next_out,u-t.avail_out),d-=t.avail_in,u-=t.avail_out,t.total_in+=d,t.total_out+=u,s.total+=u,4&s.wrap&&u&&(t.adler=s.check=s.flags?mn(s.check,n,u,t.next_out-u):In(s.check,n,u,t.next_out-u)),t.data_type=s.bits+(s.last?64:0)+(s.mode===oo?128:0)+(s.mode===ho||s.mode===lo?256:0),(0===d&&0===u||e===qr)&&A===$r&&(A=so),A},inflateEnd:t=>{if(_o(t))return Jr;let e=t.state;return e.window&&(e.window=null),t.state=null,$r},inflateGetHeader:(t,e)=>{if(_o(t))return Jr;const s=t.state;return 2&s.wrap?(s.head=e,e.done=!1,$r):Jr},inflateSetDictionary:(t,e)=>{const s=e.length;let i,n,r;return _o(t)?Jr:(i=t.state,0!==i.wrap&&i.mode!==ro?Jr:i.mode===ro&&(n=1,n=In(n,e,s,0),n!==i.check)?to:(r=yo(t,e,s,s),r?(i.mode=16210,eo):(i.havedict=1,$r)))},inflateInfo:"pako inflate (from Nodeca project)"};var So=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1};const wo=Object.prototype.toString,{Z_NO_FLUSH:xo,Z_FINISH:Oo,Z_OK:vo,Z_STREAM_END:Lo,Z_NEED_DICT:Po,Z_STREAM_ERROR:No,Z_DATA_ERROR:Mo,Z_MEM_ERROR:Do}=gn;function Uo(t){this.options=Er({chunkSize:65536,windowBits:15,to:""},t||{});const e=this.options;e.raw&&e.windowBits>=0&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(e.windowBits>=0&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32),e.windowBits>15&&e.windowBits<48&&(15&e.windowBits||(e.windowBits|=15)),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new yr,this.strm.avail_out=0;let s=Fo.inflateInit2(this.strm,e.windowBits);if(s!==vo)throw new Error(En[s]);if(this.header=new So,Fo.inflateGetHeader(this.strm,this.header),e.dictionary&&("string"==typeof e.dictionary?e.dictionary=Tr(e.dictionary):"[object ArrayBuffer]"===wo.call(e.dictionary)&&(e.dictionary=new Uint8Array(e.dictionary)),e.raw&&(s=Fo.inflateSetDictionary(this.strm,e.dictionary),s!==vo)))throw new Error(En[s])}function Vo(t,e){const s=new Uo(e);if(s.push(t),s.err)throw s.msg||En[s.err];return s.result}Uo.prototype.push=function(t,e){const s=this.strm,i=this.options.chunkSize,n=this.options.dictionary;let r,o,a;if(this.ended)return!1;for(o=e===~~e?e:!0===e?Oo:xo,"[object ArrayBuffer]"===wo.call(t)?s.input=new Uint8Array(t):s.input=t,s.next_in=0,s.avail_in=s.input.length;;){for(0===s.avail_out&&(s.output=new Uint8Array(i),s.next_out=0,s.avail_out=i),r=Fo.inflate(s,o),r===Po&&n&&(r=Fo.inflateSetDictionary(s,n),r===vo?r=Fo.inflate(s,o):r===Mo&&(r=Po));s.avail_in>0&&r===Lo&&s.state.wrap>0&&0!==t[s.next_in];)Fo.inflateReset(s),r=Fo.inflate(s,o);switch(r){case No:case Mo:case Po:case Do:return this.onEnd(r),this.ended=!0,!1}if(a=s.avail_out,s.next_out&&(0===s.avail_out||r===Lo))if("string"===this.options.to){let t=Rr(s.output,s.next_out),e=s.next_out-t,n=Ar(s.output,t);s.next_out=e,s.avail_out=i-e,e&&s.output.set(s.output.subarray(t,t+e),0),this.onData(n)}else this.onData(s.output.length===s.next_out?s.output:s.output.subarray(0,s.next_out));if(r!==vo||0!==a){if(r===Lo)return r=Fo.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,!0;if(0===s.avail_in)break}}return!0},Uo.prototype.onData=function(t){this.chunks.push(t)},Uo.prototype.onEnd=function(t){t===vo&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=gr(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg};var Bo={Inflate:Uo,inflate:Vo,inflateRaw:function(t,e){return(e=e||{}).raw=!0,Vo(t,e)},ungzip:Vo};const{Deflate:zo,deflate:Go,deflateRaw:ko,gzip:Ho}=Vr,{Inflate:Yo,inflate:Wo,inflateRaw:jo,ungzip:qo}=Bo;var Zo={Deflate:zo,deflate:Go,deflateRaw:ko,gzip:Ho,Inflate:Yo,inflate:Wo,inflateRaw:jo,ungzip:qo,constants:gn};const Xo=1.25,$o=65535,Ko=Math.pow(2,-24),Qo=Symbol("SKIP_GENERATION");function Jo(t){return function(t){return t.index?t.index.count:t.attributes.position.count}(t)/3}function ta(t,e){if(!t.index){const s=t.attributes.position.count,i=function(t,e=ArrayBuffer){return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}(s,e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);t.setIndex(new Lt(i,1));for(let t=0;t<s;t++)i[t]=t}}function ea(t){const e=Jo(t),s=t.drawRange,i=s.start/3,n=(s.start+s.count)/3,r=Math.max(0,i),o=Math.min(e,n)-r;return[{offset:Math.floor(r),count:Math.floor(o)}]}function sa(t){if(!t.groups||!t.groups.length)return ea(t);const e=[],s=new Set,i=t.drawRange,n=i.start/3,r=(i.start+i.count)/3;for(const e of t.groups){const t=e.start/3,i=(e.start+e.count)/3;s.add(Math.max(n,t)),s.add(Math.min(r,i))}const o=Array.from(s.values()).sort(((t,e)=>t-e));for(let t=0;t<o.length-1;t++){const s=o[t],i=o[t+1];e.push({offset:Math.floor(s),count:Math.floor(i-s)})}return e}function ia(t,e,s){return s.min.x=e[t],s.min.y=e[t+1],s.min.z=e[t+2],s.max.x=e[t+3],s.max.y=e[t+4],s.max.z=e[t+5],s}function na(t){let e=-1,s=-1/0;for(let i=0;i<3;i++){const n=t[i+3]-t[i];n>s&&(s=n,e=i)}return e}function ra(t,e){e.set(t)}function oa(t,e,s){let i,n;for(let r=0;r<3;r++){const o=r+3;i=t[r],n=e[r],s[r]=i<n?i:n,i=t[o],n=e[o],s[o]=i>n?i:n}}function aa(t,e,s){for(let i=0;i<3;i++){const n=e[t+2*i],r=e[t+2*i+1],o=n-r,a=n+r;o<s[i]&&(s[i]=o),a>s[i+3]&&(s[i+3]=a)}}function la(t){const e=t[3]-t[0],s=t[4]-t[1],i=t[5]-t[2];return 2*(e*s+s*i+i*e)}function ha(t,e,s,i,n=null){let r=1/0,o=1/0,a=1/0,l=-1/0,h=-1/0,c=-1/0,d=1/0,u=1/0,f=1/0,p=-1/0,I=-1/0,_=-1/0;const m=null!==n;for(let i=6*e,n=6*(e+s);i<n;i+=6){const e=t[i+0],s=t[i+1],n=e-s,E=e+s;n<r&&(r=n),E>l&&(l=E),m&&e<d&&(d=e),m&&e>p&&(p=e);const g=t[i+2],b=t[i+3],C=g-b,T=g+b;C<o&&(o=C),T>h&&(h=T),m&&g<u&&(u=g),m&&g>I&&(I=g);const A=t[i+4],R=t[i+5],y=A-R,F=A+R;y<a&&(a=y),F>c&&(c=F),m&&A<f&&(f=A),m&&A>_&&(_=A)}i[0]=r,i[1]=o,i[2]=a,i[3]=l,i[4]=h,i[5]=c,m&&(n[0]=d,n[1]=u,n[2]=f,n[3]=p,n[4]=I,n[5]=_)}const ca=32,da=(t,e)=>t.candidate-e.candidate,ua=new Array(ca).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),fa=new Float32Array(6);class pa{constructor(){}}function Ia(t,e,s,i,n,r){let o=i,a=i+n-1;const l=r.pos,h=2*r.axis;for(;;){for(;o<=a&&s[6*o+h]<l;)o++;for(;o<=a&&s[6*a+h]>=l;)a--;if(!(o<a))return o;for(let t=0;t<3;t++){let s=e[3*o+t];e[3*o+t]=e[3*a+t],e[3*a+t]=s}for(let t=0;t<6;t++){let e=s[6*o+t];s[6*o+t]=s[6*a+t],s[6*a+t]=e}o++,a--}}function _a(t,e,s,i,n,r){let o=i,a=i+n-1;const l=r.pos,h=2*r.axis;for(;;){for(;o<=a&&s[6*o+h]<l;)o++;for(;o<=a&&s[6*a+h]>=l;)a--;if(!(o<a))return o;{let e=t[o];t[o]=t[a],t[a]=e;for(let t=0;t<6;t++){let e=s[6*o+t];s[6*o+t]=s[6*a+t],s[6*a+t]=e}o++,a--}}}function ma(t,e){const s=t.geometry,i=s.index?s.index.array:null,n=e.maxDepth,r=e.verbose,o=e.maxLeafTris,a=e.strategy,l=e.onProgress,h=Jo(s),c=t._indirectBuffer;let d=!1;const u=new Float32Array(6),f=new Float32Array(6),p=function(t,e){var s;(s=e)[0]=s[1]=s[2]=1/0,s[3]=s[4]=s[5]=-1/0;const i=t.attributes.position,n=t.index?t.index.array:null,r=Jo(t),o=new Float32Array(6*r),a=i.normalized,l=i.array,h=i.offset||0;let c=3;i.isInterleavedBufferAttribute&&(c=i.data.stride);const d=["getX","getY","getZ"];for(let t=0;t<r;t++){const s=3*t,r=6*t;let u=s+0,f=s+1,p=s+2;n&&(u=n[u],f=n[f],p=n[p]),a||(u=u*c+h,f=f*c+h,p=p*c+h);for(let t=0;t<3;t++){let s,n,h;a?(s=i[d[t]](u),n=i[d[t]](f),h=i[d[t]](p)):(s=l[u+t],n=l[f+t],h=l[p+t]);let c=s;n<c&&(c=n),h<c&&(c=h);let I=s;n>I&&(I=n),h>I&&(I=h);const _=(I-c)/2,m=2*t;o[r+m+0]=c+_,o[r+m+1]=_+(Math.abs(c)+_)*Ko,c<e[t]&&(e[t]=c),I>e[t+3]&&(e[t+3]=I)}}return o}(s,u),I=e.indirect?_a:Ia,_=[],m=e.indirect?ea(s):sa(s);if(1===m.length){const t=m[0],e=new pa;e.boundingData=u,function(t,e,s,i){let n=1/0,r=1/0,o=1/0,a=-1/0,l=-1/0,h=-1/0;for(let i=6*e,c=6*(e+s);i<c;i+=6){const e=t[i+0];e<n&&(n=e),e>a&&(a=e);const s=t[i+2];s<r&&(r=s),s>l&&(l=s);const c=t[i+4];c<o&&(o=c),c>h&&(h=c)}i[0]=n,i[1]=r,i[2]=o,i[3]=a,i[4]=l,i[5]=h}(p,t.offset,t.count,f),g(e,t.offset,t.count,f),_.push(e)}else for(let t of m){const e=new pa;e.boundingData=new Float32Array(6),ha(p,t.offset,t.count,e.boundingData,f),g(e,t.offset,t.count,f),_.push(e)}return _;function E(t){l&&l(t/h)}function g(t,e,l,h=null,u=0){if(!d&&u>=n&&(d=!0,r&&(console.warn(`MeshBVH: Max depth of ${n} reached when generating BVH. Consider increasing maxDepth.`),console.warn(s))),l<=o||u>=n)return E(e+l),t.offset=e,t.count=l,t;const _=function(t,e,s,i,n,r){let o=-1,a=0;if(0===r)o=na(e),-1!==o&&(a=(e[o]+e[o+3])/2);else if(1===r)o=na(t),-1!==o&&(a=function(t,e,s,i){let n=0;for(let r=e,o=e+s;r<o;r++)n+=t[6*r+2*i];return n/s}(s,i,n,o));else if(2===r){const r=la(t);let l=Xo*n;const h=6*i,c=6*(i+n);for(let t=0;t<3;t++){const i=e[t],d=(e[t+3]-i)/ca;if(n<8){const e=[...ua];e.length=n;let i=0;for(let n=h;n<c;n+=6,i++){const r=e[i];r.candidate=s[n+2*t],r.count=0;const{bounds:o,leftCacheBounds:a,rightCacheBounds:l}=r;for(let t=0;t<3;t++)l[t]=1/0,l[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,o[t]=1/0,o[t+3]=-1/0;aa(n,s,o)}e.sort(da);let d=n;for(let t=0;t<d;t++){const s=e[t];for(;t+1<d&&e[t+1].candidate===s.candidate;)e.splice(t+1,1),d--}for(let i=h;i<c;i+=6){const n=s[i+2*t];for(let t=0;t<d;t++){const r=e[t];n>=r.candidate?aa(i,s,r.rightCacheBounds):(aa(i,s,r.leftCacheBounds),r.count++)}}for(let s=0;s<d;s++){const i=e[s],h=i.count,c=n-i.count,d=i.leftCacheBounds,u=i.rightCacheBounds;let f=0;0!==h&&(f=la(d)/r);let p=0;0!==c&&(p=la(u)/r);const I=1+Xo*(f*h+p*c);I<l&&(o=t,l=I,a=i.candidate)}}else{for(let t=0;t<ca;t++){const e=ua[t];e.count=0,e.candidate=i+d+t*d;const s=e.bounds;for(let t=0;t<3;t++)s[t]=1/0,s[t+3]=-1/0}for(let e=h;e<c;e+=6){let n=~~((s[e+2*t]-i)/d);n>=ca&&(n=31);const r=ua[n];r.count++,aa(e,s,r.bounds)}const e=ua[31];ra(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){const e=ua[t],s=ua[t+1];oa(e.bounds,s.rightCacheBounds,e.rightCacheBounds)}let u=0;for(let e=0;e<31;e++){const s=ua[e],i=s.count,h=s.bounds,c=ua[e+1].rightCacheBounds;0!==i&&(0===u?ra(h,fa):oa(h,fa,fa)),u+=i;let d=0,f=0;0!==u&&(d=la(fa)/r);const p=n-u;0!==p&&(f=la(c)/r);const I=1+Xo*(d*u+f*p);I<l&&(o=t,l=I,a=s.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:o,pos:a}}(t.boundingData,h,p,e,l,a);if(-1===_.axis)return E(e+l),t.offset=e,t.count=l,t;const m=I(c,i,p,e,l,_);if(m===e||m===e+l)E(e+l),t.offset=e,t.count=l;else{t.splitAxis=_.axis;const s=new pa,i=e,n=m-e;t.left=s,s.boundingData=new Float32Array(6),ha(p,i,n,s.boundingData,f),g(s,i,n,f,u+1);const r=new pa,o=m,a=l-n;t.right=r,r.boundingData=new Float32Array(6),ha(p,o,a,r.boundingData,f),g(r,o,a,f,u+1)}return t}}function Ea(t,e){const s=t.geometry;e.indirect&&(t._indirectBuffer=function(t,e){const s=(t.index?t.index.count:t.attributes.position.count)/3,i=s>65536,n=i?4:2,r=e?new SharedArrayBuffer(s*n):new ArrayBuffer(s*n),o=i?new Uint32Array(r):new Uint16Array(r);for(let t=0,e=o.length;t<e;t++)o[t]=t;return o}(s,e.useSharedArrayBuffer),function(t){if(0===t.groups.length)return!1;const e=Jo(t),s=sa(t).sort(((t,e)=>t.offset-e.offset)),i=s[s.length-1];i.count=Math.min(e-i.offset,i.count);let n=0;return s.forEach((({count:t})=>n+=t)),e!==n}(s)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),t._indirectBuffer||ta(s,e);const i=ma(t,e);let n,r,o;const a=[],l=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let t=0;t<i.length;t++){const e=i[t];const s=new l(32*h(e));n=new Float32Array(s),r=new Uint32Array(s),o=new Uint16Array(s),c(0,e),a.push(s)}return void(t._roots=a);function h(t){return t.count?1:1+h(t.left)+h(t.right)}function c(t,e){const s=t/4,i=t/2,a=!!e.count,l=e.boundingData;for(let t=0;t<6;t++)n[s+t]=l[t];if(a){const n=e.offset,a=e.count;return r[s+6]=n,o[i+14]=a,o[i+15]=$o,t+32}{const i=e.left,n=e.right,o=e.splitAxis;let a;if(a=c(t+32,i),a/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return r[s+6]=a/4,a=c(a,n),r[s+7]=o,a}}}class ga{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,i=-1/0;for(let n=0,r=t.length;n<r;n++){const r=t[n][e];s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}setFromPoints(t,e){let s=1/0,i=-1/0;for(let n=0,r=e.length;n<r;n++){const r=e[n],o=t.dot(r);s=o<s?o:s,i=o>i?o:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}ga.prototype.setFromBox=function(){const t=new Ct;return function(e,s){const i=s.min,n=s.max;let r=1/0,o=-1/0;for(let s=0;s<=1;s++)for(let a=0;a<=1;a++)for(let l=0;l<=1;l++){t.x=i.x*s+n.x*(1-s),t.y=i.y*a+n.y*(1-a),t.z=i.z*l+n.z*(1-l);const h=e.dot(t);r=Math.min(h,r),o=Math.max(h,o)}this.min=r,this.max=o}}();const ba=function(){const t=new Ct,e=new Ct,s=new Ct;return function(i,n,r){const o=i.start,a=t,l=n.start,h=e;s.subVectors(o,l),t.subVectors(i.end,i.start),e.subVectors(n.end,n.start);const c=s.dot(h),d=h.dot(a),u=h.dot(h),f=s.dot(a),p=a.dot(a)*u-d*d;let I,_;I=0!==p?(c*d-f*u)/p:0,_=(c+I*d)/u,r.x=I,r.y=_}}(),Ca=function(){const t=new yt,e=new Ct,s=new Ct;return function(i,n,r,o){ba(i,n,t);let a=t.x,l=t.y;if(a>=0&&a<=1&&l>=0&&l<=1)return i.at(a,r),void n.at(l,o);if(a>=0&&a<=1)return l<0?n.at(0,o):n.at(1,o),void i.closestPointToPoint(o,!0,r);if(l>=0&&l<=1)return a<0?i.at(0,r):i.at(1,r),void n.closestPointToPoint(r,!0,o);{let t,h;t=a<0?i.start:i.end,h=l<0?n.start:n.end;const c=e,d=s;return i.closestPointToPoint(h,!0,e),n.closestPointToPoint(t,!0,s),c.distanceToSquared(h)<=d.distanceToSquared(t)?(r.copy(c),void o.copy(h)):(r.copy(t),void o.copy(d))}}}(),Ta=function(){const t=new Ct,e=new Ct,s=new Pt,i=new xt;return function(n,r){const{radius:o,center:a}=n,{a:l,b:h,c:c}=r;i.start=l,i.end=h;if(i.closestPointToPoint(a,!0,t).distanceTo(a)<=o)return!0;i.start=l,i.end=c;if(i.closestPointToPoint(a,!0,t).distanceTo(a)<=o)return!0;i.start=h,i.end=c;if(i.closestPointToPoint(a,!0,t).distanceTo(a)<=o)return!0;const d=r.getPlane(s);if(Math.abs(d.distanceToPoint(a))<=o){const t=d.projectPoint(a,e);if(r.containsPoint(t))return!0}return!1}}();function Aa(t){return Math.abs(t)<1e-15}class Ra extends Nt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new Ct)),this.satBounds=new Array(4).fill().map((()=>new ga)),this.points=[this.a,this.b,this.c],this.sphere=new bt,this.plane=new Pt,this.needsUpdate=!0}intersectsSphere(t){return Ta(t,this)}update(){const t=this.a,e=this.b,s=this.c,i=this.points,n=this.satAxes,r=this.satBounds,o=n[0],a=r[0];this.getNormal(o),a.setFromPoints(o,i);const l=n[1],h=r[1];l.subVectors(t,e),h.setFromPoints(l,i);const c=n[2],d=r[2];c.subVectors(e,s),d.setFromPoints(c,i);const u=n[3],f=r[3];u.subVectors(s,t),f.setFromPoints(u,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,t),this.needsUpdate=!1}}Ra.prototype.closestPointToSegment=function(){const t=new Ct,e=new Ct,s=new xt;return function(i,n=null,r=null){const{start:o,end:a}=i,l=this.points;let h,c=1/0;for(let o=0;o<3;o++){const a=(o+1)%3;s.start.copy(l[o]),s.end.copy(l[a]),Ca(s,i,t,e),h=t.distanceToSquared(e),h<c&&(c=h,n&&n.copy(t),r&&r.copy(e))}return this.closestPointToPoint(o,t),h=o.distanceToSquared(t),h<c&&(c=h,n&&n.copy(t),r&&r.copy(o)),this.closestPointToPoint(a,t),h=a.distanceToSquared(t),h<c&&(c=h,n&&n.copy(t),r&&r.copy(a)),Math.sqrt(c)}}(),Ra.prototype.intersectsTriangle=function(){const t=new Ra,e=new Array(3),s=new Array(3),i=new ga,n=new ga,r=new Ct,o=new Ct,a=new Ct,l=new Ct,h=new Ct,c=new xt,d=new xt,u=new xt,f=new Ct;function p(t,e,s){const i=t.points;let n=0,r=-1;for(let t=0;t<3;t++){const{start:a,end:l}=c;a.copy(i[t]),l.copy(i[(t+1)%3]),c.delta(o);const h=Aa(e.distanceToPoint(a));if(Aa(e.normal.dot(o))&&h){s.copy(c),n=2;break}const d=e.intersectLine(c,f);if(!d&&h&&f.copy(a),(d||h)&&!Aa(f.distanceTo(l))){if(n<=1){(1===n?s.start:s.end).copy(f),h&&(r=n)}else if(n>=2){(1===r?s.start:s.end).copy(f),n=2;break}if(n++,2===n&&-1===r)break}}return n}return function(o,c=null,f=!1){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(t.copy(o),t.update(),o=t);const I=this.plane,_=o.plane;if(Math.abs(I.normal.dot(_.normal))>1-1e-10){const t=this.satBounds,a=this.satAxes;s[0]=o.a,s[1]=o.b,s[2]=o.c;for(let e=0;e<4;e++){const n=t[e],r=a[e];if(i.setFromPoints(r,s),n.isSeparated(i))return!1}const l=o.satBounds,h=o.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let t=0;t<4;t++){const s=l[t],n=h[t];if(i.setFromPoints(n,e),s.isSeparated(i))return!1}for(let t=0;t<4;t++){const o=a[t];for(let t=0;t<4;t++){const a=h[t];if(r.crossVectors(o,a),i.setFromPoints(r,e),n.setFromPoints(r,s),i.isSeparated(n))return!1}}return c&&(f||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),c.start.set(0,0,0),c.end.set(0,0,0)),!0}{const t=p(this,_,d);if(1===t&&o.containsPoint(d.end))return c&&(c.start.copy(d.end),c.end.copy(d.end)),!0;if(2!==t)return!1;const e=p(o,I,u);if(1===e&&this.containsPoint(u.end))return c&&(c.start.copy(u.end),c.end.copy(u.end)),!0;if(2!==e)return!1;if(d.delta(a),u.delta(l),a.dot(l)<0){let t=u.start;u.start=u.end,u.end=t}const s=d.start.dot(a),i=d.end.dot(a),n=u.start.dot(a),r=u.end.dot(a);return(s===r||n===i||i<n!==s<r)&&(c&&(h.subVectors(d.start,u.start),h.dot(a)>0?c.start.copy(d.start):c.start.copy(u.start),h.subVectors(d.end,u.end),h.dot(a)<0?c.end.copy(d.end):c.end.copy(u.end)),!0)}}}(),Ra.prototype.distanceToPoint=function(){const t=new Ct;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),Ra.prototype.distanceToTriangle=function(){const t=new Ct,e=new Ct,s=["a","b","c"],i=new xt,n=new xt;return function(r,o=null,a=null){const l=o||a?i:null;if(this.intersectsTriangle(r,l))return(o||a)&&(o&&l.getCenter(o),a&&l.getCenter(a)),0;let h=1/0;for(let e=0;e<3;e++){let i;const n=s[e],l=r[n];this.closestPointToPoint(l,t),i=l.distanceToSquared(t),i<h&&(h=i,o&&o.copy(t),a&&a.copy(l));const c=this[n];r.closestPointToPoint(c,t),i=c.distanceToSquared(t),i<h&&(h=i,o&&o.copy(c),a&&a.copy(t))}for(let l=0;l<3;l++){const c=s[l],d=s[(l+1)%3];i.set(this[c],this[d]);for(let l=0;l<3;l++){const c=s[l],d=s[(l+1)%3];n.set(r[c],r[d]),Ca(i,n,t,e);const u=t.distanceToSquared(e);u<h&&(h=u,o&&o.copy(t),a&&a.copy(e))}}return Math.sqrt(h)}}();class ya{constructor(t,e,s){this.isOrientedBox=!0,this.min=new Ct,this.max=new Ct,this.matrix=new Ot,this.invMatrix=new Ot,this.points=new Array(8).fill().map((()=>new Ct)),this.satAxes=new Array(3).fill().map((()=>new Ct)),this.satBounds=new Array(3).fill().map((()=>new ga)),this.alignedSatBounds=new Array(3).fill().map((()=>new ga)),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),s&&this.matrix.copy(s)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}ya.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,i=this.points;for(let n=0;n<=1;n++)for(let r=0;r<=1;r++)for(let o=0;o<=1;o++){const a=i[1*n|2*r|4*o];a.x=n?s.x:e.x,a.y=r?s.y:e.y,a.z=o?s.z:e.z,a.applyMatrix4(t)}const n=this.satBounds,r=this.satAxes,o=i[0];for(let t=0;t<3;t++){const e=r[t],s=n[t],a=i[1<<t];e.subVectors(o,a),s.setFromPoints(e,i)}const a=this.alignedSatBounds;a[0].setFromPointsField(i,"x"),a[1].setFromPointsField(i,"y"),a[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}(),ya.prototype.intersectsBox=function(){const t=new ga;return function(e){this.needsUpdate&&this.update();const s=e.min,i=e.max,n=this.satBounds,r=this.satAxes,o=this.alignedSatBounds;if(t.min=s.x,t.max=i.x,o[0].isSeparated(t))return!1;if(t.min=s.y,t.max=i.y,o[1].isSeparated(t))return!1;if(t.min=s.z,t.max=i.z,o[2].isSeparated(t))return!1;for(let s=0;s<3;s++){const i=r[s],o=n[s];if(t.setFromBox(i,e),o.isSeparated(t))return!1}return!0}}(),ya.prototype.intersectsTriangle=function(){const t=new Ra,e=new Array(3),s=new ga,i=new ga,n=new Ct;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(t.copy(r),t.update(),r=t);const o=this.satBounds,a=this.satAxes;e[0]=r.a,e[1]=r.b,e[2]=r.c;for(let t=0;t<3;t++){const i=o[t],n=a[t];if(s.setFromPoints(n,e),i.isSeparated(s))return!1}const l=r.satBounds,h=r.satAxes,c=this.points;for(let t=0;t<3;t++){const e=l[t],i=h[t];if(s.setFromPoints(i,c),e.isSeparated(s))return!1}for(let t=0;t<3;t++){const r=a[t];for(let t=0;t<4;t++){const o=h[t];if(n.crossVectors(r,o),s.setFromPoints(n,e),i.setFromPoints(n,c),s.isSeparated(i))return!1}}return!0}}(),ya.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}(),ya.prototype.distanceToPoint=function(){const t=new Ct;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),ya.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new xt)),s=new Array(12).fill().map((()=>new xt)),i=new Ct,n=new Ct;return function(r,o=0,a=null,l=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(a||l)&&(r.getCenter(n),this.closestPointToPoint(n,i),r.closestPointToPoint(i,n),a&&a.copy(i),l&&l.copy(n)),0;const h=o*o,c=r.min,d=r.max,u=this.points;let f=1/0;for(let t=0;t<8;t++){const e=u[t];n.copy(e).clamp(c,d);const s=e.distanceToSquared(n);if(s<f&&(f=s,a&&a.copy(e),l&&l.copy(n),s<h))return Math.sqrt(s)}let p=0;for(let i=0;i<3;i++)for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){const o=(i+1)%3,a=(i+2)%3,l=1<<i|n<<o|r<<a,h=u[n<<o|r<<a],f=u[l];e[p].set(h,f);const I=t[i],_=t[o],m=t[a],E=s[p],g=E.start,b=E.end;g[I]=c[I],g[_]=n?c[_]:d[_],g[m]=r?c[m]:d[_],b[I]=d[I],b[_]=n?c[_]:d[_],b[m]=r?c[m]:d[_],p++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let s=0;s<=1;s++){n.x=t?d.x:c.x,n.y=e?d.y:c.y,n.z=s?d.z:c.z,this.closestPointToPoint(n,i);const r=n.distanceToSquared(i);if(r<f&&(f=r,a&&a.copy(i),l&&l.copy(n),r<h))return Math.sqrt(r)}for(let t=0;t<12;t++){const r=e[t];for(let t=0;t<12;t++){const e=s[t];Ca(r,e,i,n);const o=i.distanceToSquared(n);if(o<f&&(f=o,a&&a.copy(i),l&&l.copy(n),o<h))return Math.sqrt(o)}}return Math.sqrt(f)}}();class Fa{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Sa extends Fa{constructor(){super((()=>new Ra))}}const wa=new Sa;function xa(t,e){return 65535===e[t+15]}function Oa(t,e){return e[t+6]}function va(t,e){return e[t+14]}function La(t){return t+8}function Pa(t,e){return e[t+6]}function Na(t,e){return e[t+7]}const Ma=new class{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=s=>{e&&t.push(e),e=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,0!==t.length&&this.setBuffer(t.pop())}}};let Da,Ua;const Va=[],Ba=new Fa((()=>new gt));function za(t,e,s,i,n,r){Da=Ba.getPrimitive(),Ua=Ba.getPrimitive(),Va.push(Da,Ua),Ma.setBuffer(t._roots[e]);const o=Ga(0,t.geometry,s,i,n,r);Ma.clearBuffer(),Ba.releasePrimitive(Da),Ba.releasePrimitive(Ua),Va.pop(),Va.pop();const a=Va.length;return a>0&&(Ua=Va[a-1],Da=Va[a-2]),o}function Ga(t,e,s,i,n=null,r=0,o=0){const{float32Array:a,uint16Array:l,uint32Array:h}=Ma;let c=2*t;if(xa(c,l)){const e=Oa(t,h),s=va(c,l);return ia(t,a,Da),i(e,s,!1,o,r+t,Da)}{let c=function(t){const{uint16Array:e,uint32Array:s}=Ma;let i=2*t;for(;!xa(i,e);)i=2*(t=La(t));return Oa(t,s)},d=function(t){const{uint16Array:e,uint32Array:s}=Ma;let i=2*t;for(;!xa(i,e);)i=2*(t=Pa(t,s));return Oa(t,s)+va(i,e)};const u=La(t),f=Pa(t,h);let p,I,_,m,E=u,g=f;if(n&&(_=Da,m=Ua,ia(E,a,_),ia(g,a,m),p=n(_),I=n(m),I<p)){E=f,g=u;const t=p;p=I,I=t,_=m}_||(_=Da,ia(E,a,_));const b=s(_,xa(2*E,l),p,o+1,r+E);let C;if(2===b){const t=c(E);C=i(t,d(E)-t,!0,o+1,r+E,_)}else C=b&&Ga(E,e,s,i,n,r,o+1);if(C)return!0;m=Ua,ia(g,a,m);const T=s(m,xa(2*g,l),I,o+1,r+g);let A;if(2===T){const t=c(g);A=i(t,d(g)-t,!0,o+1,r+g,m)}else A=T&&Ga(g,e,s,i,n,r,o+1);return!!A}}const ka=new Ct,Ha=new Ct;const Ya=new Ct,Wa=new Ct,ja=new Ct,qa=new yt,Za=new yt,Xa=new yt,$a=new Ct,Ka=new Ct,Qa=new Ct,Ja=new Ct;function tl(t,e,s,i,n,r,o,a,l){Ya.fromBufferAttribute(e,r),Wa.fromBufferAttribute(e,o),ja.fromBufferAttribute(e,a);const h=function(t,e,s,i,n,r){let o;return o=r===Mt?t.intersectTriangle(i,s,e,!0,n):t.intersectTriangle(e,s,i,r!==Dt,n),null===o?null:{distance:t.origin.distanceTo(n),point:n.clone()}}(t,Ya,Wa,ja,Ja,l);if(h){i&&(qa.fromBufferAttribute(i,r),Za.fromBufferAttribute(i,o),Xa.fromBufferAttribute(i,a),h.uv=Nt.getInterpolation(Ja,Ya,Wa,ja,qa,Za,Xa,new yt)),n&&(qa.fromBufferAttribute(n,r),Za.fromBufferAttribute(n,o),Xa.fromBufferAttribute(n,a),h.uv1=Nt.getInterpolation(Ja,Ya,Wa,ja,qa,Za,Xa,new yt)),s&&($a.fromBufferAttribute(s,r),Ka.fromBufferAttribute(s,o),Qa.fromBufferAttribute(s,a),h.normal=Nt.getInterpolation(Ja,Ya,Wa,ja,$a,Ka,Qa,new Ct),h.normal.dot(t.direction)>0&&h.normal.multiplyScalar(-1));const e={a:r,b:o,c:a,normal:new Ct,materialIndex:0};Nt.getNormal(Ya,Wa,ja,e.normal),h.face=e,h.faceIndex=r}return h}function el(t,e,s,i,n){const r=3*i;let o=r+0,a=r+1,l=r+2;const h=t.index;t.index&&(o=h.getX(o),a=h.getX(a),l=h.getX(l));const{position:c,normal:d,uv:u,uv1:f}=t.attributes,p=tl(s,c,d,u,f,o,a,l,e);return p?(p.faceIndex=i,n&&n.push(p),p):null}function sl(t,e,s,i){const n=t.a,r=t.b,o=t.c;let a=e,l=e+1,h=e+2;s&&(a=s.getX(a),l=s.getX(l),h=s.getX(h)),n.x=i.getX(a),n.y=i.getY(a),n.z=i.getZ(a),r.x=i.getX(l),r.y=i.getY(l),r.z=i.getZ(l),o.x=i.getX(h),o.y=i.getY(h),o.z=i.getZ(h)}function il(t,e,s,i,n,r,o){const{geometry:a}=s,{index:l}=a,h=a.attributes.position;for(let s=t,a=e+t;s<a;s++){let t;if(t=s,sl(o,3*t,l,h),o.needsUpdate=!0,i(o,t,n,r))return!0}return!1}function nl(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const s=t.geometry,i=s.index?s.index.array:null,n=s.attributes.position;let r,o,a,l,h=0;const c=t._roots;for(let t=0,e=c.length;t<e;t++)r=c[t],o=new Uint32Array(r),a=new Uint16Array(r),l=new Float32Array(r),d(0,h),h+=r.byteLength;function d(t,s,r=!1){const h=2*t;if(a[h+15]===$o){const e=o[t+6];let s=1/0,r=1/0,c=1/0,d=-1/0,u=-1/0,f=-1/0;for(let t=3*e,o=3*(e+a[h+14]);t<o;t++){let e=i[t];const o=n.getX(e),a=n.getY(e),l=n.getZ(e);o<s&&(s=o),o>d&&(d=o),a<r&&(r=a),a>u&&(u=a),l<c&&(c=l),l>f&&(f=l)}return(l[t+0]!==s||l[t+1]!==r||l[t+2]!==c||l[t+3]!==d||l[t+4]!==u||l[t+5]!==f)&&(l[t+0]=s,l[t+1]=r,l[t+2]=c,l[t+3]=d,l[t+4]=u,l[t+5]=f,!0)}{const i=t+8,n=o[t+6],a=i+s,h=n+s;let c=r,u=!1,f=!1;e?c||(u=e.has(a),f=e.has(h),c=!u&&!f):(u=!0,f=!0);const p=c||f;let I=!1;(c||u)&&(I=d(i,s,c));let _=!1;p&&(_=d(n,s,c));const m=I||_;if(m)for(let e=0;e<3;e++){const s=i+e,r=n+e,o=l[s],a=l[s+3],h=l[r],c=l[r+3];l[t+e]=o<h?o:h,l[t+e+3]=a>c?a:c}return m}}}const rl=new gt;function ol(t,e,s,i){return ia(t,e,rl),s.intersectBox(rl,i)}function al(t,e,s,i,n,r,o){const{geometry:a}=s,{index:l}=a,h=a.attributes.position;for(let a=t,c=e+t;a<c;a++){let t;if(t=s.resolveTriangleIndex(a),sl(o,3*t,l,h),o.needsUpdate=!0,i(o,t,n,r))return!0}return!1}const ll=new Ct;function hl(t,e,s,i,n){Ma.setBuffer(t._roots[e]),cl(0,t,s,i,n),Ma.clearBuffer()}function cl(t,e,s,i,n){const{float32Array:r,uint16Array:o,uint32Array:a}=Ma,l=2*t;if(xa(l,o)){!function(t,e,s,i,n,r){const{geometry:o,_indirectBuffer:a}=t;for(let t=i,a=i+n;t<a;t++)el(o,e,s,t,r)}(e,s,i,Oa(t,a),va(l,o),n)}else{const o=La(t);ol(o,r,i,ll)&&cl(o,e,s,i,n);const l=Pa(t,a);ol(l,r,i,ll)&&cl(l,e,s,i,n)}}const dl=new Ct,ul=["x","y","z"];function fl(t,e,s,i){Ma.setBuffer(t._roots[e]);const n=pl(0,t,s,i);return Ma.clearBuffer(),n}function pl(t,e,s,i){const{float32Array:n,uint16Array:r,uint32Array:o}=Ma;let a=2*t;if(xa(a,r)){return function(t,e,s,i,n){const{geometry:r,_indirectBuffer:o}=t;let a=1/0,l=null;for(let t=i,o=i+n;t<o;t++){let i;i=el(r,e,s,t),i&&i.distance<a&&(l=i,a=i.distance)}return l}(e,s,i,Oa(t,o),va(a,r))}{const r=Na(t,o),a=ul[r],l=i.direction[a]>=0;let h,c;l?(h=La(t),c=Pa(t,o)):(h=Pa(t,o),c=La(t));const d=ol(h,n,i,dl)?pl(h,e,s,i):null;if(d){const t=d.point[a];if(l?t<=n[c+r]:t>=n[c+r+3])return d}const u=ol(c,n,i,dl)?pl(c,e,s,i):null;return d&&u?d.distance<=u.distance?d:u:d||u||null}}const Il=new gt,_l=new Ra,ml=new Ra,El=new Ot,gl=new ya,bl=new ya;function Cl(t,e,s,i){Ma.setBuffer(t._roots[e]);const n=Tl(0,t,s,i);return Ma.clearBuffer(),n}function Tl(t,e,s,i,n=null){const{float32Array:r,uint16Array:o,uint32Array:a}=Ma;let l=2*t;null===n&&(s.boundingBox||s.computeBoundingBox(),gl.set(s.boundingBox.min,s.boundingBox.max,i),n=gl);if(!xa(l,o)){const o=t+8,l=a[t+6];ia(o,r,Il);if(n.intersectsBox(Il)&&Tl(o,e,s,i,n))return!0;ia(l,r,Il);return!!(n.intersectsBox(Il)&&Tl(l,e,s,i,n))}{const n=e.geometry,h=n.index,c=n.attributes.position,d=s.index,u=s.attributes.position,f=Oa(t,a),p=va(l,o);if(El.copy(i).invert(),s.boundsTree){ia(t,r,bl),bl.matrix.copy(El),bl.needsUpdate=!0;return s.boundsTree.shapecast({intersectsBounds:t=>bl.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(i),t.b.applyMatrix4(i),t.c.applyMatrix4(i),t.needsUpdate=!0;for(let e=3*f,s=3*(p+f);e<s;e+=3)if(sl(ml,e,h,c),ml.needsUpdate=!0,t.intersectsTriangle(ml))return!0;return!1}})}for(let t=3*f,e=3*(p+f);t<e;t+=3){sl(_l,t,h,c),_l.a.applyMatrix4(El),_l.b.applyMatrix4(El),_l.c.applyMatrix4(El),_l.needsUpdate=!0;for(let t=0,e=d.count;t<e;t+=3)if(sl(ml,t,d,u),ml.needsUpdate=!0,_l.intersectsTriangle(ml))return!0}}}const Al=new Ot,Rl=new ya,yl=new ya,Fl=new Ct,Sl=new Ct,wl=new Ct,xl=new Ct;function Ol(t,e,s,i={},n={},r=0,o=1/0){e.boundingBox||e.computeBoundingBox(),Rl.set(e.boundingBox.min,e.boundingBox.max,s),Rl.needsUpdate=!0;const a=t.geometry,l=a.attributes.position,h=a.index,c=e.attributes.position,d=e.index,u=wa.getPrimitive(),f=wa.getPrimitive();let p=Fl,I=Sl,_=null,m=null;n&&(_=wl,m=xl);let E=1/0,g=null,b=null;return Al.copy(s).invert(),yl.matrix.copy(Al),t.shapecast({boundsTraverseOrder:t=>Rl.distanceToBox(t),intersectsBounds:(t,e,s)=>s<E&&s<o&&(e&&(yl.min.copy(t.min),yl.max.copy(t.max),yl.needsUpdate=!0),!0),intersectsRange:(t,i)=>{if(e.boundsTree){return e.boundsTree.shapecast({boundsTraverseOrder:t=>yl.distanceToBox(t),intersectsBounds:(t,e,s)=>s<E&&s<o,intersectsRange:(e,n)=>{for(let o=e,a=e+n;o<a;o++){sl(f,3*o,d,c),f.a.applyMatrix4(s),f.b.applyMatrix4(s),f.c.applyMatrix4(s),f.needsUpdate=!0;for(let e=t,s=t+i;e<s;e++){sl(u,3*e,h,l),u.needsUpdate=!0;const t=u.distanceToTriangle(f,p,_);if(t<E&&(I.copy(p),m&&m.copy(_),E=t,g=e,b=o),t<r)return!0}}}})}for(let n=0,o=Jo(e);n<o;n++){sl(f,3*n,d,c),f.a.applyMatrix4(s),f.b.applyMatrix4(s),f.c.applyMatrix4(s),f.needsUpdate=!0;for(let e=t,s=t+i;e<s;e++){sl(u,3*e,h,l),u.needsUpdate=!0;const t=u.distanceToTriangle(f,p,_);if(t<E&&(I.copy(p),m&&m.copy(_),E=t,g=e,b=n),t<r)return!0}}}}),wa.releasePrimitive(u),wa.releasePrimitive(f),E===1/0?null:(i.point?i.point.copy(I):i.point=I.clone(),i.distance=E,i.faceIndex=g,n&&(n.point?n.point.copy(m):n.point=m.clone(),n.point.applyMatrix4(Al),I.applyMatrix4(Al),n.distance=I.sub(n.point).length(),n.faceIndex=b),i)}function vl(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const s=t.geometry,i=s.index?s.index.array:null,n=s.attributes.position;let r,o,a,l,h=0;const c=t._roots;for(let t=0,e=c.length;t<e;t++)r=c[t],o=new Uint32Array(r),a=new Uint16Array(r),l=new Float32Array(r),d(0,h),h+=r.byteLength;function d(s,r,h=!1){const c=2*s;if(a[c+15]===$o){const e=o[s+6];let r=1/0,h=1/0,d=1/0,u=-1/0,f=-1/0,p=-1/0;for(let s=e,o=e+a[c+14];s<o;s++){const e=3*t.resolveTriangleIndex(s);for(let t=0;t<3;t++){let s=e+t;s=i?i[s]:s;const o=n.getX(s),a=n.getY(s),l=n.getZ(s);o<r&&(r=o),o>u&&(u=o),a<h&&(h=a),a>f&&(f=a),l<d&&(d=l),l>p&&(p=l)}}return(l[s+0]!==r||l[s+1]!==h||l[s+2]!==d||l[s+3]!==u||l[s+4]!==f||l[s+5]!==p)&&(l[s+0]=r,l[s+1]=h,l[s+2]=d,l[s+3]=u,l[s+4]=f,l[s+5]=p,!0)}{const t=s+8,i=o[s+6],n=t+r,a=i+r;let c=h,u=!1,f=!1;e?c||(u=e.has(n),f=e.has(a),c=!u&&!f):(u=!0,f=!0);const p=c||f;let I=!1;(c||u)&&(I=d(t,r,c));let _=!1;p&&(_=d(i,r,c));const m=I||_;if(m)for(let e=0;e<3;e++){const n=t+e,r=i+e,o=l[n],a=l[n+3],h=l[r],c=l[r+3];l[s+e]=o<h?o:h,l[s+e+3]=a>c?a:c}return m}}}const Ll=new Ct;function Pl(t,e,s,i,n){Ma.setBuffer(t._roots[e]),Nl(0,t,s,i,n),Ma.clearBuffer()}function Nl(t,e,s,i,n){const{float32Array:r,uint16Array:o,uint32Array:a}=Ma,l=2*t;if(xa(l,o)){!function(t,e,s,i,n,r){const{geometry:o,_indirectBuffer:a}=t;for(let t=i,l=i+n;t<l;t++)el(o,e,s,a?a[t]:t,r)}(e,s,i,Oa(t,a),va(l,o),n)}else{const o=La(t);ol(o,r,i,Ll)&&Nl(o,e,s,i,n);const l=Pa(t,a);ol(l,r,i,Ll)&&Nl(l,e,s,i,n)}}const Ml=new Ct,Dl=["x","y","z"];function Ul(t,e,s,i){Ma.setBuffer(t._roots[e]);const n=Vl(0,t,s,i);return Ma.clearBuffer(),n}function Vl(t,e,s,i){const{float32Array:n,uint16Array:r,uint32Array:o}=Ma;let a=2*t;if(xa(a,r)){return function(t,e,s,i,n){const{geometry:r,_indirectBuffer:o}=t;let a=1/0,l=null;for(let t=i,h=i+n;t<h;t++){let i;i=el(r,e,s,o?o[t]:t),i&&i.distance<a&&(l=i,a=i.distance)}return l}(e,s,i,Oa(t,o),va(a,r))}{const r=Na(t,o),a=Dl[r],l=i.direction[a]>=0;let h,c;l?(h=La(t),c=Pa(t,o)):(h=Pa(t,o),c=La(t));const d=ol(h,n,i,Ml)?Vl(h,e,s,i):null;if(d){const t=d.point[a];if(l?t<=n[c+r]:t>=n[c+r+3])return d}const u=ol(c,n,i,Ml)?Vl(c,e,s,i):null;return d&&u?d.distance<=u.distance?d:u:d||u||null}}const Bl=new gt,zl=new Ra,Gl=new Ra,kl=new Ot,Hl=new ya,Yl=new ya;function Wl(t,e,s,i){Ma.setBuffer(t._roots[e]);const n=jl(0,t,s,i);return Ma.clearBuffer(),n}function jl(t,e,s,i,n=null){const{float32Array:r,uint16Array:o,uint32Array:a}=Ma;let l=2*t;null===n&&(s.boundingBox||s.computeBoundingBox(),Hl.set(s.boundingBox.min,s.boundingBox.max,i),n=Hl);if(!xa(l,o)){const o=t+8,l=a[t+6];ia(o,r,Bl);if(n.intersectsBox(Bl)&&jl(o,e,s,i,n))return!0;ia(l,r,Bl);return!!(n.intersectsBox(Bl)&&jl(l,e,s,i,n))}{const n=e.geometry,h=n.index,c=n.attributes.position,d=s.index,u=s.attributes.position,f=Oa(t,a),p=va(l,o);if(kl.copy(i).invert(),s.boundsTree){ia(t,r,Yl),Yl.matrix.copy(kl),Yl.needsUpdate=!0;return s.boundsTree.shapecast({intersectsBounds:t=>Yl.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(i),t.b.applyMatrix4(i),t.c.applyMatrix4(i),t.needsUpdate=!0;for(let s=f,i=p+f;s<i;s++)if(sl(Gl,3*e.resolveTriangleIndex(s),h,c),Gl.needsUpdate=!0,t.intersectsTriangle(Gl))return!0;return!1}})}for(let t=f,s=p+f;t<s;t++){const s=e.resolveTriangleIndex(t);sl(zl,3*s,h,c),zl.a.applyMatrix4(kl),zl.b.applyMatrix4(kl),zl.c.applyMatrix4(kl),zl.needsUpdate=!0;for(let t=0,e=d.count;t<e;t+=3)if(sl(Gl,t,d,u),Gl.needsUpdate=!0,zl.intersectsTriangle(Gl))return!0}}}const ql=new Ot,Zl=new ya,Xl=new ya,$l=new Ct,Kl=new Ct,Ql=new Ct,Jl=new Ct;function th(t,e,s,i={},n={},r=0,o=1/0){e.boundingBox||e.computeBoundingBox(),Zl.set(e.boundingBox.min,e.boundingBox.max,s),Zl.needsUpdate=!0;const a=t.geometry,l=a.attributes.position,h=a.index,c=e.attributes.position,d=e.index,u=wa.getPrimitive(),f=wa.getPrimitive();let p=$l,I=Kl,_=null,m=null;n&&(_=Ql,m=Jl);let E=1/0,g=null,b=null;return ql.copy(s).invert(),Xl.matrix.copy(ql),t.shapecast({boundsTraverseOrder:t=>Zl.distanceToBox(t),intersectsBounds:(t,e,s)=>s<E&&s<o&&(e&&(Xl.min.copy(t.min),Xl.max.copy(t.max),Xl.needsUpdate=!0),!0),intersectsRange:(i,n)=>{if(e.boundsTree){const a=e.boundsTree;return a.shapecast({boundsTraverseOrder:t=>Xl.distanceToBox(t),intersectsBounds:(t,e,s)=>s<E&&s<o,intersectsRange:(e,o)=>{for(let C=e,T=e+o;C<T;C++){const e=a.resolveTriangleIndex(C);sl(f,3*e,d,c),f.a.applyMatrix4(s),f.b.applyMatrix4(s),f.c.applyMatrix4(s),f.needsUpdate=!0;for(let e=i,s=i+n;e<s;e++){const s=t.resolveTriangleIndex(e);sl(u,3*s,h,l),u.needsUpdate=!0;const i=u.distanceToTriangle(f,p,_);if(i<E&&(I.copy(p),m&&m.copy(_),E=i,g=e,b=C),i<r)return!0}}}})}for(let o=0,a=Jo(e);o<a;o++){sl(f,3*o,d,c),f.a.applyMatrix4(s),f.b.applyMatrix4(s),f.c.applyMatrix4(s),f.needsUpdate=!0;for(let e=i,s=i+n;e<s;e++){const s=t.resolveTriangleIndex(e);sl(u,3*s,h,l),u.needsUpdate=!0;const i=u.distanceToTriangle(f,p,_);if(i<E&&(I.copy(p),m&&m.copy(_),E=i,g=e,b=o),i<r)return!0}}}}),wa.releasePrimitive(u),wa.releasePrimitive(f),E===1/0?null:(i.point?i.point.copy(I):i.point=I.clone(),i.distance=E,i.faceIndex=g,n&&(n.point?n.point.copy(m):n.point=m.clone(),n.point.applyMatrix4(ql),I.applyMatrix4(ql),n.distance=I.sub(n.point).length(),n.faceIndex=b),i)}const eh=new Ma.constructor,sh=new Ma.constructor,ih=new Fa((()=>new gt)),nh=new gt,rh=new gt,oh=new gt,ah=new gt;let lh=!1;function hh(t,e,s,i,n,r=0,o=0,a=0,l=0,h=null,c=!1){let d,u;c?(d=sh,u=eh):(d=eh,u=sh);const f=d.float32Array,p=d.uint32Array,I=d.uint16Array,_=u.float32Array,m=u.uint32Array,E=u.uint16Array,g=2*e,b=xa(2*t,I),C=xa(g,E);let T=!1;if(C&&b)T=c?n(Oa(e,m),va(2*e,E),Oa(t,p),va(2*t,I),l,o+e,a,r+t):n(Oa(t,p),va(2*t,I),Oa(e,m),va(2*e,E),a,r+t,l,o+e);else if(C){const h=ih.getPrimitive();ia(e,_,h),h.applyMatrix4(s);const d=La(t),u=Pa(t,p);ia(d,f,nh),ia(u,f,rh);const I=h.intersectsBox(nh),m=h.intersectsBox(rh);T=I&&hh(e,d,i,s,n,o,r,l,a+1,h,!c)||m&&hh(e,u,i,s,n,o,r,l,a+1,h,!c),ih.releasePrimitive(h)}else{const d=La(e),u=Pa(e,m);ia(d,_,oh),ia(u,_,ah);const I=h.intersectsBox(oh),E=h.intersectsBox(ah);if(I&&E)T=hh(t,d,s,i,n,r,o,a,l+1,h,c)||hh(t,u,s,i,n,r,o,a,l+1,h,c);else if(I)if(b)T=hh(t,d,s,i,n,r,o,a,l+1,h,c);else{const e=ih.getPrimitive();e.copy(oh).applyMatrix4(s);const h=La(t),u=Pa(t,p);ia(h,f,nh),ia(u,f,rh);const I=e.intersectsBox(nh),_=e.intersectsBox(rh);T=I&&hh(d,h,i,s,n,o,r,l,a+1,e,!c)||_&&hh(d,u,i,s,n,o,r,l,a+1,e,!c),ih.releasePrimitive(e)}else if(E)if(b)T=hh(t,u,s,i,n,r,o,a,l+1,h,c);else{const e=ih.getPrimitive();e.copy(ah).applyMatrix4(s);const h=La(t),d=Pa(t,p);ia(h,f,nh),ia(d,f,rh);const I=e.intersectsBox(nh),_=e.intersectsBox(rh);T=I&&hh(u,h,i,s,n,o,r,l,a+1,e,!c)||_&&hh(u,d,i,s,n,o,r,l,a+1,e,!c),ih.releasePrimitive(e)}}return T}const ch=new ya,dh=new gt;class uh{static serialize(t,e={}){e={cloneBuffers:!0,...e};const s=t.geometry,i=t._roots,n=t._indirectBuffer,r=s.getIndex();let o;return o=e.cloneBuffers?{roots:i.map((t=>t.slice())),index:r.array.slice(),indirectBuffer:n?n.slice():null}:{roots:i,index:r.array,indirectBuffer:n},o}static deserialize(t,e,s={}){s={setIndex:!0,indirect:Boolean(t.indirectBuffer),...s};const{index:i,roots:n,indirectBuffer:r}=t,o=new uh(e,{...s,[Qo]:!0});if(o._roots=n,o._indirectBuffer=r||null,s.setIndex){const s=e.getIndex();if(null===s){const s=new Lt(t.index,1,!1);e.setIndex(s)}else s.array!==i&&(s.array.set(i),s.needsUpdate=!0)}return o}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign({strategy:0,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[Qo]:!1},e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[Qo]||(Ea(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new gt)));const{_indirectBuffer:s}=this;this.resolveTriangleIndex=e.indirect?t=>s[t]:t=>t}refit(t=null){return(this.indirect?vl:nl)(this,t)}traverse(t,e=0){const s=this._roots[e],i=new Uint32Array(s),n=new Uint16Array(s);!function e(r,o=0){const a=2*r,l=n[a+15]===$o;if(l){const e=i[r+6],h=n[a+14];t(o,l,new Float32Array(s,4*r,6),e,h)}else{const n=r+8,a=i[r+6],h=i[r+7];t(o,l,new Float32Array(s,4*r,6),h)||(e(n,o+1),e(a,o+1))}}(0)}raycast(t,e=Ut){const s=this._roots,i=this.geometry,n=[],r=e.isMaterial,o=Array.isArray(e),a=i.groups,l=r?e.side:e,h=this.indirect?Pl:hl;for(let i=0,r=s.length;i<r;i++){const s=o?e[a[i].materialIndex].side:l,r=n.length;if(h(this,i,s,t,n),o){const t=a[i].materialIndex;for(let e=r,s=n.length;e<s;e++)n[e].face.materialIndex=t}}return n}raycastFirst(t,e=Ut){const s=this._roots,i=this.geometry,n=e.isMaterial,r=Array.isArray(e);let o=null;const a=i.groups,l=n?e.side:e,h=this.indirect?Ul:fl;for(let i=0,n=s.length;i<n;i++){const s=h(this,i,r?e[a[i].materialIndex].side:l,t);null!=s&&(null==o||s.distance<o.distance)&&(o=s,r&&(s.face.materialIndex=a[i].materialIndex))}return o}intersectsGeometry(t,e){let s=!1;const i=this._roots,n=this.indirect?Wl:Cl;for(let r=0,o=i.length;r<o&&(s=n(this,r,t,e),!s);r++);return s}shapecast(t){const e=wa.getPrimitive(),s=this.indirect?al:il;let{boundsTraverseOrder:i,intersectsBounds:n,intersectsRange:r,intersectsTriangle:o}=t;if(r&&o){const t=r;r=(i,n,r,a,l)=>!!t(i,n,r,a,l)||s(i,n,this,o,r,a,e)}else r||(r=o?(t,i,n,r)=>s(t,i,this,o,n,r,e):(t,e,s)=>s);let a=!1,l=0;const h=this._roots;for(let t=0,e=h.length;t<e;t++){const e=h[t];if(a=za(this,t,n,r,i,l),a)break;l+=e.byteLength}return wa.releasePrimitive(e),a}bvhcast(t,e,s){let{intersectsRanges:i,intersectsTriangles:n}=s;const r=wa.getPrimitive(),o=this.geometry.index,a=this.geometry.attributes.position,l=this.indirect?t=>{const e=this.resolveTriangleIndex(t);sl(r,3*e,o,a)}:t=>{sl(r,3*t,o,a)},h=wa.getPrimitive(),c=t.geometry.index,d=t.geometry.attributes.position,u=t.indirect?e=>{const s=t.resolveTriangleIndex(e);sl(h,3*s,c,d)}:t=>{sl(h,3*t,c,d)};if(n){const t=(t,s,i,o,a,c,d,f)=>{for(let p=i,I=i+o;p<I;p++){u(p),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let e=t,i=t+s;e<i;e++)if(l(e),r.needsUpdate=!0,n(r,h,e,p,a,c,d,f))return!0}return!1};if(i){const e=i;i=function(s,i,n,r,o,a,l,h){return!!e(s,i,n,r,o,a,l,h)||t(s,i,n,r,o,a,l,h)}}else i=t}return function(t,e,s,i){if(lh)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");lh=!0;const n=t._roots,r=e._roots;let o,a=0,l=0;const h=(new Ot).copy(s).invert();for(let t=0,e=n.length;t<e;t++){eh.setBuffer(n[t]),l=0;const e=ih.getPrimitive();ia(0,eh.float32Array,e),e.applyMatrix4(h);for(let n=0,c=r.length;n<c&&(sh.setBuffer(r[t]),o=hh(0,0,s,h,i,a,l,0,0,e),sh.clearBuffer(),l+=r[n].length,!o);n++);if(ih.releasePrimitive(e),eh.clearBuffer(),a+=n[t].length,o)break}return lh=!1,o}(this,t,e,i)}intersectsBox(t,e){return ch.set(t.min,t.max,e),ch.needsUpdate=!0,this.shapecast({intersectsBounds:t=>ch.intersectsBox(t),intersectsTriangle:t=>ch.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},i={},n=0,r=1/0){return(this.indirect?th:Ol)(this,t,e,s,i,n,r)}closestPointToPoint(t,e={},s=0,i=1/0){return function(t,e,s={},i=0,n=1/0){const r=i*i,o=n*n;let a=1/0,l=null;if(t.shapecast({boundsTraverseOrder:t=>(ka.copy(e).clamp(t.min,t.max),ka.distanceToSquared(e)),intersectsBounds:(t,e,s)=>s<a&&s<o,intersectsTriangle:(t,s)=>{t.closestPointToPoint(e,ka);const i=e.distanceToSquared(ka);return i<a&&(Ha.copy(ka),a=i,l=s),i<r}}),a===1/0)return null;const h=Math.sqrt(a);return s.point?s.point.copy(Ha):s.point=Ha.clone(),s.distance=h,s.faceIndex=l,s}(this,t,e,s,i)}getBoundingBox(t){t.makeEmpty();return this._roots.forEach((e=>{ia(0,new Float32Array(e),dh),t.union(dh)})),t}}function fh(t,e,s){return null===t?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(s.ray.origin),t.object=e,t.distance<s.near||t.distance>s.far?null:t)}const ph=new Vt,Ih=new Ot,_h=St.prototype.raycast;function mh(t,e){if(this.geometry.boundsTree){if(void 0===this.material)return;Ih.copy(this.matrixWorld).invert(),ph.copy(t.ray).applyMatrix4(Ih);const s=this.geometry.boundsTree;if(!0===t.firstHitOnly){const i=fh(s.raycastFirst(ph,this.material),this,t);i&&e.push(i)}else{const i=s.raycast(ph,this.material);for(let s=0,n=i.length;s<n;s++){const n=fh(i[s],this,t);n&&e.push(n)}}}else _h.call(this,t,e)}function Eh(t){return this.boundsTree=new uh(this,t),this.boundsTree}function gh(){this.boundsTree=null}class bh{constructor(t,e){ot(this,"meshes"),ot(this,"_templateController",new kc),ot(this,"_meshIds",new Set),ot(this,"_idGenerator",new gs),ot(this,"_modelCode"),this.meshes=e,this._modelCode=this.getModelCode(t)}dispose(){Mc.delete(this._meshIds)}useMesh(t,e,s){const i=this.meshCode(t,s);Mc.lockIn(e),this._templateController.add(i,e)}getMesh(t,e){const s=this.meshCode(t,e);return Mc.get(s)??this._templateController.get(s)}saveMesh(t,e,s){Ts.forEach(e,Mc.updateMeshMemory);const i=this.meshCode(t,s);Mc.add(i,e),this._meshIds.add(i)}meshCode(t,e){const s=[this._modelCode,this.getRepresentation(),e,t];return this._idGenerator.generate(s)}getModelCode(t){return this._idGenerator.generate([t])}}const Ch=32767;var Th=(t=>(t[t.NONE=0]="NONE",t[t.AABB=1]="AABB",t[t.CUSTOM=2]="CUSTOM",t))(Th||{});const Ah=class t{static getProfile(t,e,s){return t.type()===ye.BIG?t.bigProfiles(e,s):t.profiles(e,s)}static getPoints(t){const e=new Float32Array(3*t.pointsLength());for(let s=0;s<t.pointsLength();s++)t.points(s,this._tempPoint),e[3*s]=this._tempPoint.x(),e[3*s+1]=this._tempPoint.y(),e[3*s+2]=this._tempPoint.z();return e}static getProfileIndices(e,s){const i=e.type()===ye.BIG,n={outer:[],inners:[]},r=i?e.bigHolesLength():e.holesLength(),o=i?"bigHoles":"holes",a=t.getProfile(e,s);n.outer=Array.from(a.indicesArray());for(let t=0;t<r;t++){const i=e[o](t);if(i.profileId()===s){const t=Array.from(i.indicesArray());n.inners.push(t)}}return n}static getHole(t,e,s){return t.type()===ye.BIG?t.bigHoles(e,s):t.holes(e,s)}static getProfilesLength(t){return t.type()===ye.BIG?t.bigProfilesLength():t.profilesLength()}static getHolesLength(t){return t.type()===ye.BIG?t.bigHolesLength():t.holesLength()}static getShell(t,e){return t.shells(e,this._shell)}static point(t,e,s){t instanceof Fe&&t.points(e,this._tempPoint);const i=this._tempPoint.x(),n=this._tempPoint.y(),r=this._tempPoint.z();s.set(i,n,r)}static getNormalsOfShellProfile(e,s){const i=t.getProfilesLength(e);for(let n=0;n<i;n++){const i=t.getProfile(e,n),r=this.fetchNormalsOfProfile(e,i);s.push(r)}return s}static computeNormalsAvg(t,e,s,i){this.setupNormalBuffer(t);const n=s[e];for(let e=0;e<t.length;e++){const r=t[e],o=i.get(r);this.aggregateNormals(o,s,n),this.computeAvgNormal(e)}return this._normalBuffer}static getBuffer(t){const e=t.bb,s=e.__offset(t.bb_pos,8),i=3*t.pointsLength(),n=e.__vector(t.bb_pos+s),r=e.bytes().buffer;return new Float32Array(r,n,i)}static getPointsShell(e){return this._pointsByProfile.clear(),this.fetchAllPointsByProfile(e),t.fetchAllPointsByHole(e),this._pointsByProfile}static addNormals(t,e,s){for(const i of t){const t=e[i];s.dot(t)>this._faceThreshold&&this._tempNormal.add(t)}}static setupNormalBuffer(t){const e=3*t.length;this._normalBuffer.length<e&&(this._normalBuffer=new Int16Array(e))}static fetchNormalsOfProfile(t,e){const s=e.indicesLength();return this.isTooSmall(t,s)?new ft.Vector3(1,0,0):this.computeProfileNormal(s,e,t)}static fetchAllPointsByHole(e){const s=t.getHolesLength(e),i=this.getTempHole(e);for(let n=0;n<s;n++){t.getHole(e,n,i);const s=i.profileId(),r=i.indicesLength();for(let e=0;e<r;e++){const n=i.indices(e);t.savePointByProfile(n,s)}}}static computeProfileNormal(t,e,s){this._v3.set(0,0,0);for(let i=0;i<t;i++)this.fetchPointsForNormal(i,t,e,s),this.computeProfilePointNormal();const i=this._v3.clone();return i.normalize(),i}static computeProfilePointNormal(){const t=this._v1.x-this._v2.x,e=this._v1.y-this._v2.y,s=this._v1.z-this._v2.z,i=this._v1.x+this._v2.x,n=this._v1.y+this._v2.y,r=this._v1.z+this._v2.z;this._v3.x+=e*r,this._v3.y+=s*i,this._v3.z+=t*n}static aggregateNormals(e,s,i){this._tempNormal.set(0,0,0);if(!e||!e.length)return void this._tempNormal.set(1,0,0);if(1===e.length){const t=e[0];this._tempNormal=s[t].clone()}else t.addNormals(e,s,i)}static fetchPointsForNormal(t,e,s,i){const n=(t+1)%e,r=s.indices(t),o=s.indices(n);this.point(i,r,this._v1),this.point(i,o,this._v2)}static savePointByProfile(t,e){this._pointsByProfile.has(t)||this._pointsByProfile.set(t,[]),this._pointsByProfile.get(t).push(e)}static isTooSmall(t,e){return t.pointsLength()<=2||e<=2}static fetchAllPointsByProfile(e){const s=this.getProfilesLength(e),i=this.getTempProfile(e);for(let n=0;n<s;n++){t.getProfile(e,n,i);const s=i.indicesLength();for(let e=0;e<s;e++){const s=i.indices(e);t.savePointByProfile(s,n)}}}static computeAvgNormal(t){this._tempNormal.normalize(),this._tempNormal.multiplyScalar(Ch),this._tempNormal.toArray(this._normalBuffer,3*t)}static getTempProfile(t){return t.type()===ye.BIG?this._bigShellProfile:this._shellProfile}static getTempHole(t){return t.type()===ye.BIG?this._bigShellHole:this._shellHole}};ot(Ah,"_faceThreshold",Math.cos(Math.PI/8)),ot(Ah,"_shell",new Fe),ot(Ah,"_normalBuffer",new Int16Array),ot(Ah,"_tempNormal",new ft.Vector3),ot(Ah,"_tempPoint",new se),ot(Ah,"_shellProfile",new Re),ot(Ah,"_bigShellProfile",new he),ot(Ah,"_shellHole",new Ae),ot(Ah,"_bigShellHole",new le),ot(Ah,"_pointsByProfile",new Map),ot(Ah,"_v1",new ft.Vector3),ot(Ah,"_v2",new ft.Vector3),ot(Ah,"_v3",new ft.Vector3);let Rh=Ah;class yh{constructor(){ot(this,"_shellHole",new Ae),ot(this,"_bigShellHole",new le),ot(this,"holePoints",0),ot(this,"profilePoints",0),ot(this,"triangleAmount",0),ot(this,"indexCount",0),ot(this,"meshes",[]),ot(this,"_shellProfile",new Re),ot(this,"_bigShellProfile",new he)}newMeshTemplate(t){return this.getIsEmpty(t)?{objectClass:Me.SHELL}:(this.reset(!0),this.processShell(t),this.getResult())}manageDataLeft(){this.getIsDataLeft()&&this.setMesh()}getIsEmpty(t){return 0===Rh.getProfilesLength(t)}processShellHoles(t,e){let s=!1;const i=Rh.getHolesLength(t),n=this.getTempHole(t);for(let r=0;r<i;r++){Rh.getHole(t,r,n);n.profileId()===e&&(this.updateBuffers(t,s),s=!0)}this.manageFoundHoles(t,s)}newMesh(){return{objectClass:Me.SHELL,indexCount:3*this.triangleAmount,positionCount:3*(this.holePoints+this.profilePoints),normalCount:3*(this.holePoints+this.profilePoints)}}reset(t){this.holePoints=0,this.profilePoints=0,this.triangleAmount=0,t&&(this.meshes=void 0)}getIsDataLeft(){const t=this.triangleAmount>0,e=this.holePoints>0,s=this.profilePoints>0;return t||e||s}processShell(t){const e=Rh.getProfilesLength(t),s=this.getTempProfile(t);for(let i=0;i<e;i++)Rh.getProfile(t,i,s),this.indexCount=s.indicesLength(),this.profilePoints+=this.indexCount,this.processShellHoles(t,i),this.manageMemory();this.manageDataLeft()}manageFoundHoles(t,e){const s=this.getTempProfile(t).indicesLength();e?this.triangleAmount+=s:s>2&&(this.triangleAmount+=s-2)}getResult(){const t=this.meshes;return this.meshes=void 0,t}manageMemory(){this.holePoints+this.profilePoints+this.indexCount>Ne&&this.setMesh()}updateBuffers(t,e){const s=this.getTempHole(t);this.holePoints+=s.indicesLength(),this.triangleAmount+=s.indicesLength(),e&&(this.triangleAmount+=2)}setMesh(){const t=this.newMesh();this.meshes?Array.isArray(this.meshes)?this.meshes.push(t):this.meshes=[this.meshes,t]:this.meshes=t,this.reset(!1)}getTempProfile(t){return t.type()===ye.BIG?this._bigShellProfile:this._shellProfile}getTempHole(t){return t.type()===ye.BIG?this._bigShellHole:this._shellHole}}var Fh=(t=>(t[t.four=4]="four",t[t.three=3]="three",t))(Fh||{});function Sh(t,e,s,i,n,r){const o=e&&e.length,a=o?e[0]*s:t.length;let l,h,c,d=wh(t,0,a,s,!0,i,n);if(d&&d.next!==d.prev){if(o&&(d=function(t,e,s,i,n,r){const o=[];for(let s=0,a=e.length;s<a;s++){const l=wh(t,e[s]*i,s<a-1?e[s+1]*i:t.length,i,!1,n,r);l===l.next&&(l.steiner=!0),o.push(Bh(l))}o.sort(Mh);for(let t=0;t<o.length;t++)s=xh(s=Dh(o[t],s),s.next);return s}(t,e,d,s,i,n)),t.length>80*s){let e=t[i],r=t[n];l=e,h=r;for(let o=s;o<a;o+=s){const s=t[o+i],a=t[o+n];s<l&&(l=s),a<h&&(h=a),s>e&&(e=s),a>r&&(r=a)}c=Math.max(e-l,r-h),c=0!==c?1/c:0}Oh(d,r,s,l,h,c)}}function wh(t,e,s,i,n,r,o){let a,l,h;if(n===function(t,e,s,i,n,r){let o=0;for(let a=e,l=s-i;a<s;a+=i)o+=(t[l+n]-t[a+n])*(t[a+r]+t[l+r]),l=a;return o}(t,e,s,i,r,o)>0)for(h=e;h<s;h+=i)a=Xh(h,t[h+r],t[h+o],a);else for(h=s-i;h>=e;h-=i)a=Xh(h,t[h+r],t[h+o],a);return a&&Hh(a,a.next)&&(l=a.next,$h(a),a=l),a}function xh(t,e){if(!t)return t;e||(e=t);let s,i,n=t;do{if(s=!1,n.steiner||!Hh(n,n.next)&&0!==kh(n.prev,n,n.next))n=n.next;else{if(i=n.prev,$h(n),n=e=i,n===n.next)break;s=!0}}while(s||n!==e);return e}function Oh(t,e,s,i,n,r,o){!o&&r&&function(t,e,s,i){let n=t;do{null===n.z&&(n.z=Vh(n.x,n.y,e,s,i)),n.prevZ=n.prev,n.nextZ=n.next,n=n.next}while(n!==t);n.prevZ.nextZ=null,n.prevZ=null,function(t){let e,s=1;do{let i,n=t;t=null;let r=null;for(e=0;n;){e++;let o=n,a=0;for(let t=0;t<s&&(a++,o=o.nextZ,o);t++);let l=s;for(;a>0||l>0&&o;)0!==a&&(0===l||!o||n.z<=o.z)?(i=n,n=n.nextZ,a--):(i=o,o=o.nextZ,l--),r?r.nextZ=i:t=i,i.prevZ=r,r=i;n=o}r.nextZ=null,s*=2}while(e>1)}(n)}(t,i,n,r);let a=t;for(;t.prev!==t.next;){const l=t.prev,h=t.next;if(r?Lh(t,i,n,r):vh(t))e(l.i/s,t.i/s,h.i/s),$h(t),t=h.next,a=h.next;else if((t=h)===a){o?1===o?Oh(t=Ph(xh(t),e,s),e,s,i,n,r,2):2===o&&Nh(t,e,s,i,n,r):Oh(xh(t),e,s,i,n,r,1);break}}}function vh(t){const e=t.prev,s=t,i=t.next;if(kh(e,s,i)>=0)return!1;let n=t.next.next;for(;n!==t.prev;){if(zh(e.x,e.y,s.x,s.y,i.x,i.y,n.x,n.y)&&kh(n.prev,n,n.next)>=0)return!1;n=n.next}return!0}function Lh(t,e,s,i){const n=t.prev,r=t,o=t.next;if(kh(n,r,o)>=0)return!1;const a=Math.min(n.x,r.x,o.x),l=Math.min(n.y,r.y,o.y),h=Math.max(n.x,r.x,o.x),c=Math.max(n.y,r.y,o.y),d=Vh(a,l,e,s,i),u=Vh(h,c,e,s,i);let f=t.prevZ,p=t.nextZ;for(;f&&f.z>=d&&p&&p.z<=u;){if(f!==t.prev&&f!==t.next&&zh(n.x,n.y,r.x,r.y,o.x,o.y,f.x,f.y)&&kh(f.prev,f,f.next)>=0)return!1;if(f=f.prevZ,p!==t.prev&&p!==t.next&&zh(n.x,n.y,r.x,r.y,o.x,o.y,p.x,p.y)&&kh(p.prev,p,p.next)>=0)return!1;p=p.nextZ}for(;f&&f.z>=d;){if(f!==t.prev&&f!==t.next&&zh(n.x,n.y,r.x,r.y,o.x,o.y,f.x,f.y)&&kh(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;p&&p.z<=u;){if(p!==t.prev&&p!==t.next&&zh(n.x,n.y,r.x,r.y,o.x,o.y,p.x,p.y)&&kh(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}function Ph(t,e,s){let i=t;do{const n=i.prev,r=i.next.next;!Hh(n,r)&&Yh(n,i,i.next,r)&&qh(n,r)&&qh(r,n)&&(e(n.i/s,i.i/s,r.i/s),$h(i.next),$h(i),i=t=r),i=i.next}while(i!==t);return xh(i)}function Nh(t,e,s,i,n,r){let o=t;do{let t=o.next.next;for(;t!==o.prev;){if(o.i!==t.i&&Gh(o,t)){let a=Zh(o,t);return o=xh(o,o.next),a=xh(a,a.next),Oh(o,e,s,i,n,r),void Oh(a,e,s,i,n,r)}t=t.next}o=o.next}while(o!==t)}function Mh(t,e){return t.x-e.x}function Dh(t,e){const s=function(t,e){let s=e;const i=t.x,n=t.y;let r,o=-1/0;do{if(n<=s.y&&n>=s.next.y&&s.next.y!==s.y){const t=s.x+(n-s.y)*(s.next.x-s.x)/(s.next.y-s.y);if(t<=i&&t>o){if(o=t,t===i){if(n===s.y)return s;if(n===s.next.y)return s.next}r=s.x<s.next.x?s:s.next}}s=s.next}while(s!==e);if(!r)return null;if(i===o)return r;const a=r,l=r.x,h=r.y;let c=1/0;s=r;do{if(i>=s.x&&s.x>=l&&i!==s.x&&zh(n<h?i:o,n,l,h,n<h?o:i,n,s.x,s.y)){const e=Math.abs(n-s.y)/(i-s.x);qh(s,t)&&(e<c||e===c&&(s.x>r.x||s.x===r.x&&Uh(r,s)))&&(r=s,c=e)}s=s.next}while(s!==a);return r}(t,e);if(!s)return e;const i=Zh(s,t),n=xh(s,s.next);return xh(i,i.next),e===e.next||s===e?n:e}function Uh(t,e){return kh(t.prev,t,e.prev)<0&&kh(e.next,t,t.next)<0}function Vh(t,e,s,i,n){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-s)*n)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-i)*n)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function Bh(t){let e=t,s=t;do{(e.x<s.x||e.x===s.x&&e.y<s.y)&&(s=e),e=e.next}while(e!==t);return s}function zh(t,e,s,i,n,r,o,a){return(n-o)*(e-a)-(t-o)*(r-a)>=0&&(t-o)*(i-a)-(s-o)*(e-a)>=0&&(s-o)*(r-a)-(n-o)*(i-a)>=0}function Gh(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let s=t;do{if(s.i!==t.i&&s.next.i!==t.i&&s.i!==e.i&&s.next.i!==e.i&&Yh(s,s.next,t,e))return!0;s=s.next}while(s!==t);return!1}(t,e)&&(qh(t,e)&&qh(e,t)&&function(t,e){let s=t,i=!1;const n=(t.x+e.x)/2,r=(t.y+e.y)/2;do{s.y>r!=s.next.y>r&&s.next.y!==s.y&&n<(s.next.x-s.x)*(r-s.y)/(s.next.y-s.y)+s.x&&(i=!i),s=s.next}while(s!==t);return i}(t,e)&&(kh(t.prev,t,e.prev)||kh(t,e.prev,e))||Hh(t,e)&&kh(t.prev,t,t.next)>0&&kh(e.prev,e,e.next)>0)}function kh(t,e,s){return(e.y-t.y)*(s.x-e.x)-(e.x-t.x)*(s.y-e.y)}function Hh(t,e){return t.x===e.x&&t.y===e.y}function Yh(t,e,s,i){const n=jh(kh(t,e,s)),r=jh(kh(t,e,i)),o=jh(kh(s,i,t)),a=jh(kh(s,i,e));return n!==r&&o!==a||(!(0!==n||!Wh(t,s,e))||(!(0!==r||!Wh(t,i,e))||(!(0!==o||!Wh(s,t,i))||!(0!==a||!Wh(s,e,i)))))}function Wh(t,e,s){return e.x<=Math.max(t.x,s.x)&&e.x>=Math.min(t.x,s.x)&&e.y<=Math.max(t.y,s.y)&&e.y>=Math.min(t.y,s.y)}function jh(t){return t>0?1:t<0?-1:0}function qh(t,e){return kh(t.prev,t,t.next)<0?kh(t,e,t.next)>=0&&kh(t,t.prev,e)>=0:kh(t,e,t.prev)<0||kh(t,t.next,e)<0}function Zh(t,e){const s=Kh(t.i,t.x,t.y),i=Kh(e.i,e.x,e.y),n=t.next,r=e.prev;return t.next=e,e.prev=t,s.next=n,n.prev=s,i.next=s,s.prev=i,r.next=i,i.prev=r,i}function Xh(t,e,s,i){const n=Kh(t,e,s);return i?(n.next=i.next,n.prev=i,i.next.prev=n,i.next=n):(n.prev=n,n.next=n),n}function $h(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ),t.next=t,t.prev=t}function Kh(t,e,s){return{i:t,x:e,y:s,prev:null,next:null,z:null,prevZ:null,nextZ:null,steiner:!1}}const Qh=class t{static create(e,s,i,n,r,o,a,l){const h=e.length,c=a.verticesAmount;t.processBuffers(h,e,r,a,s,i);const d=r.positionBuffer,u=(a.verticesAmount-c)/3;this.processNormals(d,this._tempVec,u,c),this.triangulate(o,n,h,r,a,c),this.setFaceId(c,a,r,l)}static setFaceId(t,e,s,i){const n=t/3,r=e.verticesAmount/3;for(let t=n;t<r;t++)s.faceIdBuffer[t]=i}static getVertices(t,e,s){const i=t.positionBuffer.buffer,n=4*e,r=s.verticesAmount-e;return new Float32Array(i,n,r)}static getEvent(t,e,s){return(i,n,r)=>{const o=t.indexBuffer;o[e.indices++]=i+s/3,o[e.indices++]=n+s/3,o[e.indices++]=r+s/3}}static processBuffers(t,e,s,i,n,r){for(let o=0;o<t;o++)this.processPositionBuffer(s,e,o,i,n),this.processNormalbuffer(s,r,o,i),this.updateBufferData(i)}static getHoles(t,e,s,i,n){if(!t)return;if(t.has(e)){const r=t.get(e),o=[];for(const t of r.indices)o.push(t+s);return this.setHolesBuffers(i,r,n),o}}static setHolesBuffers(t,e,s){const i=t.positionBuffer,n=t.normalBuffer;i.set(e.points,s.verticesAmount);const r=e.points.length;s.verticesAmount+=r,s.vertices+=r/3,n.set(e.normals,s.normalsAmount),s.normalsAmount+=r}static updateBufferData(t){t.vertices+=1,t.verticesAmount+=3,t.normalsAmount+=3}static processPositionBuffer(t,e,s,i,n){const r=t.positionBuffer;for(let t=0;t<3;t++){const o=3*e[s];r[i.verticesAmount+t]=n[o+t]}}static triangulate(e,s,i,n,r,o){const a=this.getHoles(e,s,i,n,r),l=t.getVertices(n,o,r),h=xs.getEarcutDimensions(this._tempVec),c=this.getEvent(n,r,o);Sh(l,a,3,h[0],h[1],c)}static processNormals(t,e,s,i=0){e.set(0,0,0);for(let n=0;n<s;n++){const r=i+3*n,o=i+3*((n+1)%s),a=t[r+0],l=t[o+0],h=t[r+1],c=t[o+1],d=t[r+2],u=t[o+2];e.x+=(h-c)*(d+u),e.y+=(d-u)*(a+l),e.z+=(a-l)*(h+c)}e.normalize()}static processNormalbuffer(t,e,s,i){const n=t.normalBuffer,r=3*s,o=e[r],a=e[r+1],l=e[r+2];n.set([o,a,l],i.normalsAmount)}};ot(Qh,"_tempVec",new ft.Vector3);let Jh=Qh;const tc=class{static create(t,e,s,i,n,r,o){this.setAllVectors(t,e);this.getIsConvex()?this.processConvexFace4(n,r,s,o):Jh.create(t,e,s,i,n,void 0,r,o)}static setAllVectors(t,e){this.setVector(t,e,this.a,0),this.setVector(t,e,this.b,1),this.setVector(t,e,this.c,2),this.setVector(t,e,this.d,3),this.getCrossVectors()}static processConvexFace4(t,e,s,i){this.processIndices(t,e),this.processPoints(t,e),this.processNormal(t,e,s),this.setFaceId(t,e,i),this.updateData(e)}static setFaceId(t,e,s){const i=t.faceIdBuffer;for(let t=e.vertices;t<e.vertices+4;t++)i[t]=s}static getIsConvex(){return this.h.dot(this.i)>0}static getCrossVectors(){this.e.copy(this.b),this.f.copy(this.c),this.g.copy(this.d),this.e.sub(this.a),this.f.sub(this.a),this.g.sub(this.a),this.h.crossVectors(this.e,this.f),this.i.crossVectors(this.f,this.g)}static updateData(t){t.normalsAmount+=this.totalIncrease,t.vertices+=this.vertexIncrease,t.verticesAmount+=this.totalIncrease}static processPoints(t,e){let s=0;const i=t.positionBuffer,n=e.verticesAmount;for(let t=0;t<this.vertexIncrease;t++){const e=this._vecs[t];i[n+s++]=e.x,i[n+s++]=e.y,i[n+s++]=e.z}}static setVector(t,e,s,i){const n=3*t[i],r=e[n],o=e[n+1],a=e[n+2];s.set(r,o,a)}static processNormal(t,e,s){const i=t.normalBuffer,n=e.normalsAmount;for(let t=0;t<this.totalIncrease;t++)i[n+t]=s[t]}static processIndices(t,e){const s=t.indexBuffer;for(let t=0;t<this.indexIncrease;t++){const i=this._convexIndices[t];s[e.indices+t]=e.vertices+i}e.indices+=this.indexIncrease}};ot(tc,"a",new ft.Vector3),ot(tc,"b",new ft.Vector3),ot(tc,"c",new ft.Vector3),ot(tc,"d",new ft.Vector3),ot(tc,"e",new ft.Vector3),ot(tc,"f",new ft.Vector3),ot(tc,"g",new ft.Vector3),ot(tc,"h",new ft.Vector3),ot(tc,"i",new ft.Vector3),ot(tc,"_vecs",[tc.a,tc.b,tc.c,tc.d]),ot(tc,"_convexIndices",[0,1,3,3,1,2]),ot(tc,"totalIncrease",12),ot(tc,"indexIncrease",6),ot(tc,"vertexIncrease",4);let ec=tc;const sc=class t{static create(t,e,s,i,n,r){this.setFaceIds(n,i,r),this.setIndices(i,n),this.setPoints(t,i,n,e),this.setNormals(i,n,s),this.updateData(n)}static setFaceIds(t,e,s){const i=t.verticesAmount/3,n=i+3;for(let t=i;t<n;t++)e.faceIdBuffer[t]=s}static setNormals(t,e,s){const i=t.normalBuffer;for(let t=0;t<this.totalIncrease;t++)i[e.normalsAmount+t]=s[t]}static setPoints(t,e,s,i){let n=0;const r=e.positionBuffer;for(let e=0;e<this.vertexIncrease;e++){const o=t[e]*this.vertexIncrease;for(let t=0;t<this.vertexIncrease;t++)r[s.verticesAmount+n]=i[o+t],n++}}static setIndices(t,e){const s=t.indexBuffer;for(let t=0;t<this.vertexIncrease;t++)s[e.indices+t]=e.vertices+t;e.indices+=this.vertexIncrease}static updateData(e){e.normalsAmount+=t.totalIncrease,e.vertices+=t.vertexIncrease,e.verticesAmount+=t.totalIncrease}};ot(sc,"vertexIncrease",3),ot(sc,"totalIncrease",9);let ic=sc;class nc{constructor(){ot(this,"point",new se),ot(this,"_shellHole",new Ae),ot(this,"_bigShellHole",new le),ot(this,"interiorProfiles",new Map),ot(this,"normalsAvgInterior",new Int16Array),ot(this,"_pointsPerProfile",new Map),ot(this,"_shellProfile",new Re),ot(this,"_bigShellProfile",new he),ot(this,"_normalsAvg",new Int16Array),ot(this,"_normals",[]),ot(this,"_indices",0),ot(this,"_sizes",{vertices:0,indices:0,verticesAmount:0,normalsAmount:0,normals:0}),ot(this,"_tileData"),ot(this,"_nextFaceId",1),ot(this,"nextBuffer",(t=>{this.setTileData(t),this.initializeIndices(),this.initializePositions(),this.initializeNormals(),this.initializeFaceIds(),this.initializeSizes(),this._indices++}))}construct(t,e){this.resetConstructData(e),this.getPointsPerWire(t);const s=Rh.getBuffer(t);this.newShellInteriorProfiles(t),this.constructShell(t,s,e),this._tileData=void 0}getIntProfileNormalsAvg(t,e){const s=this.getTempHole(t).indicesArray();this.normalsAvgInterior=Rh.computeNormalsAvg(s,e,this._normals,this._pointsPerProfile)}saveInteriorProfile(t){const e=this.getTempHole(t).profileId();if(this.interiorProfiles.has(e))return this.saveExistingInteriorProfile(e),e;const s=this.getNewIntProfileData();return this.interiorProfiles.set(e,s),e}computeNormalsAvg(t,e,s){if(!this.isShell(t))return;const i=this._normals,n=this._pointsPerProfile;this._normalsAvg=Rh.computeNormalsAvg(e,s,i,n)}isShell(t){return t instanceof Fe}getPointsPerWire(t){this.isShell(t)&&(Rh.getNormalsOfShellProfile(t,this._normals),this._pointsPerProfile=Rh.getPointsShell(t))}getIndices(t,e){const s=this.getTempProfile(t);return Rh.getProfile(t,e,s),s.indicesArray()}resetConstructData(t){this._indices=0,this._tileData=void 0,this.nextBuffer(t),this._normals.length=0}initializeIndices(){const t=this._tileData.indexCount;this._tileData.indexBuffer=new Uint16Array(t)}constructFace4(t,e,s){const i=this.getNextFaceId();ec.create(t,e,this._normalsAvg,s,this._tileData,this._sizes,i)}initializeSizes(){this._sizes.vertices=0,this._sizes.indices=0,this._sizes.verticesAmount=0,this._sizes.normalsAmount=0,this._sizes.normals=0}getInteriorProfileBuffer(t,e){const s=this.getTempHole(t).indicesLength();if(this.isShell(t))for(let i=0;i<s;i++)this.getIntProfilePoints(i,t,e),this.getIntProfileNormals(e,i)}constructProfile(t,e,s,i){const n=this.getTempProfile(e).indicesLength(),r=!this.interiorProfiles.has(t);if(n===Fh.three&&r)return void this.constructFace3(s,i);n===Fh.four&&r?this.constructFace4(s,i,t):this.constructFaceX(s,i,t)}getIntProfileNormals(t,e){const s=3*e,i=this.normalsAvgInterior[s],n=this.normalsAvgInterior[s+1],r=this.normalsAvgInterior[s+2];t.normals.push(i,n,r)}saveExistingInteriorProfile(t){const e=this.interiorProfiles.get(t),s=e.points.length/3;e.indices.push(s),this.interiorProfiles.set(t,e)}getNewIntProfileData(){return{indices:[0],points:[],normals:[]}}constructFace3(t,e){const s=this.getNextFaceId();ic.create(t,e,this._normalsAvg,this._tileData,this._sizes,s)}getIntProfilePoints(t,e,s){const i=this.getTempHole(e).indices(t);e.points(i,this.point);const n=this.point.x(),r=this.point.y(),o=this.point.z();s.points.push(n,r,o)}manageMemory(t,e){const s=this.getTempProfile(t).indicesLength();this._sizes.verticesAmount/3+s>Ne&&this.nextBuffer(e)}initializeFaceIds(){const t=this._tileData.positionCount;this._tileData.faceIdBuffer=new Uint32Array(t/3)}getNextFaceId(){return this._nextFaceId++}newShellInteriorProfiles(t){this.interiorProfiles.clear();const e=Rh.getHolesLength(t),s=this.getTempHole(t);for(let i=0;i<e;i++){Rh.getHole(t,i,s);const e=this.saveInteriorProfile(t),n=this.interiorProfiles.get(e);this.getIntProfileNormalsAvg(t,e),this.getInteriorProfileBuffer(t,n)}return this.interiorProfiles}initializePositions(){const t=this._tileData.positionCount;this._tileData.positionBuffer=new Float32Array(t)}initializeNormals(){const t=this._tileData.normalCount;this._tileData.normalBuffer=new Int16Array(t)}setTileData(t){Array.isArray(t)?this._tileData=t[this._indices]:this._tileData=t}constructShell(t,e,s){const i=Rh.getProfilesLength(t);for(let n=0;n<i;n++){const i=this.getIndices(t,n);this.computeNormalsAvg(t,i,n),this.constructProfile(n,t,i,e),this.manageMemory(t,s)}}constructFaceX(t,e,s){const i=this.getNextFaceId();Jh.create(t,e,this._normalsAvg,s,this._tileData,this.interiorProfiles,this._sizes,i)}getTempProfile(t){return t.type()===ye.BIG?this._bigShellProfile:this._shellProfile}getTempHole(t){return t.type()===ye.BIG?this._bigShellHole:this._shellHole}}class rc{constructor(t){ot(this,"a",new ft.Vector3),ot(this,"b",new ft.Vector3),ot(this,"c",new ft.Vector3),ot(this,"d",new ft.Vector3),ot(this,"e",new ft.Vector3),ot(this,"f",new ft.Vector3),ot(this,"g",new ft.Vector3),ot(this,"h",new ft.Vector3),ot(this,"i",new ft.Vector3),ot(this,"j",new ft.Vector3),ot(this,"k",new ft.Vector3),ot(this,"tempTriangle",new ft.Triangle),ot(this,"tempPlane",new ft.Plane),ot(this,"includedVertices",[]),ot(this,"interiorProfiles",new Map),ot(this,"_meshes"),this._meshes=t}faceRaycast(t,e){const s=Rh.getShell(this._meshes,t);this.resetData(),this.getInteriorProfiles(s);const i=Rh.getBuffer(s);return this.processAllCollisions(s,i,e),this.includedVertices}resetVectors(){this.a.set(0,0,0),this.b.set(0,0,0),this.c.set(0,0,0),this.d.set(0,0,0)}resetData(){this.includedVertices.length=0,this.interiorProfiles.clear()}getInteriorProfiles(t){const e=Rh.getHolesLength(t);for(let s=0;s<e;s++){const e=Rh.getHole(t,s).profileId();this.interiorProfiles.has(e)||this.interiorProfiles.set(e,[]);this.interiorProfiles.get(e).push(s)}}processTriangle(t,e,s){const i=3*t[0],n=3*t[1],r=3*t[2];this.saveTriPoint(this.e,e,i),this.saveTriPoint(this.f,e,n),this.saveTriPoint(this.g,e,r);const o=this.triangleHit(s);if(o){const s=this.getTriangleBuffer(e,t);o.facePoints=s.points,o.faceIndices=s.indices,this.includedVertices.push(o)}}processAllCollisions(t,e,s){const i=Rh.getProfilesLength(t);for(let n=0;n<i;n++){this.resetVectors();const i=this.getIndices(t,n);this.getValidCollision(i,e,s,n,t)&&this.processCollision(t,n,e,i)}}saveTriPoint(t,e,s){const i=e[s],n=e[s+1],r=e[s+2];t.set(i,n,r)}getIndices(t,e){return Rh.getProfile(t,e).indicesArray()}getIsTriangle(t){return 3===t.length}getNormal(){this.tempTriangle.a=this.e,this.tempTriangle.b=this.f,this.tempTriangle.c=this.g;const t=new ft.Vector3;return this.tempTriangle.getNormal(t),t}isHole(t,e,s){if(this.interiorProfiles.has(t)){const i=this.interiorProfiles.get(t);return this.holeContains(i,e,s)}return!1}computeNormal(t,e){this.d.set(0,0,0);const s=e.length;for(let i=0;i<s;i++){const n=(i+1)%s,r=3*e[i],o=3*e[n];this.processNormal(t,r,o)}this.d.normalize()}holeContains(t,e,s){const i=t.length;for(let n=0;n<i;n++){const i=Rh.getHole(e,t[n]).indicesArray();if(this.polygonContains(s,i))return!0}return!1}triangleHit(t){const e=this.e,s=this.f,i=this.g;if(!t.intersectTriangle(e,s,i,!1,this.h))return;const n=this.getNormal();return{point:this.h.clone(),normal:n}}getValidCollision(t,e,s,i,n){if(this.getIsTriangle(t))return this.processTriangle(t,e,s),!1;if(!this.getCollidesPlane(t,e,s))return!1;return!this.isHole(i,n,e)}processCollision(t,e,s,i){if(!this.polygonContains(s,i))return;const n=this.b.clone(),r=this.tempPlane.normal.clone(),o=this.getFaceBuffer(t,e,s);this.includedVertices.push({point:n,normal:r,facePoints:o.points,faceIndices:o.indices})}newOrthoNormalBasis(){const t=this.tempPlane.normal,e=this.j,s=this.i;if(Math.abs(t.x)>=Math.abs(t.y)){const i=1/Math.sqrt(t.x*t.x+t.z*t.z),n=-t.z*i,r=0,o=t.x*i;e.set(n,r,o);const a=t.y*e.z,l=t.z*e.x-t.x*e.z,h=-t.y*e.x;s.set(a,l,h)}else{const i=1/Math.sqrt(t.y*t.y+t.z*t.z),n=0,r=t.z*i,o=-t.y*i;e.set(n,r,o);const a=t.y*e.z-t.z*e.y,l=-t.x*e.z,h=t.x*e.y;s.set(a,l,h)}e.normalize(),s.normalize()}polygonContains(t,e){let s=!1;this.newOrthoNormalBasis(),this.setPolyContainVec(e,t);let i=this.k.dot(this.i),n=this.k.dot(this.j);for(let r=0;r<e.length;r++){const o=3*e[r],a=t[o],l=t[o+1],h=t[o+2];this.k.set(a,l,h),this.k.sub(this.b);const c=this.k.dot(this.i),d=this.k.dot(this.j);if(d>0!==n>0){(i-c)*-d/(n-d)+c>0&&(s=!s)}i=c,n=d}return s}processNormal(t,e,s){const i=t[e+0],n=t[s+0],r=t[e+1],o=t[s+1],a=t[e+2],l=t[s+2];this.d.x+=(r-o)*(a+l),this.d.y+=(a-l)*(i+n),this.d.z+=(i-n)*(r+o)}getCollidesPlane(t,e,s){const i=3*t[0],n=e[i],r=e[i+1],o=e[i+2];this.a.set(n,r,o),this.computeNormal(e,t),this.tempPlane.setFromNormalAndCoplanarPoint(this.d,this.a);return s.intersectPlane(this.tempPlane,this.b)}setPolyContainVec(t,e){const s=3*t[t.length-1],i=e[s],n=e[s+1],r=e[s+2];this.k.set(i,n,r),this.k.sub(this.b)}getTriangleBuffer(t,e){const s=[],i=[];for(let n=0;n<e.length;n++){const r=3*e[n];s.push(t[r],t[r+1],t[r+2]),i.push(n)}return{points:new Float32Array(s),indices:i}}getFaceBuffer(t,e,s){const i=Rh.getProfileIndices(t,e),{outer:n,inners:r}=i,o=[];for(let t=0;t<n.length;t++){const e=3*n[t];o.push(s[e],s[e+1],s[e+2])}const a=[];for(let t=0;t<r.length;t++){const e=r[t];a.push(o.length/3);for(let t=0;t<e.length;t++){const i=3*e[t];o.push(s[i],s[i+1],s[i+2])}}const l=new ft.Vector3,h=new ft.Vector3,c=new ft.Vector3;l.set(o[0],o[1],o[2]),h.set(o[3],o[4],o[5]),c.set(o[6],o[7],o[8]);const d=new ft.Triangle;d.set(l,h,c);const u=new ft.Vector3;d.getNormal(u);const[f,p]=xs.getEarcutDimensions(u),I=[];for(let t=0;t<o.length;t+=3){const e=[o[t],o[t+1],o[t+2]];I.push(e[f],e[p])}const _=He(I,a);return{points:new Float32Array(o),indices:_}}}class oc{constructor(t){ot(this,"_meshes"),ot(this,"_minAngle",Math.PI/32),ot(this,"_shellProfile",new Re),ot(this,"_bigShellProfile",new he),ot(this,"_tempV1",new ft.Vector3),ot(this,"_tempV2",new ft.Vector3),ot(this,"_tempPoint",new ft.Vector3),ot(this,"_normals",[]),ot(this,"_pointsByProfile",new Map),ot(this,"_shell",new Fe),ot(this,"_result",[]),this._meshes=t}lineRaycast(t,e,s){return this.resetData(t),this.lineRaycastItems(e,s),this._result}lineRaycastItems(t,e){const s=Rh.getProfilesLength(this._shell);for(let i=0;i<s;i++){const s=this.getTempProfile(this._shell);Rh.getProfile(this._shell,i,s),this.lineRaycastProfile(t,e,i)}}resetData(t){this._shell=Rh.getShell(this._meshes,t),this._normals.length=0,Rh.getNormalsOfShellProfile(this._shell,this._normals),this._pointsByProfile=Rh.getPointsShell(this._shell),this._result=[]}lineRaycastProfile(t,e,s){const i=this.getTempProfile(this._shell),n=i.indicesLength();for(let r=0;r<n;r++){const o=i.indices(r),a=this.getSecondIndex(r,n);this.cast(o,a,t,e,s)&&this.saveResult(s)}}isInvalidAngle(t,e,s){const i=this.getProfile(t,e,s);if(!i.length)return!0;const n=this._normals[i[0]],r=this._normals[s];return n.dot(r)>Math.cos(this._minAngle)}getProfile(t,e,s){const i=this._pointsByProfile.get(t),n=this._pointsByProfile.get(e),r=[];for(const t of i)-1!==n.indexOf(t)&&t!==s&&r.push(t);return r}cast(t,e,s,i,n){Rh.point(this._shell,t,this._tempV1),Rh.point(this._shell,e,this._tempV2),this.raycastSegment(s);if(!i.containsPoint(this._tempPoint))return!1;return!this.isInvalidAngle(t,e,n)}saveResult(t){const e=this._tempV1.clone(),s=this._tempV2.clone(),i=this._normals[t],n=this._tempPoint.clone();this._result.push({point:n,normal:i,snappedEdgeP1:e,snappedEdgeP2:s})}getSecondIndex(t,e){const s=t===e-1,i=this.getTempProfile(this._shell);return s?i.indices(0):i.indices(t+1)}raycastSegment(t){t.distanceSqToSegment(this._tempV1,this._tempV2,void 0,this._tempPoint)}getTempProfile(t){return t.type()===ye.BIG?this._bigShellProfile:this._shellProfile}}class ac{constructor(t){ot(this,"_meshes"),ot(this,"_tempVec",new ft.Vector3),this._meshes=t}pointRaycast(t,e){const s=Rh.getShell(this._meshes,t),i=[];return this.cast(s,e,i),i}cast(t,e,s){const i=t.pointsLength();for(let n=0;n<i;n++){Rh.point(t,n,this._tempVec);if(!e.containsPoint(this._tempVec))continue;const i=this._tempVec.clone();s.push({point:i})}}}class lc extends bh{constructor(){super(...arguments),ot(this,"_lodClass",Th.AABB),ot(this,"_objectClass",Me.SHELL),ot(this,"_representationClass",Le.SHELL),ot(this,"_templates",new yh),ot(this,"_constructor",new nc),ot(this,"_faceRaycaster",new rc(this.meshes)),ot(this,"_lineRaycaster",new oc(this.meshes)),ot(this,"_pointRaycaster",new ac(this.meshes))}fetchMeshes(t,e){const s=this.getMesh(t,Ue.GEOMETRY);return this.constructMesh(s,e,t),s}newMeshTemplate(t){return this._templates.newMeshTemplate(t)}lineRaycast(t,e,s){return this._lineRaycaster.lineRaycast(t,e,s)}faceRaycast(t,e){return this._faceRaycaster.faceRaycast(t,e)}raycast(t,e){return this._faceRaycaster.faceRaycast(t,e)}pointRaycast(t,e,s){return this._pointRaycaster.pointRaycast(t,s)}setupTemplates(){for(let t=0,e=this.meshes.shellsLength();t<e;t++){const e=Rh.getShell(this.meshes,t);this.useMesh(t,this.newMeshTemplate(e),Ue.GEOMETRY)}}getRepresentation(){return this._representationClass}getObjectClass(){return this._objectClass}getLodClass(){return this._lodClass}isVoidMesh(t){return Array.isArray(t)?void 0===t[0].positionBuffer:void 0===t.positionBuffer}constructMesh(t,e,s){if(!this.isVoidMesh(t)||!e)return;const i=Rh.getShell(this.meshes,s);this._constructor.construct(i,t),this.saveMesh(s,t,Ue.GEOMETRY)}}class hc{static circleCurve3Divisions(t){const e=t.aperture()*t.radius()*4,s=Math.round(e);return Math.min(Math.max(s,4),32)}static traverseCircleCurve(t,e,s){const i=t.circleCurvesLength();for(let n=0;n<i;n++){this.getAllCircleCurveData(t,n);const i=s(this._circleCurve);this._circlePoints.length=i-2,this.getCircleCurveMids(i),this.getNewCircleCurveData(),e(this._circleP1,this._circlePoints,this._circleP2)}}static traverseWireSets(t,e){const s=t.wireSetsLength();for(let i=0;i<s;i++)t.wireSets(i,this._wireSet),this.traverseWireSetWires(e)}static raycastCircleExtr(t,e,s,i){const n=e.distanceTo(t);return this.setupCircleExtrusionAxes(e,t),this.setupCircleExtrusionTransform(t,i),this.setupCircleExtrusionRay(s),this.computeCircleExtrusionRaycast(n,i)}static traverseWires(t,e){const s=t.wiresLength();for(let i=0;i<s;i++)t.wires(i,this._wire),this.setWire(),e(this._wireP1,this._wireP2)}static getNewCircleCurveData(){this._circleP2.copy(this._circleP1);const t=this._circleCurve.aperture(),e=this._circleCurve.radius();this._circleP2.applyAxisAngle(this._circleOrientation,t),this._circleP2.multiplyScalar(e),this._circleP2.add(this._circleOrigin),this._circleP1.multiplyScalar(e),this._circleP1.add(this._circleOrigin)}static setWire(){this.setWirePoint("p1",this._wireP1),this.setWirePoint("p2",this._wireP2)}static getCircleCurveMids(t){const e=this._circlePoints.length;for(let s=0;s<e;s++)this._circlePoints[s]=this.newCirclePoint(s,t)}static newCirclePoint(t,e){const s=e-1,i=t+1,n=new ft.Vector3;n.copy(this._circleP1);const r=this._circleCurve.radius(),o=this._circleCurve.aperture()*i/s;return n.applyAxisAngle(this._circleOrientation,o),n.multiplyScalar(r),n.add(this._circleOrigin),n}static getAllCircleCurveData(t,e){t.circleCurves(e,this._circleCurve),this.getCircleCurveData(this._circleOrigin,"position"),this.getCircleCurveData(this._circleOrientation,"xDirection"),this.getCircleCurveData(this._circleP1,"yDirection")}static setWirePoint(t,e){this._wire[t](this._floats);const s=this._floats.x(),i=this._floats.y(),n=this._floats.z();e.set(s,i,n)}static getCircleCurveData(t,e){const s=this._circleCurve[e]();this.getVectorData(s,t)}static getVectorData(t,e){const s=t.x(),i=t.y(),n=t.z();e.set(s,i,n)}static traverseWireSetWires(t){const e=this._wireSet.psLength()-1;for(let s=0;s<e;s++)this.getWiresetPoint(this._currentWireSetPoint,s),this.getWiresetPoint(this._nextWireSetPoint,s+1),t(this._currentWireSetPoint,this._nextWireSetPoint)}static getWiresetPoint(t,e){const s=this._wireSet.ps(e);this.getVectorData(s,t)}static setupCircleExtrusionTransform(t,e){this._ceTransform.identity(),this._ceTransform.makeBasis(this._ceAxisX,this._ceAxisY,this._ceAxisZ),this._ceTransform.setPosition(t),this._ceSize.set(e,e,e),this._ceTransform.scale(this._ceSize)}static computeCircleExtrusionRaycastFactors(){const t=this._ceRay.direction,e=this._ceRay.origin,s=t.x*t.x+t.y*t.y,i=2*e.x*t.x+2*e.y*t.y,n=4*s*(e.x*e.x+e.y*e.y-1),r=i*i;if(n>r)return null;const o=2*s,a=Math.sqrt(r-n);return{factorA:(-i+a)/o,factorB:(-i-a)/o}}static computeCircleExtrusionRaycast(t,e){const s=this.computeCircleExtrusionRaycastFactors();if(null===s)return[];const{factorA:i,factorB:n}=s;return this._ceInverseTransform.transpose(),this._ceRaycastPoints=[],this.computeCircleExtrusionRaycastPoints(i,t,e),this.computeCircleExtrusionRaycastPoints(n,t,e),this._ceRaycastPoints}static setupCircleExtrusionRay(t){this._ceInverseTransform.copy(this._ceTransform),this._ceInverseTransform.invert(),this._ceRay.copy(t),this._ceRay.applyMatrix4(this._ceInverseTransform)}static computeCircleExtrusionRaycastPoints(t,e,s){if(!this.checkIfCircleExtrusionClashes(t,e,s))return;this._ceRaycastPoint.applyMatrix4(this._ceTransform);const i=this._ceRaycastPoint.clone();this._ceRaycastPoints.push({point:i})}static setupCircleExtrusionAxes(t,e){this._ceAxisZ.copy(t),this._ceAxisZ.sub(e),this._ceAxisZ.normalize(),this.computeNormal(this._ceAxisZ,this._ceAxisX),this._ceAxisY.crossVectors(this._ceAxisZ,this._ceAxisX)}static computeNormal(t,e){const s=t.dot(this._ceAbsoluteX),i=Math.abs(s)>.9?this._ceAbsoluteZ:this._ceAbsoluteX;e.crossVectors(t,i),e.normalize()}static setupCircleExtrusionRaycastPoint(t){this._ceRaycastPoint.copy(this._ceRay.direction),this._ceRaycastPoint.normalize(),this._ceRaycastPoint.multiplyScalar(t),this._ceRaycastPoint.add(this._ceRay.origin)}static checkIfCircleExtrusionClashes(t,e,s){this.setupCircleExtrusionRaycastPoint(t);const i=e/s,n=this._ceRaycastPoint.z;return n>=0&&n<=i}}ot(hc,"_floats",new se),ot(hc,"_wire",new ne),ot(hc,"_wireSet",new re),ot(hc,"_circleCurve",new ie),ot(hc,"_wireP1",new ft.Vector3),ot(hc,"_wireP2",new ft.Vector3),ot(hc,"_circleP1",new ft.Vector3),ot(hc,"_circleP2",new ft.Vector3),ot(hc,"_circleOrigin",new ft.Vector3),ot(hc,"_circleOrientation",new ft.Vector3),ot(hc,"_currentWireSetPoint",new ft.Vector3),ot(hc,"_nextWireSetPoint",new ft.Vector3),ot(hc,"_ceAxisZ",new ft.Vector3),ot(hc,"_ceAxisY",new ft.Vector3),ot(hc,"_ceAxisX",new ft.Vector3),ot(hc,"_ceRaycastPoint",new ft.Vector3),ot(hc,"_ceSize",new ft.Vector3),ot(hc,"_ceAbsoluteX",new ft.Vector3(0,0,1)),ot(hc,"_ceAbsoluteZ",new ft.Vector3(1,0,0)),ot(hc,"_circlePoints",[]),ot(hc,"_ceTransform",new ft.Matrix4),ot(hc,"_ceInverseTransform",new ft.Matrix4),ot(hc,"_ceRay",new ft.Ray),ot(hc,"_ceRaycastPoints",[]);const cc=class t{static newPaths(e,s){const i=t.newPathData();return this.fetchCircleCurveData(e,i),this.fetchCircleCurveMids(s,i,e),this.fetchCircleCurveEnds(i,e),this.fetchCircleCurveCuts(i),i.cuts}static getAxisPartSize(e,s,i){const n=e.parts(s),r=e.order(s),o=t.getAxisPartData(n,i,e,r);return t.fetchAxisPartSize(i,o),this._axisPartSize}static vertexLength(e,s=200){const i=Math.round(e*s),n=Math.max(i,t._minSize);return Math.min(n,t._maxSize)}static setPathVertices(t){const e=this.circleCurvePoints,s=!e,i=e&&e.length!==t;if(s||i){this.circleCurvePoints=[];for(let e=0;e<t;e++){const s=2*Math.PI*e/t,i=Math.sin(s),n=Math.cos(s),r=new ft.Vector3(i,n,0);this.circleCurvePoints.push(r)}}}static fetchCircleCurveEnds(t,e){t.last.copy(t.first),t.last.applyAxisAngle(t.axis,e.aperture()),t.last.multiplyScalar(e.radius()),t.last.add(t.center),t.first.multiplyScalar(e.radius()),t.first.add(t.center)}static getAxisPartData(t,e,s,i){return{[ae.WIRE]:this.getAxisPartWireData,[ae.WIRE_SET]:this.getAxisPartWireSetData,[ae.CIRCLE_CURVE]:this.getAxisPartCircleCurveData}[t](s,i,e)}static newEmptyAxisPartData(){return{indices:0,points:0,faces:0,links:0}}static fetchCircleCurveMids(t,e,s){const i=t-2;for(let n=0;n<i;n++){const i=new ft.Vector3;i.copy(e.first);const r=s.aperture()*(n+1)/(t-1);i.applyAxisAngle(e.axis,r),i.multiplyScalar(s.radius()),i.add(e.center),e.mids[n]=i}}static validSize(t,e,s){return Ne>=t+e+s}static fetchCircleCurveCuts(t){t.cuts.push(t.first),t.cuts.push(...t.mids),t.cuts.push(t.last)}static fetchCircleCurveData(t,e){const s=t.position();e.center.set(s.x(),s.y(),s.z());const i=t.xDirection();e.axis.set(i.x(),i.y(),i.z());const n=t.yDirection();e.first.set(n.x(),n.y(),n.z())}static newPathData(){return{axis:new ft.Vector3,cuts:[],center:new ft.Vector3,last:new ft.Vector3,first:new ft.Vector3,mids:[]}}static fetchAxisPartSize(t,e){const s=t-2,i=e.faces*s*3,n=e.links*t*this._wireSize;this._axisPartSize.verticesLength=e.points,this._axisPartSize.indicesLength=e.indices+i+n}};ot(cc,"up",new ft.Vector3(0,0,1)),ot(cc,"circleCurves",[]),ot(cc,"circleCurvePoints"),ot(cc,"temp",{circleExtrusion:new de,circleCurve:new ie,wireSet:new re,axis:new oe,rotation:new ft.Quaternion,vector:new ft.Vector3}),ot(cc,"_wireSize",6),ot(cc,"_minSize",6),ot(cc,"_maxSize",30),ot(cc,"_axisPartSize",{verticesLength:0,indicesLength:0}),ot(cc,"getAxisPartWireSetData",((t,e,s)=>{const i=cc.newEmptyAxisPartData();t.wireSets(e,cc.temp.wireSet);const n=cc.temp.wireSet.psLength()-1;return i.points=2*n*s,i.indices=cc._wireSize*n*s,i.faces=2*n,i})),ot(cc,"getAxisPartWireData",((t,e,s)=>{const i=cc.newEmptyAxisPartData();return i.points=2*s,i.indices=cc._wireSize*s,i.faces=2,i})),ot(cc,"getAxisPartCircleCurveData",((t,e,s)=>{const i=cc.newEmptyAxisPartData();t.circleCurves(e,cc.temp.circleCurve);const n=hc.circleCurve3Divisions(cc.temp.circleCurve),r=s*n;i.points=r;const o=s*(n-1),a=cc._wireSize*o;i.indices=a;return i.faces=2,i.links=2,i}));let dc=cc;class uc{constructor(){ot(this,"_minLinkDistance",1e-8),ot(this,"_first",new ft.Vector3),ot(this,"_last",new ft.Vector3),ot(this,"_currentPoint"),ot(this,"_currentIndex"),ot(this,"_v1",new ft.Vector3),ot(this,"_v2",new ft.Vector3),ot(this,"_v3",new ft.Vector3),ot(this,"_v4",new ft.Vector3),ot(this,"_tempLine",new ft.Line3),ot(this,"_total",0),ot(this,"_closest",0),ot(this,"_result",0)}newTemplate(t,e,s){const i=t.radius(e),n=t.axes(e,dc.temp.axis),r=dc.vertexLength(i);let o=s[s.length-1];const a=n.orderLength();for(let t=0;t<a;t++)o=this.generateTemplate(n,t,r,o,s)}construct(t,e){const s={};let i=0;for(let n=0,r=t.axesLength();n<r;n++){const r=t.radius(n);t.axes(n,dc.temp.axis);const o=dc.vertexLength(r);i=this.constructVce(o,s,undefined,i,0,e,r)}}getTemplateCreationData(t,e,s){const i=!t;let n=!1;if(!i){const i=t.positionCount/3,r=e.verticesLength;n=dc.validSize(i,r,s)}return{isStart:i,fits:n}}generateTemplate(t,e,s,i,n){const r=dc.getAxisPartSize(t,e,s),{isStart:o,fits:a}=this.getTemplateCreationData(i,r,s);return(o||!a)&&(i=this.newTemplateData(),n.push(i),this.savePrevious(o,e,s,i)),i.positionCount+=3*r.verticesLength,i.normalCount+=3*r.verticesLength,i.indexCount+=r.indicesLength,i}savePrevious(t,e,s,i){if(!t&&0!==e){const t=3*(s-2);i.positionCount+=3*s,i.normalCount+=3*s,i.indexCount+=t}}constructNewVce(t,e,s,i,n,r,o){const a=!t;let l=!1;if(!a){const t=e.verticesLength;l=dc.validSize(s,t,i)}if(a||!l){t=n[r++],this.setupNewVceBuffers(t);const e=this._currentPoint;s=this.clearOffset(s);if(!a&&0!==o){const o=n[r-2];this.getClone(o,t,e,i),s+=i}}return{data:t,pointAmount:s,position:r}}constructVce(t,e,s,i,n,r,o){const a=dc.temp.axis.orderLength();for(let l=0;l<a;l++){const a=dc.temp.axis,h=dc.getAxisPartSize(a,l,t);this.setupLink(l,e),({data:s,pointAmount:i,position:n}=this.constructNewVce(s,h,i,t,r,n,l)),this.newAxisPart(dc.temp.axis,l,s,o,t,e),i+=h.verticesLength}return i}newTemplateData(){return{objectClass:Me.SHELL,indexCount:0,positionCount:0,normalCount:0}}setupNewVceBuffers(t){t.positionBuffer=new Float32Array(t.positionCount),t.normalBuffer=new Int16Array(t.normalCount),t.indexBuffer=new Uint16Array(t.indexCount)}clearOffset(t){return this._currentPoint=0,this._currentIndex=0,0}getClone(t,e,s,i){for(let n=-3*i;n<0;n++){const i=e.positionBuffer,r=t.positionBuffer,o=e.normalBuffer,a=t.normalBuffer;i[this._currentPoint]=r[s+n],o[this._currentPoint]=a[s+n],this._currentPoint++}}manageAxisPartCreation(t,e,s,i,n,r,o){if(t!==ae.CIRCLE_CURVE)if(t!==ae.WIRE_SET){if(t===ae.WIRE){const t=e.wires(s);this.newWire(t,i,n,r,o)}}else{const t=e.wireSets(s);this.newWireSet(t,i,n,r,o)}else{const t=e.circleCurves(s);this.newCircleCurve(t,i,n,r,o)}}newWireSetStart(t,e,s,i){1===t?this.linkStart(e,s,i,this._first,ae.WIRE_SET):this.newPathOrderData(e,s)}newWireSet(t,e,s,i,n){for(let r=1,o=t.psLength();r<o;r++){const a=dc.temp.rotation;this.getWireSetPoints(t,r),this.setWireSetVector(),this.newPath(this._first,e,a,s,i),this.newWireSetStart(r,s,i,n),this.newPath(this._last,e,a,s,i),this.fillWireSetData(r,o,n,s,i),this.linkPaths(s,i)}}fillWireSetData(t,e,s,i,n){t!==e-1||s.last?this.newPathOrderData(i,n,!0):(s.placement=this._last,s.axisClass=ae.WIRE_SET)}setWireSetVector(){dc.temp.vector.copy(this._last),dc.temp.vector.sub(this._first),dc.temp.vector.normalize(),dc.temp.rotation.setFromUnitVectors(dc.up,dc.temp.vector)}newCircleCurveBody(t,e,s,i){const n=t-2;for(let t=0;t<n;t++){const n=dc.circleCurves[t],r=dc.circleCurves[t+1],o=dc.circleCurves[t+2],a=dc.temp.vector;a.copy(o),a.sub(n),a.normalize(),dc.temp.rotation.setFromUnitVectors(dc.up,a),this.newPath(r,e,dc.temp.rotation,s,i),this.linkPaths(s,i,!0)}}newCircleCurveFinish(t,e,s,i,n){const r=t-2,o=t-1,a=dc.circleCurves[r],l=dc.circleCurves[o],h=dc.temp.vector;h.copy(l),h.sub(a),h.normalize(),dc.temp.rotation.setFromUnitVectors(dc.up,h),this.newPath(l,e,dc.temp.rotation,s,i),n.last?this.newPathOrderData(s,i,!0):(n.placement=dc.circleCurves[o],n.axisClass=ae.CIRCLE_CURVE)}setupLink(t,e){0===t&&(e.first=!0);t===dc.temp.axis.orderLength()-1&&(e.last=!0)}newCircleCurveStart(t,e,s,i){const n=dc.circleCurves[0],r=dc.circleCurves[1],o=dc.temp.vector;o.copy(r),o.sub(n),o.normalize(),dc.temp.rotation.setFromUnitVectors(dc.up,o),this.newPath(n,t,dc.temp.rotation,e,s);const a=ae.CIRCLE_CURVE;this.linkStart(e,s,i,n,a)}getWireSetPoints(t,e){const s=t.ps(e-1);this._first.set(s.x(),s.y(),s.z());const i=t.ps(e);this._last.set(i.x(),i.y(),i.z())}finishWire(t,e,s,i){this.newPath(this._last,t,dc.temp.rotation,e,s),i.last?this.newPathOrderData(e,s,!0):(i.placement=this._last,i.axisClass=ae.WIRE),this.linkPaths(e,s)}linkPaths(t,e,s=!1){const i=e,{p1:n,p2:r,p3:o}=this.getPathPositions(i,s,t),a=t.indexBuffer;for(let t=0;t<i;t++){const e=(t+1)%i,{i3:s,i4:l,i1:h,i2:c}=this.getLinkPathIndices(o,t,n,i,e,r);a[this._currentIndex++]=s,a[this._currentIndex++]=l,a[this._currentIndex++]=h,a[this._currentIndex++]=h,a[this._currentIndex++]=l,a[this._currentIndex++]=c}}startWire(t,e,s,i){this.newPath(this._first,t,dc.temp.rotation,e,s);const n=ae.WIRE;this.linkStart(e,s,i,this._first,n)}setupWireVectors(){const t=dc.temp.vector;t.copy(this._last),t.sub(this._first),t.normalize(),dc.temp.rotation.setFromUnitVectors(dc.up,t)}getLinkPathIndices(t,e,s,i,n,r){let o=0,a=0,l=0,h=0;return o=t+e>=s?t+e-i:t+e,a=t+n>=s?t+n-i:t+n,l=r+e>=s+i?r+e-i:r+e,h=r+n>=s+i?r+n-i:r+n,{i3:l,i4:h,i1:o,i2:a}}fetchWirePoints(t){const e=t.p1(),s=t.p2();this._first.set(e.x(),e.y(),e.z()),this._last.set(s.x(),s.y(),s.z())}findLinkedVertex(t,e,s,i,n){for(let r=t;r<e;r++){this.point(r,s,this._v1);const e=r-i+n,o=e>=t?e-i:e;this.point(o,s,this._v2);const a=e+1>=t?e+1-i:e+1;this.point(a,s,this._v3),this._tempLine.set(this._v2,this._v3),this._tempLine.closestPointToPoint(this._v1,!0,this._v4),this._total+=this._v4.distanceTo(this._v1)}}newPath(t,e,s,i,n){dc.setPathVertices(n);for(let r=0;r<n;r++)this.setPathPosition(r,e,s,t,i),this.setPathNormal(r,s,i),this._currentPoint+=3}linkStart(t,e,s,i,n){if(s.first)return void this.newPathOrderData(t,e);const r=ae.CIRCLE_CURVE,o=s.axisClass===r||n===r,a=s.placement.distanceToSquared(i)<this._minLinkDistance;if(!o||!a)return this.newPathOrderData(t,e,!0,!0),void this.newPathOrderData(t,e);this.linkPaths(t,e,!0)}setPathPosition(t,e,s,i,n){const r=dc.temp.vector;r.copy(dc.circleCurvePoints[t]),r.multiplyScalar(e),r.applyQuaternion(s),r.add(i);const o=n.positionBuffer,a=this._currentPoint,l=this._currentPoint+1,h=this._currentPoint+2;o[a]=r.x,o[l]=r.y,o[h]=r.z}newWire(t,e,s,i,n){this.fetchWirePoints(t),this.setupWireVectors(),this.startWire(e,s,i,n),this.finishWire(e,s,i,n)}newCircleCurve(t,e,s,i,n){const r=hc.circleCurve3Divisions(t);dc.circleCurves=dc.newPaths(t,r),this.newCircleCurveStart(e,s,i,n),this.newCircleCurveBody(r,e,s,i),this.newCircleCurveFinish(r,e,s,i,n),this.linkPaths(s,i,!0)}newPathOrderData(t,e,s=!1,i=!1){const n=e-2,r=t.indexBuffer;for(let t=0;t<n;t++){const n=this._currentPoint/3,o=e*(i?2:1),a=n-o;r[this._currentIndex]=a,this._currentIndex++;const l=n+t+(s?2:1)-o;r[this._currentIndex]=l,this._currentIndex++;const h=n+t+(s?1:2)-o;r[this._currentIndex]=h,this._currentIndex++}}getPathPositions(t,e,s){const i=this._currentPoint/3-t,n=i;let r=i-t;return e&&(r=this.fetchLinkedVertex(i,s,t)),{p3:r,p1:i,p2:n}}newAxisPart(t,e,s,i,n,r){const o=t.parts(e),a=t.order(e);this.manageAxisPartCreation(o,t,a,i,s,n,r),r.first=!1,r.last=!1}fetchLinkedVertex(t,e,s){this._closest=Number.MAX_VALUE;for(let i=0;i<s;i++){this._total=0;const n=t+s;this.findLinkedVertex(t,n,e,s,i);this._total<this._closest&&(this._closest=this._total,this._result=t-s+i+1)}return this._result}setPathNormal(t,e,s){const i=dc.temp.vector,n=dc.circleCurvePoints[t];i.copy(n),i.applyQuaternion(e);const r=s.normalBuffer,o=this._currentPoint,a=this._currentPoint+1,l=this._currentPoint+2;r[o]=i.x*Ch,r[a]=i.y*Ch,r[l]=i.z*Ch}point(t,e,s){const i=e.positionBuffer,n=3*t+1,r=3*t+2,o=i[3*t],a=i[n],l=i[r];return s.set(o,a,l),s}}class fc{constructor(t){ot(this,"_meshes"),ot(this,"_results",[]),ot(this,"_circleExtrusion",new de),ot(this,"_axis",new oe),this._meshes=t}raycast(t,e){this._results.length=0,this._meshes.circleExtrusions(t,this._circleExtrusion);for(let t=0,s=this._circleExtrusion.axesLength();t<s;t++){this._circleExtrusion.axes(t,this._axis);const s=this._circleExtrusion.radius(t);this.traverseAllCurves(e,s)}return this._results}getTraverseWiresEvent(t,e){return(s,i)=>{this.castCurveExtrusion(s,i,t,e)}}castCurveExtrusion(t,e,s,i){const n=hc.raycastCircleExtr(t,e,s,i);for(const t of n)this._results.push(t)}getTraverseCircleCurveEvent(t,e){return(s,i,n)=>{const r=i[0];this.castCurveExtrusion(s,r,t,e);for(let s=0;s<i.length;s++){if(0===s)continue;const n=i[s-1],r=i[s];this.castCurveExtrusion(n,r,t,e)}const o=i[i.length-1];this.castCurveExtrusion(o,n,t,e)}}traverseAllCurves(t,e){const s=this.getTraverseWiresEvent(t,e);hc.traverseWires(this._axis,s);const i=this.getTraverseCircleCurveEvent(t,e),n=hc.circleCurve3Divisions;hc.traverseCircleCurve(this._axis,i,n);const r=this.getTraverseWiresEvent(t,e);hc.traverseWireSets(this._axis,r)}}class pc{constructor(t){ot(this,"_meshes"),ot(this,"_found",[]),ot(this,"_circleExtrusion",new de),ot(this,"_axis",new oe),ot(this,"_wirePoint",new ft.Vector3),this._meshes=t}lineRaycast(t,e){this._found.length=0,this._meshes.circleExtrusions(t,this._circleExtrusion);const s=this._circleExtrusion.axesLength();for(let t=0;t<s;t++)this._circleExtrusion.axes(t,this._axis),this.processLineRaycast(t,e);return this._found}wireSetRaycast(t,e){const s=this._axis;hc.traverseWireSets(s,((s,i)=>{this.cylinderRaycast(s,i,t,e)}))}exclusiveCylinderRaycast(t,e){const s=this._axis,i=this.getCylinderRaycastEvent(t,e);hc.traverseWires(s,i)}processLineRaycast(t,e){const s=this._circleExtrusion.radius(t);this.exclusiveCylinderRaycast(e,s),this.circleCurveRaycast(e,s),this.wireSetRaycast(e,s)}getCylinderRaycastEvent(t,e){return(s,i)=>{this.cylinderRaycast(s,i,t,e)}}processCircleCurveBody(t,e,s){for(let i=0;i<t.length;i++){if(0===i)continue;const n=t[i],r=t[i-1];this.cylinderRaycast(r,n,e,s)}}getCircleCurveRaycastEvent(t,e){return(s,i,n)=>{this.cylinderRaycast(s,i[0],t,e),this.processCircleCurveBody(i,t,e);const r=i[i.length-1];this.cylinderRaycast(r,n,t,e)}}fetchCylinderRaycastResult(t,e,s){t.distanceSqToSegment(e,s,void 0,this._wirePoint);const i=this.newResult(e,s);this._found.push(i)}circleCurveRaycast(t,e){const s=hc.circleCurve3Divisions,i=this.getCircleCurveRaycastEvent(t,e);hc.traverseCircleCurve(this._axis,i,s)}newResult(t,e){return{point:this._wirePoint.clone(),raySquaredDistance:void 0,snappedEdgeP1:t.clone(),snappedEdgeP2:e.clone()}}cylinderRaycast(t,e,s,i){const n=hc.raycastCircleExtr(t,e,s,i);for(const i of n)i.point&&this.fetchCylinderRaycastResult(s,t,e)}}class Ic{constructor(t){ot(this,"_meshes"),ot(this,"_results",[]),ot(this,"_circleExtrusion",new de),ot(this,"_axis",new oe),ot(this,"_normal",new ft.Vector3),ot(this,"_point",new ft.Vector3),ot(this,"_plane",new ft.Plane),this._meshes=t}pointRaycast(t,e){return this._results.length=0,this._meshes.circleExtrusions(t,this._circleExtrusion),this.traverseAllCircleExtrusions(e),this.getCleanResults()}fetchOrientation(t,e){dc.temp.vector.copy(t),dc.temp.vector.sub(e),dc.temp.vector.normalize();dc.temp.rotation.setFromUnitVectors(dc.up,dc.temp.vector)}getTraverseWiresEvent(t,e){return(s,i)=>{this.fetchOrientation(s,i);const n=this.raycastCutCircleExtrusion(s,t,e),r=this.raycastCutCircleExtrusion(i,t,e);this._results.push(n,r)}}traverseAllCircleExtrusions(t){const e=this._circleExtrusion.axesLength();for(let s=0;s<e;s++){this._circleExtrusion.axes(s,this._axis);const e=this._circleExtrusion.radius(s),i=dc.vertexLength(e);dc.setPathVertices(i),this.traverseAllCurves(t,e)}}setupCuttedCircleExtrusion(t){this._normal.set(0,0,1),this._normal.applyQuaternion(dc.temp.rotation),this._plane.setFromNormalAndCoplanarPoint(this._normal,t)}getTraverseCircleCurveEvent(t,e){return(s,i,n)=>{this.fetchOrientation(s,i[0]);const r=this.raycastCutCircleExtrusion(s,t,e),o=i[i.length-1];this.fetchOrientation(o,n);const a=this.raycastCutCircleExtrusion(n,t,e);this._results.push(r,a)}}computeCutCircleExtrCast(t,e,s){s.intersectPlane(this._plane,this._point);if(this._point.distanceTo(t)<=e){return{point:t.clone()}}}raycastCutCircleExtrusion(t,e,s){this.setupCuttedCircleExtrusion(t);if(e.intersectsPlane(this._plane))return this.computeCutCircleExtrCast(t,s,e)}getCleanResults(){const t=[];for(const e of this._results)e&&t.push(e);return t}traverseAllCurves(t,e){const s=this.getTraverseWiresEvent(t,e);hc.traverseWires(this._axis,s);const i=this.getTraverseCircleCurveEvent(t,e),n=hc.circleCurve3Divisions;hc.traverseCircleCurve(this._axis,i,n);const r=this.getTraverseWiresEvent(t,e);hc.traverseWireSets(this._axis,r)}}class _c{constructor(){ot(this,"_currentElement",0),ot(this,"_wireSize",6),ot(this,"newCircleCurveLod",((t,e,s)=>{const i=this.newCircleCurveLodPath(t,e),n=s.positionBuffer;for(let t=1;t<i;t++){const e=dc.circleCurves[t-1],s=dc.circleCurves[t];this.newWire(n,e,s)}})),ot(this,"newWireSetLod",((t,e,s)=>{const i=t.wireSets(e),n=i.psLength(),r=s.positionBuffer;for(let t=1;t<n;t++){const e=i.ps(t-1),s=i.ps(t);this.newWire(r,e,s)}})),ot(this,"newWireTemplate",((t,e)=>{e.positionCount+=this._wireSize})),ot(this,"newWireSetTemplate",((t,e)=>{const s=dc.temp.axis.wireSets(t,dc.temp.wireSet).psLength()-1;e.positionCount+=this._wireSize*s})),ot(this,"newWireLod",((t,e,s)=>{const i=t.wires(e),n=i.p1(),r=i.p2(),o=s.positionBuffer;this.newWire(o,n,r)})),ot(this,"newCircleCurveTemplate",((t,e)=>{const s=dc.temp.axis.circleCurves(t,dc.temp.circleCurve),i=hc.circleCurve3Divisions(s);e.positionCount+=this._wireSize*(i-1)}))}construct(t,e){this._currentElement=0,e.positionBuffer=new Float32Array(e.positionCount);for(let s=0,i=t.axesLength();s<i;s++)t.axes(s,dc.temp.axis),this.constructLod(e);return e}constructCircleExtrusionLod(t,e){const s=dc.temp.axis,i=s.parts(t),n=s.order(t);this.getLodConstructor(i)(s,n,e)}newCircleCurveLodPath(t,e){const s=t.circleCurves(e),i=hc.circleCurve3Divisions(s);return dc.circleCurves=dc.newPaths(s,i),i}selectNextWire(){this._currentElement+=this._wireSize}getAxisPartVertexSize(t,e){const s=dc.temp.axis,i=s.parts(t),n=s.order(t);this.getTemplateConstructor(i)(n,e)}getIndices(){return{i1:this._currentElement,i2:this._currentElement+1,i3:this._currentElement+2,i4:this._currentElement+3,i5:this._currentElement+4,i6:this._currentElement+5}}setAxisTemplate(t,e){dc.temp.circleExtrusion.axes(t,dc.temp.axis);const s=dc.temp.axis.partsLength();for(let t=0;t<s;t++)this.getAxisPartVertexSize(t,e);this.setAxisThickness(e,t)}constructLod(t){const e=dc.temp.axis.orderLength();for(let s=0;s<e;s++)this.constructCircleExtrusionLod(s,t)}getLodConstructor(t){return{[ae.WIRE]:this.newWireLod,[ae.WIRE_SET]:this.newWireSetLod,[ae.CIRCLE_CURVE]:this.newCircleCurveLod}[t]}newTemplate(){const t=dc.temp.circleExtrusion,e=this.newTemplateData(),s=t.axesLength();for(let t=0;t<s;t++)this.setAxisTemplate(t,e);return e}setAxisThickness(t,e){const s=t.lodThickness,i=dc.temp.circleExtrusion.radius(e);t.lodThickness=Math.max(s,i)}newTemplateData(){return{objectClass:Me.LINE,lod:Ue.WIRES,lodThickness:0,positionCount:0}}getTemplateConstructor(t){return{[ae.WIRE]:this.newWireTemplate,[ae.WIRE_SET]:this.newWireSetTemplate,[ae.CIRCLE_CURVE]:this.newCircleCurveTemplate}[t]}newWire(t,e,s){const i=e instanceof ft.Vector3?e.x:e.x(),n=e instanceof ft.Vector3?e.y:e.y(),r=e instanceof ft.Vector3?e.z:e.z(),o=s instanceof ft.Vector3?s.x:s.x(),a=s instanceof ft.Vector3?s.y:s.y(),l=s instanceof ft.Vector3?s.z:s.z(),{i1:h,i2:c,i3:d,i4:u,i5:f,i6:p}=this.getIndices();t[h]=i,t[c]=n,t[d]=r,t[u]=o,t[f]=a,t[p]=l,this.selectNextWire()}}class mc extends bh{constructor(){super(...arguments),ot(this,"_vceConstructor",new uc),ot(this,"_lodConstructor",new _c),ot(this,"_vceRaycaster",new fc(this.meshes)),ot(this,"_vceLineRaycaster",new pc(this.meshes)),ot(this,"_vcePointRaycaster",new Ic(this.meshes)),ot(this,"_representationClass",Le.CIRCLE_EXTRUSION),ot(this,"_objectClass",Me.LINE),ot(this,"lodClass",Th.CUSTOM)}setupTemplates(){const t=this.meshes.circleExtrusionsLength();for(let e=0;e<t;e++)this.newCircleExtrusionTemplate(e)}fetchLod(t,e){const s=this.getMesh(t,Ue.WIRES);return this.generateLodIfNeeded(t,e,s),s}fetchMeshes(t,e){const s=this.getMesh(t,Ue.GEOMETRY);return this.generateMeshesIfNeeded(t,e,s),s}raycast(t,e){return this._vceRaycaster.raycast(t,e)}faceRaycast(){return[]}pointRaycast(t,e){return this._vcePointRaycaster.pointRaycast(t,e)}lineRaycast(t,e){return this._vceLineRaycaster.lineRaycast(t,e)}getObjectClass(){return this._objectClass}getRepresentation(){return this._representationClass}getLodClass(){return this.lodClass}newMeshes(t,e){this.meshes.circleExtrusions(t,dc.temp.circleExtrusion);const s=dc.temp.circleExtrusion;this._vceConstructor.construct(s,e),this.saveMesh(t,e,Ue.GEOMETRY)}generateMeshesIfNeeded(t,e,s){if(0===s.length)return;const i=Boolean(s.length),n=!s[0].positionBuffer;e&&n&&i&&this.newMeshes(t,s)}newCircleExtrusionTemplate(t){const e=[];this.meshes.circleExtrusions(t,dc.temp.circleExtrusion);const s=dc.temp.circleExtrusion,i=s.axesLength();for(let t=0;t<i;t++)this._vceConstructor.newTemplate(s,t,e);const n=this._lodConstructor.newTemplate();this.useMesh(t,e,Ue.GEOMETRY),this.useMesh(t,n,Ue.WIRES)}generateLodIfNeeded(t,e,s){!s.positionBuffer&&e&&(this.meshes.circleExtrusions(t,dc.temp.circleExtrusion),this._lodConstructor.construct(dc.temp.circleExtrusion,s),this.saveMesh(t,s,Ue.WIRES))}}class Ec{constructor(t){ot(this,"size"),ot(this,"_data"),ot(this,"_highlightData"),this.size=t,this._data=new Uint8Array(t),this._highlightData=new Uint16Array(t),this._data.fill(1)}getHighlight(t){return this._highlightData[t]}setHighlight(t,e){Rs.checkMemory(e),this._highlightData[t]=e}clearHighlight(){this._highlightData.fill(0)}visible(t){return Rs.check(this._data,t,Be.VISIBLE)}setVisible(t,e){Rs.apply(this._data,t,Be.VISIBLE,e)}clearVisible(){this._data.fill(1)}}class gc{constructor(t,e){ot(this,"_rate",64),ot(this,"_updater"),ot(this,"_modelId"),ot(this,"_threshold",16),ot(this,"_connection"),ot(this,"_list",[]),ot(this,"refresh",(()=>{if(this._list.length){const t=this._list;this._connection.fetchMeshCompute(this._modelId,t),this._list=[]}})),this._modelId=t,this._connection=e,this._updater=Si.newUpdater(this.refresh,this._rate)}get needsRefresh(){return this._list.length>this._threshold}dispose(){Si.deleteUpdater(this._updater)}clean(){this._list=Si.cleanRequests(this._list)}process(t){this._list.push(t),this.needsRefresh&&this.refresh()}}class bc{constructor(t,e,s,i){ot(this,"_meshes"),ot(this,"_model"),ot(this,"_boxes"),ot(this,"_tiles"),ot(this,"_items"),ot(this,"_edgeThreshold",8),ot(this,"_raycastMultiplier",32),ot(this,"_maxDuration",512),ot(this,"_precission",.001),ot(this,"_temp",{sample:new Te,representation:new Ce,tempPlane:new ft.Plane,ray:new ft.Ray,frustum:new ft.Frustum,m1:new ft.Matrix4,m2:new ft.Matrix4,m3:new ft.Matrix4,v1:new ft.Vector3,planes:[]}),this._model=t,this._boxes=e,this._tiles=s,this._items=i,this._meshes=t.meshes()}static cast(t,e,s,i,n){const r=e.id();return n===ze.FACE?t.faceRaycast(r,s,i):n===ze.LINE?t.lineRaycast(r,s,i):n===ze.POINT?t.pointRaycast(r,s,i):void 0===n?t.raycast(r,s,i):void 0}raycast(t,e,s){const i={ray:t,frustum:e,planes:s},n=this.castBox(e,s);return n.length?this.computeRaycastList(n,i):null}snapRaycast(t,e,s,i){const n=[],r={ray:t,frustum:e,planes:i},o=this.raycast(t,e,i);return o?(this.getSnaps(o,r,s,n),o.normal?this.filterOnFront(n):n):this.snapCastEdges(r,s)}rectangleRaycast(t,e,s){const i=this._boxes.lookup.collideFrustum(e,t,s),n=this.filterVisible(i);return this.localIdsFromItemIds(n)}snapCastEdges(t,e){const s=[],i=e.includes(ze.POINT),n=e.includes(ze.LINE);return(i||n)&&this.computeEdgesCast(t,e,s),this.addDistanceToEdgeResult(s,t.ray),s}filterVisible(t){const e=[];for(const s of t){this._meshes.samples(s,this._temp.sample);const t=this._temp.sample.item();this._items.visible(t)&&e.push(s)}return e}computeSnaps(t,e,s,i){for(const n of t){if(this.isValidSnap(n)){const t={snap:n,...e},r=this.castSample(s,t);for(const t of r)i.push(t)}}}computeEdgesCast(t,e,s){const i=this.getRawEdges(t),n=performance.now();for(const r of i){this.fetchSampleData(r),this.computeSnaps(e,t,r,s);if(this.isTimeExceeded(n))break}}addDistanceToEdgeResult(t,e){for(const s of t){const t=s.point;s.raySquaredDistance=e.distanceSqToPoint(t)}}getRawEdges(t){const e=this.castBox(t.frustum,t.planes);return e.length<=this._edgeThreshold?e:this.sortBoxes(t.ray,e,this._edgeThreshold)}sortBoxes(t,e,s){const i=[],n=new ft.Vector3,r=t.origin;for(let s=0;s<e.length;s++){const o=e[s],a=this._boxes.get(o);t.intersectBox(a,n);const l=n.distanceToSquared(r);i.push(l)}const o=this.dataSort(e,i);return s&&o.length>s&&o.splice(s),o}castBox(t,e){const s=this._boxes.lookup;if(t instanceof ft.Ray){const i=s.collideRay(e,t);return this.filterVisible(i)}const i=s.collideFrustum(e,t);return this.filterVisible(i)}dataSort(t,e){const s=Array.from(t.keys()).sort(((t,s)=>e[t]-e[s])),i=[];for(const e of s){const s=t[e];i.push(s)}return i}localIdsFromItemIds(t){const e=new Set;for(const s of t){this._meshes.samples(s,this._temp.sample);const t=this._temp.sample.item(),i=this._meshes.meshesItems(t);if(null===i)continue;const n=this._model.localIds(i);null!==n&&e.add(n)}return Array.from(e)}getNearest(t){let e=t[0];for(let s=1;s<t.length;s++){const i=t[s];if(e.raySquaredDistance&&i.raySquaredDistance){const t=this.getNearScore(e);this.getNearScore(i)<t&&(e=i)}else i.cameraSquaredDistance<e.cameraSquaredDistance&&(e=i)}return e}getEdges(t,e,s){const i=this.snapCastEdges(t,e);if(i)for(const t of i)s.push(t)}getNearScore(t){const e=this._raycastMultiplier;return t.raySquaredDistance*e+t.cameraSquaredDistance}setupSampleCastData(t){Ss.get(this._temp.sample,this._meshes,this._temp.m1),this._temp.m2.copy(this._temp.m1).invert(),this._temp.ray.copy(t.ray).applyMatrix4(this._temp.m2),ke.transform(t.frustum,this._temp.m2,this._temp.frustum)}addLocalId(t){if(!t)return;const e=this._meshes.meshesItems(t.itemId);null!==e&&(t.localId=this._model.localIds(e))}fetchSampleData(t){this._meshes.samples(t,this._temp.sample);const e=this._temp.sample.representation();this._meshes.representations(e,this._temp.representation)}computeRaycastList(t,e){const s=Array.from(new Set(t)),i=this.sortBoxes(e.ray,s),n=this.castBox(e.ray,e.planes),r=this.findAll(i,n,e);if(r.length){const t=this.getNearest(r);return this.addLocalId(t),t}return null}formatRaycastResult(t,e,s){for(const i of t){if(i.point.applyMatrix4(this._temp.m1),i.normal&&i.normal.transformDirection(this._temp.m1),"facePoints"in i){const t=this._meshes.samples(e,this._temp.sample);Ss.get(t,this._meshes,this._temp.m3);for(let t=0;t<i.facePoints.length;t+=3){const e=i.facePoints[t],s=i.facePoints[t+1],n=i.facePoints[t+2];this._temp.v1.set(e,s,n),this._temp.v1.applyMatrix4(this._temp.m3),i.facePoints[t]=this._temp.v1.x,i.facePoints[t+1]=this._temp.v1.y,i.facePoints[t+2]=this._temp.v1.z}}i.sampleId=e,i.itemId=this._temp.sample.item();const t=s.ray.origin.distanceToSquared(i.point);i.cameraSquaredDistance=t,i.snappingClass||(i.snappingClass=s.snap),i.snappedEdgeP1&&i.snappedEdgeP1.applyMatrix4(this._temp.m1),i.snappedEdgeP2&&i.snappedEdgeP2.applyMatrix4(this._temp.m1)}}findAll(t,e,s){const i=[],n=performance.now();for(const r of t){if(this.fetchSampleData(r),!e.includes(r))continue;const t=this.castSample(r,s);for(const e of t)i.push(e);if(this.isTimeExceeded(n))break}return i}isTimeExceeded(t){return performance.now()-t>this._maxDuration}getFilteredSampleCast(t){const e=this._tiles.raycast(this._temp.representation,this._temp.ray,this._temp.frustum,t.snap);if(0===this._temp.planes.length)return e;const s=[];if(e)for(const t of e){const e=this._temp.planes,i=t.point;Ge.containedInParallelPlanes(e,i)&&s.push(t)}return s}getSnaps(t,e,s,i){this.fetchSampleData(t.sampleId),t.normal&&(this.setCastSide(t,e.ray),this.setCastPlane(t)),this.getFaces(s,e,t,i),this.getEdges(e,s,i);for(const t of i)this.addLocalId(t)}filterOnFront(t){const e=[];for(const s of t){this._temp.tempPlane.distanceToPoint(s.point)>=0&&e.push(s)}return e}setCastSide(t,e){const s=t.point.clone().sub(e.origin);t.normal.dot(s)>0&&t.normal.negate()}getFaces(t,e,s,i){for(const n of t){const t={snap:n,...e},r=this.castSample(s.sampleId,t);for(const t of r)i.push(t)}}setCastPlane(t){const e=this._temp.tempPlane,s=t.point.clone(),i=t.normal.clone();i.multiplyScalar(this._precission),s.sub(i),e.setFromNormalAndCoplanarPoint(t.normal,s)}castSample(t,e){this.setupSampleCastData(e),this.setupPlanesForSampleCast(e);const s=this.getFilteredSampleCast(e);return s&&this.formatRaycastResult(s,t,e),s}isValidSnap(t){const e=t===ze.LINE,s=t===ze.POINT;return e||s}transform(t,e){const s=[];if(t)for(const i of t){const t=(new ft.Plane).copy(i);t.applyMatrix4(e),s.push(t)}return s}setupPlanesForSampleCast(t){if(this._temp.planes.length=0,t.planes&&t.planes.length>0){const e=this.transform(t.planes,this._temp.m2);for(const t of e)this._temp.planes.push(t)}}}const Cc="object"==typeof performance&&performance&&"function"==typeof performance.now?performance:Date,Tc=new Set,Ac="object"==typeof process&&process?process:{},Rc=(t,e,s,i)=>{"function"==typeof Ac.emitWarning?Ac.emitWarning(t,e,s,i):console.error(`[${s}] ${e}: ${t}`)};let yc=globalThis.AbortController,Fc=globalThis.AbortSignal;if(void 0===yc){Fc=class{constructor(){ot(this,"onabort"),ot(this,"_onabort",[]),ot(this,"reason"),ot(this,"aborted",!1)}addEventListener(t,e){this._onabort.push(e)}},yc=class{constructor(){ot(this,"signal",new Fc),s()}abort(t){var e,s;if(!this.signal.aborted){this.signal.reason=t,this.signal.aborted=!0;for(const e of this.signal._onabort)e(t);null==(s=(e=this.signal).onabort)||s.call(e,t)}}};let e="1"!==(null==(t=Ac.env)?void 0:t.LRU_CACHE_IGNORE_AC_WARNING);const s=()=>{e&&(e=!1,Rc("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",s))}}const Sc=t=>t&&t===Math.floor(t)&&t>0&&isFinite(t),wc=t=>Sc(t)?t<=Math.pow(2,8)?Uint8Array:t<=Math.pow(2,16)?Uint16Array:t<=Math.pow(2,32)?Uint32Array:t<=Number.MAX_SAFE_INTEGER?xc:null:null;class xc extends Array{constructor(t){super(t),this.fill(0)}}const Oc=class t{constructor(s,i){if(ot(this,"heap"),ot(this,"length"),!lt(t,e))throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new i(s),this.length=0}static create(s){const i=wc(s);if(!i)return[];ct(t,e,!0);const n=new t(s,i);return ct(t,e,!1),n}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}};e=new WeakMap,ht(Oc,e,!1);let vc=Oc;const Lc=class t{constructor(e){ht(this,S),ht(this,P),ht(this,V),ht(this,z),ht(this,k),ht(this,W),ht(this,q),ht(this,X),ht(this,K),ht(this,J),ht(this,et),ht(this,it),ht(this,s,void 0),ht(this,i,void 0),ht(this,n,void 0),ht(this,r,void 0),ht(this,o,void 0),ht(this,a,void 0),ht(this,l,void 0),ot(this,"ttl"),ot(this,"ttlResolution"),ot(this,"ttlAutopurge"),ot(this,"updateAgeOnGet"),ot(this,"updateAgeOnHas"),ot(this,"allowStale"),ot(this,"noDisposeOnSet"),ot(this,"noUpdateTTL"),ot(this,"maxEntrySize"),ot(this,"sizeCalculation"),ot(this,"noDeleteOnFetchRejection"),ot(this,"noDeleteOnStaleGet"),ot(this,"allowStaleOnFetchAbort"),ot(this,"allowStaleOnFetchRejection"),ot(this,"ignoreFetchAbort"),ht(this,h,void 0),ht(this,c,void 0),ht(this,d,void 0),ht(this,u,void 0),ht(this,f,void 0),ht(this,p,void 0),ht(this,I,void 0),ht(this,_,void 0),ht(this,m,void 0),ht(this,E,void 0),ht(this,g,void 0),ht(this,b,void 0),ht(this,C,void 0),ht(this,T,void 0),ht(this,A,void 0),ht(this,R,void 0),ht(this,y,void 0),ht(this,F,void 0),ht(this,x,(()=>{})),ht(this,O,(()=>{})),ht(this,v,(()=>{})),ht(this,L,(()=>!1)),ht(this,M,(t=>{})),ht(this,D,((t,e,s)=>{})),ht(this,U,((t,e,s,i)=>{if(s||i)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0})),ot(this,Y,"LRUCache");const{max:B=0,ttl:G,ttlResolution:H=1,ttlAutopurge:j,updateAgeOnGet:Z,updateAgeOnHas:$,allowStale:Q,dispose:tt,onInsert:st,disposeAfter:nt,noDisposeOnSet:rt,noUpdateTTL:at,maxSize:dt=0,maxEntrySize:ft=0,sizeCalculation:pt,fetchMethod:It,memoMethod:_t,noDeleteOnFetchRejection:mt,noDeleteOnStaleGet:Et,allowStaleOnFetchRejection:gt,allowStaleOnFetchAbort:bt,ignoreFetchAbort:Ct}=e;if(0!==B&&!Sc(B))throw new TypeError("max option must be a nonnegative integer");const Tt=B?wc(B):Array;if(!Tt)throw new Error("invalid max value: "+B);if(ct(this,s,B),ct(this,i,dt),this.maxEntrySize=ft||lt(this,i),this.sizeCalculation=pt,this.sizeCalculation){if(!lt(this,i)&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if("function"!=typeof this.sizeCalculation)throw new TypeError("sizeCalculation set to non-function")}if(void 0!==_t&&"function"!=typeof _t)throw new TypeError("memoMethod must be a function if defined");if(ct(this,l,_t),void 0!==It&&"function"!=typeof It)throw new TypeError("fetchMethod must be a function if specified");if(ct(this,a,It),ct(this,R,!!It),ct(this,d,new Map),ct(this,u,new Array(B).fill(void 0)),ct(this,f,new Array(B).fill(void 0)),ct(this,p,new Tt(B)),ct(this,I,new Tt(B)),ct(this,_,0),ct(this,m,0),ct(this,E,vc.create(B)),ct(this,h,0),ct(this,c,0),"function"==typeof tt&&ct(this,n,tt),"function"==typeof st&&ct(this,r,st),"function"==typeof nt?(ct(this,o,nt),ct(this,g,[])):(ct(this,o,void 0),ct(this,g,void 0)),ct(this,A,!!lt(this,n)),ct(this,F,!!lt(this,r)),ct(this,y,!!lt(this,o)),this.noDisposeOnSet=!!rt,this.noUpdateTTL=!!at,this.noDeleteOnFetchRejection=!!mt,this.allowStaleOnFetchRejection=!!gt,this.allowStaleOnFetchAbort=!!bt,this.ignoreFetchAbort=!!Ct,0!==this.maxEntrySize){if(0!==lt(this,i)&&!Sc(lt(this,i)))throw new TypeError("maxSize must be a positive integer if specified");if(!Sc(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");ut(this,P,N).call(this)}if(this.allowStale=!!Q,this.noDeleteOnStaleGet=!!Et,this.updateAgeOnGet=!!Z,this.updateAgeOnHas=!!$,this.ttlResolution=Sc(H)||0===H?H:1,this.ttlAutopurge=!!j,this.ttl=G||0,this.ttl){if(!Sc(this.ttl))throw new TypeError("ttl must be a positive integer if specified");ut(this,S,w).call(this)}if(0===lt(this,s)&&0===this.ttl&&0===lt(this,i))throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!lt(this,s)&&!lt(this,i)){const e="LRU_CACHE_UNBOUNDED";if((t=>!Tc.has(t))(e)){Tc.add(e);Rc("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",e,t)}}}static unsafeExposeInternals(t){return{starts:lt(t,C),ttls:lt(t,T),sizes:lt(t,b),keyMap:lt(t,d),keyList:lt(t,u),valList:lt(t,f),next:lt(t,p),prev:lt(t,I),get head(){return lt(t,_)},get tail(){return lt(t,m)},free:lt(t,E),isBackgroundFetch:e=>{var s;return ut(s=t,X,$).call(s,e)},backgroundFetch:(e,s,i,n)=>{var r;return ut(r=t,q,Z).call(r,e,s,i,n)},moveToTail:e=>{var s;return ut(s=t,J,tt).call(s,e)},indexes:e=>{var s;return ut(s=t,V,B).call(s,e)},rindexes:e=>{var s;return ut(s=t,z,G).call(s,e)},isStale:e=>{var s;return lt(s=t,L).call(s,e)}}}get max(){return lt(this,s)}get maxSize(){return lt(this,i)}get calculatedSize(){return lt(this,c)}get size(){return lt(this,h)}get fetchMethod(){return lt(this,a)}get memoMethod(){return lt(this,l)}get dispose(){return lt(this,n)}get onInsert(){return lt(this,r)}get disposeAfter(){return lt(this,o)}getRemainingTTL(t){return lt(this,d).has(t)?1/0:0}*entries(){for(const t of ut(this,V,B).call(this))void 0===lt(this,f)[t]||void 0===lt(this,u)[t]||ut(this,X,$).call(this,lt(this,f)[t])||(yield[lt(this,u)[t],lt(this,f)[t]])}*rentries(){for(const t of ut(this,z,G).call(this))void 0===lt(this,f)[t]||void 0===lt(this,u)[t]||ut(this,X,$).call(this,lt(this,f)[t])||(yield[lt(this,u)[t],lt(this,f)[t]])}*keys(){for(const t of ut(this,V,B).call(this)){const e=lt(this,u)[t];void 0===e||ut(this,X,$).call(this,lt(this,f)[t])||(yield e)}}*rkeys(){for(const t of ut(this,z,G).call(this)){const e=lt(this,u)[t];void 0===e||ut(this,X,$).call(this,lt(this,f)[t])||(yield e)}}*values(){for(const t of ut(this,V,B).call(this)){void 0===lt(this,f)[t]||ut(this,X,$).call(this,lt(this,f)[t])||(yield lt(this,f)[t])}}*rvalues(){for(const t of ut(this,z,G).call(this)){void 0===lt(this,f)[t]||ut(this,X,$).call(this,lt(this,f)[t])||(yield lt(this,f)[t])}}[Symbol.iterator](){return this.entries()}find(t,e={}){for(const s of ut(this,V,B).call(this)){const i=lt(this,f)[s],n=ut(this,X,$).call(this,i)?i.__staleWhileFetching:i;if(void 0!==n&&t(n,lt(this,u)[s],this))return this.get(lt(this,u)[s],e)}}forEach(t,e=this){for(const s of ut(this,V,B).call(this)){const i=lt(this,f)[s],n=ut(this,X,$).call(this,i)?i.__staleWhileFetching:i;void 0!==n&&t.call(e,n,lt(this,u)[s],this)}}rforEach(t,e=this){for(const s of ut(this,z,G).call(this)){const i=lt(this,f)[s],n=ut(this,X,$).call(this,i)?i.__staleWhileFetching:i;void 0!==n&&t.call(e,n,lt(this,u)[s],this)}}purgeStale(){let t=!1;for(const e of ut(this,z,G).call(this,{allowStale:!0}))lt(this,L).call(this,e)&&(ut(this,et,st).call(this,lt(this,u)[e],"expire"),t=!0);return t}info(t){const e=lt(this,d).get(t);if(void 0===e)return;const s=lt(this,f)[e],i=ut(this,X,$).call(this,s)?s.__staleWhileFetching:s;if(void 0===i)return;const n={value:i};if(lt(this,T)&&lt(this,C)){const t=lt(this,T)[e],s=lt(this,C)[e];if(t&&s){const e=t-(Cc.now()-s);n.ttl=e,n.start=Date.now()}}return lt(this,b)&&(n.size=lt(this,b)[e]),n}dump(){const t=[];for(const e of ut(this,V,B).call(this,{allowStale:!0})){const s=lt(this,u)[e],i=lt(this,f)[e],n=ut(this,X,$).call(this,i)?i.__staleWhileFetching:i;if(void 0===n||void 0===s)continue;const r={value:n};if(lt(this,T)&&lt(this,C)){r.ttl=lt(this,T)[e];const t=Cc.now()-lt(this,C)[e];r.start=Math.floor(Date.now()-t)}lt(this,b)&&(r.size=lt(this,b)[e]),t.unshift([s,r])}return t}load(t){this.clear();for(const[e,s]of t){if(s.start){const t=Date.now()-s.start;s.start=Cc.now()-t}this.set(e,s.value,s)}}set(t,e,i={}){var a,l,c,_,b,C,x;if(void 0===e)return this.delete(t),this;const{ttl:L=this.ttl,start:P,noDisposeOnSet:N=this.noDisposeOnSet,sizeCalculation:V=this.sizeCalculation,status:B}=i;let{noUpdateTTL:z=this.noUpdateTTL}=i;const G=lt(this,U).call(this,t,e,i.size||0,V);if(this.maxEntrySize&&G>this.maxEntrySize)return B&&(B.set="miss",B.maxEntrySizeExceeded=!0),ut(this,et,st).call(this,t,"set"),this;let k=0===lt(this,h)?void 0:lt(this,d).get(t);if(void 0===k)k=0===lt(this,h)?lt(this,m):0!==lt(this,E).length?lt(this,E).pop():lt(this,h)===lt(this,s)?ut(this,W,j).call(this,!1):lt(this,h),lt(this,u)[k]=t,lt(this,f)[k]=e,lt(this,d).set(t,k),lt(this,p)[lt(this,m)]=k,lt(this,I)[k]=lt(this,m),ct(this,m,k),dt(this,h)._++,lt(this,D).call(this,k,G,B),B&&(B.set="add"),z=!1,lt(this,F)&&(null==(a=lt(this,r))||a.call(this,e,t,"add"));else{ut(this,J,tt).call(this,k);const s=lt(this,f)[k];if(e!==s){if(lt(this,R)&&ut(this,X,$).call(this,s)){s.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:e}=s;void 0===e||N||(lt(this,A)&&(null==(l=lt(this,n))||l.call(this,e,t,"set")),lt(this,y)&&(null==(c=lt(this,g))||c.push([e,t,"set"])))}else N||(lt(this,A)&&(null==(_=lt(this,n))||_.call(this,s,t,"set")),lt(this,y)&&(null==(b=lt(this,g))||b.push([s,t,"set"])));if(lt(this,M).call(this,k),lt(this,D).call(this,k,G,B),lt(this,f)[k]=e,B){B.set="replace";const t=s&&ut(this,X,$).call(this,s)?s.__staleWhileFetching:s;void 0!==t&&(B.oldValue=t)}}else B&&(B.set="update");lt(this,F)&&(null==(C=this.onInsert)||C.call(this,e,t,e===s?"update":"replace"))}if(0===L||lt(this,T)||ut(this,S,w).call(this),lt(this,T)&&(z||lt(this,v).call(this,k,L,P),B&&lt(this,O).call(this,B,k)),!N&&lt(this,y)&&lt(this,g)){const t=lt(this,g);let e;for(;e=null==t?void 0:t.shift();)null==(x=lt(this,o))||x.call(this,...e)}return this}pop(){var t;try{for(;lt(this,h);){const t=lt(this,f)[lt(this,_)];if(ut(this,W,j).call(this,!0),ut(this,X,$).call(this,t)){if(t.__staleWhileFetching)return t.__staleWhileFetching}else if(void 0!==t)return t}}finally{if(lt(this,y)&&lt(this,g)){const e=lt(this,g);let s;for(;s=null==e?void 0:e.shift();)null==(t=lt(this,o))||t.call(this,...s)}}}has(t,e={}){const{updateAgeOnHas:s=this.updateAgeOnHas,status:i}=e,n=lt(this,d).get(t);if(void 0!==n){const t=lt(this,f)[n];if(ut(this,X,$).call(this,t)&&void 0===t.__staleWhileFetching)return!1;if(!lt(this,L).call(this,n))return s&&lt(this,x).call(this,n),i&&(i.has="hit",lt(this,O).call(this,i,n)),!0;i&&(i.has="stale",lt(this,O).call(this,i,n))}else i&&(i.has="miss");return!1}peek(t,e={}){const{allowStale:s=this.allowStale}=e,i=lt(this,d).get(t);if(void 0===i||!s&&lt(this,L).call(this,i))return;const n=lt(this,f)[i];return ut(this,X,$).call(this,n)?n.__staleWhileFetching:n}async fetch(t,e={}){const{allowStale:s=this.allowStale,updateAgeOnGet:i=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,ttl:r=this.ttl,noDisposeOnSet:o=this.noDisposeOnSet,size:a=0,sizeCalculation:l=this.sizeCalculation,noUpdateTTL:h=this.noUpdateTTL,noDeleteOnFetchRejection:c=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:u=this.allowStaleOnFetchRejection,ignoreFetchAbort:p=this.ignoreFetchAbort,allowStaleOnFetchAbort:I=this.allowStaleOnFetchAbort,context:_,forceRefresh:m=!1,status:E,signal:g}=e;if(!lt(this,R))return E&&(E.fetch="get"),this.get(t,{allowStale:s,updateAgeOnGet:i,noDeleteOnStaleGet:n,status:E});const b={allowStale:s,updateAgeOnGet:i,noDeleteOnStaleGet:n,ttl:r,noDisposeOnSet:o,size:a,sizeCalculation:l,noUpdateTTL:h,noDeleteOnFetchRejection:c,allowStaleOnFetchRejection:u,allowStaleOnFetchAbort:I,ignoreFetchAbort:p,status:E,signal:g};let C=lt(this,d).get(t);if(void 0===C){E&&(E.fetch="miss");const e=ut(this,q,Z).call(this,t,C,b,_);return e.__returned=e}{const e=lt(this,f)[C];if(ut(this,X,$).call(this,e)){const t=s&&void 0!==e.__staleWhileFetching;return E&&(E.fetch="inflight",t&&(E.returnedStale=!0)),t?e.__staleWhileFetching:e.__returned=e}const n=lt(this,L).call(this,C);if(!m&&!n)return E&&(E.fetch="hit"),ut(this,J,tt).call(this,C),i&&lt(this,x).call(this,C),E&&lt(this,O).call(this,E,C),e;const r=ut(this,q,Z).call(this,t,C,b,_),o=void 0!==r.__staleWhileFetching&&s;return E&&(E.fetch=n?"stale":"refresh",o&&n&&(E.returnedStale=!0)),o?r.__staleWhileFetching:r.__returned=r}}async forceFetch(t,e={}){const s=await this.fetch(t,e);if(void 0===s)throw new Error("fetch() returned undefined");return s}memo(t,e={}){const s=lt(this,l);if(!s)throw new Error("no memoMethod provided to constructor");const{context:i,forceRefresh:n,...r}=e,o=this.get(t,r);if(!n&&void 0!==o)return o;const a=s(t,o,{options:r,context:i});return this.set(t,a,r),a}get(t,e={}){const{allowStale:s=this.allowStale,updateAgeOnGet:i=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,status:r}=e,o=lt(this,d).get(t);if(void 0!==o){const e=lt(this,f)[o],a=ut(this,X,$).call(this,e);return r&&lt(this,O).call(this,r,o),lt(this,L).call(this,o)?(r&&(r.get="stale"),a?(r&&s&&void 0!==e.__staleWhileFetching&&(r.returnedStale=!0),s?e.__staleWhileFetching:void 0):(n||ut(this,et,st).call(this,t,"expire"),r&&s&&(r.returnedStale=!0),s?e:void 0)):(r&&(r.get="hit"),a?e.__staleWhileFetching:(ut(this,J,tt).call(this,o),i&&lt(this,x).call(this,o),e))}r&&(r.get="miss")}delete(t){return ut(this,et,st).call(this,t,"delete")}clear(){return ut(this,it,nt).call(this,"delete")}};Y=Symbol.toStringTag,s=new WeakMap,i=new WeakMap,n=new WeakMap,r=new WeakMap,o=new WeakMap,a=new WeakMap,l=new WeakMap,h=new WeakMap,c=new WeakMap,d=new WeakMap,u=new WeakMap,f=new WeakMap,p=new WeakMap,I=new WeakMap,_=new WeakMap,m=new WeakMap,E=new WeakMap,g=new WeakMap,b=new WeakMap,C=new WeakMap,T=new WeakMap,A=new WeakMap,R=new WeakMap,y=new WeakMap,F=new WeakMap,S=new WeakSet,w=function(){const t=new xc(lt(this,s)),e=new xc(lt(this,s));ct(this,T,t),ct(this,C,e),ct(this,v,((s,i,n=Cc.now())=>{if(e[s]=0!==i?n:0,t[s]=i,0!==i&&this.ttlAutopurge){const t=setTimeout((()=>{lt(this,L).call(this,s)&&ut(this,et,st).call(this,lt(this,u)[s],"expire")}),i+1);t.unref&&t.unref()}})),ct(this,x,(s=>{e[s]=0!==t[s]?Cc.now():0})),ct(this,O,((s,r)=>{if(t[r]){const o=t[r],a=e[r];if(!o||!a)return;s.ttl=o,s.start=a,s.now=i||n();const l=s.now-a;s.remainingTTL=o-l}}));let i=0;const n=()=>{const t=Cc.now();if(this.ttlResolution>0){i=t;const e=setTimeout((()=>i=0),this.ttlResolution);e.unref&&e.unref()}return t};this.getRemainingTTL=s=>{const r=lt(this,d).get(s);if(void 0===r)return 0;const o=t[r],a=e[r];if(!o||!a)return 1/0;return o-((i||n())-a)},ct(this,L,(s=>{const r=e[s],o=t[s];return!!o&&!!r&&(i||n())-r>o}))},x=new WeakMap,O=new WeakMap,v=new WeakMap,L=new WeakMap,P=new WeakSet,N=function(){const t=new xc(lt(this,s));ct(this,c,0),ct(this,b,t),ct(this,M,(e=>{ct(this,c,lt(this,c)-t[e]),t[e]=0})),ct(this,U,((t,e,s,i)=>{if(ut(this,X,$).call(this,e))return 0;if(!Sc(s)){if(!i)throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");if("function"!=typeof i)throw new TypeError("sizeCalculation must be a function");if(s=i(e,t),!Sc(s))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}return s})),ct(this,D,((e,s,n)=>{if(t[e]=s,lt(this,i)){const s=lt(this,i)-t[e];for(;lt(this,c)>s;)ut(this,W,j).call(this,!0)}ct(this,c,lt(this,c)+t[e]),n&&(n.entrySize=s,n.totalCalculatedSize=lt(this,c))}))},M=new WeakMap,D=new WeakMap,U=new WeakMap,V=new WeakSet,B=function*({allowStale:t=this.allowStale}={}){if(lt(this,h))for(let e=lt(this,m);ut(this,k,H).call(this,e)&&(!t&&lt(this,L).call(this,e)||(yield e),e!==lt(this,_));)e=lt(this,I)[e]},z=new WeakSet,G=function*({allowStale:t=this.allowStale}={}){if(lt(this,h))for(let e=lt(this,_);ut(this,k,H).call(this,e)&&(!t&&lt(this,L).call(this,e)||(yield e),e!==lt(this,m));)e=lt(this,p)[e]},k=new WeakSet,H=function(t){return void 0!==t&&lt(this,d).get(lt(this,u)[t])===t},W=new WeakSet,j=function(t){var e,s;const i=lt(this,_),r=lt(this,u)[i],o=lt(this,f)[i];return lt(this,R)&&ut(this,X,$).call(this,o)?o.__abortController.abort(new Error("evicted")):(lt(this,A)||lt(this,y))&&(lt(this,A)&&(null==(e=lt(this,n))||e.call(this,o,r,"evict")),lt(this,y)&&(null==(s=lt(this,g))||s.push([o,r,"evict"]))),lt(this,M).call(this,i),t&&(lt(this,u)[i]=void 0,lt(this,f)[i]=void 0,lt(this,E).push(i)),1===lt(this,h)?(ct(this,_,ct(this,m,0)),lt(this,E).length=0):ct(this,_,lt(this,p)[i]),lt(this,d).delete(r),dt(this,h)._--,i},q=new WeakSet,Z=function(t,e,s,i){const n=void 0===e?void 0:lt(this,f)[e];if(ut(this,X,$).call(this,n))return n;const r=new yc,{signal:o}=s;null==o||o.addEventListener("abort",(()=>r.abort(o.reason)),{signal:r.signal});const l={signal:r.signal,options:s,context:i},h=(i,n=!1)=>{const{aborted:o}=r.signal,a=s.ignoreFetchAbort&&void 0!==i;if(s.status&&(o&&!n?(s.status.fetchAborted=!0,s.status.fetchError=r.signal.reason,a&&(s.status.fetchAbortIgnored=!0)):s.status.fetchResolved=!0),o&&!a&&!n)return c(r.signal.reason);const h=u;return lt(this,f)[e]===u&&(void 0===i?h.__staleWhileFetching?lt(this,f)[e]=h.__staleWhileFetching:ut(this,et,st).call(this,t,"fetch"):(s.status&&(s.status.fetchUpdated=!0),this.set(t,i,l.options))),i},c=i=>{const{aborted:n}=r.signal,o=n&&s.allowStaleOnFetchAbort,a=o||s.allowStaleOnFetchRejection,l=a||s.noDeleteOnFetchRejection,h=u;if(lt(this,f)[e]===u){!l||void 0===h.__staleWhileFetching?ut(this,et,st).call(this,t,"fetch"):o||(lt(this,f)[e]=h.__staleWhileFetching)}if(a)return s.status&&void 0!==h.__staleWhileFetching&&(s.status.returnedStale=!0),h.__staleWhileFetching;if(h.__returned===h)throw i};s.status&&(s.status.fetchDispatched=!0);const u=new Promise(((e,i)=>{var o;const c=null==(o=lt(this,a))?void 0:o.call(this,t,n,l);c&&c instanceof Promise&&c.then((t=>e(void 0===t?void 0:t)),i),r.signal.addEventListener("abort",(()=>{s.ignoreFetchAbort&&!s.allowStaleOnFetchAbort||(e(void 0),s.allowStaleOnFetchAbort&&(e=t=>h(t,!0)))}))})).then(h,(t=>(s.status&&(s.status.fetchRejected=!0,s.status.fetchError=t),c(t)))),p=Object.assign(u,{__abortController:r,__staleWhileFetching:n,__returned:void 0});return void 0===e?(this.set(t,p,{...l.options,status:void 0}),e=lt(this,d).get(t)):lt(this,f)[e]=p,p},X=new WeakSet,$=function(t){if(!lt(this,R))return!1;const e=t;return!!e&&e instanceof Promise&&e.hasOwnProperty("__staleWhileFetching")&&e.__abortController instanceof yc},K=new WeakSet,Q=function(t,e){lt(this,I)[e]=t,lt(this,p)[t]=e},J=new WeakSet,tt=function(t){t!==lt(this,m)&&(t===lt(this,_)?ct(this,_,lt(this,p)[t]):ut(this,K,Q).call(this,lt(this,I)[t],lt(this,p)[t]),ut(this,K,Q).call(this,lt(this,m),t),ct(this,m,t))},et=new WeakSet,st=function(t,e){var s,i,r,a;let l=!1;if(0!==lt(this,h)){const r=lt(this,d).get(t);if(void 0!==r)if(l=!0,1===lt(this,h))ut(this,it,nt).call(this,e);else{lt(this,M).call(this,r);const o=lt(this,f)[r];if(ut(this,X,$).call(this,o)?o.__abortController.abort(new Error("deleted")):(lt(this,A)||lt(this,y))&&(lt(this,A)&&(null==(s=lt(this,n))||s.call(this,o,t,e)),lt(this,y)&&(null==(i=lt(this,g))||i.push([o,t,e]))),lt(this,d).delete(t),lt(this,u)[r]=void 0,lt(this,f)[r]=void 0,r===lt(this,m))ct(this,m,lt(this,I)[r]);else if(r===lt(this,_))ct(this,_,lt(this,p)[r]);else{const t=lt(this,I)[r];lt(this,p)[t]=lt(this,p)[r];const e=lt(this,p)[r];lt(this,I)[e]=lt(this,I)[r]}dt(this,h)._--,lt(this,E).push(r)}}if(lt(this,y)&&(null==(r=lt(this,g))?void 0:r.length)){const t=lt(this,g);let e;for(;e=null==t?void 0:t.shift();)null==(a=lt(this,o))||a.call(this,...e)}return l},it=new WeakSet,nt=function(t){var e,s,i;for(const i of ut(this,z,G).call(this,{allowStale:!0})){const r=lt(this,f)[i];if(ut(this,X,$).call(this,r))r.__abortController.abort(new Error("deleted"));else{const o=lt(this,u)[i];lt(this,A)&&(null==(e=lt(this,n))||e.call(this,r,o,t)),lt(this,y)&&(null==(s=lt(this,g))||s.push([r,o,t]))}}if(lt(this,d).clear(),lt(this,f).fill(void 0),lt(this,u).fill(void 0),lt(this,T)&&lt(this,C)&&(lt(this,T).fill(0),lt(this,C).fill(0)),lt(this,b)&&lt(this,b).fill(0),ct(this,_,0),ct(this,m,0),lt(this,E).length=0,ct(this,c,0),ct(this,h,0),lt(this,y)&&lt(this,g)){const t=lt(this,g);let e;for(;e=null==t?void 0:t.shift();)null==(i=lt(this,o))||i.call(this,...e)}};let Pc=Lc;const Nc=class{static get(t){return this._meshes.get(t)}static lockIn(t){Object.seal(t)}static add(t,e){this._meshes.set(t,e)}static delete(t){for(const e of t)this._meshes.delete(e)}static setCapacity(t){t!==this._capacity&&(this._meshes.clear(),this._meshes=this.setupMeshes(t),this._capacity=t)}static setupMeshes(t){const e=Math.max(t??this.computeCapacity(),1),s=this.getSizeCalculationEvent();return new Pc({maxSize:e,sizeCalculation:s})}static computeCapacity(){const t=globalThis.navigator&&"deviceMemory"in globalThis.navigator?globalThis.navigator.deviceMemory:null,e=null!==t?t:2,s=this.oneHundredMb*e;return Math.trunc(s)}static getDataSetMemory(t){let e=0;for(const s of t)e+=s.usedMemory;return Math.max(e,1)}static getSizeCalculationEvent(){return t=>Array.isArray(t)?this.getDataSetMemory(t):Math.max(t.usedMemory,1)}};ot(Nc,"oneHundredMb",1e8),ot(Nc,"_meshes",Nc.setupMeshes()),ot(Nc,"_capacity"),ot(Nc,"_memoryAttributes",["positionBuffer","indexBuffer","normalBuffer"]),ot(Nc,"updateMeshMemory",(t=>{t.usedMemory=0;for(const e of Nc._memoryAttributes)void 0!==t.usedMemory&&t[e]&&(t.usedMemory+=t[e].byteLength);Nc.lockIn(t)}));let Mc=Nc;const Dc=class t{constructor(t){ot(this,"meshes"),ot(this,"tilesUpdated",!1),ot(this,"_sampleAmount"),ot(this,"_tileDimension"),ot(this,"_tileBySample"),ot(this,"_lodBySample"),ot(this,"_virtualMeshes",new Map),ot(this,"_meshConnection"),ot(this,"_samples"),ot(this,"_tileIdGenerator",new gs),ot(this,"_tiles",new Map),ot(this,"_tilesChanged",new Set),ot(this,"_sizeByTile",new Map),ot(this,"_samplesDimensions"),ot(this,"_sampleLodClass"),ot(this,"_sampleLodState"),ot(this,"_sampleLodSize"),ot(this,"_boxes"),ot(this,"_items"),ot(this,"_materials"),ot(this,"_modelId"),ot(this,"_lastView",{rotation:new ft.Vector3,location:new ft.Vector3}),ot(this,"_params",{updateTime:16,updateSamples:64,updateviewOrientation:8*Math.PI/180,updateViewPosition:256,smallTileSize:.32,mediumTileSize:4,smallObjectSize:2,smallScreenSize:2,mediumScreenSize:4,largeScreenSize:16,tempTileDataSize:6,tileIdIncrement:1,tileSizeMultiplier:10,minTileDimension:32,tileDimensionFactor:8}),ot(this,"_temp",{sample:new Te,representation:new Ce,vector:new ft.Vector3,matrix:new ft.Matrix4,transform:new ft.Matrix4,boundingBox:new ft.Box3,sampleGeometry:{},box:new ft.Box3,raycastPoints:[],tileData:{positionCount:this._params.tempTileDataSize,objectClass:Me.LINE,positionBuffer:new Float32Array(this._params.tempTileDataSize)},tileCenter:new ft.Vector3,tile:{objectClass:Me.LINE,positionCount:6},viewDimension:0,pastFieldOfview:0}),ot(this,"_currentSample",0),ot(this,"_virtualPlanes",[]),ot(this,"_changedSamples",0),ot(this,"_virtualView"),this._modelId=t.modelId,this._boxes=t.boxes,this._items=t.items,this._materials=t.materials,this._meshConnection=new gc(t.modelId,t.connection),this.meshes=t.model.meshes(),this._sampleAmount=this.meshes.samplesLength(),this._samples=new Ec(this._sampleAmount),this._samplesDimensions=new Int32Array(this._sampleAmount),this._sampleLodClass=new Uint8Array(this._sampleAmount),this._sampleLodState=new Uint8Array(this._sampleAmount),this._sampleLodSize=new Float32Array(this._sampleAmount),this._tileDimension=this.computeTileSize(),this._tileBySample=new Array(this._sampleAmount),this._lodBySample=new Array(this._sampleAmount),this.init()}restart(){this.resetUpdateProcess(),this._meshConnection.clean()}fetchSample(t,e){this.fetchSampleAndRepresentation(t);const s=this.fetchCurrentMesh(),i=this.sampleTemplate(t);return i.geometries=this.sampleGeoms(i,e,s),i}dispose(){this._meshConnection.dispose();for(const[,t]of this._virtualMeshes)t.dispose()}generate(){for(const[,t]of this._virtualMeshes)t.setupTemplates();for(let t=0;t<this._sampleAmount;t++)this.generateSampleInTiles(t);this.setupTileVisibilityAndHighlight()}setupView(t){this._virtualView=t,Mc.setCapacity(t.meshThreshold),this.restart(),this.updateOrientationIfNeeded(),this.updatePositionIfNeeded(),this.setupViewPlanes()}updateVirtualMeshes(t){if(t&&this._virtualView){for(const e of t)this.updateItem(e);this.restart()}}getSampleTransform(t){this.fetchSampleAndRepresentation(t);return this.sampleTemplate(t).transform}async update(t){this.updateTiles(t),this.notifyUpdateFinished();for(const t of this._tilesChanged){const e=this._tiles.get(t);this._meshConnection.process({tileRequestClass:De.UPDATE,modelId:this._modelId,tileId:t,objectClass:e.objectClass,material:e.materialId,tileData:this.getTileData(e),currentLod:e.lod})}this._tilesChanged.clear()}raycast(t,e,s,i){this._temp.raycastPoints=[];const n=t.representationClass(),r=this._virtualMeshes.get(n);return this.manageRaycast(r,t,e,s,i),this._temp.raycastPoints}init(){const t=new lc(this._modelId,this.meshes),e=t.getRepresentation();this._virtualMeshes.set(e,t);const s=new mc(this._modelId,this.meshes),i=s.getRepresentation();this._virtualMeshes.set(i,s),this.processSamplesDimension(),this.fetchSampleLodSize()}initSampleLod(t){this.fetchSampleAndRepresentation(t);const e=this.fetchCurrentMesh();this._sampleLodClass[t]=e.getLodClass(),this._sampleLodState[t]=Ue.INVISIBLE}fetchSampleAndRepresentation(t){this.meshes.samples(t,this._temp.sample),this.meshes.representations(this._temp.sample.representation(),this._temp.representation)}fetchCurrentMesh(){const t=this._temp.representation.representationClass();return this._virtualMeshes.get(t)}fetchCurrentMaterial(){const t=this._temp.sample.material();return this._materials[t]}fetchSampleLodSize(){for(let t=0;t<this._sampleAmount;t++)this.initSampleLod(t),Ss.getBox(this._temp.representation,this._temp.box),this._sampleLodSize[t]=ws.getWidth(this._temp.box)}setupTileVisibilityAndHighlight(){for(const[,t]of this._tiles)t.visibilities=new Cs(t.size,!1),t.highlights=new Cs(t.size,0)}addLodToTile(t,e,s){t.getLodClass()!==Th.AABB?t.getLodClass()===Th.CUSTOM&&this.addCustomLodToTile(t,e,s):this.addBoxLodToTile(e,s)}addBoxLodToTile(t,e){this._lodBySample[t]=this.lodTileAppendSample(t,e)}notifyUpdateFinished(){const t=!this.tilesUpdated;this._changedSamples>=this._sampleAmount&&t&&(this._meshConnection.process({tileRequestClass:De.FINISH,modelId:this._modelId}),this.tilesUpdated=!0)}updatePositionIfNeeded(){const t=this._params.updateViewPosition,e=this._virtualView.cameraPosition;e.distanceToSquared(this._lastView.location)>t&&(this._currentSample=0,this._lastView.location.copy(e))}updateCurrentSample(){this._currentSample++,this._currentSample>=this._sampleAmount&&(this._currentSample=0),this._changedSamples++}processSamplesDimension(){for(let t=0;t<this._sampleAmount;t++)this._samplesDimensions[t]=t;this._samplesDimensions.sort(((t,e)=>this._boxes.dimensionOf(e)-this._boxes.dimensionOf(t)))}setupViewPlanes(){this._virtualPlanes=[];for(const t of this._virtualView.cameraFrustum.planes)this._virtualPlanes.push(t);if(this._virtualView.clippingPlanes)for(const t of this._virtualView.clippingPlanes)this._virtualPlanes.push(t)}updateOrientationIfNeeded(){const t=this.getCurrentViewOrientation(),e=this._params.updateviewOrientation;t.angleTo(this._lastView.rotation)>e&&(this._currentSample=0,this._lastView.rotation.copy(t))}getCurrentViewOrientation(){return this._virtualView.cameraFrustum.planes[4].normal}resetUpdateProcess(){this._changedSamples=0,this.tilesUpdated=!1}manageRaycast(t,e,s,i,n){const r=bc.cast(t,e,s,i,n);if(r)for(const e of r)e.representationClass=t.getObjectClass(),this._temp.raycastPoints.push(e)}setTileShellBuffer(t){void 0!==t.usedMemory&&t.objectClass===Me.SHELL&&(t.ids=new Float32Array(t.positionCount/3),t.usedMemory+=t.ids.byteLength)}getTileWhenSamplePut(t,e,s){let i=this._tiles.get(t);if(void 0===i){const n=e.lod||Ue.GEOMETRY;i=this.newTile(e.objectClass,s,n),this._tiles.set(t,i)}return i}getPerspTrueDim(t,e){const s=Math.PI/180;return e*Math.tan(.5*t*s)}getTileHighlight(t,e){let s,i;const n=t.highlights;if(!n)return{highlightData:void 0,highlightIds:void 0};const r=n.size((t=>0!==t));if(r>0){i=new Uint16Array(r);const t=t=>0!==t,o=(t,e)=>i[t]=e;s=Cs.get(n,e,t,o)}return{highlightData:s,highlightIds:i}}setupTileSampleAttributes(t,e,s,i){const n=3*t.vertexLocation[e];for(let e=0;e<s.positionBuffer.length;e+=3)this._temp.vector.fromArray(s.positionBuffer,e),this._temp.vector.applyMatrix4(this._temp.matrix),this._temp.vector.toArray(t.positionBuffer,n+e);if(t.normalBuffer){const i=3*t.vertexLocation[e];for(let e=0;e<s.normalBuffer.length;e+=3)this._temp.vector.fromArray(s.normalBuffer,e),this._temp.vector.transformDirection(this._temp.matrix),this._temp.vector.multiplyScalar(Ch),this._temp.vector.toArray(t.normalBuffer,i+e)}if(t.indexBuffer){const i=t.indexLocation[e],n=t.vertexLocation[e];for(let e=0;e<s.indexCount;e++){const r=s.indexBuffer[e]+n;t.indexBuffer[e+i]=r}}if(t.faceIdBuffer&&s.faceIdBuffer){const n=100*i.sample,r=t.vertexLocation[e],o=r+s.positionCount/3;for(let e=r;e<o;e++)t.faceIdBuffer[e]=s.faceIdBuffer[e-r]+n}if(s.objectClass===Me.SHELL){const n=t.vertexLocation[e],r=n+s.positionCount/3;t.ids.fill(this.itemId(i.sample),n,r)}}getTileVisibility(t,e){if(!t.visibilities)throw new Error("Fragments: Malformed tile!");if(t.visibilities.fullOf(!1))return;return Cs.get(t.visibilities,e,(t=>t))}memoryOverflow(){return t._graphicMemoryConsumed>this._virtualView.graphicThreshold}updateMesh(t){let e=this.fetchLodLevel(t);const s=this._sampleLodState[t];e=this.hideHighlightedLods(e,t),e!==s?this.updateVisible(s,e,t):this.updateSampleIfSeen(e,t)}tileLoadSample(t,e,s){const i=t.sampleLocation.get(e.sample),n=this.getSampleGeometries(e,s);this.setupTileLocation(t,n,e),this.fetchSampleTransform(t,e),this.setupTileSampleAttributes(t,i,n,e)}updateSampleIfSeen(t,e){t!==Ue.INVISIBLE&&this.updateSample(e,t)}hideHighlightedLods(t,e){return t===Ue.WIRES&&this._samples.getHighlight(e)&&(t=Ue.INVISIBLE),t}updateVisible(t,e,s){t!==Ue.INVISIBLE&&this.makeSampleInvisible(s,t);const i=e!==Ue.INVISIBLE;i&&this.updateSample(s,e),this._samples.setVisible(s,i),this._sampleLodState[s]=e}makeInvisibleFromTile(t,e){const s=this._tiles.get(t);this.updateTileData(s,e,!1,0),this.deleteTileIfNeeded(s,t)}updateSample(t,e){const s=this.itemId(t),i=this._items.visible(s),n=this._items.getHighlight(s);this.hasChanged(t,e,i,n)&&this.setSample(t,i,n,e)}hasHighlightChanged(t,e){return e!==this._samples.getHighlight(t)}hasVisibleChanged(t,e){return e!==this._samples.visible(t)}newTile(t,e,s){const i={notVirtual:!1};return i.materialId=e,i.indexLocation=[],i.box=new ft.Box3,i.objectClass=t,i.lod=s,i.normalCount=0,i.indexCount=0,i.vertexLocation=[],i.size=0,i.geometriesLocation=[],i.positionCount=0,i.sampleLocation=new Map,i.faceIdBuffer=new Uint32Array(0),i}createLod(t){const e=Ss.boxSize(t),s=this._temp.tileData.positionBuffer;if(!s)throw new Error("Fragments: Malformed tiles!");return s[0]=e.start.x,s[1]=e.start.y,s[2]=e.start.z,s[3]=e.end.x,s[4]=e.end.y,s[5]=e.end.z,this._temp.tileData}sampleTemplate(t){const e=this._temp.sample,s=this._temp.representation;Ss.get(e,this.meshes,this._temp.transform),Ss.getBox(s,this._temp.boundingBox),this._temp.sampleGeometry.sample=t;const i=e.material();return this._temp.sampleGeometry.material=this._materials[i],this._temp.sampleGeometry.transform=this._temp.transform,this._temp.sampleGeometry.aabb=this._temp.boundingBox,delete this._temp.sampleGeometry.geometries,this._temp.sampleGeometry}makeSampleInvisible(t,e){const s=this.getTileIds(t,e);if(!s)return;Ts.forEach(s,(e=>this.makeInvisibleFromTile(e,t)))}setSample(t,e,s,i){this._samples.setVisible(t,e),this._samples.setHighlight(t,s);const n=this.getTileIds(t,i);void 0!==n&&Ts.forEach(n,(e=>{this.updateTile(e,t,s,0===s)}))}getTileIds(t,e){return e===Ue.GEOMETRY?this._tileBySample[t]:this._lodBySample[t]}addBasicTileData(t,e,s){t.sampleLocation.set(e,t.size),t.size++,t.geometriesLocation.push(s),t.indexLocation.push(t.indexCount||0),t.vertexLocation.push((t.positionCount||0)/3)}buildNewVirtualTile(t,e){this.constructTile(t),this.loadTile(e,t),t.notVirtual=!0,delete t.indexBuffer,delete t.positionBuffer,delete t.normalBuffer,delete t.faceIdBuffer,delete t.ids}deleteTileIfNeeded(e,s){if(this.getShouldDeleteTile(e))return this.deleteGeometry(s),e.notVirtual=!1,void(t._graphicMemoryConsumed-=e.usedMemory);this._tilesChanged.add(s)}getShouldDeleteTile(t){if(!t.visibilities||!t.highlights)throw new Error("Fragments: Malformed tile!");const e=t.visibilities.fullOf(!1),s=t.highlights.fullOf(0),i=this.memoryOverflow();return e&&s&&i}checkTileMemoryOverflow(t,e){const s=this._tiles.get(t);return(s?s.positionCount:0)+e.positionCount>Ne}updateTileData(t,e,s,i){if(!t.visibilities||!t.highlights)throw new Error("Fragments: Malformed tile!");const n=t.sampleLocation.get(e);t.visibilities.update(n,s),t.highlights.update(n,i)}getKeepUpdating(t,e){const s=this._params.updateTime,i=this._params.updateSamples,n=t<this._sampleAmount,r=performance.now()-e;return n&&(r<s||t<i)}computeTileSize(){const t=this._boxes.fullBox.getSize(this._temp.vector),e=Math.max(t.x,t.y,t.z)/this._params.tileDimensionFactor,s=Math.ceil(e);return Math.max(this._params.minTileDimension,s)}newTileId(t,e,s){this.logBufferOverflowIfNeeded(s);const i=s.lod||Ue.GEOMETRY,n=this.generateTileCode(t,e,s,i),r=this._sizeByTile.get(n)||1;let o=n+r-1;return this.checkTileMemoryOverflow(o,s)&&(o+=this._params.tileIdIncrement,this._sizeByTile.set(n,r+1)),o}logBufferOverflowIfNeeded(t){t.positionCount/3>Ne&&console.log("Fragments: Buffer overflow")}fetchLodLevel(t){const e=this._boxes.get(t);if(!ke.collides(e,this._virtualPlanes))return Ue.INVISIBLE;this.meshes.samples(t,this._temp.sample);const s=this._temp.sample.item();if(!this._items.visible(s))return Ue.INVISIBLE;const i=this._virtualView.graphicQuality,n=this._boxes.dimensionOf(t),r=e.distanceToPoint(this._virtualView.cameraPosition),o=this.screenSize(n,r),a=n<this._params.smallObjectSize,l=!a,h=this._params.smallScreenSize*i,c=this._params.mediumScreenSize*i,d=this._params.largeScreenSize*i,u=o<c,f=a&&o<d,p=l&&u;if(a&&u||l&&o<h)return Ue.INVISIBLE;if(f||p)return Ue.WIRES;const I=this._sampleLodSize[t];return this.screenSize(I,r)<Math.max(c,this._params.mediumScreenSize)?Ue.WIRES:Ue.GEOMETRY}generateTileCode(t,e,s,i){this._tileIdGenerator.reset(),this.processTileDataId(s,e,i);const n=this.processTileSpatialId(t,i);return this.processTileDimensionId(n),this._tileIdGenerator.value}processTileDataId(t,e,s){this._tileIdGenerator.compute(void 0!==t.objectClass?t.objectClass:0),this._tileIdGenerator.compute(e),this._tileIdGenerator.compute(s)}deleteGeometry(t){this._meshConnection.process({tileRequestClass:De.DELETE,modelId:this._modelId,tileId:t})}processTileSpatialId(t,e){const s=this._temp.tileCenter.x,i=this._temp.tileCenter.y,n=this._temp.tileCenter.z,r=this._boxes.get(t);r.getCenter(this._temp.tileCenter);const o=this.getTileDimension(e),a=s-s%o,l=i-i%o,h=n-n%o;return this._tileIdGenerator.compute(a),this._tileIdGenerator.compute(l),this._tileIdGenerator.compute(h),r}addCustomLodToTile(t,e,s){const i=this.meshData(t,!1,Ue.WIRES);this._sampleLodSize[e]=i.lodThickness||0,this._lodBySample[e]=this.putSampleInTiles(e,s,i)}getTileLocations(t){return t.indexCount?t.indexLocation:t.vertexLocation}getTileDimension(t){let e=this._tileDimension;return t===Ue.GEOMETRY&&(e*=this._params.tileSizeMultiplier),e}processTileDimensionId(t){const e=this.getTileDimensionClass(t);this._tileIdGenerator.compute(e)}tileAppend(t,e,s,i){this.addBasicTileData(t,s,i),this.tileAppendAttribute(t,e,"indexCount",!1),this.tileAppendAttribute(t,e,"positionCount",!1),this.tileAppendAttribute(t,e,"normalCount",!1),this.tileAppendAttribute(t,e,"materialId",!0)}putSampleInTiles(t,e,s){let i;return Ts.forEach(s,((s,n)=>{const r=this.newTileId(t,e,s);i=this.getTileIdsWhenSamplePut(i,r);const o=this.getTileWhenSamplePut(r,s,e);this.tileAppend(o,s,t,n)})),i}hasLodChanged(t,e){return e!==this._sampleLodState[t]}getTileIdsWhenSamplePut(t,e){return void 0===t?t=e:"number"==typeof t?t!==e&&(t=[t,e]):t.includes(e)||t.push(e),t}updateTile(t,e,s,i){const n=this._tiles.get(t);this.updateTileData(n,e,i,s),n.notVirtual?this._tilesChanged.add(t):this.buildNewVirtualTile(n,t)}getLodTileWhenPutSample(t,e){let s=this._tiles.get(t);if(!s){const i=this._temp.tile.objectClass;s=this.newTile(i,e,Ue.WIRES),this._tiles.set(t,s)}return s}lodTileAppendSample(t,e){const s=Ue.WIRES,i=this._temp.tile,n=this.generateTileCode(t,e,i,s),r=this.getLodTileWhenPutSample(n,e);return this.tileAppend(r,i,t,0),n}addSampleToTile(t,e,s){const i=this.meshData(t,!1,Ue.GEOMETRY);this._tileBySample[e]=this.putSampleInTiles(e,s,i)}setTileBuffer(t,e,s){if(void 0===t.usedMemory)return;const i=t[`${e}Count`];if(i>0){const n=s?new Uint16Array(i):new Int16Array(i);t[`${e}Buffer`]=n,t.usedMemory+=n.byteLength}}updateTiles(t){const e=this._changedSamples<this._sampleAmount;if(!(void 0!==this._virtualView)||!e)return;let s=!0,i=0;for(;s;){const e=this._samplesDimensions[this._currentSample];this.updateMesh(e),this.updateCurrentSample(),i++,s=this.getKeepUpdating(i,t)}}sampleGeoms(t,e,s){return s.getLodClass()===Th.AABB&&e===Ue.WIRES?this.createLod(t.aabb):this.meshData(s,!0,e)}generateSampleInTiles(t){this.fetchSampleAndRepresentation(t);const e=this.fetchCurrentMaterial(),s=this.fetchCurrentMesh();this.addSampleToTile(s,t,e),this.addLodToTile(s,t,e)}buildSampleInTile(t,e,s,i,n){const r=t.geometriesLocation[e];if(this.tileLoadSample(t,s,r),i){const e=this._boxes.get(n);this._temp.vector.copy(t.location),this._temp.vector.negate(),e.translate(this._temp.vector),t.box.union(e)}}getSampleGeometries(t,e){return Array.isArray(t.geometries)?t.geometries[e]:t.geometries}constructTile(t){void 0===t.positionBuffer&&(t.positionBuffer=new Float32Array(t.positionCount),t.usedMemory=t.positionBuffer.byteLength,this.setTileBuffer(t,"index",!0),this.setTileBuffer(t,"normal",!1),this.setTileShellBuffer(t),t.faceIdBuffer=new Uint32Array(t.positionCount/3),t.usedMemory+=t.faceIdBuffer.byteLength);const e=!t.location;for(const[s,i]of t.sampleLocation){const n=this.fetchSample(s,t.lod);n&&n.geometries&&this.buildSampleInTile(t,i,n,e,s)}}fetchSampleTransform(t,e){this._temp.vector.copy(t.location),this._temp.vector.negate(),this._temp.matrix.identity(),this._temp.matrix.setPosition(this._temp.vector),this._temp.matrix.multiply(e.transform)}hasChanged(t,e,s,i){const n=this.hasLodChanged(t,e),r=this.hasVisibleChanged(t,s),o=this.hasHighlightChanged(t,i);return n||r||o}setupTileLocation(t,e,s){if(t.location)return;const i=new ft.Vector3;i.fromArray(e.positionBuffer),i.applyMatrix4(s.transform),t.location=i}getTileData(t){const e=this.getTileLocations(t),s=this.getTileVisibility(t,e),i=this.getTileHighlight(t,e),{highlightData:n,highlightIds:r}=i;return{visibilityData:s,highlightData:n,highlightIds:r}}updateMemoryOnTileLoad(e){t._graphicMemoryConsumed+=e.usedMemory}fetchTileMatrixOnLoad(t){t.location&&(this._temp.matrix.identity(),this._temp.matrix.setPosition(t.location))}updateItem(t){const e=this._boxes.sampleOf(t);if(e)for(const t of e)this.updateMesh(t)}screenSize(t,e){return t/this.getViewDimension(e)*this._virtualView.viewSize}getTileDimensionClass(t){const e=t.min.distanceToSquared(t.max),s=this._params.smallTileSize;return e>this._params.mediumTileSize?2:e>s?1:0}getViewDimension(t){if(this._virtualView.orthogonalDimension)return this._virtualView.orthogonalDimension;const e=this._virtualView.fov;return e!==this._temp.pastFieldOfview&&(this._temp.viewDimension=this.getPerspTrueDim(e,1),this._temp.pastFieldOfview=e),t*this._temp.viewDimension}loadTile(t,e){const s=this.getTileData(e);this.fetchTileMatrixOnLoad(e);const i=this.getFaceIds(e);this._meshConnection.process({tileRequestClass:De.CREATE,modelId:this._modelId,objectClass:e.objectClass,tileId:t,itemId:void 0,tileData:s,indices:e.indexBuffer,positions:e.positionBuffer,normals:e.normalBuffer,faceIds:i,itemIds:e.ids,material:e.materialId,matrix:this._temp.matrix.clone(),aabb:e.box.clone(),currentLod:e.lod}),this.updateMemoryOnTileLoad(e)}getFaceIds(t){const e=new ft.Color,s=t.faceIdBuffer,i=new Float32Array(3*s.length);for(let t=0;t<s.length;t++){const n=s[t];e.set(0+n),i[3*t]=e.r,i[3*t+1]=e.g,i[3*t+2]=e.b}return i}meshData(t,e,s){const i=this._temp.representation.id(),n=t.getLodClass()===Th.CUSTOM,r=s===Ue.WIRES;if(n&&r){return t.fetchLod(i,e)}return t.fetchMeshes(i,e)}tileAppendAttribute(t,e,s,i){void 0!==e[s]&&(i?t[s]=e[s]:t[s]+=e[s])}itemId(t){return this.meshes.samples(t,this._temp.sample),this._temp.sample.item()}};ot(Dc,"_graphicMemoryConsumed",0);let Uc=Dc;class Vc{static isSame(t,e){const s=this.checkSameColor(t.color,e.color),i=this.checkSame(t.opacity,e.opacity,1),n=t.renderedFaces,r=e.renderedFaces,o=this.checkSame(n,r,ve.ONE);return s&&i&&o}static checkSame(t,e,s){return t===e||(t===s&&void 0===e||void 0===t&&e===s)}static checkSameColor(t,e){if(t===e)return!0;if(void 0===t||void 0===e)return!1;const{r:s,g:i,b:n}=t,{r:r,g:o,b:a}=e;return s===r&&i===o&&n===a}}class Bc{constructor(t,e){ot(this,"_modelId"),ot(this,"_list",[]),ot(this,"_onTransfer"),this._modelId=t,this._onTransfer=e}update(t){const e=t.meshes();return this.getAll(e,[])}fetch(t){return this._list[t]}transfer(t){const e=this.deduplicateMaterials(t),{materialDefinitions:s,ids:i}=e;return this.transferMaterialData(s),i}getItemsMaterialDefinition(t,e,s){const i=[],n=t.meshes();if(!n)return[];const r=new Map;for(const[t,i]of e.entries()){const e=n.samples(i);if(!e)continue;const o=e.material();let a=r.get(o);a||(a=new Set,r.set(o,a)),a.add(s[t])}for(const[t,e]of r.entries()){const s=n.materials(t);if(!s)continue;const r=ys.parseMaterial(s);i.push({localIds:[...e],definition:r})}return i}checkMaterialExists(t,e){const s=this._list.length;for(let i=0;i<s;i++){const s=this._list[i];if(Vc.isSame(t,s))return e.push(i),!0}return!1}deduplicateMaterials(t){const e=[],s=[];for(const i of t){if(!this.checkMaterialExists(i,e)){this._list.push(i),s.push(i);const t=this._list.length-1;e.push(t)}}return{materialDefinitions:s,ids:e}}getAll(t,e){const s=t.materialsLength();for(let i=0;i<s;i++){const s=t.materials(i),n=ys.parseMaterial(s);e.push(n)}return this.transfer(e)}transferMaterialData(t){this._onTransfer({class:Ve.CREATE_MATERIAL,modelId:this._modelId,materialDefinitions:t})}}class zc{constructor(t,e,s){if(ot(this,"_model"),ot(this,"_boxes"),ot(this,"_localIdsToGeometryIds",new Map),ot(this,"_guidToLocalIdMap",new Map),ot(this,"_items",new Map),ot(this,"_itemDataCache",new Map),ot(this,"_itemDataConfig",{attributesDefault:!0,relationsDefault:{attributes:!1,relations:!1}}),ot(this,"_spatialStructure",null),ot(this,"_relations",new Map),this._model=t,this._boxes=e,this.preindexGeometryIds(),s&&s.extraRelations)for(const t of s.extraRelations){const{category:e,relation:s,inverseName:i}=t;this.addInverseRelation(e,s,i)}const i=this._model.localIdsArray();if(i){for(let t=0;t<this._model.localIdsLength();t++){const e=this._model.categories(t),s=i[t];let n=this._items.get(s);n||(n={category:null,guid:null,geometryIds:null,attrs:null},this._items.set(s,n)),n.category=e}for(let t=0;t<this._model.guidsItemsLength();t++){const e=this._model.guidsItems(t);if(null===e)continue;const s=this._model.guids(t);this._guidToLocalIdMap.set(s,e);let i=this._items.get(e);i||(i={category:null,guid:null,geometryIds:null,attrs:null},this._items.set(e,i)),i.guid=s}}}getAllLocalIds(){return this._model.localIdsArray()??[]}addInverseRelation(t,e,s){const i=this.getItemsOfCategories([new RegExp(`^${t}$`)])[t];for(const t of i){const i=this.getItemRelations(t);if(!i||!i[e])continue;const n=i[e];for(const e of n){let i=this._relations.get(e);i||(i={},this._relations.set(e,i));let n=i[s];n||(n=[],i[s]=n),n.push(t)}}}getItemsCount(){return this._model.localIdsLength()}getMaxLocalId(){return this._model.maxLocalId()}getMetadata(){const t=this._model.metadata();return t?JSON.parse(t):null}getItemIdsFromLocalIds(t){if(!t)return Array.from(this._model.meshes().meshesItemsArray());const e=[];for(const s of t){const t=this._localIdsToGeometryIds.get(s);if(t)for(const s of t)e.push(s)}return e}getLocalIdsFromItemIds(t){const e=[],s=this._localIdsToGeometryIds.entries();for(const[i,n]of s)for(const s of t)n.includes(s)&&e.push(i);return e}getBox(t,e){for(const s of t){const t=this._boxes.sampleOf(s);if(t)for(const s of t){const t=this._boxes.get(s);e.union(t)}}}getSpatialStructure(){if(this._spatialStructure)return this._spatialStructure;const t=this._model.spatialStructure();return t?(this._spatialStructure=this.getTreeItem(t),this._spatialStructure):{}}getItemsChildren(t){const e=new Set;for(const s of t){const t=this.convertToLocalId(s);null!==t&&this.traverseSpatialStructure(t,e)}return[...e]}getGuids(){const t=[];for(let e=0;e<this._model.guidsLength();e++){const s=this._model.guids(e);t.push(s)}return t}getLocalIds(){const t=this._model.localIdsArray();return t?Array.from(t):[]}getItemsCategories(t){var e;const s=[];for(const i of t){const t=this.convertToLocalId(i);if(null===t)continue;const n=(null==(e=this._items.get(t))?void 0:e.category)??null;s.push(n)}return s}getLocalIdsByGuids(t){const e=[];for(const s of t){const t=this._guidToLocalIdMap.get(s);e.push(void 0!==t?t:null)}return e}getGuidsByLocalIds(t){var e;const s=[];for(const i of t){const t=null==(e=this._items.get(i))?void 0:e.guid;s.push(void 0!==t?t:null)}return s}getAttributeNames(){const t=new Set;for(let e=0;e<this._model.uniqueAttributesLength();e++){const s=this._model.uniqueAttributes(e);if(!s)continue;const[i]=JSON.parse(s);t.add(i)}return[...t]}getAttributeValues(){const t=new Set;for(let e=0;e<this._model.uniqueAttributesLength();e++){const s=this._model.uniqueAttributes(e);if(!s)continue;const[,i]=JSON.parse(s);t.add(i)}return[...t]}getAttributesUniqueValues(t){var e,s,i;const n=new Map,r=t.every((t=>void 0!==t.categories)),o=t.map((t=>t.categories)).filter((t=>void 0!==t)).flat();for(let a=0;a<this._model.categoriesLength();a++){let l=!0;if(r){const t=this._model.categories(a);l=o.some((e=>null==e?void 0:e.test(t)))}if(!l)continue;const h=this._model.attributes(a);if(!h)continue;const c={};for(let t=0;t<h.dataLength();t++){const e=h.data(t);if(!e)continue;const[s,i,n]=JSON.parse(e);c[s]={value:i,type:n}}const d=Object.keys(c),u=this._model.categories(a);for(const{key:r,attributes:o,get:a,categories:l}of t){let t=!0;if(l&&(t=l.some((t=>t.test(u)))),!t)continue;let h=!0;if(o){const{aggregation:t,queries:s}=o,i=[];for(const{name:t,value:n,type:r,negate:o}of s){const s=d.find((e=>t.test(e)));if(!s||void 0===(null==(e=c[s])?void 0:e.value))break;let a=!1;const{value:l,type:h}=c[s];a=n instanceof RegExp?"string"==typeof l&&n.test(l):l===n,void 0!==r&&(a=a&&"string"==typeof h&&r.test(h)),o&&(a=!a),i.push(a)}h="exclusive"===t?i.every((t=>t)):i.some((t=>t))}if(h){const t=d.find((t=>a.test(t)));if(!t||void 0===(null==(s=c[t])?void 0:s.value))continue;const e=r??t;let o=n.get(e);o||(o=new Set,n.set(e,o)),o.add(null==(i=c[t])?void 0:i.value)}}}const a={};for(const[t,e]of n)a[t]=Array.from(e);return a}getAttributeTypes(){const t=new Set;for(let e=0;e<this._model.uniqueAttributesLength();e++){const s=this._model.uniqueAttributes(e);if(!s)continue;const[,,i]=JSON.parse(s);t.add(i)}return[...t]}getRelationNames(){const t=new Set;for(let e=0;e<this._model.relationNamesLength();e++){const s=this._model.relationNames(e);s&&t.add(s)}return[...t]}getItemAttributes(t){var e;const s="number"==typeof t?t:this.getLocalIdsByGuids([t])[0];if(null===s)return null;const i=null==(e=this._model.localIdsArray())?void 0:e.indexOf(s);if(void 0===i||-1===i)return null;const n=this._model.attributes(i);if(!n)return null;const r={};for(let t=0;t<n.dataLength();t++){const e=n.data(t);if(!e)continue;const[s,i,o]=JSON.parse(e);r[s]={value:i,type:o}}return r}getItemData(t,e={}){var s,i;const n=this._itemDataConfig.attributesDefault,r=this._itemDataConfig.attributes,o=this._itemDataConfig.relations??{};let{attributes:a,relations:l}=this._itemDataConfig.relationsDefault;const{parentName:h,rel:c}=e;if(h||c){const t=h&&h in o;if(c&&c in o){const t=o[c];t&&(a=t.attributes,l=t.relations)}else if(t){const t=o[h];t&&(a=t.attributes,l=t.relations)}}else a=!0,l=!0;if(!a&&!l)return{};if(this._itemDataCache.has(t))return this._itemDataCache.get(t);const d="number"==typeof t?t:this._guidToLocalIdMap.get(t)??null,u={_category:{value:null!==d?(null==(s=this._items.get(d))?void 0:s.category)??null:null},_localId:{value:d},_guid:{value:"string"==typeof t?t:(null==(i=this._items.get(t))?void 0:i.guid)??null}};if(this._itemDataCache.set(t,u),a&&null!==d){const e=this.getItemAttributes(t);for(const[t,s]of Object.entries(e??{}))n?(null==r?void 0:r.includes(t))||(u[t]=s):(null==r?void 0:r.includes(t))&&(u[t]=s)}if(l){const e=this.getItemRelations(t);for(const[t,s]of Object.entries(e??{}))for(const e of s){const s=this.getItemData(e,{parentName:c,rel:t});if(0===Object.keys(s).length)continue;const i=u[t];Array.isArray(i)?i.push(s):u[t]=[s]}}return u}getItemsData(t,e={}){this._itemDataCache.clear();const s=[],i=0!==t.length?t:this._model.localIdsArray();if(!i)return s;this._itemDataConfig={...this._itemDataConfig,...e};for(const t of i)s.push(this.getItemData(t));return this._itemDataCache.clear(),this._itemDataConfig={relationsDefault:{attributes:!1,relations:!1},attributesDefault:!0},s}getItemRelations(t){var e;const s="number"==typeof t?t:this.getLocalIdsByGuids([t])[0];if(null===s)return null;const i=this._relations.get(s)??{},n=null==(e=this._model.relationsItemsArray())?void 0:e.indexOf(s);if(void 0===n||-1===n)return Object.keys(i).length>0?i:null;const r=this._model.relations(n);if(!r)return Object.keys(i).length>0?i:null;for(let t=0;t<r.dataLength();t++){const e=r.data(t);if(!e)continue;const[s,...n]=JSON.parse(e);i[s]=n}return i}getCategories(){const t=new Set;for(let e=0;e<this._model.categoriesLength();e++){const s=this._model.categories(e);s&&t.add(s)}return[...t]}getItemsOfCategories(t){const e={},s=this._model.localIdsArray();if(!s)return e;for(let i=0;i<this._model.categoriesLength();i++){const n=this._model.categories(i);if(n)for(const r of t)if(r.test(n)){e[n]||(e[n]=[]),e[n].push(s[i]);break}}return e}getItemsWithGeometry(){const t=this._model.meshes(new Se),e=[];if(!t)return e;const s=t.meshesItemsArray();if(!s)return e;for(const t of s){const s=this._model.localIds(t);null!==s&&e.push(s)}return e}getItemsWithGeometryCategories(){const t=this.getItemsWithGeometry();return this.getItemsCategories(t)}getItemsByAttribute({name:t,value:e,type:s,negate:i,itemIds:n}){const r=this._model.attributesLength(),o=[];for(let a=0;a<r;a++){const r=this._model.localIds(a);if(null===r)continue;if((null==n?void 0:n.length)&&!n.includes(r))continue;const l=this._model.attributes(a);if(!l)continue;const h=null==l?void 0:l.dataLength();let c=!1;for(let i=0;i<h;i++){const n=l.data(i);if(!n)continue;const[r,o,a]=JSON.parse(n);if(t.test(r)){let t=void 0===e&&void 0===s;if(t||(void 0!==e&&(t=Array.isArray(e)?e.some((t=>"string"==typeof o&&t.test(o))):e instanceof RegExp?"string"==typeof o&&e.test(o):o===e),void 0!==s&&(t=t&&"string"==typeof a&&s.test(a))),t){c=!0;break}}}(i?!c:c)&&o.push(r)}return o}getItemsByRelation({name:t,targetItemIds:e,sourceItemIds:s}){const i=[],n=s??this.getAllLocalIds();for(const s of n){const n=this.getItemRelations(s),r=null==n?void 0:n[t];if(r)if(e){for(const t of r)if(e.has(t)){i.push(s);break}}else i.push(s)}return i}getItemsByQuery(t){var e;const{categories:s,attributes:i,relation:n}=t;let r=(null==(e=null==s?void 0:s.filter(Boolean))?void 0:e.length)?Object.values(this.getItemsOfCategories(s)).flat():void 0;if(0===(null==r?void 0:r.length))return[];if(i){const t=i.aggregation??"exclusive",e=[];for(const t of i.queries)if(i&&Boolean(t.name)){const s=this.getItemsByAttribute({...t,itemIds:r});e.push(s)}const s=new Set;if("inclusive"===t)for(const t of e)for(const e of t)s.add(e);else{const t=new Map;for(const s of e)for(const e of s){const s=t.get(e);void 0===s?t.set(e,1):t.set(e,s+1)}for(const[i,n]of t)n===e.length&&s.add(i)}r=[...s]}if(0===(null==r?void 0:r.length))return[];if(n&&Boolean(n.name)){const{name:t,query:e}=n,s=e?new Set(this.getItemsByQuery(e)):void 0;r=this.getItemsByRelation({name:t,targetItemIds:s,sourceItemIds:r})}return Array.from(new Set(r))}getTreeItem(t){const e={category:t.category(),localId:t.localId()},s=[];for(let e=0;e<t.childrenLength();e++){const i=t.children(e);i&&s.push(this.getTreeItem(i))}return s.length>0&&(e.children=s),e}preindexGeometryIds(){const t=this._model.meshes(),e=t.meshesItemsLength();for(let s=0;s<e;s++){const e=t.meshesItems(s),i=this._model.localIds(e);null!==i&&(this._localIdsToGeometryIds.has(i)||this._localIdsToGeometryIds.set(i,[]),this._localIdsToGeometryIds.get(i).push(s))}}convertToLocalId(t){if("number"==typeof t)return t;const e=this._guidToLocalIdMap.get(t);return void 0===e?null:e}getChildrenLocalIds(t,e){if(null!==t.localId&&e.add(t.localId),t.children)for(const s of t.children)this.getChildrenLocalIds(s,e)}traverseSpatialStructure(t,e,s=this.getSpatialStructure()){if(s)if(s.localId===t&&s.children)for(const t of s.children)this.getChildrenLocalIds(t,e);else if(s.children)for(const i of s.children)this.traverseSpatialStructure(t,e,i)}}class Gc{constructor(t){ot(this,"_model"),this._model=t}async getAlignments(){const t=[],e=this._model.alignmentsLength();for(let s=0;s<e;s++){const e=this._model.alignments(s),i={absolute:[],horizontal:[],vertical:[]};t.push(i),this.constructAlignment(e,i,"absolute"),this.constructAlignment(e,i,"horizontal"),this.constructAlignment(e,i,"vertical")}return t}constructAlignment(t,e,s){const i=t[{absolute:"absoluteLength",horizontal:"horizontalLength",vertical:"verticalLength"}[s]](),n=this._model.geometries();for(let r=0;r<i;r++){const i=t[s](r),o=n.samples(i).id(),a=n.representations(o),l=a.id(),h=a.geometryClass(),c=[],d=n.lines(l).pointsArray();for(const t of d)c.push(t);e[s].push({points:new Float32Array(c),type:h})}}}class kc{constructor(){ot(this,"_templates",new Map)}add(t,e){this._templates.set(t,e)}get(t){const e=this._templates.get(t);return Array.isArray(e)?this.getTemplateSet(e):{...e}}getTemplateSet(t){const e=[];for(const s of t){const t={...s};e.push(t)}return e}}const Hc=class t{constructor(e,s){ot(this,"_dataBuffer"),ot(this,"_dataPosition"),this._dataBuffer=s||this.getDefaultData(),this._dataPosition=e||t._data.defaultPosition}set(e){let s=0;for(const i of t._data.points)for(const n of t._data.coords){const t=this.getPosition(n,i),r=e[s++];this.setValue(t,r)}}get(t,e){const s=this.getPosition(t,e);return this._dataBuffer[s]}clone(e){for(const s of t._data.points)for(const i of t._data.coords){const t=this.getPosition(i,s),n=e.get(i,s);this.setValue(t,n)}}combine(e,s){for(const i of t._data.points)for(const n of t._data.coords)this.save(n,i,e,s)}setValue(t,e){this._dataBuffer[t]=e}getDefaultData(){return new Float64Array(t._data.size)}getPosition(e,s){return t._data[s][e]+this._dataPosition}save(t,e,s,i){const n=this.getPosition(t,e),r=s.get(t,e),o=i.get(t,e),a=Math[e](r,o);this.setValue(n,a)}};ot(Hc,"_data",{size:6,defaultPosition:0,min:{x:0,y:2,z:4},max:{x:1,y:3,z:5},coords:["x","y","z"],points:["min","max"]});let Yc=Hc;const Wc=class t{constructor(t,e){ot(this,"box"),ot(this,"data",0),this.box=new Yc(t,e)}get size(){return this.data*t._data.factor}get isPoint(){return this.data>=t._data.threshold}transform(e,s,i){i||(e*=t._data.factor),this.data=e,this.box.clone(s)}};ot(Wc,"_data",{threshold:0,factor:-1});let jc=Wc;class qc{constructor(t){ot(this,"_boxes"),ot(this,"_min",new ft.Vector3),ot(this,"_max",new ft.Vector3),this._boxes=t}inflate(t){const e=this._boxes.fullBox.min,s=this.getVector(t,e,"min"),i=this.getVector(t,e,"max");return new ft.Box3(s,i)}deflate(t,e){this.read(t);const s=[];s.push(this._min.x,this._min.y,this._min.z),s.push(this._max.x,this._max.y,this._max.z),e.set(s)}getVector(t,e,s){const i=t.get("x",s)+e.x,n=t.get("y",s)+e.y,r=t.get("z",s)+e.z;return new ft.Vector3(i,n,r)}read(t){const{min:e}=this._boxes.fullBox;this._min.subVectors(t.min,e),this._max.subVectors(t.max,e)}}class Zc{constructor(t,e){ot(this,"_data"),ot(this,"_compressor"),this._data=e,this._compressor=t}frustumCollide(t,e,s=!1){const i=this.getFrustumPlanes(e,t),n=this.getFrustumOnCollide(i),r=this.getFrustumOnIncludes(i),o=this.newDefaultCallback(!0);return this.collide(n,r,o,s)}rayCollide(t,e){const s=this.getRayOnCollide(e),i=this.newDefaultCallback(!1),n=this.getRayOnSeen(t);return this.collide(s,i,n)}addPoint(t,e,s,i){t?i&&e.push(this.getPointData(s)):e.push(this.getPointData(s))}getPointData(t){return this.getPoint(t).data}getBounds(t){const e=this.getPoint(t);return this._compressor.inflate(e.box)}isPoint(t){return this.getPoint(t).isPoint}newDefaultCallback(t){return e=>t}groupSize(t){return this.getPoint(t).size}getPoint(t){return this._data.points[t]}getRayOnSeen(t){let e=this.newDefaultCallback(!0);return(null==t?void 0:t.length)>0&&(e=e=>ke.collides(e,t)),e}getRayOnCollide(t){return e=>t.intersectsBox(e)}collide(t,e,s,i=!1){const n=this._data.points.length,r=[];let o=0;const a=(t,e)=>{const n=o+this.groupSize(o);for(;o<n;o++){this.isPoint(o)&&s(t)&&(i?e&&this.savePoint(o,r):this.savePoint(o,r))}},l=()=>{const n=this.getBounds(o),l=e(n),h=this.isPoint(o),c=l||t(n);h&&c&&s(n)&&this.addPoint(i,r,o,l),c||h?(o++,l&&!h&&a(n,l)):o+=this.groupSize(o)};for(;o<n;)l();return r}getFrustumOnIncludes(t){return e=>ke.isIncluded(e,t)}getFrustumOnCollide(t){return e=>ke.collides(e,t)}getFrustumPlanes(t,e){const s=[];for(const e of t.planes)s.push(e);if(e)for(const t of e)s.push(t);return s}savePoint(t,e){const s=this.getPoint(t);e.push(s.data)}}class Xc{constructor(t){ot(this,"_boxes"),ot(this,"_total",new ft.Vector3),ot(this,"_change",new ft.Vector3),ot(this,"_average",new ft.Vector3),ot(this,"_tempCenterVector",new ft.Vector3),ot(this,"_tempVectors",{x:new ft.Vector3,y:new ft.Vector3,z:new ft.Vector3}),this._boxes=t}sort(t,e,s){this.average(this._average,t,e,s),this.getDataToTotal(e,s,t);let i=this.anySort(e,s,t);return i=this.adjust(s,e,i),Math.round(i)}anySort(t,e,s){return this._total.x>this._total.y?this._total.x>this._total.z?this.sortDim("x",this._average.x,t,e,s):this.sortDim("z",this._average.z,t,e,s):this._total.y>this._total.z?this.sortDim("y",this._average.y,t,e,s):this.sortDim("z",this._average.z,t,e,s)}getDataToTotal(t,e,s){this._total.set(0,0,0);for(let i=t;i<e;i++){this._boxes.get(s[i]).getCenter(this._change).sub(this._average);const t=this._change.multiply(this._change);this._total.add(t)}}sortDim(t,e,s,i,n){let r=s;for(let o=s;o<i;o++){this.getValue(n,o,t)>e&&(this.exchange(o,r,n),r++)}return r}exchange(t,e,s){const i=s[t];s[t]=s[e],s[e]=i}getValue(t,e,s){const i=this.getBox(t,e),n=this._tempVectors[s];return i.getCenter(n)[s]}average(t,e,s,i){const n=this.getBox(e,s);return n.getCenter(t),this.aggregate(s,i,e,n,t),t.divideScalar(i-s)}aggregate(t,e,s,i,n){for(let i=t+1;i<e;i++){const t=s[i],e=this._boxes.get(t).getCenter(this._tempCenterVector);n.add(e)}}adjust(t,e,s){const i=(e+t)/2,n=(t-e)/3;return(s<=e+n||s>=t-1-n)&&(s=i),s}getBox(t,e){const s=t[e];return this._boxes.get(s)}}class $c{constructor(t,e,s){ot(this,"_data"),ot(this,"_compressor"),ot(this,"_boxes"),ot(this,"_sorter"),this._data=s,this._compressor=e,this._boxes=t,this._sorter=new Xc(t)}make(t,e,s=0,i=0,n=0,r=0){const o=s-i;return 1===o?this.makePoint(t,i,e,r):2===o?this.makeGroup3(r,t,i,e):this.makeGroup(n,t,i,s,r,e)}makeGroup3(t,e,s,i){const n=this.makeBox(t+1,e,s),r=this.makeBox(t+2,e,s+1);return i.combine(n,r),this.newGroup(t,3,i),3}makeGroup(t,e,s,i,n,r){const o=this._data.limits.primary[t],a=this._data.limits.secondary[t],l=this._sorter.sort(e,s,i),h=this.make(e,o,l,s,t+1,n+1),c=n+h+1,d=this.make(e,a,i,l,t+1,c);r.combine(o,a);const u=h+d+1;return this.newGroup(n,u,r),u}makeBox(t,e,s){const i=this._data.points[t].box,n=e[s],r=this._boxes.get(n);return this._compressor.deflate(r,i),this.set(t,n),i}makePoint(t,e,s,i){const n=this._boxes.get(t[e]);return this._compressor.deflate(n,s),this.newPoint(i,t[e],s),1}newGroup(t,e,s){this.get(t).transform(e,s,!1)}get(t){return this._data.points[t]}newPoint(t,e,s){this.get(t).transform(e,s,!0)}set(t,e){this.get(t).data=e}}const Kc=class t{constructor(t){ot(this,"_compressor"),ot(this,"_collider"),ot(this,"_maker"),ot(this,"_data"),ot(this,"_boxes"),this._boxes=t,this._compressor=new qc(t),this._data=this.getData(),this._collider=new Zc(this._compressor,this._data),this._maker=new $c(this._boxes,this._compressor,this._data),this.initData()}collideFrustum(t,e,s=!1){return this._collider.frustumCollide(t,e,s)}collideRay(t,e){return this._collider.rayCollide(t,e)}setupLimits(){for(let e=0;e<t._limitThreshold;e++)this._data.limits.primary.push(new Yc),this._data.limits.secondary.push(new Yc)}getPointBuffer(){const t=this._boxes.getCount(),e=new Uint32Array(t);for(let t=0;t<e.length;t++)e[t]=t;return e}getPointsAmount(t){return 2*t.length-1}initData(){const e=this.getPointBuffer(),s=this.getPointsAmount(e),i=s*t._boxSize,n=new Float64Array(i);for(let e=0;e<s;e++){const s=e*t._boxSize,i=new jc(s,n);this._data.points.push(i)}this.setupLimits();const r=new Yc;this._maker.make(e,r,e.length)}getData(){return{points:[],limits:{primary:[],secondary:[]}}}};ot(Kc,"_boxSize",6),ot(Kc,"_limitThreshold",32);let Qc=Kc;class Jc{constructor(t){ot(this,"lookup"),ot(this,"_boxSize",6),ot(this,"_pointSize",3),ot(this,"_temp"),ot(this,"_dimensionsOfSamples"),ot(this,"_samples",[]),ot(this,"_boxes"),ot(this,"_meshes"),ot(this,"_box"),this._temp={box:new ft.Box3,vector:new ft.Vector3,transform:new ft.Matrix4,sample:new Te,representation:new Ce},this._box=new ft.Box3;const e=t.meshes();if(!e)throw new Error("Fragments: Malformed fragments data!");this._meshes=e;const s=e.samplesLength();this._dimensionsOfSamples=new Float32Array(s);const i=s*this._boxSize;this._boxes=new Float64Array(i),this.lookup=this.newLookup()}get fullBox(){return this._box}set fullBox(t){this._box=t}sampleOf(t){return this._samples[t]}get(t){const e=this.getMinPosition(t),s=this.getMaxPosition(t);return this._temp.box.min.fromArray(this._boxes,e),this._temp.box.max.fromArray(this._boxes,s),this._temp.box}process(t){this.fetchSampleAndRepresentation(t),this.getBox(),this.addToFullBox();const e=this.getMinPosition(t),s=this.getMaxPosition(t);this._temp.box.min.toArray(this._boxes,e),this._temp.box.max.toArray(this._boxes,s)}getCount(){return this._boxes.length/this._boxSize}dimensionOf(t){const e=this._dimensionsOfSamples[t];if(!e)throw new Error("Fragments: Dimension not found!");return e}newLookup(){const t=this._meshes.samplesLength(),e=this._meshes.globalTransformsLength();for(let e=0;e<t;e++){this.fetchSampleAndRepresentation(e),Ss.getBox(this._temp.representation,this._temp.box);const t=this._temp.box.getSize(this._temp.vector);this._dimensionsOfSamples[e]=t.length(),this.process(e)}this._samples=new Array(e);for(let e=0;e<t;e++)this.storeBox(e);if(!this.getCount())throw new Error("Fragments: Malformed boxes!");return new Qc(this)}getBox(){Ss.get(this._temp.sample,this._meshes,this._temp.transform),Ss.getBox(this._temp.representation,this._temp.box),this._temp.box.applyMatrix4(this._temp.transform)}fetchSampleAndRepresentation(t){this._meshes.samples(t,this._temp.sample);const e=this._temp.sample.representation();this._meshes.representations(e,this._temp.representation)}getMinPosition(t){return t*this._boxSize}storeBox(t){this.fetchSampleAndRepresentation(t);const e=this._temp.sample.item();void 0===this._samples[e]&&(this._samples[e]=[]),this._samples[e].push(t)}getMaxPosition(t){return t*this._boxSize+this._pointSize}addToFullBox(){this.fullBox.union(this._temp.box)}}class td{raycast(t,e,s){if(t.view)return t.raycaster.raycast(e,s,t.view.clippingPlanes)}snapRaycast(t,e,s,i){return t.view?t.raycaster.snapRaycast(e,s,i,t.view.clippingPlanes):[]}rectangleRaycast(t,e,s){return t.view?t.raycaster.rectangleRaycast(e,t.view.clippingPlanes,s):[]}}class ed{getPositions(t,e){const s=[],i=t.properties.getItemIdsFromLocalIds(e);for(const e of i){const i=t.tiles.meshes.globalTransforms(e);if(!i)continue;const n=i.position(),r=n.x(),o=n.y(),a=n.z();s.push({x:r,y:o,z:a})}return s}getCoordinates(t){const e=t.data.meshes().coordinates(),s=e.position(),i=e.xDirection(),n=e.yDirection();return[s.x(),s.y(),s.z(),i.x(),i.y(),i.z(),n.x(),n.y(),n.z()]}}class sd{constructor(){ot(this,"_highlightProps",["color","opacity","transparent","renderedFaces"])}resetHighlight(t,e){const s=t.properties.getItemIdsFromLocalIds(e);this.resetHighlightForItems(s,t),t.tiles.restart()}getHighlight(t,e){const s=[],i=t.properties.getItemIdsFromLocalIds(e),n=this.getFetchEvent(t,s);return t.traverse(i,n),s}getHighlightItems(t){const e=[],s=t.itemConfig.size;for(let i=0;i<s;i++){if(!t.itemConfig.getHighlight(i))continue;const[s]=t.properties.getLocalIdsFromItemIds([i]);e.push(s)}return e}highlight(t,e,s){const i=t.properties.getItemIdsFromLocalIds(e),n=[],r=this.getCheckEvent(t,s,n);t.traverse(i,r);const o=t.materials.transfer(n),a=this.getCreateEvent(t,o);t.traverse(i,a),t.tiles.updateVirtualMeshes(i)}getFetchEvent(t,e){return s=>{const i=t.itemConfig.getHighlight(s);if(i){const s=t.materials.fetch(i);e.push(s)}else e.push(void 0)}}setHighlightProperty(t,e,s){void 0===t[s]&&void 0!==e[s]&&(t[s]=e[s])}getNewHighFromPast(t,e,s){const i=t.materials.fetch(e),n={...s};for(const t of this._highlightProps)this.setHighlightProperty(n,i,t);return n}getCheckEvent(t,e,s){return i=>{const n=t.itemConfig.getHighlight(i);if(void 0===n)s.push(e);else{const i=this.getNewHighFromPast(t,n,e);s.push(i)}}}getCreateEvent(t,e){return(s,i)=>{t.itemConfig.setHighlight(s,e[i])}}resetHighlightForItems(t,e){if(t)for(const s of t)e.itemConfig.setHighlight(s,0);else e.itemConfig.clearHighlight()}}class id{resetVisible(t){t.itemConfig.clearVisible(),t.tiles.restart()}getVisible(t,e){const s=t.properties.getItemIdsFromLocalIds(e),i=[];for(const e of s){const s=t.itemConfig.visible(e);i.push(s)}return i}getItemsByVisibility(t,e){const s=this.getVisibleCondition(t,e),i=t.getItemsByConfig(s);return t.properties.getLocalIdsFromItemIds(i)}toggleVisible(t,e){const s=t.properties.getItemIdsFromLocalIds(e),i=this.getToggleEvent(t);t.traverse(s,i),t.tiles.updateVirtualMeshes(s)}setVisible(t,e,s){const i=t.properties.getItemIdsFromLocalIds(e),n=this.getSetEvent(t,s);t.traverse(i,n),t.tiles.updateVirtualMeshes(i)}getSetEvent(t,e){return s=>{t.itemConfig.setVisible(s,e)}}getVisibleCondition(t,e){return s=>t.itemConfig.visible(s)===e}getToggleEvent(t){return e=>{const s=t.itemConfig.visible(e);t.itemConfig.setVisible(e,!s)}}}class nd{getGeometriesLength(t){return t.data.meshes().globalTransformsLength()}getGeometry(t,e){const s=t.boxes.sampleOf(e),i=[];if(!s)return i;for(const e of s){const s=t.tiles.fetchSample(e,Ue.GEOMETRY),n=Array.isArray(s.geometries)?s.geometries:[s.geometries];for(const t of n)i.push({transform:s.transform.clone(),indices:t.indexBuffer,positions:t.positionBuffer,normals:t.normalBuffer})}return i}getVolume(t,e){let s=0;const i={x:0,y:0,z:0},n={x:0,y:0,z:0},r={x:0,y:0,z:0},o=this.getGeometry(t,e);for(const{indices:t,positions:e}of o)if(t&&e)for(let o=0;o<t.length-2;o+=3){const a=3*t[o],l=3*t[o+1],h=3*t[o+2];i.x=e[a],i.y=e[a+1],i.z=e[a+2],n.x=e[l],n.y=e[l+1],n.z=e[l+2],r.x=e[h],r.y=e[h+1],r.z=e[h+2],s+=this.getSignedVolumeOfTriangle(i,n,r)}return Math.abs(s)}getSignedVolumeOfTriangle(t,e,s){return 1/6*(-(s.x*e.y*t.z)+e.x*s.y*t.z+s.x*t.y*e.z-t.x*s.y*e.z-e.x*t.y*s.z+t.x*e.y*s.z)}}class rd{constructor(){ot(this,"_sectionGenerator",new Is)}async getSection(t,e,s){this._sectionGenerator.plane=e,performance.now();const i=new Map,n=[];for(const r of s){const s=t.boxes.sampleOf(r);if(s)for(const o of s){const s=t.boxes.get(o);if(!e.intersectsBox(s))continue;const a=t.tiles.meshes.meshesItems(r);if("IFCSPACE"===t.data.categories(a))continue;const l=t.tiles.meshes.samples(o);if(!l)continue;const h=l.representation();if(!i.has(h)){const e=[],s=t.tiles.fetchSample(o,Ue.GEOMETRY);Ts.forEach(s.geometries,(t=>{if(!t.indexBuffer||!t.positionBuffer)return;const s=new ft.BufferGeometry;s.setIndex(Array.from(t.indexBuffer)),s.setAttribute("position",new ft.BufferAttribute(t.positionBuffer,3)),e.push(s)})),i.set(h,e)}const c=i.get(h);if(c)for(const e of c){const s=new ft.Mesh(e),i=t.tiles.getSampleTransform(o);s.applyMatrix4(i),s.updateWorldMatrix(!0,!0),n.push(s)}}}const r=new Float32Array(6e5),o=new ft.BufferAttribute(r,3,!1),{index:a,indexes:l}=this._sectionGenerator.createEdges({meshes:n,posAttr:o}),h=this._sectionGenerator.createFills(r,l);for(const[,t]of i)for(const e of t)e.dispose();return{buffer:r,index:a,fillsIndices:h}}}class od{constructor(t){ot(this,"_model"),ot(this,"sequenceSelectorFunction",{withVisiblity:t=>this._model.getItemsByVisibility(t),highlighted:()=>this._model.getHighlightItemIds(),children:t=>this._model.getItemsChildren(t),ofCategory:t=>{const e=this._model.getItemsOfCategories(t);return Object.values(e).flat()},withCondition:()=>[],withGeometry:()=>this._model.getItemsWithGeometry()}),ot(this,"sequenceResultFunction",{attributes:t=>t.map((t=>this._model.getItemAttributes(t))),mergedBoxes:t=>this._model.getBBoxes(t),category:t=>this._model.getItemsCategories(t),children:t=>this._model.getItemsChildren(t),data:(t,...e)=>this._model.getItemsData(t,e[0]),geometry:t=>this._model.getItemsGeometry(t),guid:t=>this._model.getGuidsByLocalIds(t),highlight:t=>this._model.getHighlight(t),relations:t=>t.map((t=>this._model.getItemRelations(t))),visibility:t=>this._model.getVisible(t)}),this._model=t}getSequenced(t,e,s){var i;const n=this.sequenceResultFunction[t];if(!n)return null;let r=[],o=0;for(const t of e){const e=this.sequenceSelectorFunction[t];if(!e)continue;const n=null==(i=null==s?void 0:s.selector)?void 0:i[t];r=e(0===o?n:r),o++}return n(r,null==s?void 0:s.result)}}class ad{traverse(t,e,s){e?this.traverseItems(e,s):this.traverseAllItems(t,s)}getItemsByConfig(t,e){const s=[],i=t.data.localIdsLength();for(let t=0;t<i;t++){e(t)&&s.push(t)}return s}traverseItems(t,e){const s=t.length;for(let i=0;i<s;i++)e(t[i],i)}traverseAllItems(t,e){const s=t.itemConfig.size;for(let t=0;t<s;t++)e(t,t)}}class ld{constructor(t,e,s,i){ot(this,"data"),ot(this,"view"),ot(this,"raycaster"),ot(this,"itemConfig"),ot(this,"properties"),ot(this,"materials"),ot(this,"tiles"),ot(this,"boxes"),ot(this,"_raycastHelper",new td),ot(this,"_coordinatesHelper",new ed),ot(this,"_highlightHelper",new sd),ot(this,"_visibilityHelper",new id),ot(this,"_geometryHelper",new nd),ot(this,"_sectionHelper",new rd),ot(this,"_itemsHelper",new ad),ot(this,"_sequenceHelper",new od(this)),ot(this,"_config",{}),ot(this,"_modelId"),ot(this,"_alignments"),ot(this,"_connection"),ot(this,"_onTransferMaterial",((t,e)=>{if(this._connection)return this._connection.fetch(t,e)})),this._modelId=t,this._connection=s,this._config={...this._config,...i},this.data=this.setupModel(e),this.boxes=new Jc(this.data),this.materials=this.setupMaterials(t),this._alignments=new Gc(this.data),this.itemConfig=this.setupItemsConfig(),this.tiles=this.setupTiles(),this.properties=this.setupProperties(),this.raycaster=this.setupRaycaster(),this.setupBVH()}getItemsByConfig(t){return this._itemsHelper.getItemsByConfig(this,t)}getItemsCategories(t){return this.properties.getItemsCategories(t)}getItemIdsByLocalIds(t){return this.properties.getItemIdsFromLocalIds(t)}getItemAttributes(t){return this.properties.getItemAttributes(t)}getAttributesUniqueValues(t){return this.properties.getAttributesUniqueValues(t)}getItemsData(t,e){return this.properties.getItemsData(t,e)}getItemsOfCategories(t){return this.properties.getItemsOfCategories(t)}getItemsWithGeometry(){return this.properties.getItemsWithGeometry()}getItemsWithGeometryCategories(){return this.properties.getItemsWithGeometryCategories()}getItemsByQuery(t){return this.properties.getItemsByQuery(t)}getItemRelations(t){return this.properties.getItemRelations(t)}getSpatialStructure(){return this.properties.getSpatialStructure()}getMaxLocalId(){return this.properties.getMaxLocalId()}getCategories(){return this.properties.getCategories()}getMetadata(){return this.properties.getMetadata()}getLocalIdsByGuids(t){return this.properties.getLocalIdsByGuids(t)}getGuidsByLocalIds(t){return this.properties.getGuidsByLocalIds(t)}getSequenced(t,e,s){return this._sequenceHelper.getSequenced(t,e,s)}highlight(t,e){this._highlightHelper.highlight(this,t,e)}getHighlight(t){return this._highlightHelper.getHighlight(this,t)}getHighlightItemIds(){return this._highlightHelper.getHighlightItems(this)}resetHighlight(t){this._highlightHelper.resetHighlight(this,t)}getCoordinates(){return this._coordinatesHelper.getCoordinates(this)}getPositions(t){return this._coordinatesHelper.getPositions(this,t)}getGeometriesLength(){return this._geometryHelper.getGeometriesLength(this)}getGuids(){return this.properties.getGuids()}getLocalIds(){return this.properties.getLocalIds()}getItemsGeometry(t){const e=this.properties.getItemIdsFromLocalIds(t),s=[];for(const t of e){const e=this._geometryHelper.getGeometry(this,t);s.push(e)}return s}getItemsVolume(t){const e=this.properties.getItemIdsFromLocalIds(t);let s=0;for(const t of e)s+=this._geometryHelper.getVolume(this,t);return s}getAttributeNames(){return this.properties.getAttributeNames()}getAttributeValues(){return this.properties.getAttributeValues()}getAttributeTypes(){return this.properties.getAttributeTypes()}getRelationNames(){return this.properties.getRelationNames()}getItemsMaterialDefinition(t){const e=this.properties.getItemIdsFromLocalIds(t);return this.materials.getItemsMaterialDefinition(this.data,e,t)}resetVisible(){this._visibilityHelper.resetVisible(this)}getItemsByVisibility(t){return this._visibilityHelper.getItemsByVisibility(this,t)}raycast(t,e){return this._raycastHelper.raycast(this,t,e)}snapRaycast(t,e,s){return this._raycastHelper.snapRaycast(this,t,e,s)}rectangleRaycast(t,e){return this._raycastHelper.rectangleRaycast(this,t,e)}async getSection(t,e){const s=this.properties.getItemIdsFromLocalIds(e);return this._sectionHelper.getSection(this,t,s)}async getAlignments(){return this._alignments.getAlignments()}getBuffer(t){const e=this.data.bb.bytes().buffer;return t?e:Zo.deflate(e)}dispose(){this.tiles.dispose()}setVisible(t,e){this._visibilityHelper.setVisible(this,t,e)}toggleVisible(t){this._visibilityHelper.toggleVisible(this,t)}getVisible(t){return this._visibilityHelper.getVisible(this,t)}getItemsChildren(t){return this.properties.getItemsChildren(t)}setupData(){this.tiles.generate()}refreshView(t){this.view=t,this.tiles.setupView(t)}getFullBBox(){return this.boxes.fullBox}getBBoxes(t){const e=new ft.Box3;return this.properties.getBox(t,e),e}traverse(t,e){this._itemsHelper.traverse(this,t,e)}update(t){return this.tiles.update(t),this.tiles.tilesUpdated}setupBVH(){ft.BufferGeometry.prototype.computeBoundsTree=Eh,ft.BufferGeometry.prototype.disposeBoundsTree=gh,ft.Mesh.prototype.raycast=mh}setupProperties(){return new zc(this.data,this.boxes,this._config.properties)}setupRaycaster(){return new bc(this.data,this.boxes,this.tiles,this.itemConfig)}setupMaterials(t){return new Bc(t,this._onTransferMaterial)}setupTiles(){const t=this.materials.update(this.data);return new Uc({modelId:this._modelId,connection:this._connection,model:this.data,boxes:this.boxes,items:this.itemConfig,materials:t})}setupModel(t){const e=new Uint8Array(t),s=new Qt(e);return Oe.getRootAsModel(s)}setupItemsConfig(){const t=this.data.localIdsLength();return new Ec(t)}}class hd{constructor(t,e,s=!1){ot(this,"_modelId"),ot(this,"_virtualModel"),this._modelId=t;let i=e;s||(i=Zo.inflate(e)),this._virtualModel=new ld(t,i,void 0)}get modelId(){return this._modelId}dispose(){this._virtualModel.dispose(),this._virtualModel=null}getSpatialStructure(){return this._virtualModel.getSpatialStructure()}getLocalIdsByGuids(t){return this._virtualModel.getLocalIdsByGuids(t)}getCategories(){return this._virtualModel.getCategories()}getItemsWithGeometry(){return this._virtualModel.getItemsWithGeometry()}getMetadata(){return this._virtualModel.getMetadata()}getGuidsByLocalIds(t){return this._virtualModel.getGuidsByLocalIds(t)}getBuffer(t=!1){return this._virtualModel.getBuffer(t)}getItemsOfCategories(t){return this._virtualModel.getItemsOfCategories(t)}getMaxLocalId(){return this._virtualModel.getMaxLocalId()}getItemsChildren(t){this._virtualModel.getItemsChildren(t)}getItemsData(t,e){return this._virtualModel.getItemsData(t,e)}getPositions(t){return this._virtualModel.getPositions(t)}getCoordinates(){return this._virtualModel.getCoordinates()}}class cd{constructor(t){ot(this,"onModelLoaded",new kt),ot(this,"models"),ot(this,"settings",{autoCoordinate:!0,maxUpdateRate:100,graphicsQuality:0}),ot(this,"baseCoordinates",null),ot(this,"_connection"),ot(this,"_isDisposed",!1),ot(this,"_autoRedrawInterval",null),ot(this,"_lastUpdate",0);const e=this.newRequestEvent(),s=this.newUpdateEvent();this._connection=new Oi(e,t),this.models=new yi(s),this.models.list.onItemDeleted.add((()=>{0===this.models.list.size&&(this.baseCoordinates=null)}))}async load(t,e){const s=new Ti(e.modelId,this.models,this._connection);e.userData&&(s.object.userData=e.userData),s.frozen=!0,s.graphicsQuality=this.settings.graphicsQuality;try{if(this.models.list.set(s.modelId,s),await s._setup(t,e.raw,e.virtualModelConfig),this.settings.autoCoordinate){const t=await s.getCoordinates();if(null===this.baseCoordinates)this.baseCoordinates=t;else{const[e,i,n]=t,[r,o,a]=this.baseCoordinates,l=new ft.Vector3(r-e,o-i,a-n);s.object.position.add(l)}}}catch(t){throw this.models.list.delete(s.modelId),t}const{camera:i}=e;return i&&s.useCamera(i),s.frozen=!1,this.onModelLoaded.trigger(s),s}async dispose(){this._isDisposed=!0;const t=Array.from(this.models.list.values()),e=[];for(const s of t)e.push(s.dispose());await Promise.all(e),this.onModelLoaded.reset()}async disposeModel(t){const e=this.models.list.get(t);e&&await e.dispose()}async update(t=!1){if(this._isDisposed)return;const e=performance.now();if(e-this._lastUpdate<this.settings.maxUpdateRate)return;this._lastUpdate=e;const s=[];for(const t of this.models.list.values())s.push(t._refreshView());await Promise.all(s),t?await this.models.forceUpdateFinish():this.models.update()}async manageRequest(t){const e=this.models.list.get(t.modelId);e&&await e.handleRequest(t)}newUpdateEvent(){return()=>{this._autoRedrawInterval&&clearTimeout(this._autoRedrawInterval);const t=this.settings.maxUpdateRate+1;this._autoRedrawInterval=setTimeout((()=>{this.update()}),t)}}newRequestEvent(){return t=>{this.manageRequest(t)}}}class dd{constructor(t,e){ot(this,"_lengthUnitsFactor",1),ot(this,"_attributesOffsets",[]),ot(this,"_relationsMap",{}),ot(this,"_guids",[]),ot(this,"_guidsItems",[]),ot(this,"_uniqueAttributes",new Set),ot(this,"_uniqueRelNames",new Set),ot(this,"_ifcApi",null),ot(this,"wasm",{path:"/node_modules/web-ifc/",absolute:!1}),ot(this,"expressIDs",[]),ot(this,"classes",[]),this._serializer=t,this._builder=e}async getIfcApi(){if(!this._ifcApi){const t=new Bt.IfcAPI;t.SetWasmPath(this.wasm.path,this.wasm.absolute),await t.Init(),t.SetLogLevel(Bt.LogLevel.LOG_LEVEL_OFF),this._ifcApi=t}return this._ifcApi}async getSchema(t=0){const e=(await this.getIfcApi()).GetModelSchema(t);if(!e)throw new Error("Fragments: IFC Schema not found");return e.startsWith("IFC2X3")?"IFC2X3":e.startsWith("IFC4")&&""===e.replace("IFC4","")?"IFC4":e.startsWith("IFC4X")?"IFC4X3":e}async process(t){var e,s,i;const n=await this.getIfcApi();if(t.readFromCallback)n.OpenModelFromCallback(t.readCallback,{COORDINATE_TO_ORIGIN:!0});else{if(!t.bytes)throw new Error("Fragments: No data provided");await n.OpenModel(t.bytes,{COORDINATE_TO_ORIGIN:!0})}this._serializer.replaceStoreyElevation&&await this.setLengthUnitsFactor();const r=n.GetAllTypesOfModel(0).map((t=>t.typeID)),o=await this.getSchema();if(!Bt[o])throw new Error("Fragments: Model schema not recognized.");const a=t.geometryProcessedLocalIDs;await this.processItems(a);const l=new Set(a);null==(e=t.progressCallback)||e.call(t,.6,{process:"attributes",state:"start",entitiesProcessed:a.length});const h=new Set([...this._serializer.classes.abstract,...this._serializer.classes.elements]),c=r.filter((t=>h.has(t))),d=.15/c.length;for(const[e,i]of c.entries()){const r=n.GetLineIDsWithType(0,i);if(0===r.size())continue;const o=[];for(let t=0;t<r.size();t++){const e=r.get(t);l.has(e)||o.push(e)}0!==o.length&&(await this.processItems(o),null==(s=t.progressCallback)||s.call(t,d*(e+1)+.6,{process:"attributes",state:e+1===c.length?"finish":"inProgress",class:Gt[i],entitiesProcessed:o.length}))}const u=new Set([...this._serializer.relations.keys()]),f=r.filter((t=>u.has(t))),p=.15/f.length;for(const[e,s]of f.entries()){const n=0===e?"start":e+1===f.length?"finish":"inProgress";await this.processRelations([s]),null==(i=t.progressCallback)||i.call(t,p*(e+1)+.75,{process:"relations",state:n,class:Gt[s]})}const{relIndicesVector:I,relsVector:_}=this.getRelationsVector(),{guidsVector:m,guidsItemsVector:E}=this.getGuidsVector(),g=await this.getMetadataOffset(),b=this.getAttributesVector(),C=this.getUniqueAttributesVector(),T=this.getRelNamesVector(),A=Oe.createLocalIdsVector(this._builder,this.expressIDs),R=this.getCategoriesVector(),y=await this.getSpatialStructureOffset();return this.clean(),{relIndicesVector:I,relsVector:_,guidsVector:m,guidsItemsVector:E,metadataOffset:g,attributesVector:b,localIdsVector:A,categoriesVector:R,spatialStrutureOffset:y,uniqueAttributesVector:C,relNamesVector:T}}async processItems(t){const e=await this.getIfcApi();for(let s=0;s<t.length;s++){const i=t[s];try{const t=await e.properties.getItemProperties(0,i);if(!t)continue;const s=Gt[t.type];this.classes.push(s),this.expressIDs.push(i),await this.serializeAttributes(i,t)}catch(t){console.log(`Problem reading properties for ${i}`),console.log(t),await new Promise((t=>{setTimeout(t,100)}));continue}}}addRelation(t,e,s){this._relationsMap[t]||(this._relationsMap[t]={}),this._relationsMap[t][e]||(this._relationsMap[t][e]=[]);for(const i of s)this._relationsMap[t][e].push(i);this._serializer.includeRelationNames&&this._uniqueRelNames.add(e)}async getStoreyElevation(t,e){const s=await this.getIfcApi(),i=await s.properties.getItemProperties(0,t);let n,r;(null==i?void 0:i.RelativePlacement)&&"value"in i.RelativePlacement&&"number"==typeof i.RelativePlacement.value&&(n=await s.properties.getItemProperties(0,i.RelativePlacement.value)),(null==n?void 0:n.Location)&&"value"in n.Location&&"number"==typeof n.Location.value&&(r=await s.properties.getItemProperties(0,n.Location.value)),(null==r?void 0:r.Coordinates)&&Array.isArray(r.Coordinates)&&"value"in r.Coordinates[2]&&"number"==typeof r.Coordinates[2].value&&(e.value+=r.Coordinates[2].value),(null==i?void 0:i.PlacementRelTo)&&"value"in i.PlacementRelTo&&"number"==typeof i.PlacementRelTo.value&&await this.getStoreyElevation(i.PlacementRelTo.value,e)}async setLengthUnitsFactor(){var t,e,s,i;const n=await this.getIfcApi(),r=n.GetLineIDsWithType(0,Bt.IFCUNITASSIGNMENT);if(0!==r.size())for(let o=0;o<r.size();o++){const a=r.get(o),l=await n.properties.getItemProperties(0,a);for(const r of l.Units){const o=await n.properties.getItemProperties(0,r.value);if("LENGTHUNIT"!==(null==(t=o.UnitType)?void 0:t.value))continue;let a=1,l=1;"METRE"===o.Name.value&&(l=1),"FOOT"===o.Name.value&&(l=.3048),"MILLI"===(null==(e=o.Prefix)?void 0:e.value)?a=.001:"CENTI"===(null==(s=o.Prefix)?void 0:s.value)?a=.01:"DECI"===(null==(i=o.Prefix)?void 0:i.value)&&(a=.1),this._lengthUnitsFactor=l*a}}}async serializeAttributes(t,e){const s=[];let i=null;if(this._serializer.replaceStoreyElevation&&e.type&&"number"==typeof e.type&&e.type===Bt.IFCBUILDINGSTOREY&&e.Elevation&&"value"in e.Elevation){const t={value:0};e.ObjectPlacement&&"value"in e.ObjectPlacement&&"number"==typeof e.ObjectPlacement.value&&await this.getStoreyElevation(e.ObjectPlacement.value,t),e.Elevation.value=t.value*this._lengthUnitsFactor}for(const[n,r]of Object.entries(e)){if("number"==typeof r)continue;if(this._serializer.attributesToExclude.has(n)||null==r)continue;if(Array.isArray(r)){const e=r.filter((t=>5!==t.type));if(e.length>0){const t=[n,e.map((t=>t.value))],i="name"in e[0]&&e[0].name?e[0].name:e[0].constructor.name.toUpperCase();t.push("OBJECT"!==i?i:"UNDEFINED");const r=JSON.stringify(t),o=this._builder.createSharedString(r);s.push(o)}const i=r.filter((t=>5===t.type)).map((t=>t.value));this.addRelation(t,n,i);continue}const{value:e,type:o}=r;if(5===o){if("number"!=typeof e)continue;this.addRelation(t,n,[e])}else{if("GlobalId"===n&&"string"==typeof e){i=e;continue}const t=[n,e],o="name"in r&&r.name?r.name:r.constructor.name.toUpperCase();t.push("OBJECT"!==o?o:"UNDEFINED");const a=JSON.stringify(t),l=this._builder.createSharedString(a);s.push(l),this._serializer.includeUniqueAttributes&&this._uniqueAttributes.add(a)}}const n=ee.createDataVector(this._builder,s),r=ee.createAttribute(this._builder,n);this._attributesOffsets.push(r),i&&(this._guids.push(i),this._guidsItems.push(t))}getAttributesVector(){return Oe.createAttributesVector(this._builder,this._attributesOffsets)}getUniqueAttributesVector(){const t=[];for(const e of this._uniqueAttributes){const s=this._builder.createSharedString(e);t.push(s)}return Oe.createUniqueAttributesVector(this._builder,t)}getRelNamesVector(){const t=[];for(const e of this._uniqueRelNames){const s=this._builder.createSharedString(e);t.push(s)}return Oe.createRelationNamesVector(this._builder,t)}getGuidsVector(){const t=[];for(const e of this._guids){const s=this._builder.createString(e);t.push(s)}return{guidsVector:Oe.createGuidsVector(this._builder,t),guidsItemsVector:Oe.createGuidsItemsVector(this._builder,this._guidsItems)}}async processRelations(t){const e=await this.getIfcApi();for(const s of t){const t=this._serializer.relations.get(s);if(!t)continue;const{forRelating:i,forRelated:n}=t,r=e.GetLineIDsWithType(0,s);if(0!==r.size())for(let t=0;t<r.size();t++){const s=r.get(t),o=await e.properties.getItemProperties(0,s);if(!o)continue;const a=Object.keys(o),l=a.find((t=>t.startsWith("Relating"))),h=a.find((t=>t.startsWith("Related")));if(!l||!h)continue;const c=o[l].value,d=o[h].map((({value:t})=>t));this.addRelation(c,i,d);for(const t of d)this.addRelation(t,n,[c])}}}getRelationsVector(t=!1){const e=[],s=[];for(const[i,n]of Object.entries(this._relationsMap)){if(t&&!this.expressIDs.includes(Number(i)))continue;const r=[];for(const[e,s]of Object.entries(n)){let i=s;if(t&&(i=s.filter((t=>this.expressIDs.includes(t))),0===i.length))continue;const n=JSON.stringify([e,...i]),o=this._builder.createSharedString(n);r.push(o)}if(t&&0===r.length)continue;s.push(Number(i));const o=we.createDataVector(this._builder,r),a=we.createRelation(this._builder,o);e.push(a)}const i=Oe.createRelationsVector(this._builder,e);return{relIndicesVector:Oe.createRelationsItemsVector(this._builder,s),relsVector:i}}getCategoriesVector(){const t=this.classes.map((t=>this._builder.createSharedString(t)));return Oe.createCategoriesVector(this._builder,t)}async getMetadataOffset(){const t={schema:(await this.getIfcApi()).GetModelSchema(0)};return this._builder.createString(JSON.stringify(t))}getEntityDecomposition(t,e){var s;const i=[];for(const n of e){const r=null==(s=this._relationsMap[t])?void 0:s[n];if(!r)continue;const o={};for(const t of r){const e=this.expressIDs.indexOf(t);if(-1===e)continue;const s=this.classes[e];s&&(o[s]||(o[s]=[]),o[s].push(t))}for(const t in o){const s=o[t].map((t=>this.getEntityDecomposition(t,e))),n=xe.createChildrenVector(this._builder,s),r=this._builder.createSharedString(t);xe.startSpatialStructure(this._builder),xe.addCategory(this._builder,r),xe.addChildren(this._builder,n);const a=xe.endSpatialStructure(this._builder);i.push(a)}}const n=xe.createChildrenVector(this._builder,i);xe.startSpatialStructure(this._builder),xe.addLocalId(this._builder,t),xe.addChildren(this._builder,n);return xe.endSpatialStructure(this._builder)}async getSpatialStructureOffset(){const t=await this.getIfcApi(),e=Bt.IFCPROJECT,s=[...t.GetLineIDsWithType(0,e)].map((t=>this.getEntityDecomposition(t,["IsDecomposedBy","ContainsElements"]))),i=this._builder.createSharedString("IFCPROJECT"),n=xe.createChildrenVector(this._builder,s);xe.startSpatialStructure(this._builder),xe.addCategory(this._builder,i),xe.addChildren(this._builder,n);return xe.endSpatialStructure(this._builder)}clean(){var t;null==(t=this._ifcApi)||t.Dispose(),this._ifcApi=null,this._guids=[],this._guidsItems=[],this._attributesOffsets=[],this._relationsMap={},this._uniqueAttributes.clear(),this._uniqueRelNames.clear(),this.expressIDs=[],this.classes=[]}}function ud(t,e){return Math.round(t*e)/e}class fd{constructor(t,e,s,i){ot(this,"x"),ot(this,"y"),ot(this,"z"),ot(this,"hash"),ot(this,"id"),this.x=ud(t[3*e],i),this.y=ud(t[3*e+1],i),this.z=ud(t[3*e+2],i),this.hash=`${this.x}/${this.y}/${this.z}`,this.id=s}}class pd{constructor(t){ot(this,"list",new Map),ot(this,"tempV1",new ft.Vector3),ot(this,"tempV2",new ft.Vector3),ot(this,"tempV3",new ft.Vector3),ot(this,"precission"),this.precission=t}create(t,e){const s=new fd(t,e,this.list.size,this.precission);return this.list.has(s.hash)||this.list.set(s.hash,s),this.list.get(s.hash)}get(){return Array.from(this.list.values()).map((t=>[t.x,t.y,t.z]))}isValidTriangle(t,e,s,i){this.tempV1.set(t[3*e],t[3*e+1],t[3*e+2]),this.tempV2.set(t[3*s],t[3*s+1],t[3*s+2]),this.tempV3.set(t[3*i],t[3*i+1],t[3*i+2]);const n=1/this.precission*10,r=this.tempV1.distanceTo(this.tempV2)>n,o=this.tempV1.distanceTo(this.tempV3)>n,a=this.tempV2.distanceTo(this.tempV3)>n;return r&&o&&a}}class Id{constructor(t,e){ot(this,"p1"),ot(this,"p2"),ot(this,"hash"),this.p1=t,this.p2=e;const s=[this.p1,this.p2];s.sort(((t,e)=>t.x-e.x||t.y-e.y||t.z-e.z)),this.hash=`${s[0].hash}_${s[1].hash}`}}class _d{constructor(t,e){ot(this,"edges",new Map),ot(this,"openEdges",new Set),ot(this,"id"),ot(this,"plane"),this.id=t,this.plane=e}add(t){if(0!==this.edges.size)for(const e of t)this.openEdges.has(e.hash)?this.openEdges.delete(e.hash):this.openEdges.add(e.hash),this.edges.set(e.hash,e);else for(const e of t)this.openEdges.add(e.hash),this.edges.set(e.hash,e)}match(t,e){if(e.id!==this.plane.id)return!1;for(const e of t)if(this.openEdges.has(e.hash))return!0;return!1}getOpenEdges(){const t=[];for(const e of this.openEdges)t.push(this.edges.get(e));return t}merge(t){for(const[e,s]of t.edges)this.edges.set(e,s);for(const e of t.openEdges)this.openEdges.has(e)?this.openEdges.delete(e):this.openEdges.add(e)}}class md{constructor(){ot(this,"list",new Map),ot(this,"nextFaceID",0)}add(t,e){const s=this.match(t,e);if(0===s.length){const s=this.nextFaceID++,i=new _d(s,e);return i.add(t),void this.list.set(i.id,i)}if(1!==s.length){if(s.length>1){const e=this.list.get(s[0]);e.add(t);for(let t=1;t<s.length;t++){const i=s[t],n=this.list.get(i);e.merge(n),this.list.delete(i)}}}else{this.list.get(s[0]).add(t)}}match(t,e){let s=[];for(const i of this.list.values())i.match(t,e)&&s.push(i.id);return s}}class Ed{constructor(t){ot(this,"closed",!1),ot(this,"openStartPoint",null),ot(this,"openEndPoint",null),ot(this,"plane"),ot(this,"orderedPoints",[]),this.plane=t}getEdges(t=!1){const e=[];if(t)for(let t=this.orderedPoints.length-1;t>0;t--)e.push(new Id(this.orderedPoints[t],this.orderedPoints[t-1]));else for(let t=0;t<this.orderedPoints.length-1;t++)e.push(new Id(this.orderedPoints[t],this.orderedPoints[t+1]));return e}getIndices(){return this.orderedPoints.map((t=>t.id))}add(t){if(0===this.orderedPoints.length)return this.openStartPoint=t.p1.hash,this.openEndPoint=t.p2.hash,void this.orderedPoints.push(t.p1,t.p2);const e=this.match(t);if(0===e)throw new Error("Fragments: Edge doesn't match with any open point");if(e>2)throw new Error("Fragments: Edge matches with more than 2 open points");if(2===e)return this.closed=!0,this.openEndPoint=null,void(this.openStartPoint=null);this.openStartPoint===t.p1.hash?(this.orderedPoints.unshift(t.p2),this.openStartPoint=t.p2.hash):this.openEndPoint===t.p1.hash?(this.orderedPoints.push(t.p2),this.openEndPoint=t.p2.hash):this.openStartPoint===t.p2.hash?(this.orderedPoints.unshift(t.p1),this.openStartPoint=t.p1.hash):this.openEndPoint===t.p2.hash&&(this.orderedPoints.push(t.p1),this.openEndPoint=t.p1.hash)}match(t){if(this.closed)return 0;let e=0;return this.openStartPoint===t.p1.hash&&e++,this.openStartPoint===t.p2.hash&&e++,this.openEndPoint===t.p1.hash&&e++,this.openEndPoint===t.p2.hash&&e++,e}merge(t){if(t.closed||this.closed)throw new Error("Fragments: Cannot merge closed profiles");if(t.openStartPoint===this.openEndPoint&&t.openEndPoint===this.openStartPoint)throw new Error("Fragments: Cannot merge profiles that close each other");if(t.openEndPoint===this.openEndPoint&&t.openStartPoint===this.openStartPoint)throw new Error("Fragments: Cannot merge profiles that close each other");let e=!1;t.openEndPoint!==this.openStartPoint&&t.openEndPoint!==this.openEndPoint||(e=!0);const s=t.getEdges(e);for(const t of s)this.add(t)}getArea(){const t=this.orderedPoints.map((t=>[t.x,t.y,t.z]));let e=0,s=1;const i=Math.abs(this.plane.normal.x),n=Math.abs(this.plane.normal.y),r=Math.abs(this.plane.normal.z);i>=n&&i>=r?(e=1,s=2):n>=i&&n>=r?(e=0,s=2):(e=0,s=1);const o=[];for(const i of t)o.push(new ft.Vector2(i[e],i[s]));let a=0;for(let t=0,e=o.length;t<e;t++){a+=o[t].x*o[t===o.length-1?0:t+1].y*.5,a-=o[t===o.length-1?0:t+1].x*o[t].y*.5}return Math.abs(a)}}class gd{constructor(t){ot(this,"list",new Map),ot(this,"plane"),ot(this,"nextProfileID",0),this.plane=t}add(t){const e=this.match(t);if(0===e.length){const e=this.nextProfileID++,s=new Ed(this.plane);return s.add(t),void this.list.set(e,s)}if(1!==e.length){if(e.length>1){const s=this.list.get(e[0]);s.add(t);const i=this.list.get(e[1]);s.merge(i),this.list.delete(e[1])}}else{this.list.get(e[0]).add(t)}}getProfiles(){let t=null,e=0;for(const[s,i]of this.list){const n=i.getArea();n>e&&(e=n,t=s)}if(null===t)return null;const s=this.list.get(t).getIndices(),i=[];for(const[e,s]of this.list)e!==t&&i.push(s.getIndices());return{profile:s,holes:i}}match(t){const e=[];for(const[s,i]of this.list)i.match(t)>0&&e.push(s);return e}}function bd(t){let e=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY,r=Number.NEGATIVE_INFINITY,o=Number.NEGATIVE_INFINITY;for(let a=0;a<t.length;a+=3){const l=t[a],h=t[a+1],c=t[a+2];l<e&&(e=l),h<s&&(s=h),c<i&&(i=c),l>n&&(n=l),h>r&&(r=h),c>o&&(o=c)}return{min:{x:e,y:s,z:i},max:{x:n,y:r,z:o}}}class Cd{constructor(t,e,s){ot(this,"normal"),ot(this,"constant"),ot(this,"id"),ot(this,"faces",[]);const i=ud(t.normal.x,s),n=ud(t.normal.y,s),r=ud(t.normal.z,s),o=ud(t.constant,e);this.normal=new ft.Vector3(i,n,r),this.constant=o;const a="||";this.id=`${i}${a}${n}${a}${r}${a}${o}`}}function Td(t){const{position:e,normals:s,index:i,raw:n}=t,r=e.length/3>3e3,o=bd(e);if(n||r)return function(t,e,s){const i=new Map,n=new Map,r=(t,e,s)=>{const n=`${t},${e},${s}`;if(i.has(n))return i.get(n)[0];const r=i.size;return i.set(n,[r,t,e,s]),r};for(let s=0;s<t.length-2;s+=3){const i=t[s],o=t[s+1],a=t[s+2],l=e[3*i],h=e[3*i+1],c=e[3*i+2],d=e[3*o],u=e[3*o+1],f=e[3*o+2],p=e[3*a],I=e[3*a+1],_=e[3*a+2],m=r(l,h,c),E=r(d,u,f),g=r(p,I,_);n.set(n.size,[m,E,g])}const o=[];for(const[,[,t,e,s]]of i)o.push([t,e,s]);return{bbox:s,type:Le.SHELL,profiles:n,holes:new Map,points:o}}(i,e,o);const a=new ft.Plane,l=new ft.Vector3,h=new ft.Vector3,c=new Map;for(let t=0;t<i.length-2;t+=3){const n=i[t];l.set(s[3*n],s[3*n+1],s[3*n+2]),h.set(e[3*n],e[3*n+1],e[3*n+2]),a.setFromNormalAndCoplanarPoint(l,h);const r=new Cd(a,1e3,1e7);c.has(r.id)||c.set(r.id,r),c.get(r.id).faces.push(t)}const d=new pd(1e6),u=new md;for(const[,t]of c)for(const s of t.faces){const n=i[s],r=i[s+1],o=i[s+2];if(!d.isValidTriangle(e,n,r,o))continue;const a=d.create(e,n),l=d.create(e,r),h=d.create(e,o),c=[new Id(a,l),new Id(l,h),new Id(h,a)];u.add(c,t)}const f=new Map,p=new Map;let I=0;for(const[,t]of u.list){const e=new gd(t.plane),s=t.getOpenEdges();for(const t of s)e.add(t);const i=e.getProfiles();f.set(I,(null==i?void 0:i.profile)||[]),p.set(I,(null==i?void 0:i.holes)||[]),I++}return{bbox:o,type:Le.SHELL,profiles:f,holes:p,points:d.get()}}class Ad{read(t){try{const e=t.GetAllAlignments(0),s=[];for(const t of e){const e={absolute:[],horizontal:[],vertical:[]};s.push(e);let i=0;for(let s=0;s<t.horizontal.length;s++){const n=t.curve3D[0].points,r=t.horizontal[s],o=[],a=[],l=this.getCurveType(r.data[1]),h=[],c=[];for(const t of r.points){const{x:e,y:s,z:r}=n[i++];h.push([e,s,r]),c.push([t.x,t.y])}h.reverse(),c.reverse();for(const[t,e,s]of h)o.push(t,e,s);for(const[t,e]of c)a.push(t,0,-e);const d=new Float32Array(o),u=new Float32Array(a);e.absolute.push({points:d,type:l}),e.horizontal.push({points:u,type:l})}for(let s=0;s<t.vertical.length;s++){const i=t.vertical[s],n=[],r=this.getCurveType(i.data[1]),o=[];for(const t of i.points)o.push([t.x,t.y]);o.reverse();for(const[t,e]of o)n.push(t,e,0);const a=new Float32Array(n);e.vertical.push({points:a,type:r})}}return s}catch(t){return console.error(t),[]}}getCurveType(t){if(t.includes("CIRCULARARC"))return ge.ELLIPSE_ARC;if(t.includes("LINE")||t.includes("GRADIENT"))return ge.LINES;if(t.includes("CLOTHOID"))return ge.CLOTHOID;if(t.includes("PARABOLICARC"))return ge.PARABOLA;throw new Error(`Fragments: Unknown curve type: ${t}`)}}class Rd{constructor(t){ot(this,"_ifcAPI",null),ot(this,"wasm",{path:"../../../../node_modules/web-ifc/",absolute:!1}),ot(this,"_tempObject1",new ft.Object3D),ot(this,"_tempObject2",new ft.Object3D),ot(this,"_tempMatrix1",new ft.Matrix4),ot(this,"_previousGeometries",new Map),ot(this,"_previousGeometriesIDs",new Map),ot(this,"_previousGeometriesScales",new Map),ot(this,"_previousLocalTransforms",new Map),ot(this,"_problematicGeometries",new Set),ot(this,"_problematicGeometriesHashes",new Set),ot(this,"_coordinatesInitialized",!1),ot(this,"_civilReader",new Ad),ot(this,"_maxId",0),ot(this,"_rawCategories",new Set([Bt.IFCEARTHWORKSFILL,Bt.IFCEARTHWORKSCUT])),ot(this,"distanceThreshold",1e5),ot(this,"scene",null),ot(this,"isolatedMeshes",null),ot(this,"onElementLoaded",(()=>{})),ot(this,"onGeometryLoaded",(()=>{})),ot(this,"onLocalTransformLoaded",(()=>{})),ot(this,"onMaxIdFound",(()=>{})),ot(this,"onCoordinatesLoaded",(()=>{})),ot(this,"onAlignmentsLoaded",(()=>{})),this._serializer=t}async load(t){var e,s,i;null==(e=t.progressCallback)||e.call(t,0,{process:"conversion",state:"start"}),this._previousGeometriesIDs.clear(),this._ifcAPI=new Bt.IfcAPI,this._ifcAPI.SetWasmPath(this.wasm.path,this.wasm.absolute),await this._ifcAPI.Init();let n=0;if(t.readFromCallback&&t.readCallback)n=this._ifcAPI.OpenModelFromCallback(t.readCallback,{COORDINATE_TO_ORIGIN:!0});else{if(!t.bytes)throw new Error("Fragments: No data provided");n=await this._ifcAPI.OpenModel(t.bytes,{COORDINATE_TO_ORIGIN:!0})}this._ifcAPI.SetLogLevel(Bt.LogLevel.LOG_LEVEL_OFF),this._maxId=this._ifcAPI.GetMaxExpressID(n),this.onLocalTransformLoaded({id:0,data:[0,0,0,1,0,0,0,1,0]});const r=new ft.Vector3,o=t=>{if(null===this._ifcAPI)throw new Error("Fragments: IfcAPI not initialized");if(!this._coordinatesInitialized){const t=this._ifcAPI.GetCoordinationMatrix(n);this._tempMatrix1.fromArray(t);const e=this.decompose(this._tempMatrix1);this.onCoordinatesLoaded(e),this._coordinatesInitialized=!0}const e=this._ifcAPI.GetLine(0,t.expressID),s={id:t.expressID,type:e.type,guid:e.GlobalId.value,geometries:[]},i=t.geometries.size(),o=t.geometries.get(0).flatTransformation,{transformWithoutScale:a}=this.removeScale(o);if(r.set(0,0,0),r.applyMatrix4(a),r.x>this.distanceThreshold||r.y>this.distanceThreshold||r.z>this.distanceThreshold)return void console.log(`Object ${s.id} is more than ${this.distanceThreshold} meters away from the origin and will be skipped.`);for(let e=0;e<i;e++)s.type===Bt.IFCREINFORCINGBAR?this.loadCircleExtrusionGeometry(n,s,t,e,a.elements):this.loadShellGeometry(n,s,t,e,a.elements);const{dxx:l,dxy:h,dxz:c,dyx:d,dyy:u,dyz:f,px:p,py:I,pz:_}=this.decompose(a);s.geometries.length>0&&this.onElementLoaded({element:s,position:[p,I,_],xDirection:[l,h,c],yDirection:[d,u,f]})};if(null==(s=this.isolatedMeshes)?void 0:s.size)this._ifcAPI.StreamMeshes(n,Array.from(this.isolatedMeshes),o);else{const e=this._ifcAPI.GetAllTypesOfModel(n).map((t=>t.typeID)).filter((t=>this._serializer.classes.elements.has(t))),s=.5/e.length;for(const[r,a]of e.entries()){const l=0===r?"start":r+1===e.length?"finish":"inProgress",h=this._ifcAPI.GetLineIDsWithType(n,a),c=[];for(let t=0;t<h.size();t++)c.push(h.get(t));c.length>0&&(this._ifcAPI.StreamMeshes(n,c,o),null==(i=t.progressCallback)||i.call(t,s*(r+1),{process:"geometries",state:l,class:Gt[a],entitiesProcessed:c.length}))}}const a=this._civilReader.read(this._ifcAPI);this.onAlignmentsLoaded(a),this.onMaxIdFound(this._maxId),this._ifcAPI.Dispose(),this._ifcAPI=null,this._ifcAPI=new Bt.IfcAPI,this._ifcAPI.SetWasmPath(this.wasm.path,this.wasm.absolute),await this._ifcAPI.Init(),this._previousGeometries.clear(),this._previousGeometriesIDs.clear(),this._previousGeometriesScales.clear(),this._maxId=0,this._previousLocalTransforms.clear(),this._problematicGeometries.clear(),this._problematicGeometriesHashes.clear()}loadCircleExtrusionGeometry(t,e,s,i,n){if(null===this._ifcAPI)throw new Error("Fragments: IfcAPI not initialized");const r=s.geometries.get(i),o=r.flatTransformation,{units:a}=this.removeScale(o),{x:l,y:h,z:c,w:d}=r.color,u={id:r.geometryExpressID,color:[l,h,c,d],localTransformID:null};e.geometries.push(u);const{transformWithoutScale:f}=this.removeScale(r.flatTransformation);if(this._previousGeometriesIDs.has(u.id))return this.getLocalTransform(n,f,u),void(u.id=this._previousGeometriesIDs.get(u.id));this.getLocalTransform(n,f,u);const p=this._ifcAPI.GetGeometry(t,u.id),I=p.GetSweptDiskSolid(),_=[],m=[],E=I.axis.size();for(let t=0;t<E;t++){const e=I.axis.get(t),s=[];for(let t=0;t<e.arcSegments.size();t++)s.push(e.arcSegments.get(t));_.push(s);const i=[];for(let t=0;t<e.points.size();t++){const s=e.points.get(t);i.push({x:s.x*a.x,y:s.y*a.y,z:s.z*a.z})}m.push(i)}const g=[],b=[],C=[],T=[];for(let t=0;t<m.length;t++){const e=m[t],s=_[t],i=e.length;for(let t=0;t<i-1;t++){let i=-1,n=-1;for(let e=0;e<s.length;e+=2)if(s[e]===t){i=t,n=s[e+1];break}if(-1===i){const s=[],i=e[t],n=e[t+1],r=i.x,o=i.y,a=i.z,l=n.x,h=n.y,c=n.z;g.push(C.length),s.push(r,o,a,l,h,c),C.push(s),b.push(ae.WIRE)}else{const s=[],r=i,o=Math.round((i+n)/2),a=n,l=e[r],h=e[o],c=e[a],d=this.computeCircleCurveProperties(l,h,c),u=l.x-d.center.x,f=l.y-d.center.y,p=l.z-d.center.z;let I=Math.sqrt(u*u+f*f+p*p);0===I&&(I=1);const _=u/I,m=f/I,E=p/I,C=h.x-d.center.x,A=h.y-d.center.y,R=h.z-d.center.z;let y=Math.sqrt(C*C+A*A+R*R);0===y&&(y=1);const F=C/y,S=A/y,w=R/y;let x=this.crossProduct({x:_,y:m,z:E},{x:F,y:S,z:w});I=Math.sqrt(x.x*x.x+x.y*x.y+x.z*x.z),0===I&&(I=1),x={x:x.x/I,y:x.y/I,z:x.z/I},g.push(T.length),s.push(d.center.x,d.center.y,d.center.z,d.radius,d.angle,_,m,E,x.x,x.y,x.z),T.push(s),b.push(ae.CIRCLE_CURVE),t=a-1}}}const A=this.getGeometryBuffers(t,r);if(null===A)return console.log(`Zero length geometry: ${u.id}`),e.geometries.pop(),void this._problematicGeometries.add(u.id);const{position:R}=A;for(let t=0;t<R.length-2;t+=3)R[t]*=a.x,R[t+1]*=a.y,R[t+2]*=a.z;const y=bd(R),F=I.profileRadius*a.x;this._previousGeometriesIDs.set(u.id,u.id),this.onGeometryLoaded({id:u.id,geometry:{type:Le.CIRCLE_EXTRUSION,indicesArray:g,typesArray:b,segments:C,circleCurveData:T,radius:F,bbox:y}}),p.delete()}loadShellGeometry(t,e,s,i,n){if(null===this._ifcAPI)throw new Error("Fragments: IfcAPI not initialized");const r=s.geometries.get(i),o=r.flatTransformation,{units:a}=this.removeScale(o);if(this._problematicGeometries.has(r.geometryExpressID))return void console.log(` Problematic geometry: ${r.geometryExpressID}`);const{x:l,y:h,z:c,w:d}=r.color,u={id:r.geometryExpressID,color:[l,h,c,d],localTransformID:null};e.geometries.push(u);const{transformWithoutScale:f}=this.removeScale(r.flatTransformation);if(this._previousGeometriesIDs.has(u.id)){const t=this.getScaleHash(a);if(this._previousGeometriesScales.get(u.id)===t)return this.getLocalTransform(n,f,u),void(u.id=this._previousGeometriesIDs.get(u.id));const e=++this._maxId;this._previousGeometriesScales.set(e,t),u.id=e}const p=this.getGeometryBuffers(t,r);if(null===p)return console.log(`Zero length geometry: ${u.id}`),e.geometries.pop(),void this._problematicGeometries.add(u.id);const{position:I,normals:_,index:m}=p;for(let t=0;t<I.length-2;t+=3)I[t]*=a.x,I[t+1]*=a.y,I[t+2]*=a.z;const E=I.length/3,g=m.length/3;let b=0,C=0;const T=new ft.Triangle,A=new ft.Vector3,R=new ft.Vector3,y=new ft.Vector3,F=this.getVolume(m,I),S=new ft.Vector3;for(let t=0;t<m.length-2;t+=3){const e=m[t],s=m[t+1],i=m[t+2];A.set(I[3*e],I[3*e+1],I[3*e+2]),R.set(I[3*s],I[3*s+1],I[3*s+2]),y.set(I[3*i],I[3*i+1],I[3*i+2]),S.add(A),S.add(R),S.add(y),T.set(A,R,y);const n=T.getArea();n>b&&(b=n),C+=n}S.divideScalar(m.length),A.set(I[0],I[1],I[2]),R.set(I[3],I[4],I[5]),y.set(I[6],I[7],I[8]);const w=1e4,x=ud(C,w),O=ud(b,w),v=ud(F,w),L=ud(A.x,w),P=ud(A.y,w),N=ud(A.z,w),M=`${E}-${g}-${x}-${O}-${v}-${ud(S.x,w)}-${ud(S.x,w)}-${ud(S.x,w)}-${L}-${P}-${N}`;if(this._problematicGeometriesHashes.has(M))return console.log(`Problematic geometry: ${u.id}`),e.geometries.pop(),this._problematicGeometries.add(u.id),void this._problematicGeometriesHashes.add(M);const D=!this._previousGeometries.has(M),U=u.id;if(D)this._previousGeometries.set(M,U),this._previousGeometriesIDs.set(U,U);else{const t=this._previousGeometries.get(M);if(void 0===t)throw new Error("Fragments: Previous geometry not found");this._previousGeometriesIDs.set(U,t),u.id=t}this.getLocalTransform(n,f,u);const V=this._rawCategories.has(e.type);if(D)try{const t=Td({position:I,normals:_,index:m,raw:V});this.onGeometryLoaded({id:u.id,geometry:t})}catch(t){console.error(`Fragments: Problematic geometry: ${u.id}`),e.geometries.pop(),this._problematicGeometries.add(u.id),this._problematicGeometriesHashes.add(M)}}getScaleHash(t){return`${t.x}-${t.y}-${t.z}`}getLocalTransform(t,e,s){this._tempObject1.position.set(0,0,0),this._tempObject1.rotation.set(0,0,0),this._tempObject1.scale.set(1,1,1),this._tempObject1.updateMatrix(),this._tempMatrix1.fromArray(t),this._tempObject1.applyMatrix4(this._tempMatrix1),this._tempObject2.position.set(0,0,0),this._tempObject2.rotation.set(0,0,0),this._tempObject2.scale.set(1,1,1),this._tempObject2.updateMatrix(),this._tempObject2.applyMatrix4(e),this._tempObject1.attach(this._tempObject2);const{px:i,py:n,pz:r,dxx:o,dxy:a,dxz:l,dyx:h,dyy:c,dyz:d}=this.decompose(this._tempObject2.matrix);this._tempObject2.removeFromParent();if(!(0===i&&0===n&&0===r&&1===o&&0===a&&0===l&&0===h&&1===c&&0===d)){const t=`${i}-${n}-${r}-${o}-${a}-${l}-${h}-${c}-${d}`,e=this._previousLocalTransforms.get(t);if(e)s.localTransformID=e.id;else{const e={id:this._previousLocalTransforms.size+1,data:[i,n,r,o,a,l,h,c,d]};this._previousLocalTransforms.set(t,e),s.localTransformID=e.id,this.onLocalTransformLoaded(e)}}}removeScale(t){const e=(new ft.Matrix4).fromArray(t),s=new ft.Vector3,i=new ft.Quaternion,n=new ft.Vector3;e.decompose(s,i,n);const r=n,o=new ft.Matrix4;return o.compose(s,i,new ft.Vector3(1,1,1)),{units:r,transformWithoutScale:o}}decompose(t){const e=1e3,s=1e5;return{dxx:ud(t.elements[0],e),dxy:ud(t.elements[1],e),dxz:ud(t.elements[2],e),dyx:ud(t.elements[4],s),dyy:ud(t.elements[5],s),dyz:ud(t.elements[6],s),dzx:ud(t.elements[8],s),dzy:ud(t.elements[9],s),dzz:ud(t.elements[10],s),px:ud(t.elements[12],s),py:ud(t.elements[13],s),pz:ud(t.elements[14],s)}}getVolume(t,e){let s=0;const i=new ft.Vector3,n=new ft.Vector3,r=new ft.Vector3;for(let o=0;o<t.length-2;o+=3){const a=3*t[o],l=3*t[o+1],h=3*t[o+2];i.set(e[a],e[a+1],e[a+2]),n.set(e[l],e[l+1],e[l+2]),r.set(e[h],e[h+1],e[h+2]),s+=this.getSignedVolumeOfTriangle(i,n,r)}return Math.abs(s)}getSignedVolumeOfTriangle(t,e,s){return 1/6*(-(s.x*e.y*t.z)+e.x*s.y*t.z+s.x*t.y*e.z-t.x*s.y*e.z-e.x*t.y*s.z+t.x*e.y*s.z)}getGeometryBuffers(t,e){if(!this._ifcAPI)throw new Error("Fragments: IfcAPI not initialized");const s=this._ifcAPI.GetGeometry(t,e.geometryExpressID),i=this._ifcAPI.GetIndexArray(s.GetIndexData(),s.GetIndexDataSize()),n=this._ifcAPI.GetVertexArray(s.GetVertexData(),s.GetVertexDataSize());if(0===i.length||0===n.length)return s.delete(),null;const r=new Float32Array(n.length/2),o=new Float32Array(n.length/2);for(let t=0;t<n.length;t+=6)r[t/2]=n[t],r[t/2+1]=n[t+1],r[t/2+2]=n[t+2],o[t/2]=n[t+3],o[t/2+1]=n[t+4],o[t/2+2]=n[t+5];return s.delete(),{position:r,normals:o,index:i}}crossProduct(t,e){return{x:t.y*e.z-t.z*e.y,y:t.z*e.x-t.x*e.z,z:t.x*e.y-t.y*e.x}}computeCircleCurveProperties(t,e,s){function i(t,e){return{x:t.x-e.x,y:t.y-e.y,z:t.z-e.z}}function n(t){return Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z)}const r=i(e,t),o=i(s,e),a=this.crossProduct(r,o),l=function(t,e,s){const i=e.x-t.x,n=e.y-t.y,r=e.z-t.z,o=s.x-t.x,a=s.y-t.y,l=s.z-t.z,h=.5*(i**2+n**2+r**2),c=.5*(o**2+a**2+l**2),d=i*a-n*o,u=n*l-r*a,f=r*o-i*l,p=h*o-c*i,I=h*a-c*n,_=h*l-c*r,m=d**2+u**2+f**2;if(0===m)throw new Error("Fragments: Points are collinear, no unique circle exists.");return{x:t.x+(d*I-f*_)/m,y:t.y+(u*_-d*p)/m,z:t.z+(f*p-u*I)/m}}(t,e,s),h=i(t,l),c=i(s,l),d=n(i(l,t)),u=i(t,l),f=n(u);u.x/=f,u.y/=f,u.z/=f;return{center:l,radius:d,normal:a,initialTangent:u,angle:180*Math.acos((h.x*c.x+h.y*c.y+h.z*c.z)/(n(h)*n(c)))/Math.PI}}}class yd{constructor(t){ot(this,"wasm",{path:"../../../../node_modules/web-ifc/",absolute:!1}),this._serializer=t}async process(t){const{builder:e}=t;let s=0;const i=[];let n={dxx:1,dxy:0,dxz:0,dyx:0,dyy:1,dyz:0,px:0,py:0,pz:0};const r=[],o=[],a=[],l=[],h=new Map,c=new Map,d=new Map,u=new Rd(this._serializer);u.wasm=this.wasm,u.onGeometryLoaded=t=>{r.push(t)},u.onElementLoaded=t=>{a.push(t)},u.onLocalTransformLoaded=t=>{l.push(t)},u.onCoordinatesLoaded=t=>{n=t},u.onMaxIdFound=t=>{s=t},u.onAlignmentsLoaded=t=>{for(const e of t)o.push(e)},await u.load(t);const f=[];let p=0;Se.startGlobalTransformsVector(e,a.length);const I=new Map,_=[];for(let t=0;t<a.length;t++){const s=a[a.length-1-t];f.push(p++);const{position:n,xDirection:r,yDirection:o}=s,[l,c,d]=n,[u,m,E]=r,[g,b,C]=o;i.push(a[t].element.id);const T=a.length-1-t,A=s.element.type,R=Gt[A];I.has(R)||I.set(R,I.size),me.createTransform(e,l,c,d,u,m,E,g,b,C),I.get(R),_.unshift(s.element.id),h.set(s.element.id,T)}const m=e.endVector(),E=[];for(let t=0;t<r.length;t++){const s=r[t];if(s.geometry.type!==Le.SHELL)continue;const{points:i,profiles:n,holes:o}=s.geometry,a=65e3,l=i.length>a,h=l?ye.BIG:ye.NONE;Fe.startPointsVector(e,i.length);for(let t=0;t<i.length;t++){const[s,n,r]=i[i.length-1-t];se.createFloatVector(e,s,n,r)}const c=e.endVector(),d=[],u=[],f=[],p=[];for(const[,t]of n){if(l){const s=he.createIndicesVector(e,t),i=he.createBigShellProfile(e,s);f.push(i);continue}const s=Re.createIndicesVector(e,t),i=Re.createShellProfile(e,s);d.push(i)}const I=Fe.createBigProfilesVector(e,f),_=Fe.createProfilesVector(e,d);for(const[t,s]of o)if(l)for(const i of s){const s=le.createIndicesVector(e,i),n=le.createBigShellHole(e,s,t);p.push(n)}else for(const i of s){const s=Ae.createIndicesVector(e,i),n=Ae.createShellHole(e,s,t);u.push(n)}const m=Fe.createBigHolesVector(e,p),g=Fe.createHolesVector(e,u),b=Fe.createShell(e,_,g,c,I,m,h);E.push(b)}const g=Se.createShellsVector(e,E),b=[];for(let t=0;t<r.length;t++){const s=r[t];if(s.geometry.type!==Le.CIRCLE_EXTRUSION)continue;const i=[],{radius:n,indicesArray:o,typesArray:a,segments:l,circleCurveData:h}=s.geometry;oe.startCircleCurvesVector(e,h.length);for(let t=0;t<h.length;t++){const[s,i,n,r,o,a,l,c,d,u,f]=h[t];ie.createCircleCurve(e,o/360*2*Math.PI,s,i,n,r,d,u,f,a,l,c)}const c=e.endVector();oe.startWiresVector(e,l.length);for(let t=0;t<l.length;t++){const[s,i,n,r,o,a]=l[t];ne.createWire(e,s,i,n,r,o,a)}const d=e.endVector(),u=oe.createOrderVector(e,o),f=oe.createPartsVector(e,a);oe.startWireSetsVector(e,0);const p=e.endVector();oe.startAxis(e),oe.addCircleCurves(e,c),oe.addOrder(e,u),oe.addWires(e,d),oe.addWireSets(e,p),oe.addParts(e,f);const I=oe.endAxis(e);i.push(I);const _=de.createAxesVector(e,i),m=de.createRadiusVector(e,[n]);de.startCircleExtrusion(e),de.addAxes(e,_),de.addRadius(e,m);const E=de.endCircleExtrusion(e);b.push(E)}const C=Se.createCircleExtrusionsVector(e,b);Se.startRepresentationsVector(e,r.length);const T=new Map;for(let t=0;t<r.length;t++){const e=r.length-1-t,s=r[e].geometry.type;let i=T.get(s);void 0===i&&(i=-1),T.set(s,i+1)}const A=new ft.Vector3,R=new ft.Vector3;for(let t=0;t<r.length;t++){const s=r.length-1-t,i=r[s],{bbox:n}=i.geometry;c.set(i.id,s);const o=i.geometry.type,a=T.get(o);if(void 0===a)throw new Error("Fragments: Malformed geometry definition");T.set(o,a-1),A.set(n.min.x,n.min.y,n.min.z),R.set(n.max.x,n.max.y,n.max.z);A.distanceTo(R)>999999&&(console.log(`Infinity bounding box: ${i.id}`),n.min.x=0,n.min.y=0,n.min.z=0,n.max.x=.1,n.max.y=.1,n.max.z=.1),Ce.createRepresentation(e,a,n.min.x,n.min.y,n.min.z,n.max.x,n.max.y,n.max.z,i.geometry.type)}const y=e.endVector();let F=0;for(const t of a)for(const e of t.element.geometries){const t=e.color.toString();if(!d.has(t)){const s=e.color.map((t=>255*t));d.set(t,{id:F++,color:s})}}Se.startMaterialsVector(e,d.size);const S=Array.from(d.keys());for(let t=0;t<S.length;t++){const s=S[S.length-1-t],{color:i}=d.get(s),[n,r,o,a]=i;be.createMaterial(e,n,r,o,a,ve.ONE,0)}const w=e.endVector();let x=0;for(const t of a)x+=t.element.geometries.length;Se.startSamplesVector(e,x);for(let t=0;t<a.length;t++){const s=a[a.length-1-t],i=h.get(s.element.id),n=s.element.geometries;for(let t=0;t<n.length;t++){const s=n[n.length-t-1],r=c.get(s.id),o=d.get(s.color.toString()).id,a=s.localTransformID||0;Te.createSample(e,i,o,r,a)}}const O=e.endVector();Se.startLocalTransformsVector(e,l.length);for(let t=0;t<l.length;t++){const s=l[l.length-1-t],[i,n,r,o,a,h,c,d,u]=s.data;me.createTransform(e,i,n,r,o,a,h,c,d,u)}const v=e.endVector(),L=Se.createMeshesItemsVector(e,f),P=me.createTransform(e,n.px,n.py,n.pz,n.dxx,n.dxy,n.dxz,n.dyx,n.dyy,n.dyz);Se.startMeshes(e),Se.addCoordinates(e,P),Se.addGlobalTransforms(e,m),Se.addShells(e,g),Se.addRepresentations(e,y),Se.addSamples(e,O),Se.addLocalTransforms(e,v),Se.addMaterials(e,w),Se.addCircleExtrusions(e,C),Se.addMeshesItems(e,L);const N=Se.endMeshes(e),M=[],D=new Map,U=new Map,V=new Map;let B=0;for(let t=0;t<o.length;t++){const s=t,i=o[s],n=[];D.set(s,n);const r=[];U.set(s,r);const a=[];V.set(s,a);for(let t=0;t<i.absolute.length;t++){const s=i.absolute[i.absolute.length-1-t],{points:r}=s,o=fe.createPointsVector(e,r);fe.startGeometryLines(e),fe.addPoints(e,o);const a=fe.endGeometryLines(e);M.push(a),n.push(B++)}for(let t=0;t<i.horizontal.length;t++){const s=i.horizontal[i.horizontal.length-1-t],{points:n}=s,o=fe.createPointsVector(e,n);fe.startGeometryLines(e),fe.addPoints(e,o);const a=fe.endGeometryLines(e);M.push(a),r.push(B++)}for(let t=0;t<i.vertical.length;t++){const s=i.vertical[i.vertical.length-1-t],{points:n}=s,r=fe.createPointsVector(e,n);fe.startGeometryLines(e),fe.addPoints(e,r);const o=fe.endGeometryLines(e);M.push(o),a.push(B++)}}const z=Ee.createLinesVector(e,M);let G=B;Ee.startRepresentationsVector(e,G);const k=[];G--;for(let t=0;t<o.length;t++){const i=o.length-1-t,n=o[i];for(let t=0;t<n.absolute.length;t++){const i=n.absolute[n.absolute.length-1-t],{type:r}=i;k.unshift(s++);const o=G--;pe.createGeometryRepresentation(e,o,r)}for(let t=0;t<n.horizontal.length;t++){const i=n.horizontal[n.horizontal.length-1-t],{type:r}=i;k.unshift(s++);const o=G--;pe.createGeometryRepresentation(e,o,r)}for(let t=0;t<n.vertical.length;t++){const i=n.vertical[n.vertical.length-1-t],{type:r}=i;k.unshift(s++);const o=G--;pe.createGeometryRepresentation(e,o,r)}}const H=e.endVector();let Y=B;const W=[];Ee.startSamplesVector(e,Y),Y--;for(let t=0;t<o.length;t++){const i=o.length-1-t,n=o[i];for(let t=0;t<n.absolute.length;t++){const t=Y--;W.unshift(s++),Ie.createGeometrySample(e,t,0)}for(let t=0;t<n.horizontal.length;t++){const t=Y--;W.unshift(s++),Ie.createGeometrySample(e,t,0)}for(let t=0;t<n.vertical.length;t++){const t=Y--;W.unshift(s++),Ie.createGeometrySample(e,t,0)}}const j=e.endVector();Ee.startTransformsVector(e,1),me.createTransform(e,0,0,0,1,0,0,0,1,0);const q=e.endVector(),Z=[s++];Ee.startWallsVector(e,0);const X=e.endVector();Ee.startRepresentationsSamplesVector(e,0);const $=e.endVector(),K=Ee.createRepresentationIdsVector(e,k),Q=Ee.createSampleIdsVector(e,W),J=Ee.createRepresentationsSamplesVector(e,Z);Ee.startGeometries(e),Ee.addSamples(e,j),Ee.addSampleIds(e,Q),Ee.addRepresentations(e,H),Ee.addRepresentationIds(e,K),Ee.addTransforms(e,q),Ee.addTransformIds(e,J),Ee.addRepresentationsSamples(e,$),Ee.addLines(e,z),Ee.addWalls(e,X);const tt=Ee.endGeometries(e),et=[];for(let t=0;t<o.length;t++){const s=D.get(t),i=U.get(t),n=V.get(t);if(void 0===s||void 0===i||void 0===n)throw new Error("Fragments: Malformed alignment definition");const r=te.createAbsoluteVector(e,s),o=te.createHorizontalVector(e,i),a=te.createVerticalVector(e,n),l=te.createAlignment(e,r,o,a);et.push(l)}const st=Oe.createAlignmentsVector(e,et);return{modelMesh:N,localIDs:i,maxLocalID:s,modelGeometries:tt,modelAlignments:st}}}const Fd={base:new Set([Bt.IFCPROJECT,Bt.IFCSITE,Bt.IFCBUILDING,Bt.IFCBUILDINGSTOREY]),materials:new Set([Bt.IFCMATERIAL,Bt.IFCMATERIALLIST,Bt.IFCMATERIALCONSTITUENT,Bt.IFCMATERIALCONSTITUENTSET,Bt.IFCMATERIALLAYER,Bt.IFCMATERIALLAYERSET,Bt.IFCMATERIALLAYERSETUSAGE,Bt.IFCMATERIALPROFILE,Bt.IFCMATERIALPROFILESET,Bt.IFCMATERIALPROFILESETUSAGE]),properties:new Set([Bt.IFCPROPERTYSET,Bt.IFCPROPERTYSINGLEVALUE,Bt.IFCELEMENTQUANTITY,Bt.IFCQUANTITYAREA,Bt.IFCQUANTITYCOUNT,Bt.IFCQUANTITYLENGTH,Bt.IFCQUANTITYNUMBER,Bt.IFCQUANTITYTIME,Bt.IFCQUANTITYVOLUME,Bt.IFCQUANTITYWEIGHT]),types:new Set([Bt.IFCBEAMTYPE,Bt.IFCBEARINGTYPE,Bt.IFCBUILDINGELEMENTPROXYTYPE,Bt.IFCCHIMNEYTYPE,Bt.IFCCOLUMNTYPE,Bt.IFCCOURSETYPE,Bt.IFCCOVERINGTYPE,Bt.IFCCURTAINWALLTYPE,Bt.IFCDEEPFOUNDATIONTYPE,Bt.IFCDOORTYPE,Bt.IFCFOOTINGTYPE,Bt.IFCKERBTYPE,Bt.IFCMEMBERTYPE,Bt.IFCMOORINGDEVICETYPE,Bt.IFCNAVIGATIONELEMENTTYPE,Bt.IFCPAVEMENTTYPE,Bt.IFCPLATETYPE,Bt.IFCRAILTYPE,Bt.IFCRAILINGTYPE,Bt.IFCRAMPFLIGHTTYPE,Bt.IFCRAMPTYPE,Bt.IFCROOFTYPE,Bt.IFCSHADINGDEVICETYPE,Bt.IFCSLABTYPE,Bt.IFCSTAIRFLIGHTTYPE,Bt.IFCSTAIRTYPE,Bt.IFCTRACKELEMENTTYPE,Bt.IFCWALLTYPE,Bt.IFCWINDOWTYPE]),elements:new Set([Bt.IFCPROJECT,Bt.IFCSITE,Bt.IFCBUILDING,Bt.IFCBUILDINGSTOREY,Bt.IFCSPACE,Bt.IFCANNOTATION,Bt.IFCCONTROLLER,Bt.IFCBOILER,Bt.IFCLAMP,Bt.IFCPUMP,Bt.IFCAIRTERMINALBOX,Bt.IFCFLOWINSTRUMENT,Bt.IFCFURNISHINGELEMENT,Bt.IFCELECTRICGENERATOR,Bt.IFCAUDIOVISUALAPPLIANCE,Bt.IFCPIPEFITTING,Bt.IFCSTAIR,Bt.IFCDUCTFITTING,Bt.IFCMECHANICALFASTENER,Bt.IFCDOOR,Bt.IFCELECTRICMOTOR,Bt.IFCSYSTEMFURNITUREELEMENT,Bt.IFCEVAPORATOR,Bt.IFCWINDOWSTANDARDCASE,Bt.IFCLIGHTFIXTURE,Bt.IFCUNITARYCONTROLELEMENT,Bt.IFCCABLECARRIERFITTING,Bt.IFCCOIL,Bt.IFCFASTENER,Bt.IFCFLOWSTORAGEDEVICE,Bt.IFCPROTECTIVEDEVICE,Bt.IFCBEAM,Bt.IFCTANK,Bt.IFCFILTER,Bt.IFCCOLUMN,Bt.IFCELECTRICDISTRIBUTIONBOARD,Bt.IFCFOOTING,Bt.IFCCOLUMNSTANDARDCASE,Bt.IFCVOIDINGFEATURE,Bt.IFCREINFORCINGBAR,Bt.IFCFLOWSEGMENT,Bt.IFCELECTRICTIMECONTROL,Bt.IFCCABLEFITTING,Bt.IFCDISTRIBUTIONCHAMBERELEMENT,Bt.IFCDISTRIBUTIONCONTROLELEMENT,Bt.IFCMEMBER,Bt.IFCBUILDINGELEMENTPROXY,Bt.IFCPLATESTANDARDCASE,Bt.IFCSWITCHINGDEVICE,Bt.IFCSHADINGDEVICE,Bt.IFCDISCRETEACCESSORY,Bt.IFCDUCTSILENCER,Bt.IFCSTACKTERMINAL,Bt.IFCFIRESUPPRESSIONTERMINAL,Bt.IFCMEDICALDEVICE,Bt.IFCFURNITURE,Bt.IFCSLAB,Bt.IFCTRANSPORTELEMENT,Bt.IFCAIRTERMINAL,Bt.IFCENERGYCONVERSIONDEVICE,Bt.IFCCIVILELEMENT,Bt.IFCPILE,Bt.IFCELECTRICAPPLIANCE,Bt.IFCMEMBERSTANDARDCASE,Bt.IFCDISTRIBUTIONELEMENT,Bt.IFCCOVERING,Bt.IFCSPACEHEATER,Bt.IFCROOF,Bt.IFCAIRTOAIRHEATRECOVERY,Bt.IFCFLOWCONTROLLER,Bt.IFCHUMIDIFIER,Bt.IFCJUNCTIONBOX,Bt.IFCFLOWMETER,Bt.IFCFLOWTERMINAL,Bt.IFCRAILING,Bt.IFCCONDENSER,Bt.IFCPROTECTIVEDEVICETRIPPINGUNIT,Bt.IFCREINFORCINGMESH,Bt.IFCTENDONANCHOR,Bt.IFCVIBRATIONISOLATOR,Bt.IFCWALL,Bt.IFCMOTORCONNECTION,Bt.IFCVIRTUALELEMENT,Bt.IFCENGINE,Bt.IFCBEAMSTANDARDCASE,Bt.IFCBURNER,Bt.IFCBUILDINGELEMENTPART,Bt.IFCRAMP,Bt.IFCTUBEBUNDLE,Bt.IFCSLABSTANDARDCASE,Bt.IFCDISTRIBUTIONFLOWELEMENT,Bt.IFCSANITARYTERMINAL,Bt.IFCOPENINGSTANDARDCASE,Bt.IFCALARM,Bt.IFCSURFACEFEATURE,Bt.IFCSLABELEMENTEDCASE,Bt.IFCFLOWMOVINGDEVICE,Bt.IFCPLATE,Bt.IFCCOMMUNICATIONSAPPLIANCE,Bt.IFCDOORSTANDARDCASE,Bt.IFCRAMPFLIGHT,Bt.IFCCHIMNEY,Bt.IFCWINDOW,Bt.IFCELECTRICFLOWSTORAGEDEVICE,Bt.IFCHEATEXCHANGER,Bt.IFCFAN,Bt.IFCSOLARDEVICE,Bt.IFCGEOGRAPHICELEMENT,Bt.IFCCURTAINWALL,Bt.IFCFLOWTREATMENTDEVICE,Bt.IFCWALLSTANDARDCASE,Bt.IFCDUCTSEGMENT,Bt.IFCCOMPRESSOR,Bt.IFCPIPESEGMENT,Bt.IFCCOOLINGTOWER,Bt.IFCPROJECTIONELEMENT,Bt.IFCOUTLET,Bt.IFCEVAPORATIVECOOLER,Bt.IFCCABLECARRIERSEGMENT,Bt.IFCTENDON,Bt.IFCTRANSFORMER,Bt.IFCCHILLER,Bt.IFCDAMPER,Bt.IFCSENSOR,Bt.IFCELEMENTASSEMBLY,Bt.IFCCOOLEDBEAM,Bt.IFCWALLELEMENTEDCASE,Bt.IFCINTERCEPTOR,Bt.IFCVALVE,Bt.IFCCABLESEGMENT,Bt.IFCWASTETERMINAL,Bt.IFCSTAIRFLIGHT,Bt.IFCFLOWFITTING,Bt.IFCACTUATOR,Bt.IFCUNITARYEQUIPMENT,Bt.IFCGRID,Bt.IFCBUILTELEMENT,Bt.IFCCOURSE,Bt.IFCEARTHWORKSCUT,Bt.IFCEARTHWORKSFILL,Bt.IFCTRACKELEMENT,Bt.IFCRAIL,Bt.IFCSIGN,Bt.IFCPAVEMENT])};class Sd{constructor(){ot(this,"_builder",null),ot(this,"wasm",{path:"/node_modules/web-ifc/",absolute:!1}),ot(this,"attributesToExclude",new Set(["Representation","ObjectPlacement","CompositionType","OwnerHistory"])),ot(this,"relations",new Map([[Bt.IFCRELDEFINESBYPROPERTIES,{forRelating:"DefinesOcurrence",forRelated:"IsDefinedBy"}],[Bt.IFCRELASSOCIATESMATERIAL,{forRelated:"HasAssociations",forRelating:"AssociatedTo"}],[Bt.IFCRELAGGREGATES,{forRelated:"Decomposes",forRelating:"IsDecomposedBy"}],[Bt.IFCRELCONTAINEDINSPATIALSTRUCTURE,{forRelated:"ContainedInStructure",forRelating:"ContainsElements"}]])),ot(this,"classes",{elements:new Wt([...Fd.elements]),abstract:new Wt([...Fd.base,...Fd.materials,...Fd.properties])}),ot(this,"includeUniqueAttributes",!1),ot(this,"includeRelationNames",!1),ot(this,"replaceStoreyElevation",!0)}get builder(){if(!this._builder)throw new Error("Fragments: Builder not initialized");return this._builder}async process(t){var e;this._builder=new Jt(1024);const s=new yd(this);s.wasm=this.wasm;const i={...t,builder:this.builder},n=await s.process(i),{modelMesh:r,maxLocalID:o,localIDs:a,modelGeometries:l,modelAlignments:h}=n,c=new dd(this,this.builder);c.wasm=this.wasm;const d={...t,geometryProcessedLocalIDs:a},u=await c.process(d),{relIndicesVector:f,relsVector:p,guidsVector:I,guidsItemsVector:_,metadataOffset:m,localIdsVector:E,spatialStrutureOffset:g,attributesVector:b,categoriesVector:C,uniqueAttributesVector:T,relNamesVector:A}=u,R=t.id??vt.generateUUID(),y=this.builder.createString(R);Oe.startModel(this.builder),Oe.addMeshes(this.builder,r),Oe.addMetadata(this.builder,m),Oe.addAttributes(this.builder,b),Oe.addUniqueAttributes(this.builder,T),Oe.addRelationNames(this.builder,A),Oe.addLocalIds(this.builder,E),Oe.addCategories(this.builder,C),Oe.addRelationsItems(this.builder,f),Oe.addRelations(this.builder,p),Oe.addGuidsItems(this.builder,_),Oe.addGuids(this.builder,I),Oe.addSpatialStructure(this.builder,g),Oe.addGuid(this.builder,y),Oe.addMaxLocalId(this.builder,o),Oe.addGeometries(this.builder,l),Oe.addAlignments(this.builder,h);const F=Oe.endModel(this.builder);this.builder.finish(F);const S=this.builder.asUint8Array();this.clean();const w=t.raw?S:Zo.deflate(S);return null==(e=t.progressCallback)||e.call(t,1,{process:"conversion",state:"finish"}),w}clean(){var t;null==(t=this._builder)||t.clear(),this._builder=null}}export{te as Alignment,Ht as AsyncEvent,ee as Attribute,oe as Axis,ae as AxisPartClass,le as BigShellHole,he as BigShellProfile,ce as BoundingBox,ie as CircleCurve,de as CircleExtrusion,Ue as CurrentLod,Yt as DataMap,Wt as DataSet,ue as DoubleVector,kt as Event,se as FloatVector,Ti as FragmentsModel,cd as FragmentsModels,Ee as Geometries,ge as GeometryClass,fe as GeometryLines,pe as GeometryRepresentation,Ie as GeometrySample,_e as GeometryWall,Sd as IfcImporter,Be as ItemConfigClass,be as Material,Se as Meshes,Oe as Model,Ve as MultiThreadingRequestClass,Me as ObjectClass,we as Relation,ve as RenderedFaces,Ce as Representation,Le as RepresentationClass,Te as Sample,Fe as Shell,Ae as ShellHole,Re as ShellProfile,ye as ShellType,hd as SingleThreadedFragmentsModel,ze as SnappingClass,xe as SpatialStructure,Pe as Stroke,De as TileRequestClass,me as Transform,ne as Wire,re as WireSet,zt as getObject,Gt as ifcCategoryMap,Fd as ifcClasses,Ne as limitOf2Bytes};
